<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Deep C++(V17.04)</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #303030; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */

    body {
        margin: 0 auto;
        max-width: none;
        width: 1000px;
        padding-left: 50px;
        padding-right: 50px;
        padding-top: 50px;
        padding-bottom: 50px;
        hyphens: auto;
        overflow-wrap: break-word;
        text-rendering: optimizeLegibility;
        font-kerning: normal;
    }

    table {
        border-collapse: collapse;
    }

    table, th, td {
        border: 2px solid black;
    }

    header {
        margin-bottom: 4em;
        text-align: center;
        color: white;
        background-color: lightblue;
    }

    h1:not(:first-of-type) {
        page-break-before: always;
    }

  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Deep C++(V17.04)</h1>
<p class="author">autor:ichiroprogrammer</p>
</header>
<!-- ./md/dynamic_memory_allocation.md -->
<h1 id="ダイナミックメモリアロケーション">ダイナミックメモリアロケーション <a id="SS_5"></a></h1>
<p>本章で扱うダイナミックメモリアロケーションとは、new/delete、malloc/free によるメモリ確保/解放のことである。</p>
<p>malloc/freeは、</p>
<ul>
<li>最長処理時間を規定できない(リアルタイム性の欠如)</li>
<li>メモリのフラグメントを起こす</li>
</ul>
<p>等の問題(「<a href="dynamic_memory_allocation.html#SS_5_1">malloc/freeの問題点</a>」参照)を持っている。 new/deleteは通常malloc/freeを使って実装されているため同じ問題を持っているが、 これらが汎用OS上でのアプリケーションで実際の不具合につながることはほとんどない。一方で、</p>
<ul>
<li>リアルタイムな応答が要求される</li>
<li>メモリの使用制限が厳しい(ページングと2次記憶がない)</li>
</ul>
<p>ような組み込みソフトでは、上記の2点は致命的な不具合につながる。</p>
<p>本章では、この問題を回避するための技法を紹介する。</p>
<hr />
<p><strong>この章の構成</strong></p>
<p>   <a href="dynamic_memory_allocation.html#SS_5_1">malloc/freeの問題点</a><br />
   <a href="dynamic_memory_allocation.html#SS_5_2">グローバルnew/deleteのオーバーロード</a><br />
    <a href="dynamic_memory_allocation.html#SS_5_2_1">固定長メモリプール</a><br />
    <a href="dynamic_memory_allocation.html#SS_5_2_2">グローバルnew/deleteのオーバーロードの実装</a><br />
    <a href="dynamic_memory_allocation.html#SS_5_2_3">プレースメントnew</a><br />
    <a href="dynamic_memory_allocation.html#SS_5_2_4">デバッグ用イテレータ</a></p>
<p>   <a href="dynamic_memory_allocation.html#SS_5_3">クラスnew/deleteのオーバーロード</a><br />
   <a href="dynamic_memory_allocation.html#SS_5_4">STLコンテナのアロケーター</a><br />
    <a href="dynamic_memory_allocation.html#SS_5_4_1">STLコンテナ用アロケータ</a><br />
    <a href="dynamic_memory_allocation.html#SS_5_4_2">可変長メモリプール</a><br />
    <a href="dynamic_memory_allocation.html#SS_5_4_3">デバッグ用イテレータ</a><br />
    <a href="dynamic_memory_allocation.html#SS_5_4_4">エクセプション処理機構の変更</a></p>
<h2 id="mallocfreeの問題点">malloc/freeの問題点 <a id="SS_5_1"></a></h2>
<p>UNIX系のOSでの典型的なmalloc/freeの実装例の一部を以下に示す (この実装は長いため、全体は巻末の“<a href="sample_code.html#SS_7_1_1">example/dynamic_memory_allocation/malloc_ut.cpp</a>”に掲載する)。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/malloc_ut.cpp 19</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="kw">namespace</span> {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="kw">struct</span> <span class="dt">header_t</span> {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        <span class="dt">header_t</span>* next;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        <span class="dt">size_t</span>    n_nuits;  <span class="co">// header_tが何個あるか</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    };</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    <span class="dt">header_t</span>*        header{<span class="kw">nullptr</span>};</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    SpinLock         spin_lock{};</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> unit_size{<span class="kw">sizeof</span>(<span class="dt">header_t</span>)};</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>    <span class="kw">inline</span> <span class="dt">bool</span> sprit(<span class="dt">header_t</span>* header, <span class="dt">size_t</span> n_nuits, <span class="dt">header_t</span>*&amp; next) <span class="kw">noexcept</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>    {</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>        ...</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>    }</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>    <span class="kw">inline</span> <span class="dt">void</span> concat(<span class="dt">header_t</span>* front, <span class="dt">header_t</span>* rear) <span class="kw">noexcept</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>    {</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>        ...</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>    }</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>    <span class="dt">header_t</span>* set_back(<span class="dt">void</span>* mem) <span class="kw">noexcept</span> { <span class="cf">return</span> <span class="kw">static_cast</span>&lt;<span class="dt">header_t</span>*&gt;(mem) - <span class="dv">1</span>; }</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>    <span class="kw">static_assert</span>(<span class="kw">sizeof</span>(<span class="dt">header_t</span>) == <span class="kw">alignof</span>(<span class="bu">std::</span>max_align_t));</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>    <span class="dt">void</span>* malloc_inner(<span class="dt">size_t</span> size) <span class="kw">noexcept</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>    {</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a>        ...</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>    }</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>    }  <span class="co">// namespace</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/malloc_ut.cpp 105</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    <span class="dt">void</span> free(<span class="dt">void</span>* mem) <span class="kw">noexcept</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>        <span class="dt">header_t</span>* mem_to_free = set_back(mem);</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        mem_to_free-&gt;next = <span class="kw">nullptr</span>;</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>        <span class="kw">auto</span> lock = <span class="bu">std::</span>lock_guard{spin_lock};</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>        <span class="cf">if</span> (header == <span class="kw">nullptr</span>) {</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>            header = mem_to_free;</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>            <span class="cf">return</span>;</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>        }</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>        <span class="cf">if</span> (mem_to_free &lt; header) {</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>            concat(mem_to_free, header);</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>            header = mem_to_free;</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>            <span class="cf">return</span>;</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>        }</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a>        <span class="kw">auto</span> curr = header;</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>        <span class="cf">for</span> (; curr-&gt;next != <span class="kw">nullptr</span>; curr = curr-&gt;next) {</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>            <span class="cf">if</span> (mem_to_free &lt; curr-&gt;next) {  <span class="co">// 常に curr &lt; mem_to_free</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>                concat(mem_to_free, curr-&gt;next);</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>                concat(curr, mem_to_free);</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a>                <span class="cf">return</span>;</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a>            }</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a>        }</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true"></a>        concat(curr, mem_to_free);</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true"></a>    }</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true"></a></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true"></a>    <span class="dt">void</span>* malloc(<span class="dt">size_t</span> size) <span class="kw">noexcept</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true"></a>    {</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true"></a>        <span class="dt">void</span>* mem = malloc_inner(size);</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true"></a></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true"></a>        <span class="cf">if</span> (mem == <span class="kw">nullptr</span>) {</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true"></a>            <span class="kw">auto</span> <span class="at">const</span> add_size = Roundup(unit_size, <span class="dv">1024</span> * <span class="dv">1024</span> + size);  <span class="co">// 1MB追加</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true"></a></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true"></a>            <span class="dt">header_t</span>* add = <span class="kw">static_cast</span>&lt;<span class="dt">header_t</span>*&gt;(sbrk(add_size));</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true"></a>            add-&gt;n_nuits  = add_size / unit_size;</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true"></a>            free(++add);</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true"></a>            mem = malloc_inner(size);</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true"></a>        }</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true"></a></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true"></a>        <span class="cf">return</span> mem;</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true"></a>    }</span></code></pre></div>
<p>上記で示したようにmalloc/freeで使用されるメモリはHeader_t型のheaderで管理され、 このアクセスの競合はspin_lockによって回避される。 headerが管理するメモリ用域からのメモリの切り出しはmalloc_innerによって行われるが、 下のフラグメントの説明でも示す通り、 headerで管理されたメモリは長さの上限が単純には決まらないリスト構造になるため、 このリストをなぞるmalloc/freeにリアルタイム性の保証をすることは困難である。</p>
<p>アプリケーションが実行する最初のmallocから呼び出されるmalloc_innerは、 headerがnullptrであるため必ずnullptrを返すことになる。</p>
<p>上記の抜粋である下記のコードによりmalloc_innerの戻りがnullptrであった場合、sbrkが呼び出される。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/malloc_ut.cpp 148</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="cf">if</span> (mem == <span class="kw">nullptr</span>) {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>        <span class="kw">auto</span> <span class="at">const</span> add_size = Roundup(unit_size, <span class="dv">1024</span> * <span class="dv">1024</span> + size);  <span class="co">// 1MB追加</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>        <span class="dt">header_t</span>* add = <span class="kw">static_cast</span>&lt;<span class="dt">header_t</span>*&gt;(sbrk(add_size));</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>        add-&gt;n_nuits  = add_size / unit_size;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>        free(++add);</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>        mem = malloc_inner(size);</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>    }</span></code></pre></div>
<p>sbrkとはOSからメモリを新たに取得するための下記のようなシステムコールである。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/malloc_ut.cpp 13</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    <span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span>* sbrk(<span class="dt">ptrdiff_t</span> __incr);</span></code></pre></div>
<p>OSがアプリケーションに割り当てるための十分なメモリを持っていない場合、 sbrkは <a href="https://ja.wikipedia.org/wiki/%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%B3%E3%82%B0%E6%96%B9%E5%BC%8F">ページング</a> によるメモリ確保のトリガーとなる。 これはOSのファイルシステムの動作を含む処理であるため、やはりリアルタイム性の保証は困難である。</p>
<p><a href="term_explanation.html#SS_6_10_20">フリースタンディング環境</a>では、sbrkのようなシステムコールは存在しないため、 アプリケーションの未使用領域や静的に確保した領域を上記コードで示したようなリスト構造で管理し、 mallocで使用することになる。 このような環境では、sbrkによるリアルタイム性の阻害は発生しないものの、 メモリ管理ためのリスト構造があるため、やはりリアルタイム性の保証は難しい。</p>
<p>次にもう一つの問題である「メモリのフラグメントを起こす」ことについて見て行く。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/malloc_ut.cpp 190</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="dt">void</span>* mem[<span class="dv">1024</span>];</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="kw">auto</span>&amp; m : mem) {  <span class="co">// 32バイト x 1024個のメモリ確保</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>        m = malloc(<span class="dv">32</span>);</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>    }</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>    <span class="co">// memを使用した何らかの処理</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>    ...</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="kw">auto</span> i = <span class="dv">0</span><span class="bu">U</span>; i &lt; ArrayLength(mem); i += <span class="dv">2</span>) {  <span class="co">// 512個のメモリを解放</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>        free(mem[i]);</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>    }</span></code></pre></div>
<p>上記のような処理の後、解放されたメモリは、32バイト (メモリヘッダがあるため、実際はもう少し大きい)の断片が512個ある状態になるため、 このサイズを超える新たなmallocの呼び出しには使えない。 このため、ページングが行えないようなOS上のアプリケーションでは、 メモリは十分にあるにもかかわらずmallocが失敗してしまうことが起こり得る。</p>
<p>また、上記freeの実装例の抜粋である下記のコードからわかるように、 このように断片化されたメモリは、そのアドレス順にソートされた単方向リストによって管理される。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/malloc_ut.cpp 120</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="cf">if</span> (mem_to_free &lt; header) {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>        concat(mem_to_free, header);</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>        header = mem_to_free;</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>        <span class="cf">return</span>;</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>    }</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="kw">auto</span> curr = header;</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>    <span class="cf">for</span> (; curr-&gt;next != <span class="kw">nullptr</span>; curr = curr-&gt;next) {</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>        <span class="cf">if</span> (mem_to_free &lt; curr-&gt;next) {  <span class="co">// 常に curr &lt; mem_to_free</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>            concat(mem_to_free, curr-&gt;next);</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>            concat(curr, mem_to_free);</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>            <span class="cf">return</span>;</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>        }</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>    }</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>    concat(curr, mem_to_free);</span></code></pre></div>
<p>この状態でさらにメモリ解放が行われた場合、 freeはこのリストを辿りメモリを最適な場所に戻す必要がある。 戻したメモリがリスト前後のメモリと隣接していれば、それらは結合される。 この処理は断片化への対策であるが、 ページングの無いOS上のアプリケーションにとっては不十分であるばかりでなく、</p>
<ul>
<li>freeの排他ロックする期間が長い</li>
<li>freeの処理が遅い</li>
</ul>
<p>といったリアルタイム処理を阻害する別の問題も発生させる (繰り返しになるが、windows/linuxのような通常のOS上のアプリケーションでは、 このような仕様が問題になることはほとんどない)。</p>
<h2 id="グローバルnewdeleteのオーバーロード">グローバルnew/deleteのオーバーロード <a id="SS_5_2"></a></h2>
<p>すでに述べたように、組み込みソフトにはmalloc/freeを使用したnew/deleteは使えない可能性が高い。 そのような場合に備えC++11ではグローバルなnew/deleteのオーバーロードをサポートする。 ここでは、そのようなnew/deleteの実装例を示すが、 その前にnew/deleteの内部実装用メモリ管理用ライブラリを実装する。</p>
<h3 id="固定長メモリプール">固定長メモリプール <a id="SS_5_2_1"></a></h3>
<p>malloc/freeにリアルタイム性がない原因は、</p>
<ul>
<li>リアルタイム性がないOSのシステムコールを使用している</li>
<li>メモリを可変長で管理しているため処理が重いにもかかわらず、この処理中にグローバルロックを行う。</li>
</ul>
<p>ためである。従って、この問題に対処するためのメモリ管理システムは、</p>
<ul>
<li>初期に静的なメモリを確保</li>
<li>メモリを固定長で管理</li>
</ul>
<p>する必要がある。これを含めこの章で開発するメモリ管理システムをメモリプールと呼ぶことにする。</p>
<p>「<a href="dynamic_memory_allocation.html#SS_5_2_2">グローバルnew/deleteのオーバーロードの実装</a>」で示すように、 このメモリプールは管理する固定長のメモリブロックのサイズごとに複数必要になる一方で、 これらを統合的に扱う必要も出てくる。</p>
<p>そのため、固定長のメモリプールは、</p>
<ul>
<li>複数個のメモリプールを統合的に扱う<a href="term_explanation.html#SS_6_1_13">インターフェースクラス</a>MPool</li>
<li>MPoolを基底クラスとし、固定長メモリブロックを管理するクラステンプレートMPoolFixed</li>
</ul>
<p>によって実装することにする。</p>
<p>まずは、MPoolを下記に示す (「<a href="template_meta_programming.html#SS_4_6_7_4">ファイル位置を静的に保持したエクセプションクラスの開発</a>」参照)。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool.h 12</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="kw">class</span> MPool {</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>        <span class="kw">explicit</span> MPool(<span class="dt">size_t</span> max_size) : <span class="va">max_size_</span>{max_size} {}</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>        <span class="dt">void</span>* Alloc(<span class="dt">size_t</span> size)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>        {</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>            <span class="cf">if</span> (size &gt; <span class="va">max_size_</span>) {</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>                <span class="cf">throw</span> MAKE_EXCEPTION(MPoolBadAlloc, <span class="st">&quot;MPF : memory size too big&quot;</span>);</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>            }</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>            <span class="dt">void</span>* mem = alloc(size);</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>            <span class="cf">if</span> (mem == <span class="kw">nullptr</span>) {</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>                <span class="cf">throw</span> MAKE_EXCEPTION(MPoolBadAlloc, <span class="st">&quot;MPF : out of memory&quot;</span>);</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>            }</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>            <span class="cf">return</span> mem;</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>        }</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>        <span class="dt">void</span>* AllocNoExcept(<span class="dt">size_t</span> size) <span class="kw">noexcept</span> { <span class="cf">return</span> alloc(size); }</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>        <span class="dt">void</span>   Free(<span class="dt">void</span>* area) <span class="kw">noexcept</span> { free(area); }</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a>        <span class="dt">size_t</span> GetSize() <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> get_size(); }  <span class="co">// メモリ最小単位</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true"></a>        <span class="dt">size_t</span> GetCount() <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> get_count(); }  <span class="co">// メモリ最小単位が何個取れるか</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true"></a>        <span class="dt">size_t</span> GetCountMin() <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> get_count_min(); }  <span class="co">// GetCount()の最小値</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true"></a>        <span class="dt">bool</span>   IsValid(<span class="dt">void</span> <span class="at">const</span>* area) <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> is_valid(area); }</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true"></a>    <span class="kw">protected</span>:</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true"></a>        ~MPool() = <span class="cf">default</span>;</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true"></a>        <span class="dt">size_t</span> <span class="at">const</span> <span class="va">max_size_</span>;</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true"></a></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span>*  alloc(<span class="dt">size_t</span> size) <span class="kw">noexcept</span>               = <span class="dv">0</span>;</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span>   free(<span class="dt">void</span>* area) <span class="kw">noexcept</span>                 = <span class="dv">0</span>;</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">size_t</span> get_size() <span class="at">const</span> <span class="kw">noexcept</span>                 = <span class="dv">0</span>;</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">size_t</span> get_count() <span class="at">const</span> <span class="kw">noexcept</span>                = <span class="dv">0</span>;</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">size_t</span> get_count_min() <span class="at">const</span> <span class="kw">noexcept</span>            = <span class="dv">0</span>;</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">bool</span>   is_valid(<span class="dt">void</span> <span class="at">const</span>* area) <span class="at">const</span> <span class="kw">noexcept</span> = <span class="dv">0</span>;</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true"></a>    };</span></code></pre></div>
<p>次に、MPoolFixedを下記に示す。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_fixed.h 25</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="dt">uint32_t</span> MEM_SIZE, <span class="dt">uint32_t</span> MEM_COUNT&gt;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    <span class="kw">class</span> MPoolFixed <span class="kw">final</span> : <span class="kw">public</span> MPool {</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>        MPoolFixed() <span class="kw">noexcept</span> : MPool{<span class="va">mem_chunk_size_</span>} {}</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>        <span class="kw">using</span> <span class="dt">chunk_t</span> = Inner_::mem_chunk&lt;MEM_SIZE&gt;;</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> <span class="va">mem_chunk_size_</span>{<span class="kw">sizeof</span>(<span class="dt">chunk_t</span>)};</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>        <span class="dt">size_t</span>           <span class="va">mem_count_</span>{MEM_COUNT};</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>        <span class="dt">size_t</span>           <span class="va">mem_count_min_</span>{MEM_COUNT};</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>        <span class="dt">chunk_t</span>          <span class="va">mem_chunk_</span>[MEM_COUNT]{};</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>        <span class="dt">chunk_t</span>*         <span class="va">mem_head_</span>{setup_mem()};</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>        <span class="at">mutable</span> SpinLock <span class="va">spin_lock_</span>{};</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>        <span class="dt">chunk_t</span>* setup_mem() <span class="kw">noexcept</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>        {</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a>            <span class="cf">for</span> (<span class="kw">auto</span> i = <span class="dv">0</span><span class="bu">U</span>; i &lt; MEM_COUNT - <span class="dv">1</span>; ++i) {</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a>                <span class="va">mem_chunk_</span>[i].next = &amp;<span class="va">mem_chunk_</span>[i + <span class="dv">1</span>];</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a>            }</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true"></a>            <span class="va">mem_chunk_</span>[MEM_COUNT - <span class="dv">1</span>].next = <span class="kw">nullptr</span>;</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true"></a>            <span class="cf">return</span> <span class="va">mem_chunk_</span>;</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true"></a>        }</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span>* alloc(<span class="dt">size_t</span> size) <span class="kw">noexcept</span> <span class="kw">override</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true"></a>        {</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true"></a>            <span class="ot">assert</span>(size &lt;= <span class="va">mem_chunk_size_</span>);</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true"></a>            <span class="kw">auto</span> lock = <span class="bu">std::</span>lock_guard{<span class="va">spin_lock_</span>};</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true"></a></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true"></a>            <span class="kw">auto</span> mem = <span class="va">mem_head_</span>;</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true"></a></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true"></a>            <span class="cf">if</span> (mem != <span class="kw">nullptr</span>) {</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true"></a>                <span class="va">mem_head_</span>      = <span class="va">mem_head_</span>-&gt;next;</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true"></a>                <span class="va">mem_count_min_</span> = <span class="bu">std::</span>min(--<span class="va">mem_count_</span>, <span class="va">mem_count_min_</span>);</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true"></a>            }</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true"></a></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true"></a>            <span class="cf">return</span> mem;</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true"></a>        }</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true"></a></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span> free(<span class="dt">void</span>* mem) <span class="kw">noexcept</span> <span class="kw">override</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true"></a>        {</span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true"></a>            <span class="ot">assert</span>(is_valid(mem));</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true"></a></span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true"></a>            <span class="kw">auto</span> lock = <span class="bu">std::</span>lock_guard{<span class="va">spin_lock_</span>};</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true"></a></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true"></a>            <span class="dt">chunk_t</span>* curr_head = <span class="kw">static_cast</span>&lt;<span class="dt">chunk_t</span>*&gt;(mem);</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true"></a>            curr_head-&gt;next    = <span class="va">mem_head_</span>;</span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true"></a>            <span class="va">mem_head_</span>          = curr_head;</span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true"></a></span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true"></a>            <span class="va">mem_count_min_</span> = <span class="bu">std::</span>min(++<span class="va">mem_count_</span>, <span class="va">mem_count_min_</span>);</span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true"></a>        }</span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true"></a></span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">size_t</span> get_size() <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span> { <span class="cf">return</span> <span class="va">mem_chunk_size_</span>; }</span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">size_t</span> get_count() <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span> { <span class="cf">return</span> <span class="va">mem_count_</span>; }</span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">size_t</span> get_count_min() <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span> { <span class="cf">return</span> <span class="va">mem_count_min_</span>; }</span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true"></a></span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">bool</span> is_valid(<span class="dt">void</span> <span class="at">const</span>* mem) <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span></span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true"></a>        {</span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true"></a>            <span class="cf">return</span> (&amp;<span class="va">mem_chunk_</span>[<span class="dv">0</span>] &lt;= mem) &amp;&amp; (mem &lt;= &amp;<span class="va">mem_chunk_</span>[MEM_COUNT - <span class="dv">1</span>]);</span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true"></a>        }</span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true"></a>    };</span></code></pre></div>
<p>上記コードからわかる通り、MPoolFixedは初期化直後、 サイズMEM_SIZのメモリブロックをMEM_COUNT個、保持する。 個々のメモリブロックは、下記のコードのalignas/alignofでアライメントされた領域となる。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_fixed.h 11</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> MPoolFixed_MinSize{<span class="dv">32</span>};</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    <span class="kw">namespace</span> Inner_ {</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="dt">uint32_t</span> MEM_SIZE&gt;</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="kw">union</span> mem_chunk {</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>        mem_chunk* next;</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>        <span class="co">// MPoolFixed_MinSizeの整数倍のエリアを、最大アラインメントが必要な基本型にアライン</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>        <span class="kw">alignas</span>(<span class="kw">alignof</span>(<span class="bu">std::</span>max_align_t)) <span class="dt">uint8_t</span> mem[Roundup(MPoolFixed_MinSize, MEM_SIZE)];</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>    };</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>    }  <span class="co">// namespace Inner_</span></span></code></pre></div>
<p>MPoolFixedに限らずメモリアロケータが返すメモリは、 どのようなアライメントにも対応できなければならないため、このようにする必要がある。</p>
<p>MPoolFixed::alloc/MPoolFixed::freeを見ればわかる通り、malloc/freeの実装に比べ格段にシンプルであり、 これによりリアルタイム性の保障は容易である。</p>
<p>なお、この実装ではmalloc/freeと同様に下記のSpinLockを使用したが、 このロックは、ラウンドロビンでスケジューリングされるスレッドの競合を防ぐためのものであり、 固定プライオリティでのスケジューリングが前提となるような組み込みソフトで使用した場合、 デッドロックを引き起こす可能性がある。 組み込みソフトでは、割り込みディセーブル/イネーブルを使ってロックすることを推奨する。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/spin_lock.h 3</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="pp">#include </span><span class="im">&lt;atomic&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    <span class="kw">class</span> SpinLock {</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>        <span class="dt">void</span> lock() <span class="kw">noexcept</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>        {</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>            <span class="cf">while</span> (<span class="va">state_</span>.exchange(state::locked, <span class="bu">std::</span>memory_order_acquire) == state::locked) {</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>                ;  <span class="co">// busy wait</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>            }</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>        }</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>        <span class="dt">void</span> unlock() <span class="kw">noexcept</span> { <span class="va">state_</span>.store(state::unlocked, <span class="bu">std::</span>memory_order_release); }</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a>        <span class="kw">enum</span> <span class="kw">class</span> state { locked, unlocked };</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a>        <span class="bu">std::</span>atomic&lt;state&gt; <span class="va">state_</span>{state::unlocked};</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a>    };</span></code></pre></div>
<p>MPoolFixedの単体テストは、下記のようになる。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_fixed_ut.cpp 10</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    Inner_::mem_chunk&lt;<span class="dv">5</span>&gt; mc5[<span class="dv">3</span>];</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    <span class="kw">static_assert</span>(<span class="dv">32</span> == <span class="kw">sizeof</span>(mc5[<span class="dv">0</span>]));</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>    <span class="kw">static_assert</span>(<span class="dv">96</span> == <span class="kw">sizeof</span>(mc5));</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>    <span class="kw">auto</span> mc33 = Inner_::mem_chunk&lt;<span class="dv">33</span>&gt;{};</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>    <span class="kw">static_assert</span>(<span class="dv">64</span> == <span class="kw">sizeof</span>(mc33));</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_fixed_ut.cpp 106</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    <span class="kw">auto</span> mpf = MPoolFixed&lt;<span class="dv">33</span>, <span class="dv">2</span>&gt;{};</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">64</span>, mpf.GetSize());</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">2</span>, mpf.GetCount());</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">2</span>, mpf.GetCountMin());</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>    ASSERT_FALSE(mpf.IsValid(&amp;mpf));  <span class="co">// mpfの管理外のアドレス</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>    <span class="kw">auto</span> m0 = mpf.Alloc(<span class="dv">1</span>);</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>    ASSERT_TRUE(mpf.IsValid(m0));  <span class="co">// mpfの管理のアドレス</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>    ASSERT_NE(<span class="kw">nullptr</span>, m0);</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">1</span>, mpf.GetCount());</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">1</span>, mpf.GetCountMin());</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>    <span class="kw">auto</span> m1 = mpf.Alloc(<span class="dv">1</span>);</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a>    ASSERT_TRUE(mpf.IsValid(m1));  <span class="co">// mpfの管理のアドレス</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a>    ASSERT_NE(<span class="kw">nullptr</span>, m1);</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">0</span>, mpf.GetCount());</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">0</span>, mpf.GetCountMin());</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a>    <span class="co">// mpfが空の場合のテスト</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a>    ASSERT_THROW(mpf.Alloc(<span class="dv">1</span>), MPoolBadAlloc);  <span class="co">// MPoolBadAlloc例外が発生するはず</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a>    <span class="kw">auto</span> m2 = mpf.AllocNoExcept(<span class="dv">1</span>);</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a>    ASSERT_EQ(<span class="kw">nullptr</span>, m2);</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">0</span>, mpf.GetCount());</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a>    mpf.Free(m0);</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">1</span>, mpf.GetCount());</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">0</span>, mpf.GetCountMin());</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true"></a></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true"></a>    mpf.Free(m1);</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">2</span>, mpf.GetCount());</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">0</span>, mpf.GetCountMin());</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true"></a></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true"></a>    ASSERT_THROW(mpf.Alloc(<span class="dv">65</span>), MPoolBadAlloc);  <span class="co">// MPoolBadAlloc例外が発生するはず</span></span></code></pre></div>
<p>上記テストで使用したMPoolBadAllocは下記のように定義されたクラスであり (「<a href="template_meta_programming.html#SS_4_6_7_4">ファイル位置を静的に保持したエクセプションクラスの開発</a>」参照)、</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>    <span class="co">// @@@ example/h/nstd_exception.h 10</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="co">/// </span><span class="an">@class</span><span class="co"> </span><span class="cv">Exception</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> StaticString&lt;&gt;を使ったエクセプションクラス</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    <span class="co">///        下記のMAKE_EXCEPTIONを使い生成</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>    <span class="co">/// </span><span class="an">@tparam</span><span class="co"> </span><span class="cv">E</span><span class="co">   std::exceptionから派生したエクセプションクラス</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>    <span class="co">/// </span><span class="an">@tparam</span><span class="co"> </span><span class="cv">N</span><span class="co">   StaticString</span><span class="kw">&lt;N&gt;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span> E, <span class="dt">size_t</span> N&gt;</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>    <span class="kw">class</span> Exception : <span class="kw">public</span> E {</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>        <span class="kw">static_assert</span>(<span class="bu">std::</span>is_base_of_v&lt;<span class="bu">std::</span>exception, E&gt;);</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>        Exception(StaticString&lt;N&gt; <span class="at">const</span>&amp; what_str) <span class="kw">noexcept</span> : <span class="va">what_str_</span>{what_str} {}</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>        <span class="dt">char</span> <span class="at">const</span>* what() <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span> { <span class="cf">return</span> <span class="va">what_str_</span>.String(); }</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>        StaticString&lt;N&gt; <span class="at">const</span> <span class="va">what_str_</span>;</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a>    };</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a>    <span class="pp">#define MAKE_EXCEPTION</span>(E__,<span class="pp"> </span>msg__)<span class="pp"> </span>Nstd::MakeException&lt;E__,<span class="pp"> </span><span class="ot">__LINE__</span>&gt;(<span class="ot">__FILE__</span>,<span class="pp"> </span>msg__)</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool.h 7</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="kw">class</span> MPoolBadAlloc : <span class="kw">public</span> <span class="bu">std::</span>bad_alloc {  <span class="co">// Nstd::Exceptionの基底クラス</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>    };</span></code></pre></div>
<p>MPoolから派生したクラスが、</p>
<ul>
<li>メモリブロックを保持していない状態でのMPool::alloc(size, true)の呼び出し</li>
<li>MEM_SIZEを超えたsizeでのMPool::alloc(size, true)の呼び出し</li>
</ul>
<p>のような処理の継続ができない場合に用いるエクセプション用クラスである。</p>
<h3 id="グローバルnewdeleteのオーバーロードの実装">グローバルnew/deleteのオーバーロードの実装 <a id="SS_5_2_2"></a></h3>
<p><a href="dynamic_memory_allocation.html#SS_5_2_1">固定長メモリプール</a>を使用したoperator newのオーバーロードの実装例を以下に示す。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/global_new_delete.cpp 31</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>    <span class="kw">namespace</span> {</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>    MPool* mpool_table[<span class="dv">32</span>];</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>    <span class="co">// mainの前に呼ばれるため、mpool_tableを初期化するには下記のような方法が必要</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>    <span class="dt">bool</span> is_setup{<span class="kw">false</span>};</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>    <span class="dt">void</span> setup() <span class="kw">noexcept</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>    {</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>        is_setup = <span class="kw">true</span>;</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a>        mpool_table[<span class="dv">0</span>] = gen_mpool&lt;<span class="dv">1</span>, <span class="dv">128</span>&gt;();  <span class="co">//   32</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>        mpool_table[<span class="dv">1</span>] = gen_mpool&lt;<span class="dv">2</span>, <span class="dv">128</span>&gt;();  <span class="co">//   64</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>        mpool_table[<span class="dv">2</span>] = gen_mpool&lt;<span class="dv">3</span>, <span class="dv">128</span>&gt;();  <span class="co">//   96</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true"></a>        ...</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true"></a>        mpool_table[<span class="dv">29</span>] = gen_mpool&lt;<span class="dv">30</span>, <span class="dv">128</span>&gt;();  <span class="co">//  960</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true"></a>        mpool_table[<span class="dv">30</span>] = gen_mpool&lt;<span class="dv">31</span>, <span class="dv">128</span>&gt;();  <span class="co">//  992</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true"></a>        mpool_table[<span class="dv">31</span>] = gen_mpool&lt;<span class="dv">32</span>, <span class="dv">128</span>&gt;();  <span class="co">// 1024</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true"></a>    }</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true"></a></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true"></a>    <span class="dt">size_t</span> size2index(<span class="dt">size_t</span> v) <span class="kw">noexcept</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true"></a>    {</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true"></a>        <span class="cf">return</span> (((v + (min_unit - <span class="dv">1</span>)) &amp; ~(min_unit - <span class="dv">1</span>)) / min_unit) - <span class="dv">1</span>;</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true"></a>    }</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true"></a>    }  <span class="co">// namespace</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true"></a></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true"></a>    [[<span class="at">nodiscard</span>]] <span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>(<span class="bu">std::</span>size_t size)</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true"></a>    {</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true"></a>        <span class="cf">if</span> (!is_setup) {</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true"></a>            setup();</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true"></a>        }</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true"></a></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="kw">auto</span> i = size2index(size); i &lt; ArrayLength(mpool_table); ++i) {</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true"></a>            <span class="dt">void</span>* mem = mpool_table[i]-&gt;AllocNoExcept(size);</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true"></a>            <span class="cf">if</span> (mem != <span class="kw">nullptr</span>) {</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true"></a>                <span class="cf">return</span> mem;</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true"></a>            }</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true"></a>        }</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true"></a></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true"></a>        <span class="cf">throw</span> <span class="bu">std::</span>bad_alloc{};</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true"></a></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">char</span> fake[<span class="dv">0</span>];</span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true"></a></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true"></a>        <span class="cf">return</span> fake;</span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true"></a>    }</span></code></pre></div>
<p>上記で定義されたoperator newは、</p>
<ul>
<li>32の整数倍のサイズを持つ32個のメモリプールを持つ</li>
<li>各メモリープールは128個のメモリブロックを持つ</li>
<li>メモリブロックの最大長は1024バイト</li>
</ul>
<p>のような仕様を持つため、実際に使う場合は、メモリのサイズや個数の調整が必要だろうが、 後で詳しく見るようにリアルタイム性の阻害となるようなコードはないため、 リアルタイム性が必要なソフトウェアでも使用可能である。</p>
<p>静的オブジェクトを含まないアプリケーションでは、 上記のコードのsetupで行っているmpool_tableの初期化は <a href="term_explanation.html#SS_6_2_7">一様初期化</a>で行った方が良いが、 例で用いたアプリケーションにはnewを行う静的オブジェクトが存在するため (google testは静的オブジェクトを利用する)、 setupで行っているような方法以外では、 最初のoperator newの呼び出しより前にmpool_tableの初期化をすることはできない。</p>
<p>mpool_tableはMPoolポインタを保持するが、そのポインタが指すオブジェクトの実態は、 gen_mpool&lt;&gt;が生成したMPoolFixed&lt;&gt;オブジェクトである。 gen_mpool&lt;&gt;については、「<a href="dynamic_memory_allocation.html#SS_5_2_3">プレースメントnew</a>」で説明する。</p>
<p>size2indexは、要求されたサイズから、 それに対応するMPoolポインタを保持するmpool_tableのインデックスを導出する関数である。</p>
<p>この実装では対応するMPoolが空であった場合、 それよりも大きいメモリブロックを持つMPoolからメモリを返す仕様としたが、 その時点でアサーションフェールさせ (つまり、対応するMPoolが空である状態でのAllocの呼び出しをバグとして扱う)、 MEM_COUNTの値を見直した方が、 より少ないメモリで動作する組み込みソフトを作りやすいだろう。</p>
<p>operator deleteについては、下記の2種類が必要となる。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/global_new_delete.cpp 109</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem) <span class="kw">noexcept</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    {</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>        <span class="cf">for</span> (MPool* mp : mpool_table) {</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>            <span class="cf">if</span> (mp-&gt;IsValid(mem)) {</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>                mp-&gt;Free(mem);</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>                <span class="cf">return</span>;</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>            }</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>        }</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>        <span class="ot">assert</span>(<span class="kw">false</span>);</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>    }</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>    <span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem, <span class="bu">std::</span>size_t size) <span class="kw">noexcept</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a>    {</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>        <span class="cf">for</span> (<span class="kw">auto</span> i = size2index(size); i &lt; ArrayLength(mpool_table); ++i) {</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>            <span class="cf">if</span> (mpool_table[i]-&gt;IsValid(mem)) {</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a>                mpool_table[i]-&gt;Free(mem);</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a>                <span class="cf">return</span>;</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a>            }</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true"></a>        }</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true"></a>        <span class="ot">assert</span>(<span class="kw">false</span>);</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true"></a>    }</span></code></pre></div>
<p>operator delete(void* mem, std::size_t size)は、完全型のオブジェクトのメモリ解放に使用され、 operator delete(void* mem)は、それ以外のメモリ解放に使用される。</p>
<p>コードから明らかな通り、size付きのoperator deleteの方がループの回転数が少なくなるため、 高速に動作するが、malloc/freeの実装(「<a href="dynamic_memory_allocation.html#SS_5_1">malloc/freeの問題点</a>」参照)で使用したHeader_t を導入することでこの実行コストはほとんど排除できる。 そのトレードオフとしてメモリコストが増えるため、ここでは例示した仕様にした。</p>
<h3 id="プレースメントnew">プレースメントnew <a id="SS_5_2_3"></a></h3>
<p>「<a href="dynamic_memory_allocation.html#SS_5_2_2">グローバルnew/deleteのオーバーロードの実装</a>」で使用したgen_mpool&lt;&gt;は、 下記のように定義されている。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/global_new_delete.cpp 8</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>    <span class="kw">namespace</span> {</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> min_unit{MPoolFixed_MinSize};</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="dt">uint32_t</span> N_UNITS, <span class="dt">uint32_t</span> MEM_COUNT&gt;</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>    [[<span class="at">nodiscard</span>]] MPool* gen_mpool() <span class="kw">noexcept</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>    {</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>        <span class="kw">using</span> <span class="dt">mp_t</span> = MPoolFixed&lt;min_unit * N_UNITS, MEM_COUNT&gt;;</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>        <span class="at">static</span> <span class="kw">union</span> {</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>            <span class="bu">std::</span>max_align_t max_align;</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a>            <span class="dt">uint8_t</span>          mem[<span class="kw">sizeof</span>(<span class="dt">mp_t</span>)];</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a>        } mem;</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true"></a>        <span class="kw">static_assert</span>(<span class="kw">static_cast</span>&lt;<span class="dt">void</span>*&gt;(&amp;mem.max_align) == <span class="kw">static_cast</span>&lt;<span class="dt">void</span>*&gt;(mem.mem));</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true"></a>        <span class="kw">static_assert</span>(<span class="kw">sizeof</span>(mem) &gt;= <span class="kw">sizeof</span>(<span class="dt">mp_t</span>));</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true"></a>        <span class="cf">return</span> <span class="kw">new</span> (mem.mem) <span class="dt">mp_t</span>;  <span class="co">// プレースメントnew</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true"></a>    }</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true"></a>    }  <span class="co">// namespace</span></span></code></pre></div>
<p>この関数テンプレートは、MPoolFixed&lt;&gt;オブジェクトを生成し、それをMPool型のポインタとして返す。 MPoolFixedの生成は、上記で示したようにプレースメントnewを使用して行っている。</p>
<p>gen_mpool&lt;&gt;内でMPoolFixedのstaticなインスタンスを定義した方がシンプルに実装できるが、 その場合、main()終了後、そのインスタンスは解放され(デストラクタが呼び出され)、その後、 他の静的オブジェクトの解放が行われると、その延長でoperator deleteが呼び出され、 ライフタイム終了後のMPoolFixedのstaticなインスタンスが使われてしまう。</p>
<p>現在のMPoolFixedの実装ではこの操作で不具合は発生しないが、 解放済のオブジェクトを操作することは避けるべきであるため、 MPoolFixedの生成にプレースメントnewを用いている。</p>
<p>プレースメントnewで生成したオブジェクトをdeleteすることはできず、 デストラクタはユーザが明示的に呼び出さない限り、呼び出されない。 ここでは、プレースメントnewのこの特性を利用したが、 逆に、この特性があるため、 ここでの実装のような特殊な事情がある場合を除き、プレースメントnewを使うべきではない (デストラクタの明示的な呼び出しを忘れるとリソースリークしてしまう)。</p>
<h3 id="デバッグ用イテレータ">デバッグ用イテレータ <a id="SS_5_2_4"></a></h3>
<p>この章で例示したグローバルnew/deleteは、すでに述べたように適切なメモリの量を調整する必要がある。 そのためには、これを使用するアプリケーションをある程度動作させた後、 グローバルnew/deleteのメモリの消費量を計測しなければならない。</p>
<p>下記のコードは、そのためのインターフェースを提供する。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/global_new_delete.h 4</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    <span class="kw">class</span> GlobalNewDeleteMonitor {</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>        MPool <span class="at">const</span>* <span class="at">const</span>* cbegin() <span class="at">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>        MPool <span class="at">const</span>* <span class="at">const</span>* cend() <span class="at">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>        MPool <span class="at">const</span>* <span class="at">const</span>* begin() <span class="at">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>        MPool <span class="at">const</span>* <span class="at">const</span>* end() <span class="at">const</span> <span class="kw">noexcept</span>;</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>    };</span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/global_new_delete.cpp 135</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>    MPool <span class="at">const</span>* <span class="at">const</span>* GlobalNewDeleteMonitor::begin() <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> &amp;mpool_table[<span class="dv">0</span>]; }</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>    MPool <span class="at">const</span>* <span class="at">const</span>* GlobalNewDeleteMonitor::end() <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>    {</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>        <span class="cf">return</span> &amp;mpool_table[ArrayLength(mpool_table)];</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>    }</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>    MPool <span class="at">const</span>* <span class="at">const</span>* GlobalNewDeleteMonitor::cbegin() <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> begin(); }</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a>    MPool <span class="at">const</span>* <span class="at">const</span>* GlobalNewDeleteMonitor::cend() <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> end(); }</span></code></pre></div>
<p>このインターフェースを下記のように使用することで、</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/global_new_delete_ut.cpp 124</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>    <span class="kw">auto</span> gm = GlobalNewDeleteMonitor{};</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;  size current   min&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;  ------------------&quot;</span> &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>    <span class="cf">for</span> (MPool <span class="at">const</span>* mp : gm) {</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>setw(<span class="dv">6</span>) &lt;&lt; mp-&gt;GetSize() &lt;&lt; <span class="bu">std::</span>setw(<span class="dv">8</span>) &lt;&lt; mp-&gt;GetCount() &lt;&lt; <span class="bu">std::</span>setw(<span class="dv">6</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>                  &lt;&lt; mp-&gt;GetCountMin() &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>    }</span></code></pre></div>
<p>下記のようにメモリの現在の状態や使用履歴を見ることができる。</p>
<pre><code>          size current   min
          ------------------
            32      90     0
            64      78    74
            96     127   125

           ...

           992     128   128
          1024     128     0</code></pre>
<p>実際の組み込みソフトの開発では、 デバッグ用入出力機能からこのようなコードを実行できるようにすることで、 グローバルnew/deleteが使用するそれぞれのMPoolFixedインスタンスのメモリの調整ができるだろう。</p>
<h2 id="クラスnewdeleteのオーバーロード">クラスnew/deleteのオーバーロード <a id="SS_5_3"></a></h2>
<p>「<a href="dynamic_memory_allocation.html#SS_5_2_2">グローバルnew/deleteのオーバーロードの実装</a>」で示したコードのロックを、 「割り込みディセーブル/イネーブル」に置き換えることで、リアルタイム性を保障することができるが、 この機構はある程度多くのメモリを必要とするため、 極めてメモリ制限の厳しいシステムでは使用が困難である場合もあるだろう。</p>
<p>そのような場合、非スタック上でのオブジェクト生成には、</p>
<ul>
<li>限定的なクラスのみ、newによる動的な方法を用いる</li>
<li>その他のクラスに対しては、<a href="design_pattern.html#SS_3_12">Singleton</a>や<a href="design_pattern.html#SS_3_17">Named Constructor</a>と同様な静的な方法を用いる</li>
</ul>
<p>とし、グローバルnewを使用しないことが、より良いメモリ使用方法となり得る。</p>
<p>グローバルnewを使わずに動的にオブジェクトを生成するためには、</p>
<ul>
<li>プレースメントnewを使う</li>
<li>クラス毎にnew/deleteをオーバーロードする</li>
</ul>
<p>という2つの選択肢が考えられるが、すでに述べた理由によりプレースメントnewの使用は避けるべきである。 従って、その方法はクラス毎のnew/deleteのオーバーロードになる。</p>
<p>メモリ管理に「<a href="dynamic_memory_allocation.html#SS_5_2_1">固定長メモリプール</a>」で示したMPoolFixedを利用した実装例を以下に示す。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/class_new_delete_ut.cpp 14</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>    <span class="kw">struct</span> A {</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>        A() <span class="kw">noexcept</span> : name0{<span class="st">&quot;A&quot;</span>} {}</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>        <span class="dt">char</span> <span class="at">const</span>* name0;</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>        [[<span class="at">nodiscard</span>]] <span class="at">static</span> <span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>(<span class="dt">size_t</span> size);</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">void</span>                <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem) <span class="kw">noexcept</span>;</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">void</span>                <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem, <span class="bu">std::</span>size_t size) <span class="kw">noexcept</span>;</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a>        [[<span class="at">nodiscard</span>]] <span class="at">static</span> <span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>[](<span class="dt">size_t</span> size)                             = <span class="kw">delete</span>;</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">void</span>                <span class="kw">operator</span> <span class="kw">delete</span>[](<span class="dt">void</span>* mem) <span class="kw">noexcept</span>                   = <span class="kw">delete</span>;</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">void</span>                <span class="kw">operator</span> <span class="kw">delete</span>[](<span class="dt">void</span>* mem, <span class="bu">std::</span>size_t size) <span class="kw">noexcept</span> = <span class="kw">delete</span>;</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a>    };</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a>    MPoolFixed&lt;<span class="kw">sizeof</span>(A), <span class="dv">3</span>&gt; mpf_A;</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true"></a>    <span class="dt">void</span>* A::<span class="kw">operator</span> <span class="kw">new</span>(<span class="dt">size_t</span> size) { <span class="cf">return</span> mpf_A.Alloc(size); }</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true"></a>    <span class="dt">void</span> A::<span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem) <span class="kw">noexcept</span> { mpf_A.Free(mem); }</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true"></a>    <span class="dt">void</span> A::<span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem, <span class="bu">std::</span>size_t) <span class="kw">noexcept</span> { mpf_A.Free(mem); }</span></code></pre></div>
<p>以下の単体テストが示す通り、 静的に定義したMPoolFixedインスタンスがオーバーロードしたnew/deleteから使われていることがわかる (従ってグローバルnew/deleteは使われていないこともわかる)。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/class_new_delete_ut.cpp 43</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">3</span>, mpf_A.GetCount());</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>    {</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>        <span class="kw">auto</span> a = <span class="bu">std::</span>make_unique&lt;A&gt;();</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>        ASSERT_STREQ(<span class="st">&quot;A&quot;</span>, a-&gt;name0);</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>        ASSERT_EQ(<span class="dv">2</span>, mpf_A.GetCount());</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>    }</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">3</span>, mpf_A.GetCount());</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>    {</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true"></a>        <span class="kw">auto</span> a = <span class="bu">std::</span>make_unique&lt;A&gt;();</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true"></a>        ASSERT_STREQ(<span class="st">&quot;A&quot;</span>, a-&gt;name0);</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true"></a>        ASSERT_EQ(<span class="dv">2</span>, mpf_A.GetCount());</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true"></a></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true"></a>        <span class="kw">auto</span> b = <span class="bu">std::</span>make_unique&lt;A&gt;();</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true"></a>        ASSERT_STREQ(<span class="st">&quot;A&quot;</span>, b-&gt;name0);</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true"></a>        ASSERT_EQ(<span class="dv">1</span>, mpf_A.GetCount());</span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true"></a></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true"></a>        <span class="kw">auto</span> c = <span class="bu">std::</span>make_unique&lt;A&gt;();</span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true"></a>        ASSERT_STREQ(<span class="st">&quot;A&quot;</span>, c-&gt;name0);</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true"></a>        ASSERT_EQ(<span class="dv">0</span>, mpf_A.GetCount());</span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true"></a></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true"></a>        ASSERT_THROW(<span class="bu">std::</span>make_unique&lt;A&gt;(), MPoolBadAlloc);</span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true"></a>    }</span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true"></a>    ASSERT_EQ(<span class="dv">3</span>, mpf_A.GetCount());</span></code></pre></div>
<p>しかし、この方法ではnewのオーバーロードを行うクラス毎に、</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/class_new_delete_ut.cpp 20</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>    [[<span class="at">nodiscard</span>]] <span class="at">static</span> <span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>(<span class="dt">size_t</span> size);</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>    <span class="at">static</span> <span class="dt">void</span>                <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem) <span class="kw">noexcept</span>;</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>    <span class="at">static</span> <span class="dt">void</span>                <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem, <span class="bu">std::</span>size_t size) <span class="kw">noexcept</span>;</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>    [[<span class="at">nodiscard</span>]] <span class="at">static</span> <span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>[](<span class="dt">size_t</span> size)                             = <span class="kw">delete</span>;</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>    <span class="at">static</span> <span class="dt">void</span>                <span class="kw">operator</span> <span class="kw">delete</span>[](<span class="dt">void</span>* mem) <span class="kw">noexcept</span>                   = <span class="kw">delete</span>;</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>    <span class="at">static</span> <span class="dt">void</span>                <span class="kw">operator</span> <span class="kw">delete</span>[](<span class="dt">void</span>* mem, <span class="bu">std::</span>size_t size) <span class="kw">noexcept</span> = <span class="kw">delete</span>;</span></code></pre></div>
<p>を記述しなければならず、コードクローンの温床となってしまう。 これを避けるためには、 <a href="design_pattern.html#SS_3_21">CRTP(curiously recurring template pattern)</a> を利用した下記のようなクラステンプレートを導入すれば良い。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/op_new.h 5</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>    <span class="kw">class</span> OpNew {</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>        [[<span class="at">nodiscard</span>]] <span class="at">static</span> <span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>(<span class="dt">size_t</span> size) { <span class="cf">return</span> <span class="va">mpool_</span>.Alloc(size); }</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">void</span>                <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem) <span class="kw">noexcept</span> { <span class="va">mpool_</span>.Free(mem); }</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem, <span class="bu">std::</span>size_t) <span class="kw">noexcept</span> { <span class="va">mpool_</span>.Free(mem); }</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a>        [[<span class="at">nodiscard</span>]] <span class="at">static</span> <span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>[](<span class="dt">size_t</span> size)                             = <span class="kw">delete</span>;</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">void</span>                <span class="kw">operator</span> <span class="kw">delete</span>[](<span class="dt">void</span>* mem) <span class="kw">noexcept</span>                   = <span class="kw">delete</span>;</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">void</span>                <span class="kw">operator</span> <span class="kw">delete</span>[](<span class="dt">void</span>* mem, <span class="bu">std::</span>size_t size) <span class="kw">noexcept</span> = <span class="kw">delete</span>;</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true"></a></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true"></a>        <span class="at">static</span> MPool&amp; <span class="va">mpool_</span>;</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true"></a>    };</span></code></pre></div>
<p>このOpeNewを使用した「new/deleteのオーバーロードを持つ基底クラスとその一連の派生クラス」 の実装例を以下に示す。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/class_new_delete_ut.cpp 77</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>    <span class="kw">struct</span> A : <span class="kw">public</span> OpNew&lt;A&gt; {</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>        A() <span class="kw">noexcept</span> : name0{<span class="st">&quot;A&quot;</span>} {}</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>        <span class="dt">char</span> <span class="at">const</span>* name0;</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>    };</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>    <span class="kw">struct</span> B : A {</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>        B() <span class="kw">noexcept</span> : name1{<span class="st">&quot;B&quot;</span>} {}</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a>        <span class="dt">char</span> <span class="at">const</span>* name1;</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>    };</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a>    <span class="kw">struct</span> C : A {</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a>        C() <span class="kw">noexcept</span> : name1{<span class="st">&quot;C&quot;</span>} {}</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a>        <span class="dt">char</span> <span class="at">const</span>* name1;</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a>    };</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true"></a>    <span class="kw">struct</span> D : C {</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true"></a>        D() <span class="kw">noexcept</span> : name2{<span class="st">&quot;D&quot;</span>} {}</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true"></a>        <span class="dt">char</span> <span class="at">const</span>* name2;</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true"></a>    };</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true"></a></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true"></a>    MPoolFixed&lt;MaxSizeof&lt;A, B, C, D&gt;(), <span class="dv">10</span>&gt; mpf_ABCD;</span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true"></a></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true"></a>    <span class="kw">template</span> &lt;&gt;</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true"></a>    MPool&amp; OpNew&lt;A&gt;::<span class="va">mpool_</span> = mpf_ABCD;</span></code></pre></div>
<p>OpNewをクラステンプレートとし、内部で利用しないテンプレートパラメータを宣言した理由は、 別のクラスからはOpNewの別インスタンスを使用できるようにするためである。</p>
<p>この方法は、コードが若干複雑にることを除けば、 「<a href="dynamic_memory_allocation.html#SS_5_2">グローバルnew/deleteのオーバーロード</a>」に比べ、優れているように見えてしまうかもしれないが、 下記のように、さらに派生クラスを定義してしまうとnewが失敗してしまうことがあるので注意が必要である。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/class_new_delete_ut.cpp 135</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>    <span class="kw">struct</span> Large : A {</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>        <span class="dt">uint8_t</span> buff[<span class="dv">1024</span>];  <span class="co">// mpf_ABCDのメモリブロックのサイズを超える</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>    };</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a>    TEST(NewDelete_Opt, class_new_delete_fixed_derived_large)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a>    {</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>        ASSERT_EQ(<span class="dv">10</span>, mpf_ABCD.GetCount());</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a>        ASSERT_THROW(<span class="kw">auto</span> large = <span class="bu">std::</span>make_unique&lt;Large&gt;(), MPoolBadAlloc);  <span class="co">// サイズが大きすぎる</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true"></a>    }</span></code></pre></div>
<p>なお、 下記のようなクラスをnew/deleteをオーバーロードしないすべのクラスの基底クラスとすることで、 偶発的にグローバルnewを使ってしまわないようにすることもできる。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/op_new_deleted.h 3</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>    <span class="kw">class</span> OpNewDeleted {</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">void</span>* <span class="kw">operator</span> <span class="kw">new</span>(<span class="dt">size_t</span> size)                             = <span class="kw">delete</span>;</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">void</span>  <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem) <span class="kw">noexcept</span>                   = <span class="kw">delete</span>;</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>        <span class="at">static</span> <span class="dt">void</span>  <span class="kw">operator</span> <span class="kw">delete</span>(<span class="dt">void</span>* mem, <span class="bu">std::</span>size_t size) <span class="kw">noexcept</span> = <span class="kw">delete</span>;</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>    };</span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/class_new_delete_ut.cpp 150</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>    <span class="kw">class</span> DeletedNew : OpNewDeleted {  <span class="co">// プライベート継承</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>    };</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>    <span class="kw">class</span> DelivedDeletedNew : DeletedNew {  <span class="co">// プライベート継承</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>    };</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a>    <span class="co">// DeletedNew* ptr0 { new DeletedNew };                // OpNewDeletedの効果でコンパイルエラー</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true"></a>    <span class="co">// DelivedDeletedNew* ptr1 { new DelivedDeletedNew };  // 同上</span></span></code></pre></div>
<p>この記述方法は、コードインスペクションの省力化にも繋がるため、 OpNewを使うプロジェクトには導入するべきだろう。</p>
<h2 id="stlコンテナのアロケーター">STLコンテナのアロケーター <a id="SS_5_4"></a></h2>
<p>ここまで前提として来たような組み込みソフトにおいても、 その大部分のコードにリアルタイム性は不要であり、このような部分のコードにSTLコンテナが使用できれば、</p>
<ul>
<li>開発効率が向上する</li>
<li>開発コード量が少なくなる</li>
</ul>
<p>等のポジティブな影響を期待できることは多い。 STLコンテナはこういった状況に備えて、ユーザ定義のアロケータを使用できるように定義されている。 ここでは、アロケータの定義例や、その使い方を示す。</p>
<h3 id="stlコンテナ用アロケータ">STLコンテナ用アロケータ <a id="SS_5_4_1"></a></h3>
<p>アロケータの定義例を以下に示す。</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator.h 7</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>    <span class="kw">class</span> MPoolBasedAllocator {</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a>        <span class="kw">using</span> pointer                                = T*;</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a>        <span class="kw">using</span> const_pointer                          = T <span class="at">const</span>*;</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a>        <span class="kw">using</span> <span class="dt">value_type</span>                             = T;</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a>        <span class="kw">using</span> propagate_on_container_move_assignment = <span class="bu">std::</span>true_type;</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true"></a>        <span class="kw">using</span> is_always_equal                        = <span class="bu">std::</span>true_type;</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true"></a>        <span class="kw">using</span> <span class="dt">size_type</span>                              = <span class="dt">size_t</span>;</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true"></a>        <span class="kw">using</span> <span class="dt">difference_type</span>                        = <span class="dt">size_t</span>;</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true"></a>        <span class="kw">template</span> &lt;<span class="kw">class</span> U&gt;</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true"></a>        <span class="kw">struct</span> rebind {</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true"></a>            <span class="kw">using</span> other = MPoolBasedAllocator&lt;U&gt;;</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true"></a>        };</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true"></a></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true"></a>        T*   allocate(<span class="dt">size_type</span> count) { <span class="cf">return</span> <span class="kw">static_cast</span>&lt;pointer&gt;(<span class="va">mpool_</span>.Alloc(count * <span class="kw">sizeof</span>(T))); }</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true"></a>        <span class="dt">void</span> deallocate(T* mem, <span class="dt">size_type</span>) <span class="kw">noexcept</span> { <span class="va">mpool_</span>.Free(mem); }</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true"></a></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true"></a>        <span class="at">static</span> MPool&amp; <span class="va">mpool_</span>;</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true"></a>    };</span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true"></a></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;  <span class="co">// T型のMPoolBasedAllocatorはシステムに唯一</span></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true"></a>    <span class="dt">bool</span> <span class="kw">operator</span>==(MPoolBasedAllocator&lt;T&gt; <span class="at">const</span>&amp;, MPoolBasedAllocator&lt;T&gt; <span class="at">const</span>&amp;) <span class="kw">noexcept</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true"></a>    {</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true"></a>        <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true"></a>    }</span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true"></a></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span> U&gt;</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true"></a>    <span class="dt">bool</span> <span class="kw">operator</span>==(MPoolBasedAllocator&lt;T&gt; <span class="at">const</span>&amp;, MPoolBasedAllocator&lt;U&gt; <span class="at">const</span>&amp;) <span class="kw">noexcept</span></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true"></a>    {</span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true"></a>        <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true"></a>    }</span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true"></a></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span> U&gt;</span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true"></a>    <span class="dt">bool</span> <span class="kw">operator</span>!=(MPoolBasedAllocator&lt;T&gt; <span class="at">const</span>&amp; lhs, MPoolBasedAllocator&lt;U&gt; <span class="at">const</span>&amp; rhs) <span class="kw">noexcept</span></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true"></a>    {</span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true"></a>        <span class="cf">return</span> !(lhs == rhs);</span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true"></a>    }</span></code></pre></div>
<p>アロケータのパブリックなメンバやoperator ==、operator !=は、STLに従い定義している (<a href="https://cpprefjp.github.io/reference/memory/allocator.html">STL allocator</a>参照)。</p>
<p>上記コードからわかるようにメモリの実際のアロケーションには、 これまでと同様にMPoolから派生したクラスを使用するが、 リアルタイム性は不要であるためメモリ効率が悪いMPoolFixedは使わない。 代わりに、可変長メモリを扱うためメモリ効率がよいMPoolVariabl (「<a href="dynamic_memory_allocation.html#SS_5_4_2">可変長メモリプール</a>」参照)を使う。</p>
<h3 id="可変長メモリプール">可変長メモリプール <a id="SS_5_4_2"></a></h3>
<p>可変長メモリプールを生成するMPoolVariableの実装は下記のようになる (全体は巻末の“<a href="sample_code.html#SS_7_1_2">example/dynamic_memory_allocation/mpool_variable.h</a>”に掲載する)。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_variable.h 59</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="dt">uint32_t</span> MEM_SIZE&gt;</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>    <span class="kw">class</span> MPoolVariable <span class="kw">final</span> : <span class="kw">public</span> MPool {</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a>        MPoolVariable() <span class="kw">noexcept</span> : MPool{MEM_SIZE}</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>        {</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a>            <span class="va">header_</span>-&gt;next    = <span class="kw">nullptr</span>;</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a>            <span class="va">header_</span>-&gt;n_nuits = <span class="kw">sizeof</span>(<span class="va">buff_</span>) / Inner_::unit_size;</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a>        }</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true"></a>        <span class="co">// 中略</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true"></a>        ...</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true"></a>    <span class="kw">private</span>:</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true"></a>        <span class="kw">using</span> <span class="dt">header_t</span> = Inner_::<span class="dt">header_t</span>;</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true"></a></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true"></a>        Inner_::<span class="dt">buffer_t</span>&lt;MEM_SIZE&gt; <span class="va">buff_</span>{};</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true"></a>        <span class="dt">header_t</span>*                  <span class="va">header_</span>{<span class="kw">reinterpret_cast</span>&lt;<span class="dt">header_t</span>*&gt;(<span class="va">buff_</span>.buffer)};</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true"></a>        <span class="at">mutable</span> SpinLock           <span class="va">spin_lock_</span>{};</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true"></a>        <span class="dt">size_t</span>                     <span class="va">unit_count_</span>{<span class="kw">sizeof</span>(<span class="va">buff_</span>) / Inner_::unit_size};</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true"></a>        <span class="dt">size_t</span>                     <span class="va">unit_count_min_</span>{<span class="kw">sizeof</span>(<span class="va">buff_</span>) / Inner_::unit_size};</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true"></a></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span>* alloc(<span class="dt">size_t</span> size) <span class="kw">noexcept</span> <span class="kw">override</span></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true"></a>        {</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true"></a>            ...</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true"></a>        }</span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true"></a></span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">void</span> free(<span class="dt">void</span>* mem) <span class="kw">noexcept</span> <span class="kw">override</span></span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true"></a>        {</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true"></a>            ...</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true"></a>        }</span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true"></a></span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">size_t</span> get_size() <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span> { <span class="cf">return</span> <span class="dv">1</span>; }</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">size_t</span> get_count() <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span> { <span class="cf">return</span> <span class="va">unit_count_</span> * Inner_::unit_size; }</span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">size_t</span> get_count_min() <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span></span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true"></a>        {</span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true"></a>            <span class="cf">return</span> <span class="va">unit_count_min_</span> * Inner_::unit_size;</span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true"></a>        }</span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true"></a></span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true"></a>        <span class="kw">virtual</span> <span class="dt">bool</span> is_valid(<span class="dt">void</span> <span class="at">const</span>* mem) <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span></span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true"></a>        {</span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true"></a>            <span class="cf">return</span> (&amp;<span class="va">buff_</span> &lt; mem) &amp;&amp; (mem &lt; &amp;<span class="va">buff_</span>.buffer[ArrayLength(<span class="va">buff_</span>.buffer)]);</span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true"></a>        }</span>
<span id="cb31-45"><a href="#cb31-45" aria-hidden="true"></a>    };</span></code></pre></div>
<p>下記のようにMPoolVariable、 MPoolBasedAllocatorを使うことでnew char[]に対応するアロケータが定義できる。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 11</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>    <span class="kw">namespace</span> {</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>    MPoolVariable&lt;<span class="dv">1024</span> * <span class="dv">64</span>&gt; mpv_allocator;</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>    }</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a>    <span class="kw">template</span> &lt;&gt;</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true"></a>    MPool&amp; MPoolBasedAllocator&lt;<span class="dt">char</span>&gt;::<span class="va">mpool_</span> = mpv_allocator;</span></code></pre></div>
<p>下記の単体テストは、このアロケータを使うstd::stringオブジェクトの宣言方法と、 その振る舞いを示している。</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 24</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>    <span class="kw">auto</span> rest = mpv_allocator.GetCount();</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a>    <span class="kw">auto</span> str  = <span class="bu">std::</span>basic_string&lt;<span class="dt">char</span>, <span class="bu">std::</span>char_traits&lt;<span class="dt">char</span>&gt;, MPoolBasedAllocator&lt;<span class="dt">char</span>&gt;&gt;{<span class="st">&quot;hehe&quot;</span>};</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a>    ASSERT_TRUE(mpv_allocator.IsValid(str.c_str()));  <span class="co">// mpv_allocatorを使用してメモリ確保</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a>    ASSERT_GT(rest, mpv_allocator.GetCount());  <span class="co">// mpv_allocatorのメモリが減っていることの確認</span></span></code></pre></div>
<p>この長い宣言は、下記のようにすることで簡潔に記述できるようになる。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 34</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>    <span class="kw">using</span> mpv_string = <span class="bu">std::</span>basic_string&lt;<span class="dt">char</span>, <span class="bu">std::</span>char_traits&lt;<span class="dt">char</span>&gt;, MPoolBasedAllocator&lt;<span class="dt">char</span>&gt;&gt;;</span></code></pre></div>
<p>下記のように宣言、定義することで、</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 50</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>    <span class="kw">template</span> &lt;&gt;</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>    MPool&amp; MPoolBasedAllocator&lt;<span class="dt">int</span>&gt;::<span class="va">mpool_</span> = mpv_allocator;</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a>    <span class="kw">using</span> mpv_vector_int = <span class="bu">std::</span>vector&lt;<span class="dt">int</span>, MPoolBasedAllocator&lt;<span class="dt">int</span>&gt;&gt;;</span></code></pre></div>
<p>下記の単体テストが示す通り、std::vector&lt;int&gt;にこのアロケータを使わせることもできる。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 61</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>    <span class="kw">auto</span> rest = mpv_allocator.GetCount();</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>    <span class="kw">auto</span> ints = mpv_vector_int{<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>};</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>    ASSERT_TRUE(mpv_allocator.IsValid(&amp;ints[<span class="dv">0</span>]));  <span class="co">// mpv_allocatorのメモリであることの確認</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a>    ASSERT_GT(rest, mpv_allocator.GetCount());  <span class="co">// mpv_allocatorのメモリが減っていることの確認</span></span></code></pre></div>
<p>これまでの手法を組み合わせ下記のようにすることで、 std::stringと同等のオブジェクトを保持するstd::vectorを宣言することもできる。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 72</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>    <span class="kw">using</span> mpv_vector_str = <span class="bu">std::</span>vector&lt;mpv_string, MPoolBasedAllocator&lt;mpv_string&gt;&gt;;</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a>    <span class="kw">template</span> &lt;&gt;</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a>    MPool&amp; MPoolBasedAllocator&lt;mpv_string&gt;::<span class="va">mpool_</span> = mpv_allocator;</span></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 94</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>    <span class="kw">auto</span> strs = mpv_vector_str{<span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>};</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a>    ASSERT_GT(rest, mpv_allocator.GetCount());</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="kw">auto</span> <span class="at">const</span>&amp; s : strs) {</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true"></a>        ASSERT_TRUE(mpv_allocator.IsValid(&amp;s));  <span class="co">// mpv_allocatorのメモリであることの確認</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true"></a>        ASSERT_TRUE(mpv_allocator.IsValid(s.c_str()));  <span class="co">// mpv_allocatorのメモリであることの確認</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true"></a>    }</span></code></pre></div>
<p>しかし、下記に示すように、これまでの定義、 宣言のみではmpv_stringのnewにこのアロケータを使わせることはできない。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 121</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a>    <span class="kw">auto</span> rest = mpv_allocator.GetCount();</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a>    <span class="kw">auto</span> str0 = <span class="bu">std::</span>make_unique&lt;mpv_string&gt;();  <span class="co">// グローバルnewが使われる</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true"></a>    <span class="co">// mpv_stringのnewにはmpv_allocatorは使われない</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true"></a>    ASSERT_FALSE(mpv_allocator.IsValid(str0.get()));</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true"></a>    ASSERT_EQ(rest, mpv_allocator.GetCount());</span></code></pre></div>
<p>そうするためには、さらに下記のような定義が必要になる。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 108</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>    <span class="kw">struct</span> mpv_string_op_new : OpNew&lt;mpv_string_op_new&gt;, mpv_string {</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a>        <span class="kw">using</span> mpv_string::basic_string;</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a>    };</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true"></a>    <span class="kw">template</span> &lt;&gt;</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true"></a>    MPool&amp; OpNew&lt;mpv_string_op_new&gt;::<span class="va">mpool_</span> = mpv_allocator;</span></code></pre></div>
<p>このようにすることで、下記に示すように期待した動きになる。</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 133</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>    rest = mpv_allocator.GetCount();</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>    <span class="kw">auto</span> str1 = <span class="bu">std::</span>make_unique&lt;mpv_string_op_new&gt;();</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true"></a>    <span class="co">// mpv_string_op_newのnewにmpv_allocatorが使われる</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true"></a>    ASSERT_TRUE(mpv_allocator.IsValid(str1.get()));</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true"></a>    ASSERT_GT(rest, mpv_allocator.GetCount());</span></code></pre></div>
<p>ただし、std::make_sharedを使用した場合、この関数のメモリアロケーションの最適化により、 下記に示すように期待した結果にならないため、注意が必要である。</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 145</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a>    rest = mpv_allocator.GetCount();</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a>    <span class="kw">auto</span> str2 = <span class="bu">std::</span>make_shared&lt;mpv_string_op_new&gt;();</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true"></a>    <span class="co">// mpv_string_op_newのnewにmpv_allocatorが使われない!!!</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true"></a>    ASSERT_FALSE(mpv_allocator.IsValid(str2.get()));</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true"></a>    ASSERT_EQ(rest, mpv_allocator.GetCount());</span></code></pre></div>
<p>newをオーバーロードしたクラスをstd::shared_ptrで管理する場合、下記のようにしなければならない。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 157</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a>    rest = mpv_allocator.GetCount();</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true"></a>    <span class="kw">auto</span> str3 = <span class="bu">std::</span>shared_ptr&lt;mpv_string_op_new&gt;{<span class="kw">new</span> mpv_string_op_new};</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true"></a>    <span class="co">// mpv_string_op_newのnewにmpv_allocatorが使われる</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true"></a>    ASSERT_TRUE(mpv_allocator.IsValid(str3.get()));</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true"></a>    ASSERT_GT(rest, mpv_allocator.GetCount());</span></code></pre></div>
<h3 id="デバッグ用イテレータ-1">デバッグ用イテレータ <a id="SS_5_4_3"></a></h3>
<p><a href="dynamic_memory_allocation.html#SS_5_4_2">可変長メモリプール</a>を使用すると、 メモリのフラグメントによりアロケーションが失敗することがあり得る。 このような事態が発生している可能性がある場合、 アロケータが保持しているメモリの状態を表示させることがデバッグの第一歩となる。</p>
<p>下記のコードは、そのためのインターフェースを提供する。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_variable.h 59</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a>    <span class="kw">template</span> &lt;<span class="dt">uint32_t</span> MEM_SIZE&gt;</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a>    <span class="kw">class</span> MPoolVariable <span class="kw">final</span> : <span class="kw">public</span> MPool {</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a>    <span class="kw">public</span>:</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true"></a></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true"></a>        <span class="co">// 中略</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true"></a>        ...</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true"></a>        <span class="kw">class</span> const_iterator {</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true"></a>        <span class="kw">public</span>:</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true"></a>            <span class="kw">explicit</span> const_iterator(Inner_::<span class="dt">header_t</span> <span class="at">const</span>* header) <span class="kw">noexcept</span> : <span class="va">header_</span>{header} {}</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true"></a>            const_iterator(const_iterator <span class="at">const</span>&amp;) = <span class="cf">default</span>;</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true"></a>            const_iterator(const_iterator&amp;&amp;)      = <span class="cf">default</span>;</span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true"></a></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true"></a>            const_iterator&amp; <span class="kw">operator</span>++() <span class="kw">noexcept</span>  <span class="co">// 前置++のみ実装</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true"></a>            {</span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true"></a>                <span class="ot">assert</span>(<span class="va">header_</span> != <span class="kw">nullptr</span>);</span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true"></a>                <span class="va">header_</span> = <span class="va">header_</span>-&gt;next;</span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true"></a></span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true"></a>                <span class="cf">return</span> *<span class="kw">this</span>;</span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true"></a>            }</span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true"></a></span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true"></a>            Inner_::<span class="dt">header_t</span> <span class="at">const</span>* <span class="kw">operator</span>*() <span class="kw">noexcept</span> { <span class="cf">return</span> <span class="va">header_</span>; }</span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true"></a>            <span class="dt">bool</span> <span class="kw">operator</span>==(const_iterator <span class="at">const</span>&amp; rhs) <span class="kw">noexcept</span> { <span class="cf">return</span> <span class="va">header_</span> == rhs.<span class="va">header_</span>; }</span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true"></a>            <span class="dt">bool</span> <span class="kw">operator</span>!=(const_iterator <span class="at">const</span>&amp; rhs) <span class="kw">noexcept</span> { <span class="cf">return</span> !(*<span class="kw">this</span> == rhs); }</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true"></a></span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true"></a>        <span class="kw">private</span>:</span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true"></a>            Inner_::<span class="dt">header_t</span> <span class="at">const</span>* <span class="va">header_</span>;</span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true"></a>        };</span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true"></a></span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true"></a>        const_iterator begin() <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> const_iterator{<span class="va">header_</span>}; }</span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true"></a>        const_iterator end() <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> const_iterator{<span class="kw">nullptr</span>}; }</span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true"></a>        const_iterator cbegin() <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> const_iterator{<span class="va">header_</span>}; }</span>
<span id="cb44-35"><a href="#cb44-35" aria-hidden="true"></a>        const_iterator cend() <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> const_iterator{<span class="kw">nullptr</span>}; }</span>
<span id="cb44-36"><a href="#cb44-36" aria-hidden="true"></a></span>
<span id="cb44-37"><a href="#cb44-37" aria-hidden="true"></a>        <span class="co">// 中略</span></span>
<span id="cb44-38"><a href="#cb44-38" aria-hidden="true"></a>        ...</span>
<span id="cb44-39"><a href="#cb44-39" aria-hidden="true"></a>    };</span></code></pre></div>
<p>このインターフェースを下記のように使用することで、</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/mpool_allocator_ut.cpp 213</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a>    <span class="cf">for</span> (<span class="kw">auto</span> mem : mpv_allocator) {</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a>        <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>setw(<span class="dv">16</span>) &lt;&lt; mem-&gt;next &lt;&lt; <span class="st">&quot;:&quot;</span> &lt;&lt; mem-&gt;n_nuits &lt;&lt; <span class="bu">std::</span>endl;</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a>    }</span></code></pre></div>
<p>下記のようにmpv_allocator.header_が保持するメモリの現在の状態を見ることができる (これによるとmpv_allocatorが保持するメモリの先頭付近では多少フラグメントを起こしているが、 最後に大きなメモリブロックがあるため、全体としては問題ないレベルである)。</p>
<pre><code>        0x7f073afe59d0:3
        0x7f073afe5a60:3
        0x7f073afe5ac0:3
        0x7f073afe5b70:3
        0x7f073afe5c50:11
        0x7f073afe5cb0:3
        0x7f073afe5e50:13
                     0:4018</code></pre>
<p>「<a href="dynamic_memory_allocation.html#SS_5_2_2">グローバルnew/deleteのオーバーロードの実装</a>」でも述べたように、 デバッグ用入出力機能からこのような出力を得られるようにしておくべきである。</p>
<h3 id="エクセプション処理機構の変更">エクセプション処理機構の変更 <a id="SS_5_4_4"></a></h3>
<p>多くのコンパイラのエクセプション処理機構にはnew/deleteやmalloc/freeが使われているため、 リアルタイム性が必要な個所でエクセプション処理を行ってはならない。 そういった規制でプログラミングを行っていると、 リアルタイム性が不要な処理であるため使用しているSTLコンテナにすら、 既存のエクセプション処理機構を使わせたく無くなるものである。</p>
<p>コンパイラに<a href="term_explanation.html#SS_6_9_1">g++</a>や<a href="term_explanation.html#SS_6_9_2">clang++</a>を使っている場合、 下記関数を置き換えることでそういった要望を叶えることができる。</p>
<table>
<thead>
<tr class="header">
<th>関数</th>
<th>機能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>__cxa_allocate_exception(size_t thrown_size)</td>
<td>エクセプション処理用のメモリ確保</td>
</tr>
<tr class="even">
<td>__cxa_free_exception(void* thrown_exception)</td>
<td>上記で確保したメモリの解放</td>
</tr>
</tbody>
</table>
<p>オープンソースである<a href="https://github.com/ApexAI/static_exception">static exception</a>を使うことで、 上記2関数を置き換えることもできるが、この実装が複雑すぎると思うのであれば、 下記に示すような、これまで使用したMPoolFixedによる単純な実装を使うこともできる。</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/exception_allocator_ut.cpp 12</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a>    <span class="co">// https://github.com/hjl-tools/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/unwind-cxx.h</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true"></a>    <span class="co">// の抜粋</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true"></a>    <span class="kw">namespace</span> __cxxabiv1 {</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true"></a>    <span class="kw">struct</span> __cxa_exception {</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true"></a>        ...</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true"></a>    };</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true"></a>    }  <span class="co">// namespace __cxxabiv1</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true"></a></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true"></a>    <span class="kw">namespace</span> {</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true"></a></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span>             offset{<span class="kw">sizeof</span>(__cxxabiv1::__cxa_exception)};</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true"></a>    MPoolFixed&lt;offset + <span class="dv">128</span>, <span class="dv">50</span>&gt; mpf_exception;</span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true"></a>    }  <span class="co">// namespace</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true"></a></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true"></a>    <span class="at">extern</span> <span class="st">&quot;C&quot;</span> {</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true"></a></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true"></a>    <span class="dt">void</span>* __cxa_allocate_exception(<span class="dt">size_t</span> thrown_size)</span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true"></a>    {</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true"></a>        <span class="kw">auto</span> alloc_size = thrown_size + offset;  <span class="co">// メモリの実際の必要量はthrown_size+offset</span></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true"></a>        <span class="kw">auto</span> mem        = mpf_exception.AllocNoExcept(alloc_size);</span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true"></a></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true"></a>        <span class="ot">assert</span>(mem != <span class="kw">nullptr</span>);</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true"></a></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true"></a>        memset(mem, <span class="dv">0</span>, alloc_size);</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true"></a>        <span class="kw">auto</span>* ret = <span class="kw">static_cast</span>&lt;<span class="dt">uint8_t</span>*&gt;(mem);</span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true"></a></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true"></a>        ret += offset;</span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true"></a></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true"></a>        <span class="cf">return</span> ret;</span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true"></a>    }</span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true"></a></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true"></a>    <span class="dt">void</span> __cxa_free_exception(<span class="dt">void</span>* thrown_exception)</span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true"></a>    {</span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true"></a>        <span class="kw">auto</span>* ret = <span class="kw">static_cast</span>&lt;<span class="dt">uint8_t</span>*&gt;(thrown_exception);</span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true"></a></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true"></a>        ret -= offset;</span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true"></a>        mpf_exception.Free(ret);</span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true"></a>    }</span></code></pre></div>
<p>以下に単体テストを示す。</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a>    <span class="co">// @@@ example/dynamic_memory_allocation/exception_allocator_ut.cpp 100</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a>    <span class="kw">auto</span> count             = mpf_exception.GetCount();</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true"></a>    <span class="kw">auto</span> exception_occured = <span class="kw">false</span>;</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true"></a></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true"></a>    <span class="cf">try</span> {</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true"></a>        <span class="cf">throw</span> <span class="bu">std::</span>exception{};</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true"></a>    }</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true"></a>    <span class="cf">catch</span> (<span class="bu">std::</span>exception <span class="at">const</span>&amp; e) {</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true"></a>        ASSERT_EQ(count - <span class="dv">1</span>, mpf_exception.GetCount());  <span class="co">// 1個消費</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true"></a>        exception_occured = <span class="kw">true</span>;</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true"></a>    }</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true"></a></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true"></a>    ASSERT_TRUE(exception_occured);</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true"></a>    ASSERT_EQ(count, mpf_exception.GetCount());  <span class="co">// 1個解放</span></span></code></pre></div>
<p>すでに述べたが、残念なことに、この方法はC++の標準外であるため、 これを適用できるコンパイラは限られている。 しかし、多くのコンパイラはこれと同様の拡張方法を備えているため、 安易にエクセプションやSTLコンテナを使用禁止することなく、安全に使用する方法を探るべきだろう。</p>
</body>
</html>
