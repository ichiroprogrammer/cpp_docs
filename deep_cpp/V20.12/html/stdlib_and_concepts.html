<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Deep C++(V20.12)</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #303030; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */

    body {
        margin: 0 auto;
        max-width: none;
        width: 1000px;
        padding-left: 50px;
        padding-right: 50px;
        padding-top: 50px;
        padding-bottom: 50px;
        hyphens: auto;
        overflow-wrap: break-word;
        text-rendering: optimizeLegibility;
        font-kerning: normal;
    }

    table {
        border-collapse: collapse;
    }

    table, th, td {
        border: 2px solid black;
    }

    header {
        margin-bottom: 4em;
        text-align: center;
        color: white;
        background-color: lightblue;
    }

    h1:not(:first-of-type) {
        page-break-before: always;
    }

  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Deep C++(V20.12)</h1>
<p class="author">autor:ichiroprogrammer</p>
</header>
<!-- essential/md/stdlib_and_concepts.md -->
<h1
id="標準ライブラリとプログラミングの概念">標準ライブラリとプログラミングの概念
<a id="SS_7"></a></h1>
<p>この章では、C++標準ライブラリやそれによって導入されたプログラミングの概念等の紹介を行う。</p>
<hr />
<p><strong>この章の構成</strong></p>
<p>   <a href="stdlib_and_concepts.html#SS_7_1">ユーティリティ</a><br />
    <a href="stdlib_and_concepts.html#SS_7_1_1">std::move</a><br />
    <a href="stdlib_and_concepts.html#SS_7_1_2">std::forward</a></p>
<p>   <a href="stdlib_and_concepts.html#SS_7_2">type_traits</a><br />
    <a
href="stdlib_and_concepts.html#SS_7_2_1">std::integral_constant</a><br />
    <a href="stdlib_and_concepts.html#SS_7_2_2">std::true_type</a><br />
    <a href="stdlib_and_concepts.html#SS_7_2_3">std::false_type</a><br />
    <a href="stdlib_and_concepts.html#SS_7_2_4">std::is_same</a><br />
    <a href="stdlib_and_concepts.html#SS_7_2_5">std::enable_if</a><br />
    <a href="stdlib_and_concepts.html#SS_7_2_6">std::conditional</a><br />
    <a href="stdlib_and_concepts.html#SS_7_2_7">std::is_void</a><br />
    <a
href="stdlib_and_concepts.html#SS_7_2_8">std::is_copy_assignable</a><br />
    <a
href="stdlib_and_concepts.html#SS_7_2_9">std::is_move_assignable</a></p>
<p>   <a href="stdlib_and_concepts.html#SS_7_3">並列処理</a><br />
    <a href="stdlib_and_concepts.html#SS_7_3_1">std::thread</a><br />
    <a href="stdlib_and_concepts.html#SS_7_3_2">std::mutex</a><br />
    <a href="stdlib_and_concepts.html#SS_7_3_3">std::atomic</a><br />
    <a
href="stdlib_and_concepts.html#SS_7_3_4">std::condition_variable</a></p>
<p>   <a
href="stdlib_and_concepts.html#SS_7_4">ロック所有ラッパー</a><br />
    <a href="stdlib_and_concepts.html#SS_7_4_1">std::lock_guard</a><br />
    <a href="stdlib_and_concepts.html#SS_7_4_2">std::unique_lock</a><br />
    <a href="stdlib_and_concepts.html#SS_7_4_3">std::scoped_lock</a></p>
<p>   <a href="stdlib_and_concepts.html#SS_7_5">スマートポインタ</a><br />
    <a href="stdlib_and_concepts.html#SS_7_5_1">std::unique_ptr</a><br />
     <a
href="stdlib_and_concepts.html#SS_7_5_1_1">std::make_unique</a></p>
<p>    <a
href="stdlib_and_concepts.html#SS_7_5_2">std::shared_ptr</a><br />
     <a
href="stdlib_and_concepts.html#SS_7_5_2_1">std::make_shared</a><br />
     <a
href="stdlib_and_concepts.html#SS_7_5_2_2">std::enable_shared_from_this</a></p>
<p>    <a href="stdlib_and_concepts.html#SS_7_5_3">std::weak_ptr</a><br />
    <a href="stdlib_and_concepts.html#SS_7_5_4">std::auto_ptr</a></p>
<p>   <a href="stdlib_and_concepts.html#SS_7_6">Polymorphic Memory
Resource(pmr)</a><br />
    <a
href="stdlib_and_concepts.html#SS_7_6_1">std::pmr::memory_resource</a><br />
    <a
href="stdlib_and_concepts.html#SS_7_6_2">std::pmr::polymorphic_allocator</a><br />
    <a href="stdlib_and_concepts.html#SS_7_6_3">pool_resource</a></p>
<p>   <a href="stdlib_and_concepts.html#SS_7_7">コンテナ</a><br />
    <a
href="stdlib_and_concepts.html#SS_7_7_1">シーケンスコンテナ(Sequence
Containers)</a><br />
     <a
href="stdlib_and_concepts.html#SS_7_7_1_1">std::forward_list</a></p>
<p>    <a
href="stdlib_and_concepts.html#SS_7_7_2">連想コンテナ(Associative
Containers)</a><br />
    <a
href="stdlib_and_concepts.html#SS_7_7_3">無順序連想コンテナ(Unordered
Associative Containers)</a><br />
     <a
href="stdlib_and_concepts.html#SS_7_7_3_1">std::unordered_set</a><br />
     <a
href="stdlib_and_concepts.html#SS_7_7_3_2">std::unordered_map</a><br />
     <a href="stdlib_and_concepts.html#SS_7_7_3_3">std::type_index</a></p>
<p>    <a
href="stdlib_and_concepts.html#SS_7_7_4">コンテナアダプタ(Container
Adapters)</a><br />
    <a href="stdlib_and_concepts.html#SS_7_7_5">特殊なコンテナ</a></p>
<p>   <a href="stdlib_and_concepts.html#SS_7_8">std::optional</a><br />
    <a href="stdlib_and_concepts.html#SS_7_8_1">戻り値の無効表現</a><br />
    <a
href="stdlib_and_concepts.html#SS_7_8_2">オブジェクトの遅延初期化</a></p>
<p>   <a href="stdlib_and_concepts.html#SS_7_9">std::variant</a><br />
   <a href="stdlib_and_concepts.html#SS_7_10">オブジェクトの比較</a><br />
    <a href="stdlib_and_concepts.html#SS_7_10_1">std::rel_ops</a><br />
    <a
href="stdlib_and_concepts.html#SS_7_10_2">std::tuppleを使用した比較演算子の実装方法</a></p>
<p>   <a href="stdlib_and_concepts.html#SS_7_11">その他</a><br />
    <a href="stdlib_and_concepts.html#SS_7_11_1">SSO(Small String
Optimization)</a><br />
    <a href="stdlib_and_concepts.html#SS_7_11_2">heap allocation
elision</a></p>
<p><a href="deep_intro.html#SS_1_2">インデックス</a>に戻る。</p>
<hr />
<h2 id="ユーティリティ">ユーティリティ <a id="SS_7_1"></a></h2>
<h3 id="stdmove">std::move <a id="SS_7_1_1"></a></h3>
<p>std::moveは引数を<a
href="core_lang_spec.html#SS_6_8_2">rvalueリファレンス</a>に変換する関数テンプレートである。</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th>引数</th>
<th>std::moveの動作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>非const <a href="core_lang_spec.html#SS_6_7_1_1">lvalue</a></td>
<td>引数を<a
href="core_lang_spec.html#SS_6_8_2">rvalueリファレンス</a>にキャストする</td>
</tr>
<tr class="even">
<td>const <a href="core_lang_spec.html#SS_6_7_1_1">lvalue</a></td>
<td>引数をconst <a
href="core_lang_spec.html#SS_6_8_2">rvalueリファレンス</a>にキャストする</td>
</tr>
</tbody>
</table>
<p>この表の動作仕様を下記ののコードで示す。</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/utility_ut.cpp 10</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> f<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span>         <span class="co">// f-0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> f<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span>        <span class="co">// f-1</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> f<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span>   <span class="co">// f-2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> f<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// f-3</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/utility_ut.cpp 21</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string       str<span class="op">{};</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="at">const</span> cstr<span class="op">{};</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> f<span class="op">(</span>str<span class="op">));</span>               <span class="co">// strはlvalue → f(std::string&amp;)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> f<span class="op">(</span><span class="bu">std::</span>string<span class="op">{}));</span>     <span class="co">// 一時オブジェクトはrvalue → f(std::string&amp;&amp;)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> f<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>str<span class="op">)));</span>    <span class="co">// std::moveでrvalueに変換 → f(std::string&amp;&amp;)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> f<span class="op">(</span>cstr<span class="op">));</span>              <span class="co">// cstrはconst lvalue → f(std::string const&amp;)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> f<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>cstr<span class="op">)));</span>   <span class="co">// std::moveでconst rvalueに変換 → f(std::string const&amp;&amp;)</span></span></code></pre></div>
<p>std::moveは以下の２つの概念ときわめて密接に関連しており、</p>
<ul>
<li><a href="core_lang_spec.html#SS_6_8_2">rvalueリファレンス</a></li>
<li><a href="cpp_idioms.html#SS_8_5_3">moveセマンティクス</a></li>
</ul>
<p>これら3つが組み合わさることで、不要なコピーを避けた高効率なリソース管理が実現される。</p>
<h3 id="stdforward">std::forward <a id="SS_7_1_2"></a></h3>
<p>std::forwardは、下記の２つの概念を実現するための関数テンプレートである。</p>
<ul>
<li><a href="core_lang_spec.html#SS_6_8_3">forwardingリファレンス</a></li>
<li><a href="core_lang_spec.html#SS_6_8_5">perfect forwarding</a></li>
</ul>
<p>std::forwardを適切に使用することで、引数の値カテゴリを保持したまま転送でき、
move可能なオブジェクトの不要なコピーを避けることができる。</p>
<h2 id="type_traits">type_traits <a id="SS_7_2"></a></h2>
<p>type_traitsは、型に関する情報をコンパイル時に取得・変換するためのメタ関数群で、
型特性の判定や型操作を静的に行うために用いられる。</p>
<p>以下に代表的なものをいくつか説明する。</p>
<ul>
<li><a
href="stdlib_and_concepts.html#SS_7_2_1">std::integral_constant</a></li>
<li><a href="stdlib_and_concepts.html#SS_7_2_2">std::true_type</a>/<a
href="stdlib_and_concepts.html#SS_7_2_3">std::false_type</a></li>
<li><a href="stdlib_and_concepts.html#SS_7_2_4">std::is_same</a></li>
<li><a href="stdlib_and_concepts.html#SS_7_2_5">std::enable_if</a></li>
<li><a href="stdlib_and_concepts.html#SS_7_2_6">std::conditional</a></li>
<li><a href="stdlib_and_concepts.html#SS_7_2_7">std::is_void</a></li>
<li><a
href="stdlib_and_concepts.html#SS_7_2_8">std::is_copy_assignable</a></li>
<li><a
href="stdlib_and_concepts.html#SS_7_2_9">std::is_move_assignable</a></li>
</ul>
<h3 id="stdintegral_constant">std::integral_constant
<a id="SS_7_2_1"></a></h3>
<p>std::integral_constantは「テンプレートパラメータとして与えられた型とその定数から新たな型を定義する」
クラステンプレートである。</p>
<p>以下に簡単な使用例を示す。</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 13</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> int3 <span class="op">=</span> <span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::is_same_vの2パラメータが同一であれば、std::is_same_v&lt;&gt; == true</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> int3<span class="op">::</span><span class="dt">value_type</span><span class="op">&gt;);</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;,</span> int3<span class="op">::</span>type<span class="op">&gt;);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>int3<span class="op">::</span>value <span class="op">==</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> bool_true <span class="op">=</span> <span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> <span class="kw">true</span><span class="op">&gt;;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> bool_true<span class="op">::</span><span class="dt">value_type</span><span class="op">&gt;);</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> <span class="kw">true</span><span class="op">&gt;,</span> bool_true<span class="op">::</span>type<span class="op">&gt;);</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>bool_true<span class="op">::</span>value <span class="op">==</span> <span class="kw">true</span><span class="op">);</span></span></code></pre></div>
<p>また、すでに示したようにstd::true_type/std::false_typeを実装するためのクラステンプレートでもある。</p>
<h3 id="stdtrue_type">std::true_type <a id="SS_7_2_2"></a></h3>
<p><code>std::true_type</code>(と<code>std::false_type</code>)は真/偽を返す標準ライブラリの<a
href="core_lang_spec.html#SS_6_11_2">メタ関数</a>群の戻り型となる型エイリアスであるため、
最も使われるテンプレートの一つである。</p>
<p>これらは、下記で確かめられる通り、後述する<a
href="stdlib_and_concepts.html#SS_7_2_1">std::integral_constant</a>を使い定義されている。</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 32</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::is_same_vの2パラメータが同一であれば、std::is_same_v&lt;&gt; == true</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> <span class="kw">true</span><span class="op">&gt;,</span> <span class="bu">std::</span>true_type<span class="op">&gt;);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> <span class="kw">false</span><span class="op">&gt;,</span> <span class="bu">std::</span>false_type<span class="op">&gt;);</span></span></code></pre></div>
<p>それぞれの型が持つvalue定数は、下記のように定義されている。</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 39</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>true_type::value<span class="op">,</span> <span class="st">&quot;must be true&quot;</span><span class="op">);</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>false_type::value<span class="op">,</span> <span class="st">&quot;must be false&quot;</span><span class="op">);</span></span></code></pre></div>
<p>これらが何の役に立つのか直ちに理解することは難しいが、
true/falseのメタ関数版と考えれば、追々理解できるだろう。</p>
<p>以下に簡単な使用例を示す。</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 48</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 引数の型がintに変換できるかどうかを判定する関数</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// decltypeの中でのみ使用されるため、定義は不要</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="bu">std::</span>true_type  IsCovertibleToInt<span class="op">(</span><span class="dt">int</span><span class="op">);</span>  <span class="co">// intに変換できる型はこちら</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="bu">std::</span>false_type IsCovertibleToInt<span class="op">(...);</span>  <span class="co">// それ以外はこちら</span></span></code></pre></div>
<p>上記の単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 59</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">decltype</span><span class="op">(</span>IsCovertibleToInt<span class="op">(</span><span class="dv">1</span><span class="op">))::</span>value<span class="op">);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">decltype</span><span class="op">(</span>IsCovertibleToInt<span class="op">(</span><span class="dv">1</span><span class="bu">u</span><span class="op">))::</span>value<span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="kw">decltype</span><span class="op">(</span>IsCovertibleToInt<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">))::</span>value<span class="op">);</span>  <span class="co">// ポインタはintに変換不可</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ConvertibleToInt <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">operator</span> <span class="dt">int</span><span class="op">();</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> NotConvertibleToInt <span class="op">{};</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">decltype</span><span class="op">(</span>IsCovertibleToInt<span class="op">(</span>ConvertibleToInt<span class="op">{}))::</span>value<span class="op">);</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="kw">decltype</span><span class="op">(</span>IsCovertibleToInt<span class="op">(</span>NotConvertibleToInt<span class="op">{}))::</span>value<span class="op">);</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// なお、IsCovertibleToInt()やConvertibleToInt::operator int()は実際に呼び出されるわけでは</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ないため、定義は必要なく宣言のみがあれば良い。</span></span></code></pre></div>
<p>IsCovertibleToIntの呼び出しをdecltypeのオペランドにすることで、
std::true_typeかstd::false_typeを受け取ることができる。</p>
<h3 id="stdfalse_type">std::false_type <a id="SS_7_2_3"></a></h3>
<p><a
href="stdlib_and_concepts.html#SS_7_2_2">std::true_type</a>を参照せよ。</p>
<h3 id="stdis_same">std::is_same <a id="SS_7_2_4"></a></h3>
<p>すでに上記の例でも使用したが、std::is_sameは2つのテンプレートパラメータが</p>
<ul>
<li>同じ型である場合、std::true_type</li>
<li>違う型である場合、std::false_type</li>
</ul>
<p>から派生した型となる。</p>
<p>以下に簡単な使用例を示す。</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 99</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int32_t</span><span class="op">&gt;::</span>value<span class="op">);</span>   <span class="co">// 64ビットg++/clang++</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int64_t</span><span class="op">&gt;::</span>value<span class="op">);</span>  <span class="co">// 64ビットg++/clang++</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;::</span>value<span class="op">);</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">typename</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>reference<span class="op">,</span> <span class="dt">int</span><span class="op">&amp;&gt;::</span>value<span class="op">);</span></span></code></pre></div>
<p>また、 C++17で導入されたstd::is_same_vは、定数テンプレートを使用し、
下記のように定義されている。</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 90</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_v<span class="op">{</span><span class="bu">std::</span>is_same<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 108</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int32_t</span><span class="op">&gt;);</span>   <span class="co">// 64ビットg++/clang++</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int64_t</span><span class="op">&gt;);</span>  <span class="co">// 64ビットg++/clang++</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;);</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="kw">typename</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>reference<span class="op">,</span> <span class="dt">int</span><span class="op">&amp;&gt;);</span></span></code></pre></div>
<p>このような簡潔な記述の一般形式は、</p>
<pre><code>   T::value  -&gt; T_v
   T::type   -&gt; T_t</code></pre>
<p>のように定義されている(このドキュメントのほとんど場所では、簡潔な形式を用いる)。</p>
<p>第1テンプレートパラメータが第2テンプレートパラメータの基底クラスかどうかを判断する
std::is_base_ofを使うことで下記のようにstd::is_sameの基底クラス確認することもできる。</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 117</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>true_type<span class="op">,</span> <span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>false_type<span class="op">,</span> <span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<h3 id="stdenable_if">std::enable_if <a id="SS_7_2_5"></a></h3>
<p>std::enable_ifは、bool値である第1テンプレートパラメータが</p>
<ul>
<li>trueである場合、型である第2テンプレートパラメータをメンバ型typeとして宣言する。</li>
<li>falseである場合、メンバ型typeを持たない。</li>
</ul>
<p>下記のコードはクラステンプレートの特殊化を用いたstd::enable_ifの実装例である。</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 124</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> T_F<span class="op">,</span> <span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> enable_if<span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> enable_if<span class="op">&lt;</span><span class="kw">true</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> enable_if<span class="op">&lt;</span><span class="kw">false</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span>  <span class="co">// メンバエイリアスtypeを持たない</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> COND<span class="op">,</span> <span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">enable_if_t</span> <span class="op">=</span> <span class="kw">typename</span> enable_if<span class="op">&lt;</span>COND<span class="op">,</span> T<span class="op">&gt;::</span>type<span class="op">;</span></span></code></pre></div>
<p>std::enable_ifの使用例を下記に示す。</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 148</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="kw">true</span><span class="op">&gt;&gt;);</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="kw">true</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<p>実装例から明らかなように</p>
<ul>
<li>std::enable_if&lt;true&gt;::typeは<a
href="core_lang_spec.html#SS_6_14_2">well-formed</a></li>
<li>std::enable_if&lt;false&gt;::typeは<a
href="core_lang_spec.html#SS_6_14_1">ill-formed</a></li>
</ul>
<p>となるため、下記のコードはコンパイルできない。</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 155</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記はill-formedとなるため、コンパイルできない。</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="kw">false</span><span class="op">&gt;&gt;);</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="kw">false</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<p>std::enable_ifのこの特性と後述する<a
href="core_lang_spec.html#SS_6_11_1">SFINAE</a>により、
様々な静的ディスパッチを行うことができる。</p>
<h3 id="stdconditional">std::conditional <a id="SS_7_2_6"></a></h3>
<p>std::conditionalは、bool値である第1テンプレートパラメータが</p>
<ul>
<li>trueである場合、第2テンプレートパラメータ</li>
<li>falseである場合、第3テンプレートパラメータ</li>
</ul>
<p>をメンバ型typeとして宣言する。</p>
<p>下記のコードはクラステンプレートの特殊化を用いたstd::conditionalの実装例である。</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 164</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> T_F<span class="op">,</span> <span class="kw">typename</span><span class="op">,</span> <span class="kw">typename</span><span class="op">&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> conditional<span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> conditional<span class="op">&lt;</span><span class="kw">true</span><span class="op">,</span> T<span class="op">,</span> U<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> conditional<span class="op">&lt;</span><span class="kw">false</span><span class="op">,</span> T<span class="op">,</span> U<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> U<span class="op">;</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> COND<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">conditional_t</span> <span class="op">=</span> <span class="kw">typename</span> conditional<span class="op">&lt;</span>COND<span class="op">,</span> T<span class="op">,</span> U<span class="op">&gt;::</span>type<span class="op">;</span></span></code></pre></div>
<p>std::conditionalの使用例を下記に示す。</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 189</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span><span class="kw">true</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;&gt;);</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span><span class="kw">false</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<h3 id="stdis_void">std::is_void <a id="SS_7_2_7"></a></h3>
<p>std::is_voidはテンプレートパラメータの型が</p>
<ul>
<li>voidである場合、std::true_type</li>
<li>voidでない場合、std::false_type</li>
</ul>
<p>から派生した型となる。</p>
<p>以下に簡単な使用例を示す。</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/type_traits_ut.cpp 82</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_void<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_void<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_void<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;::</span>value<span class="op">);</span></span></code></pre></div>
<h3 id="stdis_copy_assignable">std::is_copy_assignable
<a id="SS_7_2_8"></a></h3>
<p>std::is_copy_assignableはテンプレートパラメータの型(T)がcopy代入可能かを調べる。
Tが<a
href="cpp_idioms.html#SS_8_5_5">CopyAssignable要件</a>を満たすためには<code>std::is_copy_assignable&lt;T&gt;</code>がtrueでなければならないが、
その逆が成立するとは限らない。</p>
<h3 id="stdis_move_assignable">std::is_move_assignable
<a id="SS_7_2_9"></a></h3>
<p>std::is_move_assignableはテンプレートパラメータの型(T)がmove代入可能かを調べる。
Tが<a
href="cpp_idioms.html#SS_8_5_4">MoveAssignable要件</a>を満たすためには<code>std::is_move_assignable&lt;T&gt;</code>がtrueでなければならないが、
その逆が成立するとは限らない。</p>
<h2 id="並列処理">並列処理 <a id="SS_7_3"></a></h2>
<h3 id="stdthread">std::thread <a id="SS_7_3_1"></a></h3>
<p>クラスthread
は、新しい実行のスレッドの作成/待機/その他を行う機構を提供する。</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/thread_ut.cpp 9</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Conflict <span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span>     increment<span class="op">()</span> <span class="op">{</span> <span class="op">++</span><span class="va">count_</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// 非アトミック（データレースの原因）</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span> <span class="va">count_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/thread_ut.cpp 19</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    Conflict c<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint32_t</span> inc_per_thread <span class="op">=</span> <span class="dv">5&#39;000&#39;000</span><span class="op">;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint32_t</span> expected       <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> inc_per_thread<span class="op">;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> worker <span class="op">=</span> <span class="op">[&amp;</span>c<span class="op">]</span> <span class="op">{</span>  <span class="co">// スレッドのボディとなるラムダの定義</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">uint32_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> inc_per_thread<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>            c<span class="op">.</span>increment<span class="op">();</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t1<span class="op">{</span>worker<span class="op">};</span>  <span class="co">// ラムダworker関数を使用したスレッドの起動</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t2<span class="op">{</span>worker<span class="op">};</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    t1<span class="op">.</span>join<span class="op">();</span>  <span class="co">// スレッドの終了待ち</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    t2<span class="op">.</span>join<span class="op">();</span>  <span class="co">// スレッドの終了待ち</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 注意: join()もdetach()も呼ばずにスレッドオブジェクトが</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>                <span class="co">// デストラクトされると、std::terminateが呼ばれる</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_EQ(c.count_, expected);  t1とt2が++count_が競合するためこのテストは成立しないため、</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">//                                 一例では次のようになる  c.count_: 6825610 expected: 10000000</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    ASSERT_NE<span class="op">(</span>c<span class="op">.</span><span class="va">count_</span><span class="op">,</span> expected<span class="op">);</span></span></code></pre></div>
<h3 id="stdmutex">std::mutex <a id="SS_7_3_2"></a></h3>
<p>mutex
は、スレッド間で使用する共有リソースを排他制御するためのクラスである。</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">メンバ関数</th>
<th>動作説明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">lock()</td>
<td>lock()が即時リターンするスレッドはただ一つ。そうでない場合、unlock()が呼ばれるまでブロック</td>
</tr>
<tr class="even">
<td style="text-align: left;">unlock()</td>
<td>lock()でブロックされていたスレッドの中から一つが動き出す</td>
</tr>
</tbody>
</table>
<p>以下のコード例では、メンバ変数のインクリメントがスレッド間の競合を引き起こす(こういったコード領域を
<a
href="cpp_idioms.html#SS_8_12_4">クリティカルセクション</a>と呼ぶ)が、std::mutexによりこの問題を回避している。</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/thread_ut.cpp 48</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Conflict <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> increment<span class="op">()</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>            <span class="va">mtx_</span><span class="op">.</span>lock<span class="op">();</span>  <span class="co">// クリティカルセクションの保護開始</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span><span class="va">count_</span><span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>            <span class="va">mtx_</span><span class="op">.</span>unlock<span class="op">();</span>  <span class="co">// クリティカルセクションの保護終了</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span>   <span class="va">count_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>mutex <span class="va">mtx_</span><span class="op">{};</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb22"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/thread_ut.cpp 66</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    Conflict c<span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint32_t</span> inc_per_thread <span class="op">=</span> <span class="dv">5&#39;000&#39;000</span><span class="op">;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint32_t</span> expected       <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> inc_per_thread<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> worker <span class="op">=</span> <span class="op">[&amp;</span>c<span class="op">]</span> <span class="op">{</span>  <span class="co">// スレッドのボディとなるラムダの定義</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">uint32_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> inc_per_thread<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>            c<span class="op">.</span>increment<span class="op">();</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t1<span class="op">{</span>worker<span class="op">};</span>  <span class="co">// ラムダworker関数を使用したスレッドの起動</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t2<span class="op">{</span>worker<span class="op">};</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    t1<span class="op">.</span>join<span class="op">();</span>  <span class="co">// スレッドの終了待ち</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    t2<span class="op">.</span>join<span class="op">();</span>  <span class="co">// スレッドの終了待ち</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 注意: join()もdetach()も呼ばずにスレッドオブジェクトが</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>                <span class="co">// デストラクトされると、std::terminateが呼ばれる</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>c<span class="op">.</span><span class="va">count_</span><span class="op">,</span> expected<span class="op">);</span></span></code></pre></div>
<p>lock()を呼び出した状態で、unlock()を呼び出さなかった場合、デッドロックを引き起こしてしまうため、
永久に処理が完了しないバグの元となり得る。このような問題を避けるために、
mutexは通常、<a
href="stdlib_and_concepts.html#SS_7_4_1">std::lock_guard</a>と組み合わせて使われる。</p>
<h3 id="stdatomic">std::atomic <a id="SS_7_3_3"></a></h3>
<p>atomicクラステンプレートは、型Tをアトミック操作するためのものである。
<a
href="core_lang_spec.html#SS_6_1_2">組み込み型</a>に対する特殊化が提供されており、それぞれに特化した演算が用意されている。
<a
href="stdlib_and_concepts.html#SS_7_3_2">std::mutex</a>で示したような単純なコードではstd::atomicを使用して下記のように書く方が一般的である。</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/thread_ut.cpp 92</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Conflict <span class="op">{</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> increment<span class="op">()</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span><span class="va">count_</span><span class="op">;</span>  <span class="co">// ++count_は「count_の値の呼び出し -&gt; その値のインクリメント、その値のcount_への書き戻し」である</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>                       <span class="co">// この一連の操作は排他的(アトミック)に行われる</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>  <span class="co">// lockオブジェクトのデストラクタでmtx_.unlock()が呼ばれる</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>atomic<span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;</span> <span class="va">count_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb24"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/thread_ut.cpp 107</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    Conflict c<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint32_t</span> inc_per_thread <span class="op">=</span> <span class="dv">5&#39;000&#39;000</span><span class="op">;</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint32_t</span> expected       <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> inc_per_thread<span class="op">;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> worker <span class="op">=</span> <span class="op">[&amp;</span>c<span class="op">]</span> <span class="op">{</span>  <span class="co">// スレッドのボディとなるラムダの定義</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">uint32_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> inc_per_thread<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>            c<span class="op">.</span>increment<span class="op">();</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t1<span class="op">{</span>worker<span class="op">};</span>  <span class="co">// ラムダworker関数を使用したスレッドの起動</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t2<span class="op">{</span>worker<span class="op">};</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    t1<span class="op">.</span>join<span class="op">();</span>  <span class="co">// スレッドの終了待ち</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    t2<span class="op">.</span>join<span class="op">();</span>  <span class="co">// スレッドの終了待ち</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 注意: join()もdetach()も呼ばずにスレッドオブジェクトが</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>                <span class="co">// デストラクトされると、std::terminateが呼ばれる</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>c<span class="op">.</span><span class="va">count_</span><span class="op">,</span> expected<span class="op">);</span></span></code></pre></div>
<h3 id="stdcondition_variable">std::condition_variable
<a id="SS_7_3_4"></a></h3>
<p>condition_variable
は、特定のイベントが発生するまでスレッドの待ち合わせを行うためのクラスである。
最も単純な使用例を以下に示す(「<a
href="cpp_idioms.html#SS_8_12_11">Spurious Wakeup</a>」参照)。</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/thread_ut.cpp 135</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>mutex              mutex<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>condition_variable cond_var<span class="op">;</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span>                    event_occured <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> notify<span class="op">()</span>  <span class="co">// 通知を行うスレッドが呼び出す関数</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> lock <span class="op">=</span> <span class="bu">std::</span>lock_guard<span class="op">{</span>mutex<span class="op">};</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>        event_occured <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        cond_var<span class="op">.</span>notify_all<span class="op">();</span>  <span class="co">// wait()で待ち状態のすべてのスレッドを起こす</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> wait<span class="op">()</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> lock <span class="op">=</span> <span class="bu">std::</span>unique_lock<span class="op">{</span>mutex<span class="op">};</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// notifyされるのを待つ。</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>        cond_var<span class="op">.</span>wait<span class="op">(</span>lock<span class="op">,</span> <span class="op">[]()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> event_occured<span class="op">;</span> <span class="op">});</span>  <span class="co">// Spurious Wakeup対策</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb26"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/thread_ut.cpp 162</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t1<span class="op">{[]()</span> <span class="op">{</span> wait<span class="op">();</span> <span class="co">/* 通知待ち */</span> <span class="op">}};</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t2<span class="op">{[]()</span> <span class="op">{</span> wait<span class="op">();</span> <span class="co">/* 通知待ち */</span> <span class="op">}};</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    notify<span class="op">();</span>  <span class="co">// 通知待ちのスレッドに通知</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    t1<span class="op">.</span>join<span class="op">();</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    t2<span class="op">.</span>join<span class="op">();</span></span></code></pre></div>
<h2 id="ロック所有ラッパー">ロック所有ラッパー <a id="SS_7_4"></a></h2>
<p>ロック所有ラッパーとはミューテックスのロックおよびアンロックを管理するための以下のクラスを指す。</p>
<ul>
<li><a href="stdlib_and_concepts.html#SS_7_4_1">std::lock_guard</a></li>
<li><a href="stdlib_and_concepts.html#SS_7_4_2">std::unique_lock</a></li>
<li><a href="stdlib_and_concepts.html#SS_7_4_3">std::scoped_lock</a></li>
</ul>
<h3 id="stdlock_guard">std::lock_guard <a id="SS_7_4_1"></a></h3>
<p>std::lock_guardを使わない問題のあるコードを以下に示す。</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/lock_ownership_wrapper_ut.cpp 14</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Conflict <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> increment<span class="op">()</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>            <span class="va">mtx_</span><span class="op">.</span>lock<span class="op">();</span>  <span class="co">// ++count_の排他のためのロック</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span><span class="va">count_</span><span class="op">;</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>            <span class="va">mtx_</span><span class="op">.</span>unlock<span class="op">();</span>  <span class="co">// 上記のアンロック</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span>   <span class="va">count_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>mutex <span class="va">mtx_</span><span class="op">{};</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>上記で示したConflict::increment()には以下のようなリスクが存在する。</p>
<ol type="1">
<li>関数が複雑化してエクセプションを投げる可能性がある場合、
<ul>
<li>エクセプションをこの関数内で捕捉し、ロック解除 (mtx_.unlock())
を行った上で再スローしなければならない。</li>
<li>ロック解除を忘れるとデッドロックにつながる。</li>
</ul></li>
<li>複数の return 文を持つように関数が拡張された場合、
<ul>
<li>すべての return の前で mtx_.unlock()
を呼び出さなければならない。</li>
</ul></li>
</ol>
<p>これらを正しく管理するためには、重複コードが増え、関数の保守性が著しく低下する。</p>
<p>std::lock_guardを使用して、このような問題に対処したコードを以下に示す。</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/lock_ownership_wrapper_ut.cpp 63</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Conflict <span class="op">{</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> increment<span class="op">()</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>lock_guard<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock<span class="op">{</span><span class="va">mtx_</span><span class="op">};</span>  <span class="co">// lockオブジェクトのコンストラクタでmtx_.lock()が呼ばれる</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>                                                     <span class="co">// ++count_の排他</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span><span class="va">count_</span><span class="op">;</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>  <span class="co">// lockオブジェクトのデストラクタでmtx_.unlock()が呼ばれる</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span>   <span class="va">count_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>mutex <span class="va">mtx_</span><span class="op">{};</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>オリジナルの単純な以下のincrement()と改善版を比較すると、大差ないように見えるが、</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/lock_ownership_wrapper_ut.cpp 19</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">mtx_</span><span class="op">.</span>lock<span class="op">();</span>  <span class="co">// ++count_の排他のためのロック</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span><span class="va">count_</span><span class="op">;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">mtx_</span><span class="op">.</span>unlock<span class="op">();</span>  <span class="co">// 上記のアンロック</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>オリジナルのコードで指摘したすべてのリスクが、わずか一行の変更で解決されている。</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/lock_ownership_wrapper_ut.cpp 68</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>lock_guard<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock<span class="op">{</span><span class="va">mtx_</span><span class="op">};</span>  <span class="co">// lockオブジェクトのコンストラクタでmtx_.lock()が呼ばれる</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>                                                 <span class="co">// ++count_の排他</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span><span class="va">count_</span><span class="op">;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// lockオブジェクトのデストラクタでmtx_.unlock()が呼ばれる</span></span></code></pre></div>
<h3 id="stdunique_lock">std::unique_lock <a id="SS_7_4_2"></a></h3>
<p>std::unique_lockとは、ミューテックスのロック管理を柔軟に行えるロックオブジェクトである。
std::lock_guardと異なり、ロックの手動解放や再取得が可能であり、特にcondition_variable::wait()と組み合わせて使用される。
wait()は内部でロックを一時的に解放し、通知受信後に再取得する。</p>
<p>下記の例では、IntQueue::push()、 IntQueue::pop_ng()、
IntQueue::pop_ok()の中で行われるIntQueue::q_へのアクセスで発生する競合を回避するためにIntQueue::mtx_を使用する。</p>
<p>下記のコード例では、<a
href="stdlib_and_concepts.html#SS_7_4_1">std::lock_guard</a>の説明で述べたようにmutex::lock()、mutex::unlock()を直接呼び出すのではなく、
std::unique_lockやstd::lock_guardによりmutexを使用する。</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/lock_ownership_wrapper_ut.cpp 112</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> IntQueue <span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> push<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>lock_guard<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lg<span class="op">{</span><span class="va">mtx_</span><span class="op">};</span>  <span class="co">// ロック取得</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>                <span class="va">q_</span><span class="op">.</span>push<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>  <span class="co">// ロック解放</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>            <span class="va">cv_</span><span class="op">.</span>notify_one<span class="op">();</span>  <span class="co">// 待機中のスレッドを1つ起床</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>                               <span class="co">// 注: ロック解放後に呼び出すことで、起床したスレッドがすぐにロックを取得できる</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> pop_ng<span class="op">()</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>unique_lock<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock<span class="op">{</span><span class="va">mtx_</span><span class="op">};</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>            <span class="va">cv_</span><span class="op">.</span>wait<span class="op">(</span>lock<span class="op">);</span>  <span class="co">// NG: Spurious Wakeup対策なし</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>                             <span class="co">// 起床時に条件を再確認しないため、</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>                             <span class="co">// q_.empty() が true のまま起床する可能性がある</span></span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v <span class="op">=</span> <span class="va">q_</span><span class="op">.</span>front<span class="op">();</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>            <span class="va">q_</span><span class="op">.</span>pop<span class="op">();</span>  <span class="co">// 条件未確認アクセス（危険）</span></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> v<span class="op">;</span></span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> pop_ok<span class="op">()</span></span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>unique_lock<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock<span class="op">{</span><span class="va">mtx_</span><span class="op">};</span></span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>            <span class="va">cv_</span><span class="op">.</span>wait<span class="op">(</span>lock<span class="op">,</span> <span class="op">[&amp;</span><span class="va">q_</span> <span class="op">=</span> <span class="va">q_</span><span class="op">]</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">!</span><span class="va">q_</span><span class="op">.</span>empty<span class="op">();</span> <span class="op">});</span>  <span class="co">// waitの述語が true になるまで待機(Spurious Wakeup対策)</span></span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>            <span class="co">// wait()の動作:</span></span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 1. 述語を評価してtrueならすぐreturn</span></span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 2. falseなら: unlock() → 通知待機 → 通知受信 → lock() → 述語再評価</span></span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 3. 述語がtrueになるまで2を繰り返す</span></span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> v <span class="op">=</span> <span class="va">q_</span><span class="op">.</span>front<span class="op">();</span></span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a>            <span class="va">q_</span><span class="op">.</span>pop<span class="op">();</span>  <span class="co">// ここでは、q_.empty()は必ずfalse</span></span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> v<span class="op">;</span></span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>mutex              <span class="va">mtx_</span><span class="op">{};</span></span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>condition_variable <span class="va">cv_</span><span class="op">{};</span></span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span>         <span class="va">q_</span><span class="op">{};</span></span>
<span id="cb31-45"><a href="#cb31-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb32"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/lock_ownership_wrapper_ut.cpp 168</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    IntQueue           iq<span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span>      end_data       <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint32_t</span> push_count_max <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Producer</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t1<span class="op">([&amp;</span>iq<span class="op">]</span> <span class="op">{</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">uint32_t</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> push_count_max<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>            iq<span class="op">.</span>push<span class="op">(</span><span class="dv">100</span> <span class="op">+</span> i<span class="op">);</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>        iq<span class="op">.</span>push<span class="op">(</span>end_data<span class="op">);</span>  <span class="co">// t2が-1を受信したらt2のループ終了</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> pop_count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t2<span class="op">([&amp;</span>iq<span class="op">,</span> <span class="op">&amp;</span>pop_count<span class="op">]</span> <span class="op">{</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(;;)</span> <span class="op">{</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> iq<span class="op">.</span>pop_ok<span class="op">();</span> v <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>                <span class="op">++</span>pop_count<span class="op">;</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    t1<span class="op">.</span>join<span class="op">();</span>  <span class="co">// スレッドの終了待ち</span></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>    t2<span class="op">.</span>join<span class="op">();</span>  <span class="co">// スレッドの終了待ち</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>push_count_max<span class="op">,</span> pop_count<span class="op">);</span></span></code></pre></div>
<p>一般に条件変数には、<a href="cpp_idioms.html#SS_8_12_11">Spurious
Wakeup</a>という問題があり、std::condition_variableも同様である。</p>
<p>上記の抜粋である下記のコード例では<a
href="cpp_idioms.html#SS_8_12_11">Spurious
Wakeup</a>の対策が行われていないため、
意図通り動作しない可能性がある。</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/lock_ownership_wrapper_ut.cpp 127</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> pop_ng<span class="op">()</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>unique_lock<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock<span class="op">{</span><span class="va">mtx_</span><span class="op">};</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">cv_</span><span class="op">.</span>wait<span class="op">(</span>lock<span class="op">);</span>  <span class="co">// NG: Spurious Wakeup対策なし</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>                         <span class="co">// 起床時に条件を再確認しないため、</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>                         <span class="co">// q_.empty() が true のまま起床する可能性がある</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> <span class="va">q_</span><span class="op">.</span>front<span class="op">();</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">q_</span><span class="op">.</span>pop<span class="op">();</span>  <span class="co">// 条件未確認アクセス（危険）</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v<span class="op">;</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>下記のIntQueue::pop_ok()は、pop_ng()にSpurious
Wakeupの対策を施したものである。</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/lock_ownership_wrapper_ut.cpp 141</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> pop_ok<span class="op">()</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>unique_lock<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock<span class="op">{</span><span class="va">mtx_</span><span class="op">};</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">cv_</span><span class="op">.</span>wait<span class="op">(</span>lock<span class="op">,</span> <span class="op">[&amp;</span><span class="va">q_</span> <span class="op">=</span> <span class="va">q_</span><span class="op">]</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">!</span><span class="va">q_</span><span class="op">.</span>empty<span class="op">();</span> <span class="op">});</span>  <span class="co">// waitの述語が true になるまで待機(Spurious Wakeup対策)</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// wait()の動作:</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 1. 述語を評価してtrueならすぐreturn</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 2. falseなら: unlock() → 通知待機 → 通知受信 → lock() → 述語再評価</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 3. 述語がtrueになるまで2を繰り返す</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> v <span class="op">=</span> <span class="va">q_</span><span class="op">.</span>front<span class="op">();</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">q_</span><span class="op">.</span>pop<span class="op">();</span>  <span class="co">// ここでは、q_.empty()は必ずfalse</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> v<span class="op">;</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="stdscoped_lock">std::scoped_lock <a id="SS_7_4_3"></a></h3>
<p>std::scoped_lockとは、複数のミューテックスを同時にロックするためのロックオブジェクトである。
C++17で導入され、デッドロックを回避しながら複数のミューテックスを安全にロックできる。</p>
<p>複数のミューテックスを扱う際、異なるスレッドが異なる順序でロックを取得しようとすると、
デッドロックが発生する可能性がある。下記の例では、2つの銀行口座間で送金を行う際に、
両方の口座を同時にロックする必要がある。</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/lock_ownership_wrapper_ut.cpp 205</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> BankAccount <span class="op">{</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> BankAccount<span class="op">(</span><span class="dt">int</span> balance<span class="op">)</span> <span class="op">:</span> <span class="va">balance_</span><span class="op">{</span>balance<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> transfer_ng<span class="op">(</span>BankAccount<span class="op">&amp;</span> to<span class="op">,</span> <span class="dt">int</span> amount<span class="op">)</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>lock_guard<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock1<span class="op">{</span><span class="va">mtx_</span><span class="op">};</span>     <span class="co">// 自分のアカウントをロック</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>lock_guard<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock2<span class="op">{</span>to<span class="op">.</span><span class="va">mtx_</span><span class="op">};</span>  <span class="co">// 相手のアカウントをロック</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">// NG: 異なるスレッドが異なる順序でロックを取得するとデッドロックの可能性</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="va">balance_</span> <span class="op">&gt;=</span> amount<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>                <span class="va">balance_</span> <span class="op">-=</span> amount<span class="op">;</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>                to<span class="op">.</span><span class="va">balance_</span> <span class="op">+=</span> amount<span class="op">;</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> transfer_ok<span class="op">(</span>BankAccount<span class="op">&amp;</span> to<span class="op">,</span> <span class="dt">int</span> amount<span class="op">)</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>scoped_lock lock<span class="op">{</span><span class="va">mtx_</span><span class="op">,</span> to<span class="op">.</span><span class="va">mtx_</span><span class="op">};</span>  <span class="co">// 複数のmutexを安全にロック</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">// デッドロック回避アルゴリズムにより、常に同じ順序でロックを取得</span></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="va">balance_</span> <span class="op">&gt;=</span> amount<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>                <span class="va">balance_</span> <span class="op">-=</span> amount<span class="op">;</span></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>                to<span class="op">.</span><span class="va">balance_</span> <span class="op">+=</span> amount<span class="op">;</span></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> balance<span class="op">()</span> <span class="at">const</span></span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb35-32"><a href="#cb35-32" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>lock_guard<span class="op">&lt;</span><span class="bu">std::</span>mutex<span class="op">&gt;</span> lock<span class="op">{</span><span class="va">mtx_</span><span class="op">};</span></span>
<span id="cb35-33"><a href="#cb35-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">balance_</span><span class="op">;</span></span>
<span id="cb35-34"><a href="#cb35-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb35-35"><a href="#cb35-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-36"><a href="#cb35-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb35-37"><a href="#cb35-37" aria-hidden="true" tabindex="-1"></a>        <span class="at">mutable</span> <span class="bu">std::</span>mutex <span class="va">mtx_</span><span class="op">{};</span></span>
<span id="cb35-38"><a href="#cb35-38" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>                <span class="va">balance_</span><span class="op">;</span></span>
<span id="cb35-39"><a href="#cb35-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>下記の例では、2つのスレッドがそれぞれ逆方向の送金を同時に行う。
transfer_ok()の代わりにtransfer_ng()を使用した場合、デッドロックが発生する可能性がある。</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/lock_ownership_wrapper_ut.cpp 254</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    BankAccount acc1<span class="op">{</span><span class="dv">1000</span><span class="op">};</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    BankAccount acc2<span class="op">{</span><span class="dv">1000</span><span class="op">};</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> transfer_amount <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> transfer_count  <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// スレッド1: acc1 → acc2 へ送金</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t1<span class="op">([&amp;</span>acc1<span class="op">,</span> <span class="op">&amp;</span>acc2<span class="op">]</span> <span class="op">{</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> transfer_count<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>            acc1<span class="op">.</span>transfer_ok<span class="op">(</span>acc2<span class="op">,</span> transfer_amount<span class="op">);</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// スレッド2: acc2 → acc1 へ送金</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t2<span class="op">([&amp;</span>acc2<span class="op">,</span> <span class="op">&amp;</span>acc1<span class="op">]</span> <span class="op">{</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> transfer_count<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>            acc2<span class="op">.</span>transfer_ok<span class="op">(</span>acc1<span class="op">,</span> transfer_amount<span class="op">);</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>    t1<span class="op">.</span>join<span class="op">();</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>    t2<span class="op">.</span>join<span class="op">();</span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 総額は変わらない</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>acc1<span class="op">.</span>balance<span class="op">()</span> <span class="op">+</span> acc2<span class="op">.</span>balance<span class="op">(),</span> <span class="dv">2000</span><span class="op">);</span></span></code></pre></div>
<p>transfer_ng()がデッドロックを引き起こすシナリオは、以下のようなものである。</p>
<ol type="1">
<li>スレッド1が acc1.transfer_ng(acc2, 100) を呼び出し、acc1.mtx_
をロック</li>
<li>スレッド2が acc2.transfer_ng(acc1, 100) を呼び出し、acc2.mtx_
をロック</li>
<li>スレッド1が acc2.mtx_
のロックを試みるが、スレッド2が保持しているため待機</li>
<li>スレッド2が acc1.mtx_
のロックを試みるが、スレッド1が保持しているため待機</li>
<li>互いに相手のロック解放を待ち続け、永遠に進まない（デッドロック）</li>
</ol>
<!-- pu:essential/plant_uml/mutex_deadlock.pu-->
<p>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbUAAAMbCAIAAABFQZw9AAAAKnRFWHRjb3B5bGVmdABHZW5lcmF0ZWQgYnkgaHR0cHM6Ly9wbGFudHVtbC5jb212zsofAAAFBGlUWHRwbGFudHVtbAABAAAAeJztV19vE0cQf79PsaUvSQSpfTQRtQgCB1JI4xBhJzyizd3aXnLedff2QtIqEmcXkhCkQkqJaEGBViqClhb1gaYIhe/CYqd54it09i4Xn2ObPyGPiezovDPzm5nfzM7tHnclFtIrOcYnskhKBJUdTJkhqXQIUtV5Va2q6qKqPtEPlb827jzfuLWq/D9V5R9Vvaaqj1XlsWGUAYNatIyZRAdyRUGwjZIHEHZRLtksxJaV7C3JmQuBNNMqNWNSsy2wGQKbhjEwgGoL9+p3VzeuPatfWUIDAwbjkiA+TQR4PqiVEHq99kBV/lXVP7Zy8a/Xblyv36ko//fNy/7m/M3a/G8bN66qyvLm7aXawyWDMBtpnMDBduq172/X1ldU9UdVeaiqL1TlufaXS6JDxyCPFHK4NdXVjV7d/cHAlqTTGAKB/IKABC0UJeJ5TQdCAQdSYObmibjACl067YMomUh0R1LNAdI0R97rCzdq11ZjoeXMwLHZwbEZOnZIPvRrhsjmTr/JuF/zPfwGlLRvi4iPmeawVjpw0MZbbf1K/dHq67Unvb29oNQVVRxq9vrlvfp1H0TdO0iYaWZ/pX3ibSjt4CzZydnO1kKfDg31p/vTYNvT04mTnh7dgc+Xlf8d9NvGz2v1xaV4EP89/LV+ax16D6JR/oONZz8p/6aqLIEVfKKQUvEUKstheOqyH2MxQIB8GlZmCjXJ41bJViv4vLq6DMVd0cFVnqrqI1W9r3eLf7f+5Jc3LxbqT9c2/fvBtvlb+evKfwxZvXmxGOPoODzqYWIc354rW39HXTnrkGPgRXAu0bfwgFAaW1MFwT1mD3KHC3SpSAFFS4Y4k+HapANK22ujGGbUBBE2ZjhYPD1bJmKEsqlI2wsBYInsBNBruSK1phhxXZQM1jJYFChDffBjDr42t7wSYVGAFi5LytnWr50IiWB1Lvifh6ygNd6tWITavJdiOIMjPZ18ln5DkGm+w1J/Gbcj0wyeoSWvdJ7asogOJxKBxtHPtsphuFOUwZTFJXRCCH5phDsOLfNynLqGSvt6NeQnSR57jmwpVItGhjPulrFF7G3dQe4JSkRMd4TmiQNJZmFmSVKYhaxc7lA7pjLWeD+MYdumrADjLCbPkq89wiyioTRfaS6A/PbJZYvY5pc0RB47bjytcZekicRZTRmSAjosTpueuVTOBnR3aug0Fs3N2BpIu55vIXIuXgztBovQ8U7bZsWZQCdiqK9JOkiF5RB7sAi/rKiF3xJKVCeEzmGbei76ohnOwdCNb+Xi41MPnJyQUtBJT5J3RdwRIQvpEi5hguwGYqix4z/Q8nRjBHyopZ52sCemAuPYyIsrnbE4GwMwXCBNalud17YsLfYiPEjs3h7IgXayd4/gTTrU2pX5KN9dU5ydvAgxh83b0qRzTWOnwe4etHNWRlS//55pto/6+MSeoAzuCcqpPUE5sycoox+BAtN/ELskBMt90LDYv0btX6P2r1H716hdX6PGHNiy45kRBHy5+iKS7DUTZl9vous8vFqHMUOJIyhhpg73pQ73o+FsDmlxt9H15dgIcuGkZhFkUzc8KIF9tzGMpzE65zFJSySFzpYJGz75VbSATrFpKjjTNyBjeCLTUOj//FCaSjhPC125iYyxdZAHC4vrU2UKjeeGDh0xRjArePBuTKGL2ICzIpNiNoWGx4z/AVVQIzFNRo+EAACAAElEQVR4Xuydd3wURR/GQ+iBQAIhQEKR3qQjSBPpIL0oSFOK9Ca9CUiVJtIRpAqoVKkiHSmCKL0TIPROaCGh7vt48zJu5nYnm8xd2Enm+0c+e9N25tmdZ3+zu3fx0BQKhUJhhAeboFAoFAoHyh8VCoXCGOWPCoVCYYzyR4VCoTBG+aNCoVAYo/xRoVAojFH+qFAoFMYof1QoFApjlD8qFAqFMcofFQqFwhjljwqFQmGM8keFQqEwRvmjQqFQGKP8UaFQKIxR/qhQKBTGKH9UKBQKY5Q/KhQKhTHKH/9j7ty5x44dY1MVCkVcRfnjvzx8+LBly5YeHh5+fn7nzp1jsxXm3Lp1i00S4PTp0xs3btR/DAkJ0eVHwokTJ4Y7CA8PZ/MUiqij/FE7depUjhw5PN6QJ0+ep0+fsoVcR8+ePYs6uHLlCpunadevX2eTbMyTJ09SpEhRoECByZMns3km3L9/P7MJTZs2hf6pUqV6+fIlSu7cuTNlypRp06b99ddf2VbeMHDgwE6dOv3xxx/k408//UQOYpRcVZB79+4FBQWxqWK8ePGihoOvvvqKzYsuOFg/OtiwYQObZ4HXr1+T87ZJkyZsXuwlNvvjs2fPhligY8eO1BwJmHVsW66jTp06ZC9MoPrgwYN69eohgJVojT9r1iwyli+++ILNM+HOnTv/CR2RKVOmkI0lS5YMGjQoYcKE2E6TJs2RI0fYVhzARFKnTo0ybdu2JSni/hgaGnr27Nm9e/cePnz4xo0bbLYRsLB48eJVqFBhxYoVxNnFefXqFRkImmXzzEEsn9IBzjE2T9MuXrxI2ixevDibZw1PT09UL1iwIJsRe4nN/vj48WNyQljB29ubbBQpUuTo0aNsW67D0B8RIuXKlQuxGNIzZcp09+5dXY1/2bx5c9qowFR3E9CKjOXgwYM0EbYVFhaG2ahfKVOQNXHixGHDhk18A0IStJAoUaLLly+/99572IbdkGbz589//vz5Q4cOPX/+nG1I01avXk2Kwc5ISrT9EZfS6dOnly1blpgyBVEtLp+cWy5YauCSRsu/8847aMclq3tiRmXKlGEzzIGhk25UrFiRzdP54/vvv8/mWSNJkiQeyh9jDVHyxzlz5uBvo0aNDKeiC3H2R0zmdOnSISV58uTJkiXDRrNmzSJW0tauXavrbOQw1d2BvkteXl4wODKlKfHjx4dhMbUwh2vWrBkQEEBMbd++fcSSevTogY+IHEndxIkTI4onZop28uXL988//zBNlStXDiVz5sxJU6Lnjzt27MA16U2vDcC40Bn4PlvTsWhFD9E9ffmMGTP+8ssvbNEoQsyoRIkSbIY5Fv2xdOnSbJ4DhPa4zv39999//fUXjgsO0O7du//44w/os3379q1btyZNmhTVs2XL9vvvv69bt27VqlVLly5FFttQLCImJtLb4vXr16csgxWNxSN95syZEydOMInWb1k6+yPAEtLX1xeJxB8RRjGzkZoRIpTS5pAI1MOyP0Z7LJCrQIECZF8cMKOY6w0iZXifhyNgHDx4MFkgZ8mS5dGjR5rjkJEQEmXmz5+PEZF2ELPcvHlT3w4mMMnCkHO9AbZLEnPkyEETKWPGjNG3QPjhhx8SJEhAaqVKlap9+/b4i+3evXtjvdy4cWNq+rB1Q4skIMCvVq0aKQl+/PFHtoSmXbt2jUlBg+yJ+AZyJuTNm5fNcBAcHMw0pVn2R4TJbJ6DGTNm0P5bp2rVqmxDsQirE0kBMNX79++PiV28eHEYBE3HrMbZjKjhk08+0RU3xtAfNYdxIBFRA9aezgs06o/jxo1jsvSQkMrDgj8KjoWE2yBDhgwY0ccff9y0adOWLVu2a9euS5cu9JYu/IWtqWm4DqVMmZIU8HDEnnv27Al7A0IYEjpR0DLCNH0L6GTJkiX1ZazQs2dPfSMAQRCCUw+HHY8aNQoXBjJ8pEydOpWUQTyFaxJpoVOnThEbYNm/fz8OQa1atdgMTdu0aZO3tzcTUF+5ckXXwShQtGhRfTsEi/744YcfsnkO4On/7cAyyh+lZP369T9FnUOHDrENadrJkyc//fTTP//8E9s0opk7dy4tQM/ywoUL/1fNBOqPWJddunRJnzVgwACzW5+u8keXjAXdpoHqzp072WxNQ+RFcg2XmfCgzp07kwKR8vXXX7P1NW3evHkkt0mTJuSFHgI8naRjOaxPJ2zZskXfyIMHD8itw+TJkxNBwPnz50kLGAItefnyZRKZIpaEXdJ0LEhho84Pr50D8JcvX7777rukZX033oo/mj3zQVg6cuTIb775ZuzYsRMmTMD5OXny5GnTpiGubN26Nd01roizdRjeZY41mE4k2cF6ih5R6ziHGFh+khVWtmzZEN38888/5GNgYCA+kjIIiEj12rVrR6xtAPVHQubMmZs3b45VnuGKieISf3TJWDDVEYCQMmaPrRFOIjdhwoTwICYL6+L333+fVLcCetiqVSvYFm0BcTd5mJYzZ05m8f5TVO4/wkNJYf1amLbAvEXw888/k3SExjRx0aJFJBF6du/eHf6iqxGB8ePHk5L58+fXP+N++PDhQBOId+M6xGY4mD59uq75/2PRHytXrszmcTl9+jS5DULIly8fWyL2YjyRYgGu8kfQsGFDkktimc8//5x8nDJlCilAX3PBJIlQ0wjGH/VgzYh45Pbt22wdF/mj5oqxtGnThhSAwsyyl4CYiNzRq1mzJpNet25dUhfAQ3/77Tesxz0cTvqbA/IiKpZs2F68eDGW+aQwVsENGjQgboiek5QdO3bo29ei6I9Zs2ZFyezZsyOepYldunTxcCy3GefFRxIy582blyZS9SiVKlVas2aNrt6/4LJE7xgwMSwH8lgfgrAZ5lj0xyitiC9cuIBLOKlI0D8Qi/WYTiTZwQV/hhH0Svjdd9+xeTNm0HWWHkxsLME8HO8AYUl15swZGoWRqdW7d2/S5syZM9nKTlB/HDJkCNaD/v7+5CMF5lK/fn39pNVc54+CY8HKi+TCLMzCpS+//JKUWbVqlT4dq06Yi4fjERN9RRmLOA+HH5GPxBSwmiMfYXMIUYnbzpkzhyRqjnAMK0H6kWLdHy9dukRKdu3aVZ+O+M7D5KlxwYIFkeXj40NTEB0jhITpJ0qUiLQGPvjgA12lf1+oLFy4MMn67LPP9Fl8ihcv7hHFl2ks+mP16tXZPBP+/vvvtGnTklo1atQgT65wXWHLxV5MJ1JshbxJA6L0Ki/iSlJr0KBB+IgpAZeBwZEoA4ESyaUv4nFwfj5z/Phx2ESpUqXoe3+dO3eOWMll/qiJjQX2mjt3btjBpk2b2DwHGBQxC6zZnZ/2Hj58uE+fPrAMmsL3RwIm9vz58/UphDFjxjB3GDn3H5cuXaqvi9GRkpMmTaKJd+/eJYfAMHYmKxJcz9gMh49jwUsMVL/yxSUHYS/ZUaZMmbCa1lWKBOiMWjigbIY5fH88efIkyTW7c8KwcuVK8qjKw/FIJywsjNyERVDPFo298CZS7AMzlgQjCH/YPC4IN0jFIkWK4GNQUBBdBT9+/NjLy8vDMcmfPXsWoZoRzv5IuXr1KvyibNmyzHMbzaX+KDgWRJ1mX1B79epV+fLlSQfo8189uCaR76hRyAoarkQ+kr37+flFLFUUc5ttS9Po7LUC85USepsVgtNEeChJhDXoyv4Lgl8rb0dv3bqVvtsPc+zQoQNpEHUNrzdmQCiyu5YtW7J55vD9cfPmzST3888/Z/MiAiukPQdYzZAnTuQ5fvr06dkKsRfeRIp9HDt2jBzyYsWKsXmRgbBr1qxZzm+PDx48mLTJ3G4zg+OPHFzoj5rrxsIwYMAAUj1LliyG9orrEykQVQ4cOMC25fj2TsQXHHnvPzKv5pw+fZqU1K+vsf71cDwRcv7+ErXO9u3bM1mGwFA+/fRTUgXu/5PTe/J8du/eTeqOHj2azTOH74/Dhg0juYim2TwdWFPTR+0ejjvy9PWvnDlzejiuXhFrxGYimUixjKFDh5Kj3qVLFzYvWmzcuJG+XQwLY7ONsIM/GhKNseihtyZhB9u2bWOzHWCm9Y0I6TDCVfKR3P0oUKBAxFJ9EVmzbRlh/f4jgjvygDhDhgzkOgFDJ6/oO389+cGDB/QXTMyGpuevv/7K9ebxINzW8FkzH/oYDU2xeeZA3hsO7t+/z2RhjLhokTZ37drF5BIwTMwL+j68j4+P/iUnQL4mpL8DG+uJzkSSlIMHD9K39ugvvojw/fff0xvz1apVY7NNEPTHMWPGvDDngw8+IMXY+pERvbEQMPf07zMOjMqve3z00UceuldGijrdf0TjefLk6dWrl/Nrhs5Y90eANklhODs+Lly4kHwcP368vti1a9dKlSpFssy+eUI5e/Zs48aN6X1krJF//vlnthAXeBx5QO/h9Gw92oSHhzdv3py0mT9/fjbbAQJeaqAeju8gOr9wRh40JUuWjEmPxUR5IslIaGjoN998Q7496uF4CYMtERVwyv7+++/05WqQO3fuO3fusOVMEPRHi7D1TRAcC/jnn3+IqRHM3og0ZNSoUaQWjg5JcfZH+sI284DFkCj5471798jDWdhZy5YtyYsEmPx0cX3q1Cl4Pf2qD+JN5/vChJcvX65Zs6ZGjRr6b6AXKlTI+bubHOBQS5YsIQ95SK84P+xmEegwc+ZMGvzGjx/f8H1+AqwcO02ePPmkSZP0X6milChRwkP3MC0uYHUiSQpOUKzO9L+wkjdv3ijNfwpOX5hUjx49mNfBypQpE6XfiLWDP7pkLIgv2rZtSx0BU2vo0KEW4x3Upe9CYj1Lv0/p7I9z584lxY4fP05SHj58eNGEyZMnk8JHjhxh8xzAE2nLACtNetUkkNsXGEhgYKA+HbGV4ftM69at+/zzz/UnmIfje9wTJkwwvANryOrVq3FW0F+Q8nB8OX3WrFlsOcscPnx4wIAB5cqVozdMSJsLFixgi0YEBZiwcdmyZbhkInCuX78+VtZox9fXV18gdhPJRJIazNUKFSrQ8wMTGKfy48eP2XLWwLQk5wclXbp0U6ZMMbzSchD0R8QCFc2hPWTrR0R8LHAr/U+BwU3gFGwhI+BciDHJT1R4ON4W1D8MIStZOAXW3QjH3nvvPbKX9OnTU+eFhdH9RhXnL1DDSuAjODdgH/369SOJ5LvwBC8vrz59+pidNs2aNdM17xEQEIDVsfO3hvhs3bpV3wg0MfuaqUXg+/oGPRxXPv03I62zf/9+pimzryfGSiKZSLJz8+ZNTC3EOLVq1Yre+aFn0KBBHo477uXLl8eV1vlXJKwQPX/ctm1bNgc//PADm6ejSZMmpBib4YT4WBA8eji++tK5c2eLb/aFhYXRXxLDShbr6xcR35Hs2rXr/2dhRPRvC7nWHwkIqOk3LDXHTUCsjmvWrDljxgz+0HCdIN6KwlifOr8SYBGcFTDiTz/9dPfu3WxetCBXGsR6LVu2FLnbjuHrQ2wcPv1vfcZ6Yrk/ao6ABQsrNjVaINKZN2+e4ff/rHPgwIG1DvSvScc84mNB/3v16hVVbdevX4/QtWfPnszvlREQpmGN3KFDh+bNmyPYh/OOHTuWebkHFQ9EF7MbiCL8/vvvUQ0YncHhMPyyZrSBcSMgsL4g4AOXPOuAuZ7FemK/PyrsRjRiVYXiraD8UaFQKIxR/qhQKBTGKH9UKBQKY5Q/KhQKhTHKHxUKhcIY5Y8KhUJhjPJHhUKhMEb5o0KhUBij/FGhUCiMUf6oUCgUxih/VCgUCmOUPyoUCoUxyh8VCoXCGCF/DAsLq1Onjv435WXHy8urcePG+p8CdDnHjh2rWLEi+e+dsRgMEMPEYNnxu47Yd/qZoU7LaOAS0YT8sW/fvs2aNSP/Gzd2gLFgRBgXm+EicBb6+/svWLBA8LDZHwwQw8Rg3WeRse/0M0OdltHAJaIJ+WOWLFnOnDnDpkoORoRxsakuolKlSvPnz2dTYy8YrOB/Q+MQK08/M9RpGQ3ERRPyxwQJErx8+ZJNlRyMCONiU10E1i+x6RIdKRgshsymuohYefqZoU7LaCAumpA/ekT2f6AkxX3jcl/LtsV9Q3Zfy/bEfeN1X8tvHcGhiVUW27dtcd+43NeybXHfkN3Xsj1x33jd1/JbR3BoYpXF9m1b3Dcu97VsW9w3ZPe1bE/cN173tfzWERyaWGWxfdsW943LfS3bFvcN2X0t2xP3jdd9Lb91BIcmVlls37bFfeNyX8u2xX1Ddl/L9sR943Vfy28dwaGJVRbbt21x37jc17Jtcd+Q3deyPXHfeN3X8ltHcGhilcX2bVvcNy73tWxb3Ddk97VsT9w3Xve1/NYRHJpYZad9v3r16pwJISEhixYt2rNnD1PFHSxYsODAgQNsqgP0cPPmzefPn2czdDiPy1W4r2U9VsYYY7hvyO5rmXL8+PE1a9b8888/kJTNi3HcN17Dlu0wlzkTWbN2dAyHZh2xyk77fvDgQco3JEmSJH78+PTjlClTKlasOHr0aKaKOyhdujR2xySePn26Z8+emTNnRrdnz57N5OpxHpercF/LBOtjtAKmAZsUddw3ZPe1rDm+nVajRo00adJUrlw5ffr0pUqVunv3LlvIMjIqaYe5bDiRtagcHcOhWUesMnffw4cPx/D0KTGjqWYi6x9//DFy5Mi//vorR44cfO/gj0sE97VMsD7GSMGR6ty5M5saddw3ZPe1DHr37v3+++8/efIE26GhocWKFevQoQNbyBqxQMm3NZcNJ7IWlaMT6dD4iFXm7ttMUwTDBw8eRKSjz7p9+3aogy1btrx+/VpzfDUNAfyOHTuIChRcOnbv3n3o0CHmu2WPHz/euXMnrAHVzWQl5MqVi+8d/HGJwG/ZbGjh4eH79u3buHHj/fv3+YkUzhiJ1KiF6hBNc0gN3fRX4IcPH37u4MqVKxcuXLh3756+OiIL+jFS+EMWgdNylJQ0TMf58+eff9ICgwYNKlGiBP1IiVRMvZLYvnPnTrTF5IxXkEhbtj6XnSeyFsW5bGUiWzw6moWh8RGrzN23oabt27cvWLBgoUKFvL29GzRoQLNQcs6cOfnz58+WLRs+HjhwIEuWLNWrV69bt26GDBlw8pFiW7duTZs2LYLqAgUKvPfee1RuiJUuXTo0UqVKlfLly7/77ruGshI43kHgj0sETstmQ8PZg2AQolWrVg1Lm5UrV5ol6uGMESrhKEDnwoULY48IOfPmzVuyZMnkyZOvWrWKlPnhhx8CHJQrVw5XZh8fn6tXryL95MmT2B2mRIQWuXCGLIhZy1FSkpNOwfTGGduxY0cmXbMgpl5JbC9fvjzaYpqNV5xIW7Y+l5mJrEVxLkdpIhM4R0ezMDQ+YpW5+zbUFCcETkdsBwUFeXp6Hj58mGShZKlSpdauXYvt58+fZ86c+dtvvyVZM2bMyJkzJ7kFO2HCBJxh2MC1BQH2zJkzSXmc3wMGDCDlt2/fniBBAo6sHO8g8MclAqdlw6HhuorzrFOnTqTMpk2bGjdubJj4ppn/wxkjpM6dOze5I4azNmnSpOSITJo0CXObFuvkgGy3bdsW3vHixQssZCZOnEjLWIEzZEHMWrauJCedEhwcjEaKFi2qj/soVsTUK6kJiGk2XnEibdn6XNZPZC2KczmqE1mL7OhoFobGR6wyd9+Gmvbu3Zt+DAwMpAELSn7yySdkG6E4WoZe8xxAU3w8e/YsycXKBaH7woULcXnp378/Uo4ePYoC+hUTLkccWTneQeCPSwR+y85Dw8UWVZh7z4aJDJwxQmp656hfv364gJNtrHQSJ05Mi+lnNdZBmO1lypT56KOP6KLJIvwhi8Bp2aKSnHQCJnDq1Kl79uyJBTib58CKmIw/RltMzngFibRl63NZP5G1KM7lqE7kSI+OZmFofMQqc/dtqKn+ni4uLMuWLSPbKInrCdlet24dzq2BEblw4QKyICKOBK7AI0eO/PDDD8mPX27YsCFRokRvWv1/axxZOd5B4I9LBE7LhkNbv349QhKmpGEiA2eMEIeGLRC2Tp06ZBtLm/jx49NizKweNWoUOv/rr7/SFItwhiyIWcvWleSkA0Q977zzDl0PGmJFTEZJLbpimo1XnEhbtj6X9RNZi+JcjtJEtnJ0NAtD4yNWmbtv65pqEc+zc+fOoeWLFy/SkuT27fnz5/XpzZs3J6f+8ePHkU5vEmPlgpbNZNW43kHgj0sEs5bNhoZBIf3UqVO05IMHDwwT6TaBM0YrU1qLOKuhMC7UY8aMyZgxo9lCxgyzIYtj2HKUlOSkr169GmfR9evXabohVsRk/DHaYhqO1yVE2rL1uawXRIviXLY+kS0eHc3C0PiIVebu27qmmpOstWrVwiXl5s2b2D548CDWI4i6r1y54unpSd4X/f333318fOhN2VKlSmFp8+jRo2fPniExRYoUhrISON5B4I9LBLOWOUOrUqVKyZIlg4ODsRbDCgXXTIzRMFHfoPMY27dvP3fuXM3alAZ9+vRp0KABzuarV69C/0mTJiGxWbNm9erVo2WsYDZkcQxbjqqShulYr+Hk/Oqrr7ZHhLRDldSsiUmVhBuGhoZGW0zD8bqESFu2PpeZiaxFcS5bmcg4TJyjwxDp0PiIVebue9q0aY0aNdKntGjRgtwsJ5QrV+63334j2yiJU5NmhYSEtGnTJlWqVGnTpoWgtBjE8vX19fPzq1mz5po1a2j7N27cwGFIlixZ+vTpsXjp3Lnzjz/+SFtjwHxYunQpm6qDPy4ROC2bDQ3hTKtWrXCiYJ3y3nvvkcedhol6nMeIYjiltIhSY5GC2U62Dx06BFd9U/zfj+TB68cff1y3bl1ypwzHpVixYlFaGHKGLIhZy1FS0jCdPLRxhpSnSmrWxKRK4pzEWjLaYpqNV5xIW7Y+l5mJrEVxLluZyPyjwxDp0PiIVRbbtxWc77zi3GJiJQoC8ijd8DbDfePit8wZGjDMMkyMAUKMYAs54A9ZBE7L0VBSM093N6yODthC3PEK4r6W9Vify66ayJrw0MQqi+3btrhvXO5rOYZpagRbyIH7huy+lmMYVkcHbCF3jtd9Lb91BIcmVlls37bFfeNyX8u2xX1Ddl/L9sR943Vfy28dwaGJVRbbt21x37jc17Jtcd+Q3deyPXHfeN3X8ltHcGhilcX2bVvcNy73tWxb3Ddk97VsT9w3Xve1/NYRHJpYZbF92xb3jct9LdsW9w3ZfS3bE/eN130tv3UEhyZWWWzftsV943Jfy7bFfUN2X8v2xH3jdV/Lbx3BoYlVFtu3bXHfuNzXsm1x35Dd17I9cd943dfyW0dwaEKVEyRIwPy+XiwAI8K42FQXkSRJkrCwMDY19oLBYshsqouIlaefGeq0jAbiogn5Y5YsWc6cOcOmSg5GhHGxqS6iUqVK8+fPZ1NjLxgshsymuohYefqZoU7LaCAumpA/9u3bt1mzZk+fPmUzpAVjwYjILxq4g2PHjvn7+y9YsCBWXq71YIAYJgaLIbN5LiL2nX5mqNMyGrhENCF/hJqNGzf28vLyiC14enrWqVPHrWcJzsWKFStiRcPuO3aBAWKY7jNHLTaefmao0zIauEQ0IX+MSTzE7rPGcZR6LkSJKYJc6knTV7lktRtKPReixBRBLvWk6atcstoNpZ4LUWKKIJd60vRVLlnthlLPhSgxRZBLPWn6KpesdkOp50KUmCLIpZ40fZVLVruh1HMhSkwR5FJPmr7KJavdUOq5ECWmCHKpJ01f5ZLVbij1XIgSUwS51JOmr3LJajeUei5EiSmCXOpJ01e5ZLUbSj0XosQUQS71pOmrXLLaDaWeC1FiiiCXetL0VS5Z7YZSz4UoMUWQSz1p+iqXrHZDqedClJgiyKWeNH2VS1a7odRzIUpMEeRST5q+yiWr3VDquRAlpghyqSdNX+WS1W4o9VyIElMEudSTpq9yyWo3lHouRIkpglzqSdNXuWS1G0o9F6LEFEEu9aTpq1yy2g2lngtRYoogl3rS9FUuWe2GUs+FKDFFkEs9afoql6x2Q0Q9j1gKO07LiNRVyKWeNH2VS1a7IaKeSF3bIjIokboKudSTpq9yyWo3RNQTqWtbRAYlUlchl3rS9FUuWe2GiHoidW2LyKBE6irkUk+avsolq90QUU+krm0RGZRIXYVc6knTV7lktRsi6onUtS0igxKpq5BLPWn6KpesdkNEPZG67uP58+dsUlQQGZRIXYVc6knTV7lktRsi6nHqDh48uGfPnti4ffv2KicePnyIrFOnTqVOnXr37t0vX77Exvz58/fu3TtQx+nTp/VtzpkzJ1u2bPRj1qxZZ8yY8eDBg7CwMJq4Zs2aZMmSzZ49e+LEiWi2WbNmc+fOffz48YgRI1CYFuPAGVSkiNRVyKWeNH2VS1a7IaKeWd2NGzc2b97c09MTjjZu3DgPJ44cOXLv3r2vv/4a27169fr++++xAS/74osvsAHjy5w5MzbWrl2rbxaWFz9+fPoxceLEY8aMyZAhQ9++fUnKrFmzkFisWLHRo0ejOtIDAwPRmre3d/LkyYcNG2YltPQwGZQVROoq5FJPmr7KJavdEFHPrG7KlCn/b4QeHo0bNw4JCYGvjRo1ChvLli1D4tGjR48dO+bj44PtFClSIHjEBuK+d999FxsI9y5evOjxxh9v3rxZpEgReB/jj/HixUNICG9NlCjRlStX0HiCBAlQC38zZcpUuHDhhAkT4mP27NknTZp09erVzz///PLly//10gSzQVlBpK5CLvWk6atcstoNEfXM6oaHh2PNu27dOhTYvHkzUuBrcDdsrF+/HoknT57ENiwS29OmTcMSGxswO5TBxoQJE0hoSeNHxJWw0R49eqCdbdu2TZky5bvvvkOBTz/9FBtdu3bdtGkTimH1DU/MmDEjwk9YZKFChXLmzOnv71+gQIG0adMiC7ZLO2mG2aCsIFJXIZd6bF/nzZs31JYgUmCTFJYRUY9zQt+4cQMOheBx8eLFL168oP64Zs0a1Dpz5oz2xh8p1B/haH5+fh46f7x//3758uUbNWqEdlq3bq2vRWjatCmKlShRAjFpLgeIYcuVK4eANHfu3Gi2U6dO8+fP13XQFLTGjtMyImIq7Kye88ljeuorFAQPE38MDg7Oly8fcomjIeLD9uzZs5G1atUqbJM4jvjjokWLTp8+7aHzR2Z9TdGvr0ldrKz1D2fgj2nSpCnqAA4Lf4RRIopE/IjCFSpUCA0NpYXNMBuUQqFHnSWKSDC0EqygfX19YWSOwM6je/fuiBaxgeU2cn/++WdsI7rUjOLHb7/9FhszZ84kT3X0/hgUFATPpf64fPny9OnTp0uXbseOHbQM/BGOmdIBNog/BgYG9urVa//+/f379//pp59oYTM8jAalUDCwZ4lt19d16tRhkxSWEVHP0ErghhUrVvzhhx+Qmz9/fnhl+/btsX3p0iXN8Y6OhyNC1N74I+LKv//+m/jjkCFD4sWLlyxZMi8vL70/zp07FwtnZFF/bNOmTeXKlRs0aNCyZcs3e/7XH9u1a4dwtWDBgogf69evjw7kyZMHZbDSh2kOGDCAFjbDQ2B9LSKmws7qSby+NpylCouIqMepu337duQePHgQVoU1b7FixUg6IsSECRNqjgAwadKkKJMkSRIYIjYSJ04MByxSpAhy9evrhQsXYrtq1aqDBg0i/vjgwQPY5aRJkxAPohHivACBZ9u2beGPqVKl6tatG2x67NixrVq1gjmiYvPmze/du0dKcuAMKlJE6irkUk+avsolq90QUY9Tl/jjlStXxowZgw26sO3Ro0fGjBmxceHCBaxI8ubNW7hw4U8++cTf35+Elh06dNAi+uOjR49GjRr16tUrev+RPM6+f/9+eHg4ltg1a9YkjW/cuBG1ateujb/w0EqVKsGar1+/3rlzZ6TkyJGDxK18OIOKFJG6CrnUk6avcslqN0TU49Ql/oglM6JFxHFImTp16pdffpk2bdoaNWrgI/xu8ODBKNOlSxfEktjAkhl/169fv2TJEvL6DvxO3ybxR/Lqz4IFC0gicVWElnfu3AkMDHz//fexYEfKpk2bNmzYkC9fvunTpyPGLFeuHILT/v376xs0hDOoSBGpq5BLPWn6KpesdkNEPU5d4o8VKlTA+hqBHlKGDBkCd0MQ9/fff+Pj3bt3s2XL1qxZsxcvXuAjDK5Fixa5cuV6/fr1Z599hrp+fn63b9/Wtwl/hMch3hw+fDhNRPn69eu3a9cuJCSkWrVqJ0+ePHbsGMJGDx2ZMmU6deoUYliU0bVnDGdQkSJSVyGXetL0VS5Z7YaIepy6Dx8+/PPPP7H+JV+1NgQRH5NC/Ovly5c3b97Uv7hDuHHjxr59+7BwZtKfPHnCfHEQpglvvXTpEhb4WJ7rsyKFM6hIEamrkEs9afoql6x2Q0Q9kbq2RWRQInUVcqknTV/lktVuiKgnUte2iAxKpK5CLvWk6atcstoNEfVE6toWkUGJ1FXIpZ40fZVLVrshop5IXdsiMiiRugq51JOmr3LJajdE1BOpa1tEBiVSVyGXetL0VS5Z7YaIeh6xFHaclhGpq5BLPWn6KpesdkOp50KUmCLIpZ40fZVLVruh1HMhSkwR5FJPmr7KJavdUOq5ECWmCHKpJ01f5ZLVbij1XIgSUwS51JOmr3LJajeUei5EiSmCXOpJ01e5ZLUbSj0XosQUQS71pOmrXLLaDaWeC1FiiiCXetL0VS5Z7YZSz4UoMUWQSz1p+iqXrHZDqedClJgiyKWeNH2VS1a7odRzIUpMEeRST5q+yiWr3VDquRAlpghyqSdNX+WS1W4o9VyIElMEudSTpq9yyWo3lHouRIkpglzqSdNXuWS1G0o9F6LEFCFm1AsNDWWTooWlvnooFAqFVEyaNIk1sqhj1R/ZJIVCobArsCwvLy9xi7RkfMofFQqFRMCyduzYIW6RloxP+aNCoZAIYlniFmnJ+JQ/KhQKiaCWJWiRloxP+aNCoZAIvWWJWKQl41P+qFAoJIKxrGhbpCXjU/6oUCgkwtmyomeRbCuGOO9MISl3794NCQlhU50IDw9/9OiRPuXly5ddu3a9ffs2tu/cuXPFHOTqKzKsX7/+t99+Y1Mt8OTJE7r9+PHjrVu3ku2dO3du3LiRZul59erV1KlTL126xGY42Lx58/Hjx9lUYe7fv4/9sqkO1q1bt+oN2EbK33//fUDH69evSckLFy5s2bKFVoT4mNjPnj2jKQo+hpYVDYs0aMUZw50p9Ozfvz9tZKAMKYzpfSMisJV79+5FbPJfmjRpMmvWLDZVgDp16rRr145+XLt2LWxCl/9/li9fni1bNvoR3lS+fHl4TePGjfGxYsWK6dOnz2YE0pGrOb7A0PMNkydPJikYeJ8+ffr3748N/TccUIZvmmFhYWh83rx55OORI0e8vb1PnjyJ7dKlS//444/6wgT4+8cff5wxY8YqVaoYWmSFChV+/vlnsg2jpIdpwYIFJBHmRcc1dOjQunXrJosIUYMBzfbu3ZtNdeDr69vaQbNmzVKmTImU+PHjo5ONHMSLFw/DJCW/++67Xr160Ypr1qwpUKAA/aiIFDPLiqpFGrfCYLYzBQVX+JCIQDQSrFFQhhQeOHCghxM5c+ak4QOlbNmy48aNYxJF0PvjqFGjRowYkSdPnsuXL0cspWEOd+zYkWxPmDAB8/mvv/5q2LDhn3/+qTn80czOkE78EVGkn58fnGvkyJElSpRASrFixTJnzpzSATbef/99WitHjhw//fTTixcvtm/fjhYQXi1ZsmTu3LnTp08PDg4mZU6cOBEYGHj+/PmbN28uW7ase/fuKIPGU6VK9csvvxw6dIi2Bn7//Xe0OWzYMIRyKANjmjJlij7+ev78efLkyfPly4e+DR48GNWhA45R8+bNZ8yYQcqgPK5befPmxaRCVtWqVRHT4VIBU0NXEQhDTFJy9erVgwYNgi22bdsWh7JmzZrwu2rVqmGM2DvdKbo63AGuENQfhwwZQhI9PT3hj9Bt165d2BdOEmzcunULxUqVKrVo0SJ0Eom0NQUHdnY5gWPK1jHCkvF5KH+0ACbtFB0ejm840Y/IpSUx2S5evIiZf+3aNcyHhw8fYhJ++eWXusb+T5kyZb799ls21Qh4K2Ys/Xju3Dms0XT5/0fvjwjiEJUsXLjw+vXrJAUehJBq/Pjx/v7+iMu6desGw4J74pKL1R/6SYoRf+zSpUvViLRs2VLvjzBBbGBWE38kYIbDEehHAvxr27ZtWJmiSq5cuQoVKgRn+fDDD2ExBw8epMXQYc0RPDZ1ULRoUVxUyDYN+vbt21ejRg2EjbBIWhGNvPfee4gNEQaSOB1Olzt37mPHjsEce/TogU7CKzXHhYH6I6FgwYKnTp3CBgb4xRdfECMbPXo0Bkv9ETE+PsIcEyZM2KBBA5RBAPjDDz/AuI8ePUqbgj8ucwDrp/4IlyeJxB8hOATENoaPCwzScY3BSGH0yM2ePfvevXtpg4roYd3QLJWz3lxcBi6ABRddVEI0TDyyjXS9RzCsW7cO8wqhCpvhWDxGuhbADERYh0ADS06si0kipmutWrUiFvwXTGlMv8OHD5N7ZCQ8oWBiFylSpGTJkokSJUJoiTAHzohlZt++fbFspMWIPyJ9e0TgTWb+uGHDBrK0hPcVLlyYbMPpSIOwCbptnTFjxnTq1EmfEhQUlCZNGvg77PK/Nb+DNm3aLF26tFKlSmTIcDocHWzgGjBt2jS4vxV/bN++PZwR5oWgHg1SfyRMnjz53XffRRZiRsOLk4+PTzkHiAepP+ISVdABThiyvsa1M0OGDJojbITz4rCik1hu169fPyAggMirEMG6oVkqZ725uAxcAAsirL/IWQ7RsArDNlKQbuaPWHQjtGnVqhWb4QBWhdiTSURsCGugHydOnIhwCXvBehmLSmJ8WJh37tz5vzpvwJROkSIFpiXmau3atefPn0+jQso333xTvXp1sg1TwPoangIHJ/f7tDf+iD2SwIfy4MEDvT9iL1gRIxTF2I8fP/6jDtgQZv7Vq1c1xzIWWp05c+bN/g2AtSVOnDhevHgwMsRlfR188MEHcHOyDaC25niyhL/oySkHaPmvv/7Chv7ygyFDBOJu5cuXR0SGYBOurUX0R0SaCDkTJEiAOA5hNaT49ddf0WeMC6NDbKj3R5gaFuxYpHft2hUujFEj2j1//jwq7tmzh5RJnTo1eoKKOGQwU2iFMBPbaBbpaJacOVDms88+w0a6dOlwycGlDhcqmDiuQLdv30bY63w/RBElrBuapXLWm4vLEH/E6pU4GvFHbCOF44+9e/fGXL158yab4QDLzOnTp+tTsDbHChT2Rx+SwmFhi2PHjsW0RzBCbtilT5+eqUgg62uURNCKmYw4JUmSJMxj3GLFitGHQh999BHsEhs1a9bs3r07SST+CJtOlizZZ2+A4SJUZOJHKIAwE2PH2vmYDvgOLAkupjkepEAr0m1kkV0YgiAL/gg3IbcssNhEy/QOBrm9C9fWP0xHyydOnKAfyUMhhOQff/wxYj3YDTzr+fPnCPrq1aunOfwRTsTslMSPzZo1C3SANskGCpMy8DU4NVYJaArbuADA7BB642/+/PlxESLFsC/8RWxbwgGC3yxZsiDMX7VqleaIJYk/om9oAb2FL2uOGJ/2H5BXCBQiWDc0S+WsNxeXiYY//vTTT1iswaFmzpzJ5jlAre+//55+vHbtGqYrTJA4C2Xu3LnExQhYbmPvhitW5vn169ev4V+6fA1xHELFu3fvko8ffvghYhzNcXeVLtipP5IVNAHrU2d/1N6sr1esWFFUB3YB4yC3CDEW9Pb69euwIazrrxjdZyAQfyTbGF3SpEnh702aNIH50jKLFi3KpQMt4+JBP65cuVJzBIaI7OB3cLRPP/0UKQjhSdgIy8MhQ6RMFaD+SICFwcjoR8KcOXMQh8IcEdvC1OC8WD4jMCQ3TCnEHzXHfQygOQ4HfdJF/RFr/2rVqqH6J598go+QC9oS3SApc0tBEQ2sG5qlctabi8tQf8SMnT17NkSDtWHbzB/Hjx8Pc8TfzZs3IxAbOnQoU0BzzFs0Rba3bt2KdTTmoeGbQJSnT5+WLl0aC3M2wwHjj84MHDiwRo0a9CNWc/TRB4X6I7zgpzfAqhh/RAyLFCwwydixQZ8tIPjCgpRsw0Sg1aVLl6ZOnVqmTJn/78MI6o8bNmxABDpkyBA4Y926dRFI6pfnCCTpUx20HOJ433P16tVkOU/ZsWMHcnFo4IzoDwktyeHDVYE+7MJOcYAQhCJCb9q0KfwUy3zyUAgWRltDdQSeOXPmRIP4CC+mxkeBPwYFBWFfKRxgA5dGaIgNTeePWBm0bdsW58aaNWs0hz9Sg8bJoPxRHOuGZqmc9ebiMsQf4QKdIoIUxh+xmsbswnygt7q2bduGqTJq1ChahoClLmJDrDoR7CRIkKBHjx4IUpgyeo4ePQqLwZSj9woZ+P6IgBemhliPfITVItD7448/Ipb6vz9i3UcX1wR4nN4fMSJsk7Wk5giW8+TJQ16y0fsjuf8It4VQcA0EgDAyOAXiSpQ5ffo03S+sat++faNHj4bR0FUwQmB4eqVKlWixCxcuIHwjN+mIP8I9U6VKRR/TE6B24sSJBwwYgAU7eW9JcyzwBw8ePGHChPDwcFyHYNnYF6wf48JBRBC9ZMkSOBe538o8SsZg6ZuYaMH5jiqJHyFyoUKFsKbGRu3atWHE5M4p9UeAXiGUbt++vab80Q1YNzRL5aw3F5ch/simOkCoQl/3mzx5MlwAiz5mdmHCYIZgpaZPzJYtW0BAAAIWzD3mFT+GWbNmwSPQAiJHvacw8P0Rkx+7gwXDpAYNGoSS6CqdtBTij0wiYe3atcSq4Erkkfft27fpa9hoFp6LDUR/1B81xwl2/PhxOB08C2bkoaNUqVKa465ir169sMyEbujVzJkzIReiSER2CKu3O96aJDfmrl27hhU6lqjNmze/8ub+Y/369eE4+IhcskcshKFtcHBwgwYN0CYGi54fPnz47NmzsFcYPfYIwXFZgnvCv9A4+YrLnj17IPKbL7wc0C/t4Ynw5ZYtWw4bNgwmjj126dKlTZs2tAD8EbFt79698+bNSzyRrq9hxzjK5OIxf/58X19f7L1w4cII3uGPLVq06OYA2ip/FMe6oVkqZ725uIyhP27cuBGOkyZNGjpPEGJ888035DErw6RJk7Dc1qf07du3Q4cO+vtfZowcORLG4RzrMfTv35/zwvm3335LXidCt6tXr44R0ReG9Bj6I8wCI0WY1qdPHyZLD9anRBD992fKli2L+JF+ROBG3t/EBvERBIMffPDB3bt3EbRiVduwYUNE1lj709d3sJ4l/ghPoYnOkIfUWOSiLv6S3R05cgT+WK1aNazT/f39vby8EFcySiKmLm2E/luAmuP1eCj8+eefY5gwNdg0XJLmwh9x3BEV0nusX3/9NQwX8b6Pjw+iY6ScP38eIfzu3bs1x5MZ+Cn8EUt7+txf+aM41g3NUjnrzcVlEAEx31nWHPeSsFpEVGL2nVwZOXjwIH18QcEAMe0xvZl0BhgEjIl5cBHzvJXvMptd5xBTY+1P75zov2muOdyc9hbhKnOXQBENrBuapXLWm1MoFAqbY93QLJWz3pxCoVDYHOuGZqmc9eYUCoXC5lg3NEvlrDenUCgUNse6oVkqZ705hUKhsDnWDc1SOevNKRQKhc2xbmiWynkoFApFLIL1OBOslnvrWB+SwhmlngtRYoogl3rS9FUuWe2GUs+FKDFFkEs9afoql6x2Q6nnQpSYIsilnjR9lUtWu6HUcyFKTBHkUk+avsolq91Q6rkQJaYIcqknTV/lktVuKPVciBJTBLnUk6avcslqN5R6LkSJKYJc6knTV7lktRtKPReixBRBLvWk6atcstoNpZ4LUWKKIJd60vRVLlnthlLPhSgxRZBLPWn6KpesdkOp50KUmCLIpZ40fZVLVruh1HMhSkwR5FJPmr7KJavdUOq5ECWmCHKpJ01f5ZLVbij1XIgSUwS51JOmr3LJGmN4KOwNe8DiPHJpIk1f5ZI1xlCy2Bl1dJyRSxNp+iqXrDGGksXOqKPjjFyaSNNXuWSNMZQsdkYdHWfk0kSavsola4yhZLEz6ug4I5cm0vRVLlljDCWLnVFHxxm5NJGmr3LJGmMoWWKY169fr1q1ik01QR0dZ+TSRJq+yiVrjBHDshw8eLBLly7nz59nMzTtxo0bAyPSs2fPVRG5evUqLf/o0aNSpUqtX79+0aJFoyOycOFCXcM24sKFCzVr1kycOHHXrl3ZPCNi+OhIgVyaSNNXuWSNMcxkWbly5WwTbt++zZa2TOvWrbHH48eP05QnT56QjZMnT/r5+SE3W7ZsWbJk8TBi06ZNpDCisE8//TRFihSXL18uXbp0qlSpCr4hderUJUqUoMXWrl27evXqX3/9FSNasWLFsmXLli5d+tNPP82fP5+UcRNbt24d4kTVqlW9vb0zZcqUIEECXCrYOk54mByduIxcmkjTV7lkjTHMZIHRRLSm//jzzz/Z0tZA9JckSRJPT8+cOXPCBN9555106dIVKFAgJCSEFJgyZYqHoz937tzBBgLDfv365cmTBwVgbUg5deoUcp8/f96kSZN48eIRj4M/pkmTpsQb/P39qT++ePGC6byesWPH/r9nbgDxL7s/B507d86cObMVc9TMj05cRi5NpOmrXLLGGGaywB9z5cp1LCJfffWVh4k/3rx5s3bt2ljtko9wrvbt28Pm9GVatmyJ6h9++OFHH31Ut27djz/+OGvWrPHjx0ddUoD4IwJAxIPYQJSHlXKyZMkQBk6aNClRokRwRhS7ePEiyixevBjuWaFChZIlS8Jk+76hUKFC+vhxwYIF8Fk0hbARJotAct26dQ0bNkT7CPFo30jhF0a8evVKX8wi8HT0Mzg4GFcFRNz379/HJQHjffnyZVhYGFvaBLOjE5eRSxO2r/PmzRtqSzCF2CTF0KFmZxtZqzKJM2bMcPbHyZMnf/DBB7AABG4IDImFYfGLknp/3LBhA1IaN278X01NQ2yIuvQj8Ucs4SdOnEj88dChQ9gICgr64osvihQpQkvCfdANeOuwYcMQP3pEhPqjGXBVrHCfPn2qT1y1ahXTDqF169b6YtEDY0FT06ZNYzO4oAp7wOI8dp7IzjdtjGeXQhY8hP0RIR4SR40aRXIRryHxvffe8/b2pmWOHz/u6+ubMWNGvWP+8ccfKD916lSa4uyPCN8QP86ZMycwMLBXr1605MmTJwMCAmCv27ZtGz58OHObDymGQS4BfYA5Vq5cmUlHm+S5UNeuXbH38uXLk4/6x82HDx/OZQ72q2vvPx48eIDgER1mHDlSzI6OQhbU8ZMbsxlo3R9B4cKFsSJGCJk9e3aUwRLSx8fn/fffpwWw7kZ0iRW6rpKGyBHeh4UnTSH+mDJlyhQpUhB/RGLNmjUzZ86Mjzt37iTFYGRp0qRBSqNGjeCk+XRkyJAB6blz5+ZEauQuAecZ95UrV1Bg9OjRbIamYewe5nTq1ImtoGlYnteoUQO5kyZNYvMiw8Pk6ChkgT1+tl1f169fn01SuGJ9DZYsWfLJJ5/cuHEDzoiPS5cuRbE+ffroy9Dn1ASYBcr0799fn8g8nyH+iMaxjejs9evXpNitW7cQ/cGU4Y+tWrVqpKNkyZIoXK9eva+//lrfMuXIkSNJkybNkSMHIlM27w0cf0QfwsxxbhMpbdu2RWvx4sVDBL1r1y6mAB8Ptb52ws4TWeL1tZkRxHHMZImSP+pBkIjgDh5k+JIjAadR/PjxYVKhoaE08fHjx/369UP73333XYcOHbCRNm3aoKCgzZs3Y7tMmTLUHwlVq1Yl/lilSpXixYtb8Uc05efnh8X1nj172DwdHH+MEgiNK1asiKbg5gcOHMBwvLy8tm3bxpYzx+zoxGXk0kSavsola4xhJgvMEZOZvjRDIK8lmvnj9evXBwwYgFqenp5z585lsx3AMtq0aYNGAgICzp07p88iPgjQAhbI2GjYsOH+/fsDAwNRGB9HjBihL0/8ERvVq1dHx8g6nTwGYZ6bY4WLxmvVqkUaX716tT6XsmLFiikOhg8fjpK1a9cmH8G9e/fY0lxg5Vi/o+dop0mTJmGOB9bHjx9PnTp18uTJ//rrL7aCCWZHJy4jlybS9FUuWWMMM1ngj4kTJ2aePyACMvNHuBWWkMjNlCnTmjVr2GwHMC8fHx+UKVu27LVr15hcxJK7d++GyWpv1teDBg1Ca/7+/sHBwR07dkT75OEPgfrjpUuXvL29v/3221WrVg113DG4e/cuLbZy5Uq04OFY4cLyOFGt83NwCnPnNFKqVauGWilSpPjhhx/06Xv37kVkjf5cvHhRn26Gh8nRicvIpYk0fZVL1hjDTJapDphEBD4DBw7E8pNJ1xz3E+FWCMHI+z2GwMjy588Py2BWys4Qf+zWrVvhwoWxxEbKy5cvGzRo0KVLF1qG+qPmeCMSf9E4ar3zzjv6NxZDQkLKlSuHbp8+fZomGoLunTLh2bNnbGkuGzdubN++PX2vU8/SpUs//vjjx48fsxlGmB2duIxcmkjTV7lkjTHsKQvcECHbgwcP9E4Hk9I/AIFtMSt0LGNhpvp7mrJjz6PzdpFLE2n6KpesMYaSxc6oo+OMXJpI01e5ZI0xlCx2Rh0dZ+TSRJq+yiVrjKFksTPq6DgjlybS9FUuWWMMJYudUUfHGbk0kaavcskaYyhZ7Iw6Os7IpYk0fZVL1hjDQ2Fv2AMW55FLE2n6KpesdkOp50KUmCLIpZ40fZVLVruh1HMhSkwR5FJPmr7KJavdUOq5ECWmCHKpJ01f5ZLVbij1XIgSUwS51JOmr3LJajeUei5EiSmCXOpJ01e5ZLUbSj0XosQUQS71pOmrXLLaDaWeC1FiiiCXetL0VS5Z7YZSz4UoMUWQSz1p+iqXrHZDqedClJgiyKWeNH2VS1a7odRzIUpMEeRST5q+yiWr3VDquRAlpghyqSdNX+WS1W4o9VyIElMEudSTpq9yyWo3lHouRIkpglzqSdNXuWS1G0o9F6LEFEEu9aTpq1yy2g2lngtRYoogl3rS9FUuWe2GUs+FKDFFkEs9afoql6x2Q6nnQpSYIsilnjR9NZO1Xbt2+/btY1MtgIoHDx5kUzXt2rVrHTt2XLhw4YoVK9i8yHj+/PmlS5fYVBtgpp4iGigxRZBLPWn6aiZrwYIF165dy6ZaABU3b97MpmpapUqVDhw4EB4eXqhQoevXr7PZXCZMmPD48WM21QaYqaeIBkpMEeRST5q+msnqWn/ctm1bhQoVyPbEiRO7desWMZ/H7NmzDx06xKbaAzP1FNFAiSmCXOpJ01czWfX++PLly0mTJtWoUaNhw4YrV66kZZ49ezZq1CgEhjVr1qSFqT+eOHGiQ4cOt2/fxnbr1q1nzJhBCmCh7e/v//r16zfN8Ni6dSutaEPM1FNEAyWmCHKpJ01fzWTV+2OLFi2qV69+8uTJPXv25MmTB15J0mGXlStXRnAHF8uUKRP+korwx8uXL2fJkoXeasyePbv+pmTGjBnhnvSjGadOnWrVqhWbaifM1FNEAyWmCHKpJ01fzWSl/nj69OkkSZLcu3ePpO/cudPb2/vVq1ewS336lStXEGaSir/88kv+/PmXL1/+pjHNy8vrxo0b9GPx4sWd1+CEWbNmkY1Lly5VrFgxJCQkYr69MFNPEQ2UmCLIpZ40fTWTlfrjqlWrEDPS9CdPnqBKcHAwk05BxQwZMgQGBl69epUmJkiQgDopKFu2rNnNzYCAgN27d9+5c6dEiRKwZjbbZpipp4gGSkwR5FJPmr6ayUr9cd++fb6+vggYSTo8y9PT8+nTp/v37/fx8Xnx4gVJp/cTUXHhwoUTJ04sXbo0zU2XLt25c+fINsibN6/Zy0MjRoyoVq0aAswNGzawefbDTD1FNFBiiiCXetL01UxW6o/wOGx//fXX2A4PD69Xr16TJk1oevfu3bGsRnrTpk0XLFhAKmLtDLusXLlyz549SWtVq1alD3bCwsKSJUtm9r7OgwcPUqVKNW7cODbDlpipp4gGSkwR5FJPmr6ayVq9enXyvAVcvHgRBpc1a9ZMmTK1atXq4cOHJP38+fOVKlVCdOnn59e2bVu4JKmIBbLmeE6NOJFsT506tUOHDqTWxo0bYZ1k2xA0yybZFTP1FNFAiSmCXOpJ01frsiJgNHwpB+l09W1GaGho9uzZHz16hO06deps2bKFLfG2uX79+qxZs/Q3Sa1gXT1FpCgxRZBLPWn6GmOyLlu2DItxxKQtWrRg8+zBjh07UqZMWaFChZ07d7J5JsSYenEBJaYIcqknTV9jUtajR48GBQU9ffqUzbANsMiECRNCE39//6FDh0YaTsakerEeJaYIcqknTV/lkjUGgEV6eXlBlnjx4sEr+eGkUs+FKDFFkEs9afoql6wxA7VIAlzSLJxU6rkQJaYIcqknTV+pCyg4BAYG4q+Pj89vv/3G5jnBSqywhpJOBLnUk6avcskaM0yYMAGLayiTLFmyUqVKZc2aNW/evBMnTiTxI18xfq6Cg5JOBLnUk6avcskaAxBzDAgIKFGiRMqUKZs1a7Zr1y59Ab5i/FwFByWdCHKpJ01f5ZLV3UybNi1hwoSenp76gJGBrxg/V8FBSSeCXOpJ01e5ZHUrO3bsSJ06tXPAyMBXjJ+r4KCkE0Eu9aTpq1yyug/r35/hK8bPVXBQ0okgl3rS9FUuWe0AXzF+roKDkk4EudSTpq9yyWoH+IrxcxUclHQiyKWeNH2VS1Y7wFeMn6vgoKQTQS71pOmrXLLaAb5i/FwFByWdCHKpJ01f5ZLVDvAV4+cqOCjpRJBLPWn6KpesdoCvGD9XwUFJJ4Jc6knTV7lktQN8xfi5shMaGsomuY7YLZ27kUs9afrKyOqhUHCh//3c5XhINcPthlzqSdNXRla5VFbEMDg9kiZN6iaLVOeeCHKpJ01flT8qrIPTY/v27W6ySHXuiSCXetL0Vfmjwjrk9HCTRapzTwS51JOmr8ofFdahp4c7LFKdeyLIpZ40fVX+qLCO/vRwuUWqc08EudSTpq/KHxXWYU4P11qkOvdEkEs9afqq/FFhHefTw4UW6dy4wjpyqSdNX5U/KqxjeHq4yiING1dYRC71pOlrzPjjq1evfvvtt/bt27MZ7ufp06ddunQpUqTIl19+yea5jWvXrnXs2JFNjS5BQUEjRozo1avXkiVLoCSbHREzqS9cuEAaYf6dt3P6woULV6xYoS9DMTs9XGKRZo0rrCCXetL0NQb8cd68eQEBAQUKFOA0fvr06YMHD7KprgCTv1atWiEhISdPnmTz3EalSpUOHDjApkaLbdu2pU6desiQId9//z1cvl69emwJHWZS7969O1WqVCNHjpw2bVr69Olnz57NSQ8PDy9UqND169f1LRA8ImPHjh1sHct4mJ8eikiRSz1p+srI6g6VEUw9fPjw3LlznMYbNGhAJ61rgaFMnTqVTXUncLQKFSqwqdGlWLFiCBvJ9p07dzw9PTlGbyY1HPObb74h25s2bfL19YUJctInTpzYrVu3N7Wtwjm+VhCsHseRSz1p+mrFHxF89e7dGzHRF198cfnyZZL47NmzUaNGIbFmzZpr167lJBKcJy3l559/fuedd8qUKdO6dWu0379//4sXL/br1w9NaSZ7RxmEnIMHD0Zs+NVXX2ERTdJ//fXXKlWq1K5de9GiRfg4duzYjBkzli5dGi3DO8LCwoYOHVquXLn69evv3bv3zf7/bU2/R2fMdnf//v0+ffpUr14dblK+fPmePXsiEfuaMWMGKWDYeTOVDNPv3bv38uVLug1/PHz4MK1iCCM1VtD4SOPB169fI1Rct26dWbrm8Fl/f3+k0EasYHZ8LSJYPY4jl3rS9NWKP2L+9+jR48yZM8OHD8cSjyQ2bNiwcuXKhw4d2rp1a6ZMmfDXLJHA8cerV6/CFOA+qAjryZYtW5s2beA1xAgM944y+fLlw6oQu0AQhOUnEq9cuZI2bVqUPHHiRKtWrWBe2GnZsmUHDhyIlmGOdevW/eyzzzD5UQvzH8Voa/o9OmO4OwBPh6sGBwfDiBHokcTs2bPTewWGnTdTySydAKut4kCfaAgjNQJDLy8vXb6GC8aUKVPM0sk2ritUH4uYHV+LCFaP48ilnjR9teKP8KzXDrC+S5AgAT5iiZckSRL63/5gTIhxDBNpIxx/1CKur2FGHTp0oFnOeydlxo0bRwogWCOugRgwZcqUu3fvpnVBjRo1SDR37Ngx5N66dSvEQffu3ekjFGaPzhjuLjQ0FCN68uQJScfY4bzYgOncuHGDJDp33kwls3TCnj17EGIjCKWhKwdG6o0bN/r5+enyNbgwltVm6WS7ePHimzdv1udGCuf4WkGwehxHLvWk6asVf8RatWjRoiVKlKhatSomOcxl1apVefLkYYoZJlKi5I9r1qyhWc57J2Xo7P3xxx8R+JBtrK8R6BUqVGjlypUkhfrjsmXLvL29S+tAZEfKMHt0xmx377777nfffRceHr548eIMGTK8ePECiegktTnnzpupZJYO5s6dmyVLFutuxUiNoBirctI3AkLg+fPnm6WTbcTdzB2SSOEcXysIVo/jyKWeNH2N1B9PnTqVPHnyoKAgbCOiSZQoESb5/v37fXx86NQiN6oMEylR8kfqBYZ7Z8roDYuAlWnq1Kn//vtvTeePu3btSpcuneH7MfrWDDHbHfqM7fLlyzdr1gxdJYnYCwarmXTeTCWzdBh33rx5aUBqBUZq2HeqVKmwmiYfEcnGjx//7NmzZunkI3a6b98+sm0RzvG1gmD1OI5c6knT10j9ES6DWURcafjw4ZhCWEViGhcsWBBLVEx7TLOmTZsuWLDAMJG24+yPffv2pTMQhUeOHEnXztSMDPfOlKGGdfny5enTpxNnKVWqFGJJTeePz58/R2g5cOBAUmDmzJljx44lLUTbHzNmzDhlypQjR47o/QuhIoleDTtvppJh+rNnzwICAn755ZdTOu7fv4/ykydPJs7rjKHUiGER1aLlJk2aoIf89LCwsGTJkj1+/Pi/JizgfPJECcHqcRy51JOmr5H6I+jVq1f69Olz5MgxbNiwVq1aIRBD4vnz5ytVquTr6+vn59e2bVvyXohhIiE4ODhz5sz0I8BH8pQZrFu3DrWwLobHlStXTn8P0XDv+jJYmTZs2BAbMKm6dev6+/tjNdqoUSOYCxJRhe7lwoULsAAshLNmzVq/fn1ETCSd2aMzhrsDs2bNwqK4du3acEwMh7xiPXXqVHo307DzZio5p9++fTuzE3PmzEEW3Pbq1aukIoOz1CiPBr29veF6uGDcunWLn75x48bKlSv/V98ahiePdQSrx3HkUk+avlrxR83xrQxmvUxA1OO8YjVMFMFs74a8cMCm6kCu/tGHnotOkOjPkOPHj8P7EJaSj6NGjUIIpjme22TPnv3Ro0ck3azzZiqZpeuBERcoUIBNjQyMmvaWn16nTp0tW7boU6xgdvJYRLB6HEcu9aTpq0V/jCP0dYKz7ka4mjZtWqxz4VYIUXPmzLls2TKShQ2slCMWdyUDBw5EFMmmuoitW7e2aNGCTbWA4MkjWD2OI5d60vRV+aMI169fnzZt2oABA8aPH0+fzxCOHj2q/+hyDGNSlxAUFGTlLSJnBE8ewepxHLnUk6avyh8VrkLw5BGsHseRSz1p+qr8UeEqBE8ewepxHLnUk6avyh8VrkLw5BGsHseRSz1p+qr8MQa4f//+zZs32VRzRo4ciSrLly8PDQ1l83Ts3bs3ql9xcSuCJ49g9TiOXOpJ09eY8UezH219K4Q4fgvy0qVL7nvEwTBkyJCCBQuyqeYEBgaeOXOmc+fO/fr1Iyn37t2brePixYua41fIOnXqpK/4dhE8eQSrx3HkUk+avsaAP5r9aGuUcMkP6G7evLlkyZKenp4JEyZMmTJlmjRpvvrqK/1L7KBo0aLxjUC6vph10D6GX6VKlQkTJowdO3b06NFwve3bt9MChw4d6hQR9K1JkyZt27bFFWXWrFma4yeOunXrVrZs2UKFCmFj69atu3bt6tq1a/369Xe9Icbs3gyR46sJV4/jyKWeNH2NAX80+9HWKCH+A7qTJk3y8fEZM2bM9evXye/WHDhwoJQD/TIWgR5M81hEkGIYAMKS1q9fTz9ijBcuXNDl/8u3337r6+sLf6xZs2a9evU++eSTPHnyfPTRR7TAsmXLYHzLdOTNmxd7JNv636kcN24c+dnaPXv2VKxYMUeOHBkzZqzoANqS7wu9RUSOryZcPY4jl3rS9NWKP4ZY/pFXw0QC3x/79+//559/tm7dGj64f//+s2fPtmjRomnTpvAmzekHdPERS0tS8ciRI+hbpF84QXiFoIz8vCOq5MyZk6Q/ffoUxkeXsZrDH+mv21KQwvjj0aNH0eFbt255e3svX76cJLZs2bJWrVr6YsHBwSlSpFi6dKk+EW5IokICTBAj1eVrdevWXbx4seb42qXeu6k/EgYPHjxo0CCyDW353xqKATjH1wqC1eM4cqknTV+t+KP1H3k1TCTw/TFbtmxYOcIOJk+enC5dugoVKmzatAmr0fTp08NzmR/QvXPnDlasW7ZsQRaW7fSnzDjArwcMGEC2v//+exgQzVqwYIH+28oW/REGjdjtyZMnuB4gjiMGDePr3LkzLQNrK168OALG/6ppGqw/UaJE+sc18Md8+fLRb+ygzS5dumDs2EicOLH+S9aMP2L1Tf4l1vPnz6GtWl/HZeRST5q+WvFHiz/yaphIG4nUH+kvDyLgov9xxcvLi/y7FWZ9vXnz5ixZsnTt2rVdu3Y0kUPq1Kl///13sk1+K4hmwcT1P6Nt0R8xNNgiXOzhw4fwaMSJSISbT58+nZZBBF2iRAnmGXSrVq2Y/7EFf/zwww/JatrT0xPR+rRp05o0abJixQp6NSIw/ohrxjLHNxofP36M4/JfubcE5/haQbB6HEcu9aTpqxV/tPgjr4aJlEj9kX7TOW3atFi6km34GvlHgM73Hxs1apQ8eXL68918UqVKRX6ABy6P9v/44w+a9cMPP2TPnp1+tOiPmuNna+mvbQP0GQPE4l1X5N8fm9B/xDI/fvz4zL82RABLfsk8LCwMLYSHh6NAYGAgwvbRo0frS+r9EbabNGlSEofevn0bUuhLvhU4x9cKgtXjOHKpJ01fI/VH6z/yaphIca0/Hjt2DItiLMP1kSAHBGjk1x7JfzSlncTGe++9pw/KrPujHsTUpUuXLlmyJJuhAytrBJjOLzkNHTqUjOLWrVuwPM2hs7+/v6+v74MHD/Ql4Y9ffPEFrkNjxoxBiF2oUCGSfuHCBbSsL/lW4BxfKwhWj+PIpZ40fY3UH63/yKthIm3H2R/76n4fN1J/1P+ALkKnvHnzLl++/Pr16/ARWpjDhg0b0NSePXs++uijLl26kEQMpG7duojU6O8eag5/bNGixbyIIIXjj0ePHi1Tpoyfnx/nP69idY8CWBEzrxOBihUrrl69Gn3YuXMnxqU53ifPmjUrLgma48UmCHvx4sUePXrkypUrRYoUCJxhjrg8LFy4kLQAiTjdizGcT54oIVg9jiOXetL0NVJ/1KLyI6+GiQTnH23NrPt9XP0P0BYrVoy+6li4cGHyQzj6H9BFwNW6dWtS4Oeffy5fvryz6Tgzfvx4Ly8vtHDnzp2rV6/C0RIkSIC65F1rCowGBp0rIkgxNKBZs2ZhvLhmIHKEkbHZDhA2wtHixYvXrl0751dwbty4gV49fPhwxIgR8Ho0CKGgQI0aNXBZOnz4MFr+66+/Ll269O2338IHce1BI7DOEiVKIEJHdVwtcOX4+OOPmZZjHsOTxzqC1eM4cqknTV+t+KMWxR95NUx0K+S3bPUY/q6tvleTJ082fOF86tSp8CMmESlIZxI1xxcB4Xr6u5nOHDp0qFSpUtu2bWMzHOzYsQMXEn0KVtBt2rR5/vw5rD958uTwcX0uWLx4MS4b5MfPsfc0adIgBCYXrbeL2cljEcHqcRy51JOmrxb90eb893u2b+D8rq3N0cfCt2/fdg45tYhl7IPgySNYPY4jl3rS9DV2+KPCDgiePILV4zhyqSdNX5U/KlyF4MkjWD2OI5d60vRV+aPCVQiePILV4zhyqSdNX5U/KlyF4MkjWD2OI5d60vRV+aPCVQiePILV4zhyqSdNX5U/KlyF4MkjWD2OI5d60vTV2R8VimijP5eiimD1OI5c6knTV7lktQN8xfi5Cg5KOhHkUk+avsolqx3gK8bPVXBQ0okgl3rS9FUuWe0AXzF+roKDkk4EudSTpq9yyWoH+IrxcxUclHQiyKWeNH2VS1Y7wFeMn6vgoKQTQS71pOmrXLLaAb5i/FwFByWdCHKpJ01f5ZLVDvAV4+cqOCjpRJBLPWn6KpesdoCvGD9XwUFJJ4Jc6knTV7lktQN8xfi5Cg5KOhHkUk+avsolqx3gK8bPVXBQ0okgl3rS9FUuWe0AXzF+roKDkk4EudSTpq9yyWoH+IrxcxUclHQiyKWeNH2VS1Y7wFeMn6vg4BLp2rVrR/9pcJRARcP/13bt2rWOHTsuXLhwxYoVbF5kPH/+/NKlS2yqe3CJejGGNH2VS1Y7wFeMn6vg4BLpChYsuHbtWjbVAqho+D/dKlWqdODAgfDw8EKFCl2/fp3N5jJhwoTHjx+zqe7BJerFGNL0VS5Z7QBfMX6ugoNLpHOtP27btq1ChQpke+LEid26dYuYz2P27NmHDh1iU92GS9SLMaTpq1yy2gG+YvxcBQeXSKf3x5cvX06aNKlGjRoNGzZcuXIlLfPs2bNRo0YhMKxZsyYtTP3xxIkTHTp0uH37NrZbt249Y8YMUgALbX9/f8P/Au/M1q1bacWYwSXqxRjS9FUuWe0AXzF+roKDS6TT+2OLFi2qV69+8uTJPXv25MmTB15J0mGXlStXRnAHF8uUKRP+korwx8uXL2fJkoXeasyePbv+pmTGjBnhnvSjGadOnWrVqhWb6mZcol6MIU1f5ZLVDvAV4+cqOLhEOuqPp0+fTpIkyb1790j6zp07vb29X716BbvUp1+5cgVhJqn4yy+/5M+ff/ny5W8a07y8vG7cuEE/Fi9e3HkNTpg1axbZuHTpUsWKFUNCQiLmux2XqBdjSNNXuWS1A3zF+LkKDi6RjvrjqlWrEDPS9CdPnqD94OBgJp2CihkyZAgMDLx69SpNTJAgAXVSULZsWbObmwEBAbt3775z506JEiVgzWy2+3GJejGGNH2VS1Y7wFeMn6vg4BLpqD/u27fP19cXASNJh2d5eno+ffp0//79Pj4+L168IOn0fiIqLly4cOLEiaVLl6a56dKlO3fuHNkGefPmNXt5aMSIEdWqVUOAuWHDBjYvRnCJejGGNH2VS1Y7wFeMn6vg4BLpqD/C47D99ddfYzs8PLxevXpNmjSh6d27d8eyGulNmzZdsGABqYi1M+yycuXKPXv2JK1VrVqVPtgJCwtLliyZ2fs6Dx48SJUq1bhx49iMmMIl6sUY0vRVLlntAF8xfq6Cg0ukq169OnneAi5evAiDy5o1a6ZMmVq1avXw4UOSfv78+UqVKiG69PPza9u2LVySVMQCWXM8p0acSLanTp3aoUMHUmvjxo2wTrJtCJplk2IQl6gXY0jTV7lktQN8xfi5Cg5Rle7evXuzZs2K9J1tBIyGL+Ugna6+zQgNDc2ePfujR4+wXadOnS1btrAlbENU1Xu7SNNXuWS1A3zF+LkKDtal27BhQ6lSpbCe3bFjB5vnapYtW4bFOGLSFi1asHl2wrp6dkCavsolqx3gK8bPVXCIVDoEjF27dk2ZMiVKJk2aNAbMkXD06NGgoKCnT5+yGXYiUvVshTR9lUtWO8BXjJ+r4MCRDgFjsWLF4sePT5wxZiJHueCoZ0Ok6atcstoBvmL8XAUHZ+lowBgvXjwPB97e3socDXFWz85I01e5ZLUDfMX4uQo9xPI4pEiRAn8TJkzIZiiMYPW1MdL0VS5Z7QBfMX6uQg9fK+Qifpw4cWLu3LnTp08fEBBAXCBRokSbNm1iS8d5+GLaDWn6KpesdoCvGD9XoYevlT53165dzZo1w+I6e/bsCCeVRTrDF9NuSNNXuWS1A3zF+LkKPXytnHNpOOnp6QmXVBapx1kuOyNNX+WS1Q7wFePnKvTwteLkknAyderU6kENhSOXDZGmr3LJagf4ivFzFXr4WvFzNcvfn4kjRCqXrZCmr3LJagf4ivFzFXr4WvFzFQxyySVNX+WS1Q7wFePnKvTwteLnKhjkkkuavsolqx3gK8bPVejha8XPVTDIJZc0fZVLVjvAV4yfq9DD14qfq2CQSy5p+iqXrHaArxg/V6GHrxU/V8Egl1zS9FUuWe0AXzF+rkIPXyt+roJBLrmk6atcstoBvmL8XIUevlb83LhAaGgom2SOXHJJ01e5ZLUDfMX4uQweCgUX+j+7I8UjKifeW0eavsolqx3gK8bPZYhSYUVcA6dHkiRJLFqkXOeSNH2VS1Y7wFeMn8sQpcKKuAZOj+3bt1u0SLnOJWn6KpesdoCvGD+XIUqFFXENcnpYtEi5ziVp+iqXrHaArxg/lyFKhRVxDXp6WLFIuc4lafoql6x2gK8YP5chSoUVcQ396RGpRcp1LknTV7lktQN8xfi5DFEqrIhrMKcH3yLlOpek6atcstoBvmL8XIYoFVbENZxPD45FOhe2M9L0VS5Z7QBfMX4uQ5QKK+IahqeHmUUaFrYt0vRVLlntAF8xfi5DlApbJygoaMSIEb169VqyZMmrV6/YbHfy9OnTLl26FClS5Msvv2Tz3Ma1a9c6duzIpkYXKPbbb7+1b9+ezTDCrPCFCxfIIdi5cyc/feHChStWrNCXoZidHoYWaVbYnkjTV7lktQN8xfi5DFEqbJFt27alTp16yJAh33//PXyqXr16bAlNO3369MGDB9lUV4DJX6tWrZCQkJMnT7J5bqNSpUoHDhxgU6PFvHnzAgICChQoYOXQmBXevXt3qlSpRo4cOW3atPTp08+ePZuTHh4eXqhQIcNfQfeIDP2/l/Cw0GH7IE1f5ZLVDvAV4+cyRKmwRYoVK4awkWzfuXPH09PT2aoaNGhAJ61rgR1PnTqVTXUnuB5UqFCBTY0uCEUfPnx47tw5K4fGrDAc85tvviHbmzZt8vX1hQly0idOnNitW7c3ta3C7NRKh+2DNH2VS1Y7wFeMn8tgWBjBV+/evRETffHFF5cvXyaJz549GzVqFBJr1qy5du1aTuK9e/devnxJt+GPhw8fJh8JP//88zvvvFOmTJnWrVuj/f79+1+8eLFfv35oSjPZO8og5Bw8eDBiw6+++gqLaJL+66+/VqlSpXbt2osWLcLHsWPHZsyYsXTp0mgZ3hEWFjZ06NBy5crVr19/7969b/b/b2v6PTpjtrv79+/36dOnevXqcJPy5cv37NkTidjXjBkzSAHDzhuqxEkHzpbHgSmMFTQ+0njw9evXCBXXrVtnlq45fNbf3x8ptBErKH+MCeSS1Q7wFePnMhgWxvzv0aPHmTNnhg8fjgUySWzYsGHlypUPHTq0devWTJky4a9ZIgVmUcWBPhFcvXoVpgD3QUVYT7Zs2dq0aQOvITZquHeUyZcvH1aF2AWCICzekXjlypW0adOi5IkTJ1q1agXzglOULVt24MCBaBnmWLdu3c8++wyTH7Uw/1GMtqbfozOGuwPwdLhqcHAwjBhhMknMnj07vVdg2HkzlczSNSfL48MURmDo5eWly9dwwZgyZYpZOtnGdYXqYxHljzGBXLLaAb5i/FwGw8LwrNcOsDpOkCABPmKBnCRJEgSDpACMCRGiYSJtZM+ePQgSEUbR4EuPfn0NM+rQoQPNct47KTNu3DhSAMEa8VzEgClTpty9ezetC2rUqEGiuWPHjiH31q1bIQ66d+9OH6Ewe3TGcHehoaGQ68mTJyQdY4fzYgOmc+PGDZLo3HkzlczSCSL+uHHjRj8/P12+BhfGstosnWwXL1588+bN+txIUf4YE8glqx3gK8bPZTAsjLVq0aJFS5QoUbVqVUxymMuqVavy5MnDFDNMJMydOzdLliyc+cb445o1a2iW895JGdrajz/+iMCHbGN9jUCvUKFCK1euJCnUH5ctW+bt7V1aByI7UobZozNmu3v33Xe/++678PDwxYsXZ8iQ4cWLF0hEJ6nNOXfeTCWzdIKIPyIo9vT0JH0jIASeP3++WTrZRtzNrPEjRfljTCCXrHaArxg/l8G58KlTp5InTx4UFIRtRDSJEiXCJN+/f7+Pjw+dWuRGlWEigPXkzZuXhlSGMP5Izchw70wZvWERsDJNnTr133//ren8cdeuXenSpTN8u0jfmiFmu0OfsV2+fPlmzZqhqyQRe4FDaSadN1PJLJ0g4o+w71SpUmE1TT4iko0fP/7Zs2fN0slHHLJ9+/aRbYsof4wJ5JLVDvAV4+cyOBeGy2AWEVcaPnw4phBWkZjGBQsWxBIV0x7TrGnTpgsWLDBMfPbsWUBAwC+//HJKx/3799Fa37596QxE4ZEjR9K1MzUjw70zZahhXb58efr06cRZSpUqhVhS0/nj8+fPEVoOHDiQFJg5c+bYsWNJC9H2x4wZM06ZMuXIkSN690eoSKJXw84bqoQCZukEZ3+cPHkycV5nnAtDasSwiGrRcpMmTdBDfnpYWFiyZMkeP378XxMWUP4YE8glqx3gK8bPZTAs3KtXr/Tp0+fIkWPYsGGtWrVCIIbE8+fPV6pUydfX18/Pr23btuS9EOfE27dvZ3Zizpw5KIwN8pQZrFu3DrWwLobHlStXTn8P0XDv+jJYmTZs2BAbMKm6dev6+/tjLd+oUSNYMxJRhe7lwoULsAAshLNmzVq/fn1ETCSd2aMzhrsDs2bNwqK4du3acEwMh7xiPXXqVHo307DzziqRwmbpIDg4GO3Tj8iC2169epWm6GEKa47yaNDb2xuuhwvGrVu3+OkbN26sXLnyf/WtofwxJpBLVjvAV4yfy2BWGMtSZsVHQNTjvGI1TBTBbO+GvHDApupArv7Rh56LTpDoz5Djx4/D+xCWko+jRo1CCKY5nttkz5790aNHJN2s82YqmaXrgREXKFCATY0MjJr2lp9ep06dLVu26FOsoPwxJpBLVjvAV4yfyxClwrGPvk5w1t0IV9OmTYt1LtwKIWrOnDmXLVtGsrCBlXLE4q5k4MCBJAZ3B1u3bm3RogWbagHljzGBXLLaAb5i/FyGKBVWXL9+fdq0aQMGDBg/fjx9PkM4evSo/qPLMYxJXUJQUJDhO1iRovwxJpBLVjvAV4yfyxClwgqFHuWPMYFcstoBvmL8XIYoFVYo9Ch/jAnkktUO8BXj5zJEqbBCoUf5Y0wgl6x2gK8YP5chSoUVFrl///7NmzfZVHNGjhyJKsuXLw8NDWXzdOzduzeqX3FxK8ofYwK5ZLUDfMX4uQxRKmydt/j7uM6EOH4L8tKlS+57xMEwZMiQggULsqnmBAYGnjlzpnPnzv369SMp9+7dm63j4sWLmuNXyDp16qSv+HZR/hgTyCWrHeArxs9liFJhi1j5fdxIcckP6G7evLlkyZKenp4JEyZMmTJlmjRpvvrqK/1r2KBo0aLxjUC6vtj/2LsO8CyKrU0vgUAoIbRQQgIkoQRIaCHUBIQECL0ahEBCQJSrXhWxXr1gBWnqRSxgQyliw0ZRFEVQQRREqlQFVLpU/f7XnT/DZHa/ky+UZCec9zlPntk5M7uzb3bfPWd3v1nfgfVXrVq1c+fOTzzxxKOPPjp58mSo3sqVK2WD9evXj80KjG3w4MFpaWmjR4+ePXu2x5ri6Oabb46Li4uKikJh+fLln3322U033dS7d+/PMpFrcu8NrI+5AbNodQNoxmivhhw19hG+zI+bLS5/At1p06YFBAQ88sgjBw4cEPPWrFu3rrUFNY1FoAfR/D4rUOMYAEKS3nvvPbm4bdu2nTt3Kv5/MGXKlHLlykEfk5KScG3o379/eHh4t27dZIMFCxZA+BYoiIiIwBZFWZ2n8rHHHhPT1q5evbpTp05hYWHBwcGdLOAfJ34vlIdgfcwNmEWrG0AzRns1ODY+4vMkr46V2c6P67EmoP3yyy9TU1Ohg1999dXWrVtTUlKGDBkCbfLYJtDFIlJL0fG7777D2LLN2RFeISgT20WXunXrivo///wTwifTWI+lj3J2WwnUaPq4ceNGDPjgwYP+/v4LFy4UlcOHD+/evbva7Oeffy5Tpswbb7yhVkINRVQoABHEnip+T3Jy8iuvvOKxfnaparfUR4F777337rvvFmX84+hfDeUCWB9zA2bR6gbQjNFeDY6NfZ/k1bFS4oiX+XE91gQQyBwhB9OnT69cuXLHjh0/+ugjZKNVqlSB5moT6CIIRca6bNkyuBo1aiSnMiMAvb7rrrtEGWk+BEi65s6dq/5a2Ud9hEAjdjt58iSuB4jjhEBD+G688UbZBtLWvHlzBIwXu3k8kP5ixYqpj2ugj5GRkfIXO1jnuHHjsO8oFC9eXP2RtaaPyL7FJ7HOnTuHfxzn15cDY8ZqFq1uAM0Y7dXg2NjHSV4dK+VK6PlxoY9y5kEEXDIf9/PzE8m4ll9//PHHtWvXvummm9LT02UlgQoVKnz44YeiLOYKki6IuDqNto/6iF2DLELFjh07Bo1GnIhKqPlTTz0l2yCCbtGihfYMesSIEdodWOhj+/btRTaN4BpXkVmzZg0ePHjRokXyaiSg6SOuGQusXzSeOHEC/5eL7fIIrI+5AbNodQNoxmivBsfGPk7y6lgpkO38uOoEYkFBQUhdRRm6Jj4EaL//OGDAgNKlS8vpu2mUL19eTMADlcf6V61aJV1z5swJDQ2Viz7qo8faKTnbNoAxgz0k70qTfyabUBeR5hcuXFj7tCECWDGT+enTp7GGM2fOoEG1atUQtk+ePFltqeojZLdkyZIiDj106BCoUFvmCVgfcwNm0eoG0IzRXg32xr5P8upY6fFtftyc6uP333+PpBhpuBoJEkCAJmZ7FF80lYNEISYmRg3KfNdHFQiKY2NjW7VqpTsUILNGgGn/MvX9998v9uLgwYOQPI/Fc6VKlcqVK3f06FG1JfQRATiuQ4888ghC7KioKFG/c+dOrFltmSdgfcwNmEWrG0AzRns12Bv7PsmrY6WP8+Nmq4/qBLoInSC4CxcuPHDgAHRENiawdOlSrAo5frdu3caNGycqsSPJycmI1OS8hx5LH1NSUl7ICtQQ+rhx48Y2bdpUrFiReC6P7B4NkBFrrxMBnTp1euuttzCGTz/9FPvlsd4nDwkJwSXBY73YBGJ37dp1yy231KtXr0yZMgicIY64PMybN0+sARQRw8s1sD7mBsyi1Q2gGaO9Ghwb+z7Jq73Sx/lx1Qloo6Oj5auOTZo0ERPhqBPoIuBKTU0VDebPn9+hQwe76Njx+OOP+/n5YQ2HDx/et28fFK1IkSLoK961loDQQKDrZQVqHAVo9uzZ2F9cMxA5Qsh0twWEjVC0ggULpqen21/BQViNUR07duyhhx6C1mOFP//8MxhITEzEZWnDhg1Y89q1a3fv3j1lyhToIK49WAmks0WLFojQ0R1XC1w5+vXrp60598H6mBswi1Y3gGaM9mrw1jhHk7w6Vl5ViLlsVTjOa6uOavr06Y4vnM+cORN6pFWiBvVapcf6ISBUT72bacf69etbt269YsUK3WHhk08+wYVErUEGPXLkyHPnzkH6S5cuDR1XvcArr7yCy4aY/BxbDwwMRAgsLlp5C9bH3IBZtLoBNGO0V0OOGrsHF+ezzQTxLMjlUGNhRN/2kNOTtY17wPqYGzCLVjeAZoz2ashRYwZDBetjbsAsWt0AmjHaqyFHjRkMFayPuQGzaHUDaMZor4YcNWYwVLA+5gbMotUNoBmjvRpy1JjBUMH6mBswi1Y3gGaM9mrIUWMGQwXrY27ALFrdAJox2qshR40ZDBWsj7kBs2h1A2jGaK+GAgzGZUA7ltRFl8OYsZpFqxtAM0Z7GSpormgvQ4NZdBkzVrNodQNoxmgvQwXNFe1laDCLLmPGahatbgDNGO1lqKC5or0MDWbRZcxYzaLVDaAZo70MFTRXtJehwSy6jBmrWbS6ATRjtJehguaK9jI0mEWXMWM1i1Y3gGaM9jJU0FzRXoYGs+gyZqxm0eoG0IzRXoYKmivay9BgFl3GjNUsWt0AmjHay1BBc0V7GRrMosuYsZpFqxtAM0Z7GSpormgvQ4NZdBkzVrNodQNoxmgvQwXNFe1laDCLLmPGahatbgDNGO1lqKC5or0MDWbRZcxYzaLVDaAZo70MFTRXtJehwSy6jBmrWbS6ATRjtJehguaK9jI0mEWXMWM1i1Y3gGaM9jJU0FzRXoYGs+gyZqxm0ZqHKMDII+j/CYYTzCLKmLGaRWsegonKEzDtPsIsoowZq1m05iGYqDwB0+4jzCLKmLGaRWsegonKEzDtPsIsoowZq1m05iGYqDwB0+4jzCLKmLGaRWsegonKEzDtPsIsoowZq1m05iEujagXX3zxyJEjei3DZ1wa7dcgzCLKmLGaRWseIqdEnThxIjk5Gb1iY2MvXLigu33AK6+8MnHiRLXm+PHj6uJVwrfffjtu3LgdO3boDgs//fTTzQqeeOKJtm3bbtiw4eDBg7179/7kk0+09s8+++y2bdtQGDx4cP/+/TVvtsgp7dcszCLKmLGaRWsegiDqgQceaGdDXFxcgUysXr1a7+MDevbsKTf666+/3nDDDQ0bNvzjjz9kg8WLFz/rBYcOHZLNcorU1FRs94cffpA1J0+elOU1a9Y0ttCoUSM0w6jq1KnTqVOnoKCgsLCwrVu3ypbAjz/+iDbPPPMMyomJiV26dFG9voCgnaHCLKKMGatZtOYhCKJuu+22SCekpaW1bt36008/1Tv4BlUfMzIy/Pz8SpYsOXLkSNkAIiUlWMOXX34pm+UI+/btK1GiRKFCherWrQvhq1WrVuXKlSGF8i7BypUrmzVrBpV8/PHH0Wz9+vUoYIt9+/Z95513qlevPmfOHLm2W265BW0+++yz77//HmEmQunvFZw9e1a29IYC3mlnqDCLKGPGahateYgrRRQiwR49erz33nti8cUXXxw9evThw4eztvoHqj5CSpo3b474cdWqVbIB9LFevXqq4gD33HOPN330ZdPDhw9H9/bt23fr1i05Oblfv34hISGFCxdGX9EAeXR0dHSxYsUKFiyINHzv3r27du2CkgYEBKAjuhw7dky03LNnj7+/v5RsO0TeTaPAFaI938MsovSxvvDCC/e7EqGhoXoVwwnejr+JEycmkjhw4IBoOX36dMRQyHwrVaqE6OzcuXOoHDRoENZM6OOAAQOefvppJKqQoVOnTqkNRJ6r1gBoXMCmjz5ueunSpagZOHDgxZ4eT3h4OPrKReyOuK9qR9myZZcsWSJbdu3aFfq4evXq9Rbi4uIQTYuygI/xo/6fYDjBzScyrsT6v1VbZpiOAl70sXfv3hUUoFnRokXVmp07d4qW8+bNg3fSpElCwubOnYvKmJgYiEiWNWZC6CNyaqE+OAEQG27ZskU28F0ffdn0Dz/8UK5cueDgYFUxEa6i/cyZM8XiggULkOYj40YSDRmtWLHixx9/DAHt1KnT+++/L265duzY8e+//8ZKatSo8dRTT8lVJfL9R0Ym+J+a3+DLiYqACM2ga7ojE02aNClfvjziOIgdpOrChQtIS1u2bKm3syD08cyZMytXrrz77rshQ1jU7j/6qI8eHzaNvBvRJTJ0pZMHkWOpUqXkQ6Hffvvtlltuwd/z58/ffvvt1apVQ6FFixaDBw9GAWHpq6++umbNGtH46NGjy5cvn5GJyMhI7IJcXLZs2cXNeIcvtDOMg/5PdW1+PXToUL2K4QRfTtRt27ahWXp6uu7IBOSjf//+v/zyi3jj54033kB7CI3ezoJ6/1Fg06ZN+/fvl4s50kdfNq0+pwamTZuGNhMmTFArIXMFvAMpttp47NixpTJR2IJcJFhSUYDza9/g5hPZ4Py6gA+nPcPjG1FIYNHs+eef1x1OQKQWGBiI9Nnbm4Z2fdSQI31Uke2mPdbTG8hZWFiYdtPznXfeeclCmzZtkEGjUKdOndatW4vKiRMnipubdnB+fVVhFlHGjNUsWvMQNFHHjh3DdbJIkSLBwcFaFGbHgQMH7rrrLj8/v0KFChFi6os+YiUtsqJ27dqEPvqyaWTTyOKxkqpVq3p7xPzFF1/4+/uPHz8eZWx0yJAhoj4kJMRbYMj6eFVhFlHGjNUsWvMQBFGvvPJK6dKl0aBBgwbq8xNHQCMKFiyIxgi+3n77bd2twBd9LF68eL2sCAoK8qaPvmz6tddeE2/qxMXFqbm8xNatWzMyMhBaIn4UVwIEjw0bNpw1axaUFx1R8Fg/9RmQFVDbypUrqzUPPPCAvnYbaAYYEmYRZcxYzaI1D0EQBZno1avXc889d/78ed1nw7Rp0yANixYt8paHSkyYMCE2NlavVTDTgla5du1aJLl79+7V6j2+bXr37t0Quzlz5vz999+6z8LQoUMrVqw4efJk+aPJRx99FNk6YtJKlSp1795dvP+Iv12yw7///e8sq3YCQTtDhVlEGTNWs2jNQzBRAhA+7Y7kVQXT7iPMIsqYsZpFax6CicoTMO0+wiyijBmrWbTmIZioPAHT7iPMIsqYsZpFax6CicoTMO0+wiyijBmrWbTmIZioPAHT7iPMIsqYsZpFax6CicoTMO0+wiyijBmrWbTmIQow8gj6f4LhBLOIMmasZtHqBtCM0V6GCpor2svQYBZdxozVLFrdAJox2stQQXNFexkazKLLmLGaRasbQDNGexkqaK5oL0ODWXQZM1azaHUDaMZoL0MFzRXtZWgwiy5jxmoWrW4AzRjtZaiguaK9DA1m0WXMWM2i1Q2gGaO9DBU0V7SXocEsuowZq1m0ugE0Y7SXoYLmivYyNJhFlzFjNYtWN4BmjPYyVNBc0V6GBrPoMmasZtHqBtCM0V6GCpor2svQYBZdxozVLFrdAJox2stQQXNFexkazKLLmLGaRasbQDNGexkqaK5oL0ODWXQZM1azaHUDaMZoL0MFzRXtZWgwiy5jxmoWrW4AzRjtZaiguaK9DA1m0WXMWM2i1Q2gGaO9DBU0V7SXocEsuowZq1m0ugE0Y7SXoYLmivYyNJhFlzFjNYtWN4BmjPYyVNBc0V6GBrPoMmasZtHqBtCM0V6GCpor2svQYBZdxozVG63p6elr1qzRa30AOn777bd6rcezf//+MWPGzJs3b9GiRbovK06fPi0K27dvf/7554mP2ecJvDEmQHsZKmiuaC9Dg1l0GTNWb7Q2btz4nXfe0Wt9ADp+/PHHeq3HEx8fv27dujNnzkRFRR04cEB3Z2LKlCnVq1c/e/bsnj17atSogV5///233ihP4Y0xAdrLUEFzRXsZGsyiy5ixeqP1yurjihUrOnbsKMpTp069+eabs/ov4osvvsCQZsyY0bBhw4iIiKNHj+ot8hreGBOgvQwVNFe0l6HBLLqMGas3WlV9vHDhwrRp0xITE/v27bt48WLZBlHepEmTEOIlJSXJxlIfN23alJGRcejQIZRTU1Offvpp0QCJdqVKlbxFhagPCwsrWLCgv7//li1bdLcL4I0xAdrLUEFzRXsZGsyiy5ixeqNV1ceUlJSuXbtu3rx59erV4eHh0EpRD7lMSEhYv3798uXLkQvjr+gIfUR2XLt2bXmrMTQ0VL0pGRwcDPWUixrS0tIwqltvvVV3uAPeGBOgvQwVNFe0l6HBLLqMGas3WqU+IogrUaLE77//Luo//fRTRHZ//fUX5FKt37t3L8JM0fH1119Hdrxw4cLMlXn8/Px++eUXudi8eXN7Di6ATLxIkSIYlbgLqbtdAG+MCdBehgqaK9rL0GAWXcaM1RutUh/ffPNNxIyy/uTJk+jy888/a/US6Ahpq1at2r59+2QlJE8qKRAXF+d4cxMaGhgYiMBz1qxZ2MqUKVP0Fi6AN8YEaC9DBc0V7WVoMIsuY8bqjVapj2vWrClXrhwCRlGPcLJQoUJ//vnnV199FRAQcP78eVEv7yei47x586ZOnRobGyu9lStX3rZtmygDERERji8PJSYmYuXI4lFOTk6Wj3RcBW+MCdBehgqaK9rL0GAWXcaM1RutUh+hcSg/8MADKJ85c6ZXr16DBw+W9ePHj0dajfohQ4bMnTtXdETuDLlMSEiQ9xC7dOkiH+ycPn26VKlSJ06cEIsSixYtwmDGjh0rFo8cOfLdd99lbeIKeGNMgPYyVNBc0V6GBrPoMmas3mjt2rWreN4C7Nq1CwIXEhJSo0aNESNGHDt2TNTv2LEjPj4e0WXFihXT0tKgkqLj559/7rGeUyNOFOWZM2dmZGSIXh988AGkU5RVvPLKK0jMXfhCjwZvjAnQ3nyJgwcP9uvXT7yoYAfhpbmivQwNZtFlzFh9pxUBo+NLOaiX2bc3nDp1KjQ09Pjx4yj37Nlz2bJlegsrQ0farte6DzRjtDdfAvKHvY6MjLSLIMQR9fD2799fc3my44r2MjSYRZcxY801WhcsWIBkHDFpSkqK7jMKNGO0N18CsihEUJNIKY4NGjSwS6cnO65oL0ODWXQZM9bcpHXjxo3bt283IkgkQDNGe/Mr7BKZrTh6suOK9jI0mEWXMWM1i1Y3gGaM9uZjqBK5efPmbMXRkx1XtJehwSy6jBmrWbS6ATRjtDd/Q0pk8eLFsxVHT3Zc0V6GBrPoMmasBRiMqwBI5I8//qgfbVlRgDylaS9Dg1l0GTNWs2h1A2jGaG/+hrznKOJHxyfaKmiuaC9Dg1l0GTNWs2h1A2jGaG8+hvpABpGj4xNtDTRXtJehwSy6jBmrWbS6ATRjtDe/wv602v5E2w6aK9rL0GAWXcaM1Sxa3QCaMdqbL2EXR4FsJZLmivYyNJhFlzFjNYtWN4BmjPbmS4jfzzg+rZYSyb+fudowiy5jxmoWrW4AzRjtzZeACEL+7OIoQHhprmgvQ4NZdBkzVrNodQNoxmgvQwXNFe1laDCLLmPGahatbgDNGO1lqKC5or0MDWbRZcxYzaLVDaAZo70MFTRXtJehwSy6jBmrWbS6ATRjtJehguaK9jI0mEWXMWM1i1Y3gGaM9jJU0FzRXoYGs+gyZqxm0eoG0IzRXhNx6tQpveoKgeaK9jI0mEWXMWPVaC3AYNggv3h+ZVGAPKVpL0ODWXQZM1aNVrNYZuQCcEiUKFHiakgkfbDRXoYGs+gyZqysjwwaOCRWrFhxNSSSPthoL0ODWXQZM1bWRwYNcUhcDYmkDzbay9BgFl3GjJX1kUFDHhJXXCLpg432MjSYRZcxY2V9ZNBQD4krK5H0wUZ7GRrMosuYsbI+Mmhoh8QVlEj6YKO9DA1m0WXMWFkfGTTsh8SVkkj7mlXQXoYGs+gyZqysj7mAP/7449dff9Vrs2LRokXnz5+XixMnTjx+/Lji/wczZ848e/YsCt9+++3OnTt/+OEH1GDx3XffPXPmjNYY+PPPP2+//Xa9NodwPCSuiEQ6rlmC9jI0mEWXMWPNHX3cvn37Qw89dNttt7366qt//fWX7s5dHDlyZPPmzbt37/77779139XBfffd17hxY71WwYwZM1q1anXhwoXTp0+fsFChQoUdO3agAI2TzbAS1KDQrl275cuXf/TRR927dz9w4EBISIjjr1ywp6VKldJrcwhvh8TlS6S3NQvQXoYGs+gyZqy5oI84kXC2QyP+97//NW3atFevXnoLH7BlyxYETXptDvHxxx9DhgoVKlS0aNGyZcsGBgbec889WuTVrFmzwk5AvdrMd2D9VatW7dy58xNPPPHoo49Onjz5zjvvXLlypWyAa0bFihV/+uknlDMyMmpawCCrV6+OAjp6rEhw165d4eHhmzZtWrJkSZMmTaCMuN4kJiaOGDHi3//+d0RExLlz59DyjTfeGJuJUaNGYU/lIvDSSy/J7fqIAtnhk08+0fv4hgLkwUZ7GRrMosuYsWq0Xg2Wo6OjIQGifPjwYZz5CN+yNskeffr0efbZZ/XanACRTkBAwCOPPIKAC3qEmnXr1rW2oAZfiNEgmt9nBWocA0BEoO+9955c3LZtG9Jexf8PpkyZUq5cOchcUlISrg39+/eHzHXr1k14Dx48WKtWrQ0bNkC7v/nmG9kLV5RffvlFLn755ZcYAP47MTExkDnoY/PmzVevXh0fH5+cnAyhf/LJJ0VLeAcNGvSChVmzZhUvXlyUgeHDhw8bNkyu84rgcg4Yui/tZWgwiy5jxuqLPiJNQ4SCUxHxyJ49e0Tl2bNnJ02ahEqc9u+88w5R+fvvvyNzlGXoI+RALEpMmDABEpCamgod/Oqrr7Zu3ZqSkjJkyBBoE7zz58+HiLRp0wYNMAAsTp06VXT87rvvMLZsc/bPPvsMAaPYLrrUrVtX1CMug+4goJMtsfj000/LRQHUaPq4ceNGDBjq5u/vv3DhQlEJAUJYpzb7+eefy5Qpg5hOrYyLi5s9e7ZcRE6N9VSqVAlKmpoJ6NrgwYNFGQNGszfffBP/HbQEybGxsdC+uXPnooDwrW3btugrbhdAHyU5Wn6NCwzrY36FWXQZM1Zf9LFr16633HILEsAHH3wQCbKo7Nu3b0JCwvr165cvX16jRg389VYpgdO1swW1UqBOnTpRUVHvvvvu9OnTK1eu3LFjx48++gjZaJUqVSAH+/btg+bee++9WDMUDUEoMtZly5bB1ahRo8WLF+urswF6fdddd4ky0nzEXNIFlUEaKxd91EdoUHBw8MmTJ3E9CAsLEwIN4bvxxhtlG4SliPK0T1NB+osVK6Y+roE+grTx48fv3r37JQXPPfccBBcF7D6ajRs3Dv8diCa2iIAUUTky68jIyAYNGoSGhoaEhECyPayP1yrMosuYsfqij5Ckvy1AmIoUKYJFJMglSpRAMCga7N27FxGiY6VcCZJBxICIQNUHDhLQxxdffFGUEXDJfNzPz08k41p+jWy0du3aN910U3p6uqwkgHT1ww8/FGWEpf/973+lCyKOrchFH/URuwZZhIIfO3YMGo04EZVQ86eeekq2QQTdokUL7ckJRE29AwsvpB+0r1y5EsyoST0Cw4CAABSOHj2KKwEoQtiLK8eSJUvACS4Va9euxbXkxx9/RCyJmt9++81j6eP999+/18KmTZuwa6IMYLSsj/kVZtFlzFh90ceXX365WbNmONW7dOkCfURUglwvPDxca+ZYKfD8889DziBquiMTOPmlNygoCKmrKEPX1q1b57HpIzBgwIDSpUsjglMrvaF8+fKff/65x7pjiPWvWrVKuubMmYP4Sy76qI8ea6cefvhhuYgxgz2RC0uor+x4rDS/cOHCYo8EduzYAYmH6kEfIYXNFGCLYBsFKDsG2aNHD9RADREII9ZGGQzggtS7d+9ChQr17Nnziy++8Fj6iFS9ngUoeMGCBUUZgJiyPuZXmEWXMWPNVh9xQkKGtm/f7rGCJuSG0MevvvoKoY08+cWdL8dK4O23346IiFCfNtiRU32ElCAphqyokSCB9u3bI3pCASoJrZSDRCEmJubmm2+WLX3XRxUI/WJjY1u1aqU7FCCzRoA5evRo3eHx4MIjnmgjnBnbBqQAAF03SURBVET0J7J1MIbdFw0grND0xtb7PYhVu3XrNnnyZPxroIb/+c9/MLw1a9aI9yWnTJkib3dq+fWKFSvU8PaKwH7A+A66L+1laDCLLmPGmq0+fv311xAUnGkoP/jggwh/9u/fD1nBuTp+/Hgo5pkzZ5Cxzp0717ESiWHVqlVff/31HxX88ccfWNsdd9yBs1psJVt9FEmxyM0hIhDchQsXHjhwALGSbExg6dKlWBVyfCjLuHHjRCV2JDk5uVq1agcPHpQtsQspKSnyma8Aagh93LhxY5s2bSpWrEg8l0cMiAZIpR1f5Jb6CCQkJDz33HOerPooIPQR9AYHBzdo0ADiCM2NjIzELmBf1JYCxPuPknz1v6CWfYT9gPEddF/ay9BgFl3GjDVbfQRuu+02BD5I1hCqjBgxArGMx0oMcbaXK1cOp31aWpo47e2Vhw4dEi/0qRDnPwrI3MUm2rVrJ/Jfj/U+kHzVsUmTJuKxw7vvvovVIq/cs2cPIqzU1FTRYP78+R06dHAUHQ2PP/64n58f1nD48OF9+/ZB0ZC9ou+uXbvUZtAgCLTMSQVQ46iPs2fPxv7imoHIccuWLbrbAiQMiTDyXOTR4tcvdqj6uGHDhvXr16Owe/duR32cNWtWUlISokUUEFMjor/33nunTZumvh4kQOijJF/9L6hlH+F4wPgIui/tZWgwiy5jxuqLPgLI+Bx/bYKY0f5ujWPlVcUuG0TAq0Ed1fTp0x1fOJ85c+batWu1StSIX/JpQEgL1VPvZtoBsWvdujVyW92hQNVHT+Y9jcDAwI4dO15sZOnjsWPHmjZtKl4mj4mJ6dmzJ8aGWBIXj11Zhd5D6uOVgrcDxhfQfWkvQ4NZdBkzVh/10eW4wwbiWZALAUGE8Kk1iLu3bdumvgDgsX6mCYkXv5PxKF/O+vPPP8XDaw24UKmyezVwOQcM3Zf2MjSYRZcxY80f+sjIK1zOAUP3pb0MDWbRZcxYWR8Zl4PLOWDovrSXocEsuowZK+sj43JwOQcM3Zf2MjSYRZcxY2V9ZFwOLueAofvSXoYGs+gyZqz5Wx/PnDmjzTJ74cKFm2666dChQ7Lm5ZdfPnnypPwRnoT6bOTzzz9X5+kBsPj++++rNSquyMS0RuByDhi6L+1laDCLLmPG6qM+7t+/f/To0U87QfxWOj09PaevFvuOzZs3Dxw4UK+1QM+8u3Dhwjp16shF6GCHDh1mzpwp17Z169bAwMBTp05hxxsrKF68uPq6zGOPPSZ/Y4PGJ06cgPxNmDABhRxNTDtv3rxFixbptSbD2wHjC+i+tJehwSy6jBmrj/oYHx+PGCo9E9WqVWvTpo0o33PPPR7r1Tw5odkVx5dffokt6rU+zLybmpo6ZswYUX7iiSeGDh26du3avn37yp/c/Otf/4K2nj9/XtvxevXqCX3cuXPnCy+8MGDAgISEBBQgiNHR0TVr1ixrAYWWLVuKLr5MTIt4Nioq6sCBA8qmzIa3A8YX0H1pL0ODWXQZM1Zf9BEypL2o3KlTpxkzZqg1eaKP3mbe3bRp0/z58x9//PFKlSrFxsYi9Fu5cuWePXv8/PzWrVsn3zQUszdi2EIfjygICwsT+vjNN99A3bAS7CAKcnaiiRMnQpdFWWCsbxPTTp06Vf25t+lwPGB8BN2X9jI0mEWXMWP1RR8RhT2ddcoGR31EMotUt3v37kg85bQ6KENo7rzzzkmTJnmsuQ7vv//+du3a9e7dW8w34/Ey/+7x48fRC7qckZGxZMkSR330NvOumKeyVatWxYoVw5AwBijj119/fccdd6hCj/3C/kIfsZI6FipWrIioUJTFrIsCMr9eunSpmLMWYWCTJk3U+WvH+jbx4v79+6Hajj9GMhGOB4yPoPvSXoYGs+gyZqy+6GNoaKj2UzxHfQwJCXnyyScRbDZv3lw+nYDQjBw58tZbbxXKlZycDKWARixfvhwygUDP42X+3c6dO/fp02fLli0ffvhheHi4oz5KHHGaeffhhx/GmkW5S5cuyK8RMCLtFTEmxlm9evWYmBg17IXAQebkooTQx++//37VqlXqFLYQx9mzZwsl9VEfgeDgYLHj+QCOB4yPoPvSXoYGs+gyZqy+6COCL212Mkd9hLqJMoSjbdu2ogx9RAAoytAXRGcQKZHDjh8/XtwctM+/u3HjxpIlS8pHz2+99Rahj95m3kX2LT9j0K1bNzFXY1JSErbrsX7SB4mEbkIfkT63sFCzZs2goCBRBkQ2/euvv15//fVlypRB0o1tqVPYojHk++jRo56cTEyL64dZP38k4HjA+Ai6L+1laDCLLmPG6os+QrPkfTcBR32Ugdibb74pv/YHfXz77bdFecGCBf7+/rEKEDZ6nObfXbx4cUREhOjl8X7/0eN95l1EowgV5a+S27dvL75ghTGon4gR+rh9+/Zt27ZB1gtYQMttFpB3Y1+wHmx90KBBf/3116JFi9QpbOFq2LChmJl8rM8T08bFxV29e7W5DMcDxkfQfWkvQ4NZdBkzVl/0Eac3xEKtyZE+SvH67LPPsCrtLRzH+XchiOXKlZOz2L7//vuO+kjMvDtx4sTExES5WL9+/blz5yr+/4fQR4+VEYeEhCAfj4+PDw0N3bp1q2hw7NgxrF99v2f+/PnyzilGJV8D8n1iWoz56r0LlctwPGB8BN2X9jI0mEWXMWP1RR8hIto3sC5NH8+dOxcZGQnlEk8nnnnmGSSejvPvnj17tm7dug899JDHSm+xNrs+EjPvQlirVKki3zRE3o1Az3EWMqGPBw4caNmy5V133SXuPy5durR69epyPkpP1vcfX3vttfDwcDGTo6qPKjR9VHH69Gm4Tpw4oTvMhOMB4yPovrSXocEsuowZqy/6OHPmTHkPUUDMDa7WIPKSXytEvilzWHXiW4/1OiEkCeqDYK13796HDx/2eJl/d+PGjU2bNoUCQowQl8nXDCWImXdfffVVdIQcI3O/++6709PTy5QpA2HS1uCx9HHOnDloDPlDYCufz2AXkCwjbhVS/vDDD6sv5WC14l5nUFBQTvXxgw8+SEhI0GuNheMB4yPovrSXocEsuowZqy/6eOrUKaSc2g/1LgeI77SZDb3Nv+ttwm0aSHWnTZvmscQIwt2iRQv5iWoNIn6Uyq4+v96zZ494UlTGghYvDxo0CKoqfnuj1gsQ+tizZ89ly5bptcbC8YDxEXRf2svQYBZdxozVF330WI81xGPffIaff/5Z1f3ffvvN/uMWBLni9qiKM2fOoNJbmuxtYloIcUpKil5rMrwdML6A7kt7GRrMosuYsfqojx4r4dWrGDkEJNXx89/mgjhgsgXdl/YyNJhFlzFj9V0fGQw7LueAofvSXoYGs+gyZqysj4zLweUcMHRf2svQYBZdxoyV9ZFxObicA4buS3sZGsyiy5ixsj4yLgeXc8DQfWkvQ4NZdBkzVtZHxuXgcg4Yui/tZWgwiy5jxmrXRwYjR1CPnxyB7kt7GRrMosuYsZpFqxtAM0Z7GSpormgvQ4NZdBkzVrNodQNoxmgvQwXNFe1laDCLLmPGahatbgDNGO1lqKC5or0MDWbRZcxYzaLVDaAZo70MFTRXtJehwSy6jBmrWbS6ATRjtJehguaK9jI0mEWXMWM1i1Y3gGaM9jJU0FzRXoYGs+gyZqxm0eoG0IzRXoYKmivay9BgFl3GjNUsWt0AmjHay1BBc0V7GRrMosuYsZpFqxtAM0Z7GSpormgvQ4NZdBkzVrNodQNoxmgvQwXNFe1laDCLLmPGahatbgDNGO1lqKC5or0MDWbRZcxYzaLVDaAZo70MFTRXtJehwSy6jBmrWbS6ATRjtNcb0tPTL+2L2Oj47bffapX79+8fM2YMCvPmzZMfuXWE/Kbj9u3bn3/++XPnzmX1X13QXNFehgaz6DJmrGbR6gbQjNFeb1C/Hp4joKP8vLhEfHz8unXrPNZHxKKiouxfHBOYMmVK9erVz549u2fPnho1aqCX4yckrx5ormgvQ4NZdBkzVrNodQNoxmivN1xBfVyxYkXHjh3l4tSpU9Uvd6v44osvMNoZM2Y0bNgwIiLi6NGjeourDJor2svQYBZdxozVLFrdAJox2usNqj5euHBh2rRpiYmJffv2Xbx4sahElDdp0iSEeElJSaqSSn3ctGlTRkbGoUOHUlNTn376adkAuXalSpUcA0NUhoWFFSxY0N/ff8uWLbr76oPmivYyNJhFlzFjNYtWN4BmjPZ6g6qPKSkpXbt23bx58+rVq8PDw6GVqIRWJiQkrF+/fvny5ciF8Vd2hD4iQa5du7a41RgaGqrdkQwODoZ6qjUSaWlpGPCtt96qO3IFNFe0l6HBLLqMGatZtLoBNGO01xukPiKOK1GixO+//y7qP/30UwR3P/zwg1q5d+9exJiy4+uvv44EeeHChaLGz8/vl19+EWWB5s2b2+9ReqxMvEiRIhiwuAupu68+aK5oL0ODWXQZM1azaHUDaMZorzdIfXzzzTcRM8r6kydPYoWzZ89WK1WgI9StWrVq+/btEzWQPKmkAnFxcfabm9DQwMBARJ2zZs3CJqZMmaI1yAXQXNFehgaz6DJmrGbR6gbQjNFeb5D6uGbNmnLlyv3111+iHuFkoUKFVq1aFRAQcP78eVGp3kxEx3nz5k2dOjU2NlY0qFy58rZt22QDICIiwv7yUGJiItaMFB7l5ORk9ZFOroHmivYyNJhFlzFjNYtWN4BmjPZ6g9RHaBzKDzzwgMd6O6dXr16DBw8WlePHj0dajcohQ4bMnTtXdkTuDMVMSEgQtxG7dOkin+p4rDccS5UqdeLECVkDLFq0COMcO3asWDxy5Mh3332nNsgd0FzRXoYGs+gyZqxm0eoG0IzZvQcPHuzXr9+hQ4e0egHh7dSpk3zksmvXLmhcSEhIjRo1RowYcezYMVTu2LEjPj4eoWXFihXT0tKgkqJx165dP//8c4/1nBpxIsozZ87MyMjIXL3ngw8+gHTKRYFXXnkFWXnuv9Cjwc6VCtrL0GAWXcaM1Sxa3QCaMbsX8ofKyMhIu0RCHFEPb//+/TUXYkb7SzmolKm3N5w6dSo0NPT48eNisWfPnsuWLcva5J8M/c8//9Qqcx92rlTQXoYGs+gyZqxm0eoG0IzZvZBFIYKaREpxbNCggV06LwcLFixAMo4CYtKUlBTd7RrYuVJBexkazKLLmLGaRasbQDPm6LVL5NUTR4GNGzd6rF9VuyFO9AZHriRoL0ODWXQZM1azaHUDaMa8eVWJ3Lx581UVR1PgjSsB2svQYBZdxozVLFrdAJoxwislsnjx4iyOHpIrT3Zehgaz6DJmrGbR6gbQjNFeRI5CHBmMKw79aHMxjBmrWbS6ATRjhFfecxQS6fhE+5oCwZUnOy9Dg1l0GTNWs2h1A2jGvHnVBzI//vij4xPtaw3euBKgvQwNZtFlzFjNotUNoBlz9NqfVtufaF+DcORKgvYyNJhFlzFjNYtWN4BmzO61i6MAS6SdKxW0l6HBLLqMGatZtLoBNGN2r/j9jOPTaimR9t/PXAuwc6WC9jI0mEWXMWM1i1Y3gGbM7oUIQv7s4ihAe/M37FypoL0MDWbRZcxYzaLVDaAZo70MFTRXtJehwSy6jBmrWbS6ATRjtJehguaK9jI0mEWXMWM1i1Y3gGaM9jJU0FzRXoYGs+gyZqxm0eoG0IzRXoYKmivay9BgFl3GjNUsWt0AmjHay1BBc0V7GRrMosuYsZpFqxtAM0Z7GSpormjvtYBTp07pVd5hFl3GjNUsWt0AmjHaS6AAg2GD+Pq5LyhwqQdensCYsZpFqxtAM0Z7CVxyR0Z+RQFrKhMfJdKs48eYsZpFqxtAM0Z7CVxyR0Z+BQ6JFStW+CiRZh0/xozVLFrdAJox2kvgkjsy8ivEIeGjRJp1/BgzVrNodQNoxmgvgUvuyMivkIeELxJp1vFjzFjNotUNoBmjvQQuuSMjv0I9JLKVSLOOH2PGahatbgDNGO0lcMkdGfkV2iFBS6RZx48xYzWLVjeAZoz2Erjkjoz8CvshQUikvbGbYcxYzaLVDaAZo70ELrkjg8Aff/zx66+/6rVZsWjRovPnz8vFiRMnHj9+XPH/g5kzZ549exaFb7/9dufOnT/88ANqsPjuu++eOXNGawz8+eeft99+u16bQzgeEt4k0rGxa2HMWM2i1Q2gGaO9BC65I42//vrr/fffHz16tO7ICxw5cmTz5s27d+/++++/dd/VwX333de4cWO9VsGMGTNatWp14cKF06dPn7BQoUKFHTt2oACNk82wEtSg0K5du+XLl3/00Ufdu3c/cOBASEiI469csKelSpXSa3MIb4eEo0R6a+xOGDNWs2h1A2jGaC+BS+5I4IUXXqhatWqjRo0uZ+VbtmxB0KTX5hAff/wxZKhQoUJFixYtW7ZsYGDgPffco0VezZo1K+wE1KvNfAfWj93v3LnzE0888eijj06ePPnOO+9cuXKlbPDqq69WrFjxp59+QjkjI6OmBQyyevXqKKCjx4oEd+3aFR4evmnTpiVLljRp0gTKeNtttyUmJo4YMeLf//53RETEuXPn0PKNN94Ym4lRo0ZhT+Ui8NJLL8nt+ogC2eGTTz5RGytd3Q5jxmoWrW4AzRjtJXDJHQns37//2LFj27Ztu5yV9+nT59lnn9VrcwJEOgEBAY888ggCLugRatatW9faghp8IUaDaH6fFahxDAARgb733ntyEfuItFfx/4MpU6aUK1cOMpeUlNSrV6/+/ftD5rp16ya8Bw8erFWr1oYNG6Dd33zzjeyF+PGXX36Ri19++SUGAAJjYmIgc9DH5s2br169Oj4+Pjk5GUL/5JNPipbwDho06AULs2bNQognysDw4cOHDRsm13lFoP1PL+dfnPswZqxm0eoG0IzRXgKOHZGmIULBqYh4ZM+ePaLy7NmzkyZNQiVO+3feeYeoFKD1ccKECZCA1NRU6OBXX321devWlJSUIUOGQJvgnT9/PkSkTZs2aIABYHHq1Kmi43fffYexIX/PsjobPvvsMwSMkCGP1aVu3bqiHnEZdAcBnWyJxaefflouCqBG08eNGzdiwFA3f3//hQsXikoIEMI6tdnPP/9cpkwZxHRqZVxc3OzZs+Uicmqsp1KlSlDS1ExA1wYPHizKGDCavfnmmyAQLUFybGwstG/u3LkoIHxr27Yt+orbBdBHSY6WX+MCw/qowpixmkWrG0AzRnsJOHbs2rXrLbfcggTwwQcfbNq0qajs27dvQkLC+vXrly9fXqNGDfz1VilA62OdOnWioqLefffd6dOnV65cuWPHjh999BGy0SpVqkAO9u3bB8299957sWYo2uHDh5GxLlu2DC6k7YsXL9ZXZwP0+q677hLl//3vf4i5pAsqgzRWLvqoj9Cg4ODgkydP4noQFhYmBBrCd+ONN8o2CEsR5WlfPYP0FytWTH1cA30EaePHj9+9e/dLCp577jkILgrYfTQbN24cCIRoYosISKOjo5FZR0ZGNmjQIDQ0NCQkBJLtYX3MCYwZq1m0ugE0Y7SXgGNHSNLfFiBMRYoUweLmzZtLlCjx+++/iwZ79+69cOGCY6VcSbb6+OKLL4oyAq5XX31VlP38/LBajy2/RjZau3btm266KT09XVYSQLr64YcfijLC0v/+97/SBRHHVuSij/qIXYMsQsGPHTsGjUaciEqo+VNPPSXbIIJu0aKF9uQEooYsWy7CC+kHMytXrgSxalKPwDAgIACFo0eP4koAihD24sqxZMkScIJLxdq1a3Et+fHHHxFLoua3337zWPp4//3377WwadMm7JooAxgt66MKY8ZqFq1uAM0Y7SXg2PHll19u1qwZTvUuXbpAHxGVINcLDw/XmjlWSmSrj5A8UQ4KCkLqKsrQtXXr1nls+ggMGDCgdOnSiODUSm8oX778559/7rHuGGL9q1atkq45c+Yg/pKLPuoj8Pzzzz/88MNyEWPGDopcWEJ9ZcdjpfmFCxcWeySwY8cOSDxUD/oIKWymAFsE2yhA2THIHj16oAZqiEAYsTbKYAAXpN69excqVKhnz55ffPGFx9JHpOr1LEDBCxYsKMoAxJT1UYUxYzWLVjeAZoz2ErB3xAkJGdq+fbvHCpqQG0Ifv/rqK4Q28uQXd74cKyWurD5CSpAUQ1bUSJBA+/btET2hAJWEVspBohATE3PzzTfLlr7rowqEfrGxsa1atdIdCpBZI8B0fMkJFx7xRBvhJKI/ka3/8ssv2H3RAMIKTW9svd+DWLVbt26TJ0/GvwZq+J///AfDW7NmjXhfcsqUKfJ2p5Zfr1ixQg1vrwhYH3MDZtHqBtCM0V4C9o5ff/01BAVnGsoPPvggwp/9+/dDVnCujh8/Hop55swZZKxz5851rJTrsevjHXfcgbNalLPVR5EUi5cBISIRERELFy48cOAAYiXZmMDSpUuxqtWrV0NZxo0bJyqxI8nJydWqVTt48KBsiV1ISUmRz3wFUEPo48aNG9u0aVOxYkVxK8ARiAHRAKm044vcUh+BhISE5557zpNVHwWEPoLe4ODgBg0aQByhuZGRkdgF7IvaUoB4/1GSr/4X1LKPYH3MDZhFqxtAM0Z7CTh2vO222xD4IFlDqDJixAjEMh4rMcTZXq5cOZz2aWlp4rR3rBRA1KM+BgGwiMxdlNu1ayfyXyA6Olq+6tikSRPx2OHdd9/FapFX7tmzBxFWamqqaDB//vwOHTo4io6Gxx9/3M/PD2s4fPjwvn37oGjIXtF3165dajNoEARa5qQCqHHUx9mzZ2N/cc1A5LhlyxbdbQEShkQYeS7yaPHrFztUfdywYcP69etR2L17t6M+zpo1KykpCdEiCoipEdHfe++906ZNU18PEiD0UZKv/hfUso9gfcwNmEWrG0AzRnsJeOuIjM/x1yaIGe3v1jhWXlXsskEEvBrUUU2fPt3xhfOZM2euXbtWq0SN+CWfBoS0UD31bqYdELvWrVsjt9UdClR99GTe0wgMDOzYsePFRpY+Hjt2rGnTpuJl8piYmJ49e2JsiCVx8diVVeg9pD5eKbA+5gbMotUNoBmjvQQuuWPe4g4bZLZuBCCIED615tChQ9u2bVNfAAC2b98OiRe/k/EoX876888/xcNrDbhQqbJ7NcD6mBswi1Y3gGaM9hK45I6MaxOsj7kBs2h1A2jGaC+BS+7IuDbB+pgbMItWN4BmjPYSuOSOjGsTrI+5AbNodQNoxmgvgUvuyLg2wfqYGzCLVjeAZoz2Erjkju7EmTNntFlmL1y4cNNNNx06dEjWvPzyyydPnpQ/wpNQn418/vnn6jw9ABbff/99tUbFFZmY1giwPuYGzKLVDaAZo70EvHXcv3//6NGjn3aC+K10enp6Tl8t9h2bN28eOHCgXmuBnnl34cKFderUkYvQwQ4dOsycOVOubevWrYGBgadOncKON1ZQvHhx9XWZxx57TP7GBo1PnDgB+ZswYQIKOZqYdt68eYsWLdJrTQbrY27ALFrdAJox2kvAW8f4+HjEUOmZqFatWps2bUT5nnvu8Viv5mkTml1BfPnll9iiXuvDzLupqaljxowR5SeeeGLo0KFr167t27ev/MnNv/71r9tuu+38+fPaGurVqyf0cefOndjKgAEDEhISUIAgRkdH16xZs6wFFFq2bCm6+DIxLeLZqKioAwcOKJsyG6yPuQGzaHUDaMZoLwHHjitWrNBeVO7UqdOMGTPUmjzRR28z727atGn+/PmPP/54pUqVYmNjEfqtXLlyz549fn5+69atk28aitkbMWyhj0cUhIWFCX385ptvoG5YCXYQBTk70cSJE++77z5RFhjr28S0U6dOVX/ubTpYH3MDZtHqBtCM0V4Cjh0RhT2ddcoGR31EMvvQQw91794diaecVgdlCM2dd945adIkjzXX4f3339+uXbvevXuL+WY8XubfPX78OHpBlzMyMpYsWeKojwJ2fRTzVLZq1apYsWIYEsYAZfz666/vuOMOVeixX+gIfbxw4UIdCxUrVkRUKMpi1kUBmV8vXbpUzFmLMLBJkybq/LVjfZt4EZoO1Xb8MZKJYH3MDZhFqxtAM0Z7CTh2DA0N1X6K56iPISEhTz75JILN5s2by6cTEJqRI0feeuutYu7u5ORkKAU0Yvny5ZAJBHoeL/Pvdu7cuU+fPlu2bPnwww/Dw8NzpI8CDz/8MNYsyl26dEF+jYARaa+YRQLjrF69ekxMjBr2QuAgc3JRQujj999/v2rVKnUKW4jj7NmzhZL6qI9AcHCw2PF8ANbH3IBZtLoBNGO0l4BjRwRf6rdQPF70EeomyhCOtm3bijL0EQGgKENfEJ1BpEQOO378eHFz0D7/7saNG0uWLCkfPb/11luXoI/R0dHyMwbdunUTczUmJSVhux7rJ32QSOgm9BHpcwsLNWvWDAoKEmVAZNO//vrr9ddfX6ZMGSTdq1evVqewRWPI99GjRz05mZgW1w+zfv5IgPUxN2AWrW4AzRjtJeDYEZol77sJOOqjDMTefPNN+bU/6OPbb78tygsWLPD3949VgLDR4zT/7uLFiyMiIkQvj/f7jwKO+ohoFKGi/FVy+/btxResMAb1EzFCH7dv346VQNYLWEDLbRaQd2NfsB5sfdCgQX/99deiRYvUKWzhatiwoZiZfKzPE9PGxcVdvXu1uQzWx9yAWbS6ATRjtJeAY0ec3hALtSZH+ihjpc8++wyr0qb2cZx/F4JYrlw5OYvt+++/n1N9nDhxYmJiolysX7++OhmlhNBHj5URh4SEIB+Pj48PDQ3dunWraHDs2DHEzur7PfPnz5d3TjEq+RqQ7xPTQvqv3rtQuQzWx9yAWbS6ATRjtJeAY0eIiPYNrEvTx3PnzkVGRkK5xNOJZ555Bomn4/y7Z8+erVu37kMPPeSx0lusLUf6CGGtUqWKfNMQCTsCPcdZyIQ+HjhwoGXLlnfddZe4/7h06dLq1avL+Sg9Wd9/fO2118LDw8VMjqo+qtD0UcXp06fhOnHihO4wE6yPuQGzaHUDaMZoLwHHjjNnzpT3EAW0ucE91jMW+bVC5Jsyh1UnvvVYrxNCkqA+CNZ69+59+PBhj5f5dzdu3Ni0adOqVatCjBCXydcM7bDPvPvqq6+iI+QYmfvdd9+dnp5epkwZCJPaRgCDmTNnDhpD/hDYyucz2AUky4hbhZQ//PDD6ks5WK2YyTwoKCin+vjBBx8kJCTotcaC9TE3YBatbgDNGO0l4Njx1KlTSDm1H+pdDhDfaTMbept/19uE2zSQ6k6bNs1jiRGEu0WLFvIT1RpE/CiVXX1+vWfPHvGkqIwFLV4eNGgQVFX89katFyD0sWfPnsuWLdNrjQXrY27ALFrdAJox2kvAW8cFCxaIx775DIg9Vd3/7bff7D9uQZArbo+qOHPmDCq9pcneJqaFEKekpOi1JoP1MTdgFq1uAM0Y7SVAdBTfgWFcDiCpIjHPN2B9zA2YRasbQDNGewlcckfGtQnWx9yAWbS6ATRjtJfAJXdkXJtgfcwNmEWrG0AzRnsJXHJHxrUJ1sfcgFm0ugE0Y7SXwCV3ZFybYH3MDZhFqxtAM0Z7CVxyR8a1CdbH3IBZtLoBNGO0l0ABBiOH0I4fddHlMGasZtHqBtCM0V6GCpor2svQYBZdxozVLFrdAJox2stQQXNFexkazKLLmLGaRasbQDNGexkqaK5oL0ODWXQZM1azaHUDaMZoL0MFzRXtZWgwiy5jxmoWrW4AzRjtZaiguaK9DA1m0WXMWM2i1Q2gGaO9DBU0V7SXocEsuowZq1m0ugE0Y7SXoYLmivYyNJhFlzFjNYtWN4BmjPYyVNBc0V6GBrPoMmasZtHqBtCM0V6GCpor2svQkDt0Oc5JfAnwaawFGAwGwyiI+eEvE77qo2fsWDY2NjYjDJJVvHDhy5dI1kc2Nrb8ZpCsFcnJly+RrI9sbGz5zYRkXb5Esj6ysbHlN5OSdZkSyfrIxsaW30yVrMuRSNZHNja2/GaaZF2yRF67+vhip05HRo6017OxsZludsm6NIm8FvXxRFpackgIdiq2SpULY8bYG9D2SkLCxOhoteZ4Wpq92dWwb/v3H9eo0Y7rr7e7YD8NGXJz48bSnoiNbVu16oYBAw6OGNE7JOSTXr3Uxs926LBt6FAUBtet2z801L42NjZzzVGyLkEi87k+PtC8ebuqVTWLq1q1QCZW9+lj70Vbz9q1JSG/Dh9+Q/36DStU+CNrKLq4a1cIkKMdGjHCvk4fLTUiApv+YdAgWXNSkeY1ffs2rlgR1qhCBTTDwOqULdupevUgP7+wgICtQ4bIlj8OHowGz7Rvj3JizZpdatSwb4uNzVzzJlk5lch8ro+3NWkSWb683dIiI1tXrvxp1pDKR1P1MaNBA78iRUoWKTIyIkJtA5GSEqzhy7597ev0xfbdcEOJwoULFSxYNyAAwlfL37+ynx+kUN4lWJmc3CwwECr5eGwsmq0fMAAFbLFvnTrvJCZWL116TocOouUtUVFo8Fnv3t8PGoQYE3E0CtLOjh5t3zobm0Gmn3U2fPLJJ7rMOSGf62OODMFgj9q130tKEosvduo0ukGDw6mpWjNVHyElzYOCED+uyiq10Md6AQGq6MDuiY4u4KSPPm53eHg4urevVq1bzZrJISH9QkNDypQpXLAguosGyKOjK1UqVrhwwQIFkIbvHTZsV0oKlDSgeHF0RJdjo0ah2Z5hw/yLFs1ysGSFyLvZ2PKr4SDXNc4LfGr3z+ps23C/TYyORvJI2IFMZZkeF4cwCplvpZIlEZ2dy8hA5aCwMOy4XaeEPg4IC3u6XTskqtCgU+npWhuR52qVaF8gqz76vt2lSUmoHBgWplaGlyuH7nIRuyPuq9pRtlixJd26iWZda9aEPq7u0wcBJiyualWE0qIsjONHtvxtBVgfYb1DQiqUKCENe1G0UCG1Zmfmg4558fHwTmrZUkjY3Ph4VMZUqgQdsa9W6CNyaiE9oWXLIjDcotzd8/isjz5u94dBg8oVLx5curQqmohY0WVm27ZiccF11yHTR8aNJBoyWrFEiY979ICAdqpe/f3u3cUt147Vqx9KTa3h7/9Uu3ZyPXz/ke1aM9ZH3RATYS8gbXaXsCaBgeVLlEAoB72DWl0YMwZpacugIHtLoY9nRo9emZx8d3Q0NAiL9vuPvuijx7ftIvVGgPm98lgGhsixVNGi8rnQb6mpt0RF4e/5jIzbmzatVqoUCi2CggbXrYsCItNXO3deY2366KhRy3v2nNG2rbDI8uWxC3JxWc+e6lbY2PKfsT7qtm3oUOxFemSk3SUM8tE/NPSX4cPFGz9vdOmC9hAae0v1/qOwTYMG7b/hBrXGd330cbvqc2rYtLg4NJvQrJlaCaUr4B1IsWXLsQ0bQluFFS5YECYXCYrY2PKHFWB91Aw5LPbi+Y4d7S67IVILLFkSGbTjm4Z2fbSb7/qoGr1daS926gRFCwsI0O57vpOY+FJ8PKxNlSpIolGoU7Zs68qVReXE6Ghxf1Mzzq/ZrjVjfbxox0aNur958yKFCgWXLq1FYXY7MHz4Xc2a+RUpUqhgQW9i6qM+YiVIb1WrXaaMN330ZbswZNMjrVcgq5Yq5e0p8xd9+vgXLTq+cWOUsdEhdeuK+pAyZRxjQ9ZHtmvNWB//315JSChtvcvSoHx57RGK3SATBa1UFMHX24mJ9gbCfNTH4oUL1wsIUC3Iz89RH33c7mudO4s3deKqVtXSeWFbhwzJaNAAoSXiR3ElQPDYsEKFWe3aQXzREYXjaWkDwsJUg9RW9vNTax5o3ty+cja2fGOsj/9vkIleISHPdex43im11GxaXBzUYVHXro55qLQJzZrFVqlir1dtZtu28smytLX9+iHJ3TtsmFbv43Z3p6RA7OZ06PC3zSVsaL16FUuUmNyqlfzR5KOtWyNhR1haqWTJ7rVqIZSGQY5p+3eTJvaVs7HlG2N9vBYN2md/E5ONjU0z1kc2NjY2Z2N9ZGNjY3M21kc2NjY2Z2N9ZGNjY3M21se8tM2DB79k/ZI6p3Zg+PAPunef3KrV77ZJMfLE/hg5Uk4O5Gg/DRmyqGtXe71m2B05O4awefHxxCwY2O5f5LzF2Kj6QsLE6GhvUxSfy8iY37nzae/bWtO3r/bDzcdjY+382+dR/nvsWGK1bG421sd/rHutWs0CA71Z+2rVRLOv+vb9yvZOoseSOTmBhbBbo6Le797d3lKzN7t2TaxZ02M9UA7y81OtXeZ0Oy8nJNzRtOnNjRtfX6/edTVqNKpQoXTRorX8/THmu5o1c3xV88jIkRjS7pQUb+/3XHG7LybG/isg1ToHBzesUAG0vNCpE8ZWp2zZ8iVK1PT3R8G/aFE5m8bBESPKFiv2Z+azdewCdpZ446pj9erEO0Yz2rZtVbkyBAvydCItDVahRIkd11+PgtyEtB8GDSpaqBChxbFVqgiJ/6RXr9c6d4ZVLFHiyTZtRPmEJbu4SGAlv2S9VDzSqlWcMnmSMIzqf+3bz2zbdkqbNmjwYIsW9zdvbtdWtrw11sd/bPvQoT8OHry2X7/ihQtvGDAAZdXkfNpiGjR79yF1645p0ECtCQsIwDmDE3tlcjKEEjr4aufOz3fs+FS7dj+npHisgALByDRr1jIUsAloItoLw3giy5cXq1qalHRvTMzUNm2gLIitqpYqtX7AAPsYhH3cowcUoVDBgjhLITSBJUveEx19Jus5D8UXv6TWDPX2FfpiWD9GBQV8Ijb20datEdXe2bQpdlw2gARAHBEpd6lR42br5zrogrEdtWaZLFW0KArfDRyIywAMogM+UcC+4NoAJrHjwoSovdWt293R0ZDFtMhIHG9JtWoNCAvDlaNlUNB/W7aUG33V0q+frP9dRoMG0GIYmKleujQKGK1otislBXq3rGdPSHxlPz9sBXuBC8/oBg36h4ZiAKIZhhdcuvTqPn2Gh4c/0769+C4FlP2G+vVFWUj8un79wKQmc9h9+/QlCHu71azZs3ZtXPZuiYqqGxCAK8GmrPEpW54b6+NFg4q1rlwZwZdqajo2vnFj+SM81XAq1vD3V2vKFS++IjkZ2R9OxXoBAVEVK+IMQRyK0/jb/v091i9YWgQFwRtQvDgKkD/oo+yOk1bqo2YIuCDZ9nqP9fY41oZgBNk3pMFjna7YI5j6tiMCPYimfUZexwDwb2tOILm4behQLVL2WOc/9heKA6nqFRICWQkvV65b5oXk6/79oUr9QkNxdYGgjAgPx3UIYoQG2E3oV7HChSEWKIAERMfD6tdHAfZl376jIiI6Va8+tmHD6EqVYipVEv+L2R06QKQgjrgG9KlTB5EXgrg5HTq83qXLxoEDxUYRhyLExqUOIvuNRbgwxI9acDepZctqpUrB/IoUgWTj39S1Zs3Bdeve2LAhOJGTGSOcx+EBfUfQh2AfY4NBTxdcdx0K2zN/wQmusCoUMBjQMj0uDmODCOKfmxoRgWGrmxYGMcUO4jLA4uhCY328aAgZEHOpSS5UJkpRjZERETiU7R1xnmPH5Ry6MAQR32Weq4Th/A8tW/ZkWhqEGCKiblfqI6JOMYeFMKhJ/XLl5OKzmR9C+Kx3bwx+gxVaYtOIR0Q9Yi40u1OZ5geLTyuzOgpDjaaP0Bqc+RAaiNrC664TlTjDkderzRAOlylW7I0uXdRKpJOzMwd2LiMDcpMcEoKOKMQHB9/etCmGh44INhFXqlMQQYCWZsoxQmzIrrjlB1WdlXXMkJ4G5cs/1ro1Yka7ZIvuB63phKFT0CZhyA8wBlHW/kG4Sr2V9danNFzSShYpgvgazCO6B8na9MlQc9HylYQE8Y+b0KwZcn9cM3rUrt08KAj/U1weZDNpkFpcMrEGEUqzuc1YHy9a7TJlEHCpNYu6dlUn4h4UFqZ9j1Ba+RIl3sn8QbSYQVJkdoQhcKji51eicOG+deog0vQWPyLewaikIT2EWslFKcpJ1u1IUUaMAz2Sa5sbH19TCW991EeczGKeDkRYiG7EYxAI343KFQJhKU5+7aOGW62QUH1cg4x7lBU9/atxYwSS2NanvXohOhvToMEHWe/SInxDug2hRyCMqBw0iudXuEohEpTNdln3JRGl3tSoEQQXIngiLW3H9dfP79xZfkYN+pgQHIyQf3dKipiXSNhzHTtiJCjsU36Z/ntqKq5JZ63blIgZcW1Qb0rgP3VoxAhE7hDlp9q1w6XI/jE1kVOjYL9NgR1BXKxVeqxLCyQetCNkBrEQ7o+UfWRzg7E+/r9BzpBeaQ80cODKAA0GIbjfy4wMyP6Q3ooy0kDwIO4zak88VUNqhnQPaSZyNwRB3vRRM2/5NVb1YebZNaRuXfVO3PKePZE8ykUf9REnPGQRIR5iHJzeYncg6OqM4rgkIOzSfqqIWK+Xos4eSx+bBAZi/WgMUcO2bqhfv02VKlg/dh8hubyJAaXDhhCjQWEfj43FlQPCgYsHFuXHxSB8TQMDcd1CZIoylA7ROnYQfxGNvtipk8cSbugm/gsrk5MRQat3Ej7p1SvACkvVkA3/ZYwZYgppDilTBmRiT9UnbNB35PI3Wpk+Yk8MTNwtFYboUjyhBjn2X9zjH4291irX9O0rcoWMBg2ead8e1zBsHXtxj5cLMFueGOvj/9s8K8hSvwoNQ36n5m6QyzusZPCFTp20eXFwdt2W+SAVJ55ItyFkOLHt00x4rBgT54x44LNt6NBvrZt09vwaeStSQtUKFihQLGuNyG0RwH7eu7fHumOINahfAZvToQOyeLnooz56rNT+4Vat5CLSbeyXlpZqD5cRW0GntDB8svV89r6YmBlt24LVcY0agerXOnduVbnyrVFRr2W+VQMdFLdNIXwIqz3WQ4yI8uURWKnPfxEAdqhWDW2wX2iPEAyihmhXPEEWhlgyPTISGS70EVKovo2A3SxSqBAK8nICw0ogmggPhVKDQ1xgyhQrJr9ThiMBETo2jZa4/ODCAInEJUR83Qx6KnZhVrt29kfVr3fpEpH1aofGlf38bm/aVLu0LOnWDezZ3xliyytjffx/g6hBI1S7JSoKGbfa5t9Nmlxfrx7iEcQL2uRjiC9GZN59P2HFj0jrZrZt28YWTQiD7uC0l+/3HPGSX0N9xIsp0hDdfNO/v1ojFKp9tWqI9VCASkIrpWyhgNhWPDUW5rs+qoa9RmQERbO7pCGzRtg1OuujfNhDLVqIb9sid4bwPdKqlchSO1WvjuQdBfHwF6KTYD1WhkBAj0Rf8eEdJM7qCiErUKK6AQGfWZeEegEBjm9TdalRQzxGR3sE/uIWwS/Dh1ewVFi1xV27arNk4vKG7Yr1e6xXu9AAfyHEWAP+X0LBQRqugvIux//at7c/qv5PixbX2ebNxEpwDcPh0bZq1dcy9w4pPzbqeDuVLU+M9dGr4azWvhWDJAiBwMsJCQjHtEz8pkaNBmXeqRT3H3E64axGDIL2OO4RMkCCIXzijcVDI0YgXMpWH+3mLb9empSE0351nz7IWBHUiEoEuckhIdVKlTo4YoRsiVM6pV49+dKMMNQQ+rhx4ECcyQjWNjttWhjCMTRAVqu9TuSxvi2O0EzGjyggV4VVL10agouCiHzHNGggJpRE9FfLumH6t3XPFyGV/bEYtFW+Wv9EbKzj3V6pjzAo73PWdMKO+mi3KW3a4J+4y7qrAEPmjksa4n1Evvj/QijrWykzSAMn8m1KMNk06/1HXMBq+PtDN+2bQECKawmCdPAwoVkzyHdaZKQWabLlrbE+/nObHDplNxz6OC1FWdx9+y01tXTRokhpF2Q+z5X2XlKSGuOAhx8GDfrben0ER38BBa2VEEzVR6gAtE8YTkJNH/+yXnJGAWLn+E64x/o5B8K0qIoVEY5BkaFoSCSRisqTXBj2C1psn5HXUR9nd+gAycPYIGTetouwcUBYWEHroz2O71d3r1VrUdeu0A6EadBHGb2i15uZP6qBxEBexaumb3XrhsFjf1MjIsAG1BmEQPTV9wqhiUirh4eHIzpD/n5Xs2ZooF3PVH3cYH2Q1mO9c27XR6T/LYKCkDLfUL8+9BqRaaGCBbFm4UXSjXR4Wc+e/UJDIWRYVfOgoActL0hD/o5UQNzQeCUhoaHyKAZXQeT4iN/t1wxP5rFxT3T0rVFRYA/7iOTgB+83rNly31gfx65ITtYmyrbbCuU0+0S5tefN4qpWVfM1JIzizcHfra8GynpVH8VDWGGbBg3S9BHSIB7sIoElvv2g/tgOIZt411IzZP1rs94f9Fgz8tqn6fVYt+GgeurdTLtBdyD6kiLNIA3QI5FBI83EbsofGqr6+GmvXiDtrHVjDnv6YqdOkHvEYrstcUd4CKEUby9JQ04NtYKiIcZE/DsqIkI+wRem6iMMcTcub4ElS0Kz1GYeK31+tHXre2NiIFV3Nm0KBVc/7IPdH1K3LuJ98X4lLjngRIh1/9BQJBO4aInHR1C3F6wHRMKwC7i6qMG7Zu8mJWFziCLvaNp04XXXOcooWx4a62NeGgITcf5D19To7FxGhv2jMTghkRuaeArJBw4Iw9XHO3uHDVNfvxe7hhohpuetx9OaN0cGQRQPWKQhoAOxl/AzPvWqpv028VR6OvE7TsLF5n5jfWRjY2NzNtZHNjY2NmdjfWRjY2NzNtZHNjY2NmdjfWRjY2NzNtZHNjY2NmdjfWRjY2NzNtZHNjY2NmdjfWRjY2NzNtZHNjY2NmdjfWRjY2NzNtZHNjY2NmdjfWRjY2NzNtZHNjY2NmdjfWRjY2NzNtZHNjY2NmdjfWRjY2NzNtZHNjY2NmdjfWRjY2NzNtZHNjY2NmdjfWRjY2NzNtZHNhfZHyNHqp+otdvLCQkn09L2DhummfpJws97934vKUnthcX3u3e3r+1as2zpXdS1q/qlxonR0eoHJoXNbNtWfOX82/79d15//Q+DBokvA7+blHQJ35h0uV3r+oj/9NPt2tnt1c6d0yMj1/Tta+9ypWzz4MEDw8Ls9TiCcTKPbtDA7roalsubo61j9er/btLEXi9s65AhgSVLnkpPx2HWuGJFacULF95lfSZX2GOtW9/cuLEoo/GJtLTbmzad0KwZCqeyfpo1F2z70KEPtWhxW5MmOKJobcoFo+md0bZtq8qVcaU5PXq0+A57hRIldlx/PQrqJ21B+AlLNNtVrbq8Z8+PevToXqvWgeHDQ8qUyX16r7Zd6/qIfzx0UFi1UqXaVKkiyvdER+M4eCcx0d7lStmXfftii1rlC506VS1VqlGFCrnD5BXZ3JYhQxBK2Ot9tLe6dbs7OhrnbVpkJIaRVKvWgLCw62rUaBkU9N+WLdWW/2rcGEKDAEcbbb2AAKGPCGewR+ieEByMAk7j6EqVavr7ly1WDIYC1mkfwNWzFcnJkJj7YmL+175908DAXiEh9jbZWu7QC/muWKLET9ZH2DMaNABXsEIFC1YvXRqFzsHBHutkAc/h5cptGjRoSbduTQIDoYz4jyTWrDkiPBybiChf/pwSfuYDu9b1UbVO1avPsDIFYXmij/tvuOHYqFHbhg7NHSavyOb61KnzbIcO9nofbXaHDsPDw3H2Fi1UCKt6sEWLJ9u0mdOhw+tdumwcOFA2OzhihH/RoviPCH08MnKktLBMffymf/+xDRvGVqmC/x0Kv6emir7IEyFS9k1fbYM6Q3dE+XBqKuQGSYO9GW25QC+4reXvv2HAgI979PhG0WKI+y/Dh8tFHLEgFuTHVKoEeqGPzYOCVvfpEx8cnBwSgtAea7YPwGhjfbxodn1ceN11SI5wkUR2djLzRgzKOBvvbNp0knX5RTJyf/PmyDV6h4R80aeP7I7zFldUHDqjIiL2DBsmKo+npaEj0hxconEFtuujMLtg4YAWm9PMcStnR49GY1QiWJAS71gpzL451bC/ODFSIyJwdn3Vty+S3JR69YbUrfv9oEHwzu/cGacW4u5UawBYnJp5knw3cCDG5mNSOT0urkH58kiNEdQgDLQ3wPoxSIwcCWCdsmVhiHcQFYryvhtukC1lfr00KQm9YFEVK+JkFuXvFM3N1i6TXgi0vDH6u6WP0CBtEy6hF4cxVLJSyZJT2rQRRMGKFy48uG5dlbc3u3bFfwEtsb+4Ds1q125ufDwKn/Tq1bZqVfT927Zmo4318aLZ9TGkTBlcEpEl4Tp5e9Omoh5n48iIiFujosSxjivnsPr1EYgt79kTh9cm67CGda1Z85aoKCQsuGIjtxKVyFNwGiBj+rBHD+Qpvusj8v0b6te3t3TcSt86dZBgrh8wAEOq4e+Pv94qvW1ONewv9OXdpCScY5X9/CDuH/Xo8Wjr1lX8/HCSQJggCvfGxGDNyL8QJSFhX9azJ1xI2xd37Wpfod1wvSldtCgIualRI6wNNCI13nH99ZCD1dYlB/8CJHoIW1Rlh1IgirGvTegj9GVVr14vxcdLw0mOYEpV0mztitDrsXQW/3qRpWrmBno9lj5i/OMbN96dkqKS9lzHjgg/URC8jWvUCIcKRBMXg3LFiyNARmYdWb48xDe0bFmcL2rInw+M9fGi2fURZ4Uo4/jA5VGUcUBnZD7NwEmIEAaXU5Ho4fAak+nC0Yxr6d9WYlWkUCEs4tApWaSIfCD4Vk7iR29m3woyuBKFC8vUUjzbdayUK6E3h/19sVMnUS5TrJhMGP2KFBHZopYAIkerXaYMTsX0yEj72uyGMxPSMzAs7FxGBsqgunDBglg5/jasUEFs+sfBgyGRXWrUgD4iWmkRFASr6e8f5OcnyjCxd78OH359vXoYJ5JunPz4B0lDY1yWjo4aZR+DN7si9GIYiAERgapPOaS5gd5T6enQTRwDK5OTMUiVNASGAcWLowDeIMoYbd2AAIg4sh8MD6q9tl8/yDr+QYglUfNbJgn5w1gfL5pdH2W0grSiWWb4gEPk7cz6Bddd51+0KM5YaQg3hOvlhAR0wXmLsxqnFtQTV/uI8uXl+h3vPwqjBUs1+1YwVEQKWjPHSmn05rC/OCdFGRLzZeYz/QolSqzr189jO4FhA8LCELDIOxK0IULpUK0azt45HTogZUYkgksOYkPxkFQ1oY/bhw7FgHGeF7CAAH+bVQNJwm4WLVQIrA4KC0Piucj6r0mDC4rwYea++GKXT+/zHTtCziSBdnMDvYglobZQPegjpFAlDWcBdhwF8IY19KhdGzVQw7uaNYuyXh7AYHBt6B0SUqhgwZ61a6u3mPKBsT5eNN/1UR7Qn/XujYun/R4QDiAcwTiTUcZ5W6xwYZxaOPSRksj3y97v3v0y9dFxK1/17RugbEXcD3KslEZvLqcnME4wRHY42bSnz4QhfkH0gcAEfHqs59GOrysKffRY6SpSOSS/iHqQ1m21nrrCjo0a9cvw4er7PUgh5RkLttXXgLK1y6cX11FcEdVHHHZzFb3QR9H+/ubNxVGNwWMkogG6r+rVS7zf83NKSreaNSe3agWWxjZs+J8WLZ5u125N37729yWNNtbHi3YJ+ojLcmT58hOjo8Up8Uz79o+2bo3C1/37ly9RAqcTykjSkcvsv+EGpCc4Rh+ycnakgVih7/qI8xyHuNbMcSs4SzFyZPo4pc+MHj2kbt258fGOlcTm7mjaVL77me0JjLXhXBXJI04tKMLC6647MHx4pZIlZeNsDeS/lDmkJ2JjxYsmmgl9xJpbBgUhfhH3H5cmJVUvXfpz68wXpurja507I7IT7zNLfURUiDA/2ycJl0kvNlq1VKnXu3SBgkj7w1qba+kV+ghLCA5G4OnJqo/ChD5iT4NLl0Y0in8Brk84C0Dv/pzc2zXCWB8vmqYaCE/kXfYPrZdgRbld1arq2bjz+utxYOEURUSDLONw5v2X25o0qeLnFxYQgEvriPBwceneOHBg08BAnDY4ad/o0sXb63i4OCNGUGtw7iU7vT3nuBWkSwisEKsin0qLjBS/anCs9LY5LEJERFnd3+hKleS7eE0CA8XN+HeTkrBaZFt7hg1D3JEaESEaQNOR2fn4mwqctMj7hoeHY0cQlUD+xjVqNDJzVcLAM1I8sAf5Q3Qjn8/gvwOxQEwkJO/hVq2kPnosNRTiAvUR+ojTG6vSVu5ol0PvoREjxFuEqgnRcS29Uh83DBiw3nr8uDslxVEfcbVOqlXruFVAeIvg+t6YmGlxcerrQfnAWB+vjCGCUG/JC8M57BikiHDmSpm3rWBI9sTfsfKqGiRJMxGR2Q0CN6FZsxvq1x8UFpZSr96oiAicxmoDET/Ki5b6/BraIZ6AlSlWDKbmATCsEKoqfnsjas5YTy2mx8WpzRztmqJX6qMn8/YCSEMurzaDPh4bNQrsiSA0plKlnrVrr+3XD7EkdDxHdzDcb6yPbFfXkEtqRjysoA1xrnp767fU1AO2W3uI38UdQ9WghqjUHvgg8N/h9CagWXYF6YUgHsv6cB8hsHjwpVaCSVwD5O9k5CUH16d89vDaw/rIxsbG5s1YH9nY2NicjfWRjY2NzdlYH9nY2NicjfWRzUWW7QSuPD/u5Vi29PL8uJpd6/rowvlxc3lG1VzeHG30BK4mzo/7lznTD/P8uHa71vXxT5fNj3tFZlT13a7I5nJnAlePgfPjGjT9MM+P62jXuj6qRvy+8GqYoz5ekRlVfbcrsjn7BAo5Ml8mcPWYOT+uKdMP8/y43oz18aLZ9TH358f1NqPqVZof19vmVHPJBK6pBs6PK4zWR5fQy/PjOhrr40Wz62NezY/rsc2oelXnx7VvTrU6LpjA1ej5cWl9dAO9Hp4f14uxPl40uz7m1fy49Iyqqtm34jhXq2OlXAm9uToumMDV6Plxs9XHPKeX58f1ZqyPF82uj97mN7uq8+NmO6OqavatOM7V6lgpLNvNZTsBl/0G2RWfwFWYifPjenzQxzynl+fH9WasjxfNd328evPj+jKjqjTHrTjO1epY6fFtczk9ga/qBK7iP3LEkPlxhV1Zfbyq9PL8uJqxPl60S9DHKzs/LjGj6tWYH5fYnGsncH3HnPlx5Xrs+uhaenl+XM1YHy9ans+PS8yoejXmxyU2V9OtE7gaND+uXIlB0w/z/LiasT5eGTvP8+N6MW321l2XN4HrOzw/bla7svTy/LiasT6yXV27ghO48vy4druC9P7I8+PajPWRjY2NzdlYH9nY2NicjfWRjY2NzdlYH9nY2NicjfWRjY2NzdlYH9nY2NicjfWRjY2NzdlYH9nY2NicjfWRjY2NzdlYH9nY2NicjfWRjY2NzdlYH9nY2NicjfWRjY2NzdlYH9nY2NicjfWRjY2NzdlYH9nY2NicjfWRjY2NzdlYH9nY2NicjfWRjY2NzdlYH9nY2NicjfXxCtu5jAztI0dsbGyGGuvjlTSIY9uqVVtXrnxp35DbO2yY+o29v8aM+bZ//5ERET5+4/jSDCtXPwoIuzBmzE2NGh0aMUIsruvXT3yI2WN9rO6RVq0cv3eq2pYhQ9QviV+aLe7a9dHWrd9LSvo5JcVxiyezDhv2Sa9eH14S856sa9s6ZMgz7duj8FS7dt4+l+qj2b+wyGaQsT5eSTucmtqlRg2cWg+2aGH3ZmuJNWvKr7/DPujePT44+LYmTYaHh4uatxMTH7K+7/5Y69ZT2rSZHhc3q127/7Vv/7OXjw4PqVsXLe31qi287ro6ZcvKRchEh2rVZrZtOzAsTNT0CgnBhtIjI4UVK1y4X2ioKD/Zpo19hbB3EhPBg73e0VYkJ++/4QZ7PZTxzqZNk2rVqlaqVOmiRZsHBeH6Ib2nR4/GsF/o1Mljba5ZYCCsaqlSlf38RPm5jh1l41ujot7v3t2+Cce1wdIiIyc0a4ZrFfi/LyYGhf9r71qgsyiyNCSEPEhCSAghITwChLAQkgAJkASNAYkEEwgEiBDeOpAIs7MzHII6OGd3XGA9O8jhsB7dBZkROLODOoAoiAqLOjKwMgLrsOKCPEZYwQeCj6CA0vvRNalTqe6u9J/6i3Rn6zv3cDrVVbf63u771b3VHQKxcvTx6dPxwAtWL5yKCA19d+pU6yki/zl5MsTa/v706actf3sWXvoP5u9Ta7kNovmxOYIMC0GbHBWFaOwSGZkYGZkQEREfERHbvj088GBm5hcNSQcCNbRtW6ugndP54YwZIW3bgh9/VViIHA0k+LOcnKVDhtQNGUJzEHDi6NTUopSUkcnJI5KS8rp0GZyYmJWQsHfCBOtFIvEJDw1tMo/DjLhgcryqsHBGRsY7U6ZM7tPngBm3VxcsiAsPvzB37m9Gj149ciQne5h5/zJr1sGGUHfJjyCd8l69fpGX90Pjv7AM2V9ZCUajgnx8W2kp1+e/p03DXYDfQEB/mDQJ8qMBA7AkkOM/TZ1KGS09Lu7fS0pu1Nbuq6iANqj6bUnJhlGjkB7SpYVoOzVz5vk5c0BqPWJiesbE4CApKqqneUx6grnW3nnnU0VF64qLl48Ygdu9YsQI3Kx/GDbs57m51BB4DFcFjsYteH7s2PXFxSD33C5d0Plqwx+MhmAIFkXOLsNc2OhNoQLl8NX4tDTuD3lrUSeaHx0FdeVJy1+aJ4LAA+9sHjMGUffcPff8vrR0+7hxIIVZGRmp0dFsQpHdufOjubl/njaNFbSgndM5vV8/BCFoBZQxqXfvqvR0MC/igfvr7O4FwRnVrp1TLIEOfldSAi7GLIXJyT/JzgZ3fDR7NobAcLqFuunuu5FO4gAZMTIssDMVrApsUoaeVQ0pp0t+BAsjs7O2Q5Cc0onSYmPBI6Qd6TNbQcO667W1E9LSbIX+DftO4eHIvLBowcMZcXE5nTtjdbmrW7exPXocZpI7kiSO6d4djzHxG6zY1zhlw+z0wrBKoScIrrJPn6l9+05LT6f8CLqEf0CvWDjzu3ZFFoxnCcvJkMREkDXYn3T7u+xsUCGrnwjoGwRtbYegnkD+bm3XokI0PzoKiCwzPn4DU6Y1KZPNOGFbwIPINbhuaOH4EVGHuvXYtGm0BbGNxI0tzVCIIZZAwSi3kSjVZGYuGjQIvPbT7GykmdYUDHE+3S72iIDvEKsIXcwL0kE5CWZEzgVVo1JTSR/o/JtOnUA0pD9Mw3pABdmQgB9jwsJgIxFrsgzZVVbWPTr6RgOFCQQVLkgBB6j6kc39xbKZ8EF1NXiWE7pnCkHC/l/MjwJBogq74PlBCQm4cliBVQEH4GtrZ6SEeODJBiUq9Ev33891ABez+TuSStAusk6y5EAeGDBg4aBB3CjImVmzoNl27xLrJVh+Z1mZ9ZSWoIvmx4XXampQMdkKiKNDWBiY6JrzHhOrB3H1r+a+PhU3/IhgQJ3+98OGsX2QlvaKiWH3vI5WVf04KwuciMqrNjMTETt/4EAEGLK/6LAwbrvqk3nzQAqEv05UV2O6zyzRC/mn/PzShvoOuRLqawwMCwlBFYkW1KHIgAg/IuVZaVb9rLCTcvyI3Or49OlEwF/WqZFSgfis7WAQLANUkL6hG/wDq5GRofYn3eAflK5t27RBtgszhyUl4WqpFKWkoKolPXFf8Fj+j901UGG11S9YgKQP/UF/yDFxCgfUe/gxOSoKNN05IqKjuZ2CdSWkLYbeAkv3YGR4ku60QPp36vR7c5eA1gRIOWlqzEl8RATcaG2H/HL48HF2VbmWoIvmx1srvzX7IPK3WVmgHjyLV1x8soOaCLkYfe1LxA0/IqFAgcZSIY6Rxbh8yYP6bk7//lzjWjPVInGIVBRJ0CK7PAWz/FtxMTmGmaBLw2Qu1H2G+f4BoQh+BPeBm5JMXmAFHEEpMtD6OqVDB+uWomHSGaiNCGhxd3k5+BEchKTJmjnCjWA0ZN8k0cOK0js2FgdgLsJEkK/mz8djSXYP/8xk6FYh2nAAfsRSAR8ifcYzgIPt48aRPv87Zw5yTLD2HyZNwgE0I6/HhYFA65mNRcN8KTTeXFqogMQ3Nd4ORkrOrYtU8rp0WXPHHdZ2w3xNB+db27UEXTQ/OgqqGyRBy5hNd4Eg60FYWvfU3fAjhCsznywqQirq5suSg5MnI09ka0kiSCoJxxFB1oNc5kxjfkGKhMbPGzIj5ErkfTSIqbxXL9IICgA/risuRhJN80Ei0DYwPp5u0QbKj+1CQt6eNMnaTmVraWlWQsJNs75GEQo+/ZPlRTBltItz5yKVRg64d8IEOBO0TjM+rG2kVsU1YwFjX4I7aQM/Pjx0KObFPZ3dvz8OuNdc38yfD/PBldB80a4K/q6mpktk5NbGC8CY7t258gLKlw4ZgoNfjx7NvcSf2Ls32VWwyoHJk5GxWt+nawm6aH50FGQub02caG23CsgRdNA9Otq6A+WSH1kBJSHO3ex7IhtCJLM8SOSj2bNR73Fskt+164+Yj4cMy8tTVH/Wl92EH8G/CHXYCEG39Lg4HGAxQL5JaShQfkQ+SEtgq5yaORMpEnkhDnrCpYLi4WGO3eBGJI+TevfGqYKuXbEqZMTFdevQAQd0VfvazB+R4v3LnXdiwbPOxWqj/IhlA4UFGA36cQAhfIQDFMVYVzqEhZGa+qfZ2dbEFnyHS0L+vmfCBDj5zpSU6n79kNv+Y+OaYMngwTMzMq4uWBDZrh35YIAKbta8hu+6OEFqDOXWdi1BF82PUoIAQNymxcb2iIkhe3acIORmZWQgWlhBiy0/3jQ/SEaO4/RWlwpo4hd5eQhRxCqXeyJzQcGO6zlSVfXa+PGbx4xZPXLkI0OHFqWkIKo/auAXjEqOiqJFKEIUZ63rAeFHtgXabAv/QPlxer9+P7EwOxHwfmp0NOiM/Ej40TBf3cKuo1VVtCfcCA7dVVYG2vrnggJ0u2kmy+hGvyQl+4/Ic39XUhLbvj0ccn7OHPRHXokckN0bJdpwMDgxkXzTwwqp0FHz3pGSQkrpY9OmQXNxt25I4af07cuyJNhtrXn9ncLDcVWYFE5DCoz+yNPfbPAzFqQB8fE427djRy4fRF0/rcGfnPwsJ4d+napFqWh+bKYgtJaY4Qo6q83MdKqFEXLIg5DUsIIWKz+Cm5D1IHNc7fDRtWF+Y4jAw1ikh/h3yz33WPt0jYoieQ2CtnNEBNI9JE3gOPAFQvHHWVmk229LShCu12trEZzLcnMXDBwI7vjW8hrKyo9PWPgRdLOttBRpLCYir0fACKAY9oXJecsX4GCiuPBw9vUFkcNTp6Kd/PoKEcqPhrmpB4efqK5GhQu6RIGPZBZ8AaJZmZ+PfBYXjBJ7Z1kZKlm6FwxvgMtAQCtGjADzEv8QIOs0zHqZ04ZrBu0SbfsqKiBE2/Zx4+DhVYWFz4waNT4tbVhSErnmUampUe3avcEsMITvUGVjGUCmjCFYz34zejRqamS4hGGRpUaHhZFvJOlAIjABhM41GuZnrfEREVyyqUWR3CI0d3DV75Y6yxytUi7OnYvi61eFhbbbT1SQBNFXrlTQQpMjKhvvvhvxdtwuCaWCmhFVLSKN/RKIE9TCyIkQeNb9KZSKSxq2tEBzZPt/d3l5ac+ew5OSXrCEqNGYH8E4WA8SIyM3Ni7D/1hZicxRLH9s+OKPlbohQ8b26MF94AkbaSaOpKxfXBxYnqVLwkFIhFG0wsxP5s3DijK5T5/cLl2wGPTp2JEI1iHKj8j42E9ZL91/P348PXMmDkj2HZA2UCSK4om9e4O1P2FexyFrtn7nsL+ysqxXLzAviHh9w6swdh1COsyyqljgHNwssmWp5TaI5kctIkFiRctGBOfHc+dyL3lkBAp/OXw4Av6CwxoDusGMTl/p/38TeAm+gsfcvDDUEhTR/KilhQU1vpuvxLXAS/Q3grTcHtH8qEWLFi32ovlRixYtWuxF86MWLVq02IvmRy1atGixF82PWrRo0WIvwedHDQ0NjVYDnuMc4LZfi8O9SRoEYo+Jz2qwEPtKfFaDg7/c5Ztr9ZdbvQCxx8RnNViIfSU+q8HBX+7yzbX6y61egNhj4rMaLMS+Ep/V4OAvd/nmWv3lVi9A7DHxWQ0WYl+Jz2pw8Je7fHOt/nKrFyD2mPisBguxr8RnNTj4y12+uVZ/udVr0N4LIrQzZeAv7/nmWv3lVq9Bey+I0M6Ugb+855tr9ZdbvQbtvSBCO1MG/vKeb67VX271GrT3ggjtTBn4y3u+uVZ/udVr0N4LIrQzZeAv7/nmWv3lVq9Bey+I0M6Ugb+855tr9ZdbvQbtvSBCO1MG/vKeb67VX271GrT3ggjtTBn4y3tS13rgwIGcnJyQkJA2rQWwBRbBLt7UIOHq1at1dXXp6en8xK0RMBPGwmTeC0FC63v8nKAfy2YgKE6T4sfs7OwtW7bwrT4HLIJdfGuQUFVVVV1dffz4cf5EawTMhLHl5eX8iSChVT5+TtCPZTMg7zQpfgwLC/v+++/5Vp8DFsEuvjVIiIqKqq+v51tbL2CsOme2ysfPCfqxbAbknSbFj218tZXgHursUqfZs1BnsjrN3oQ6e9VpbnFImiY3WG5uz0KdXeo0exbqTFan2ZtQZ686zS0OSdPkBsvN7Vmos0udZs9CncnqNHsT6uxVp7nFIWma3GC5uT0LdXap0+xZqDNZnWZvQp296jS3OCRNkxssN7dnoc4udZo9C3Umq9PsTaizV53mFoekaXKD5eb2LNTZpU6zZ6HOZHWavQl19qrT3OKQNE1usNzcnoU6u9Rp9izUmaxOszehzl51mlsckqbJDZab27NQZ5c6zZ6FOpPVafYm1NmrTnOLQ9I0ucGWuX/44YeTDrh8+fLmzZv379/PDVGBZ5999tChQ3yrCVzh66+/furUKf4EA6tdwYI6zSzc2HjboM5kdZopjh07tmPHjnfffRcu5c/ddqiz11azF2JZEMiGu7tja5p7yA22zH3lypWODYiIiAgNDaU/rl27dvTo0StXruSGqEBhYSGm4xo/+OCDxYsX9+zZE5e9bt067iwLq13BgjrNBO5tdAOEAd8UONSZrE6zYf5K8r333puYmDhmzJjk5OSCgoLPP/+c7+QafvSkF2LZNpCNQO6OrWnuITdYOPdjjz0G89iW2+NTw8Gtb7311vLly99555309HQxd4jtkoE6zQTubWwSuFOLFi3iWwOHOpPVaQaWLFkyYsSIb775xjB/SzI3N7e2tpbv5A6twJMtFcu2gWwEcneaNE0MucHCuZ18imT48OHDyHTYU59++mm9iT179ty8eRMt3377LRL4N954g3iBAkvH22+/feTIEe53b7/++us333wT1IDhTm4lyMjIEHOH2C4ZiDU7mfbdd98dPHhw9+7dX3zxhbiRQmAjcTVGYTicZpiuht/YFfjLL7+cY+LcuXOnT5++dOkSOxyZBf2xSYhNloFAc0CetG3H88P+1y/Lli0bPnw4/ZGiSWeynsTxZ5991mxnCuyVRJOa3ceyNZCNAGPZTSC7vDuGC9PEkBssnNvWpzU1NdnZ2Tk5OTExMZWVlfQUej7zzDODBg3q06cPfjx06FBaWlppaWlFRUVqaioePtJt7969SUlJSKqzsrLy8vKou+Gsrl27QklJSUlxcXFmZqatWwkE3EEgtksGAs1OpuHpQTIIp40dOxalzdatW50aWQhshJdwF+DnwYMHY0aknAMGDMjPz4+Ojt62bRvps379+hQTRUVFWJnj4uLOnz+P9vfffx/TISQaaRRCYLIknDQH5ElBOwXCG0/sgw8+yLUbLpzJehLHL7zwQrOd6WSvPJrU7D6WuUA2AozlgAKZQHB3DBemiSE3WDi3rU/xQOBxxPGHH34YEhJy9OhRcgo9CwoKXnrpJRxfv369Z8+eTzzxBDn11FNP9evXj2zBrlq1Ck8YDrC2IMF++umnSX8834888gjpv2/fvnbt2gncKuAOArFdMhBotjUN6yqes4ULF5I+r7322n333Wfb2KDmrxDYCFf379+f7IjhqY2MjCR3ZM2aNYht2m2hCXI8f/58cMeNGzdQyKxevZr2cQOByZJw0uzek4J2irNnz0LJ0KFD2byPwo0zWU8aEs50slceTWp2H8tsIBsBxnKggWw0dXcMF6aJITdYOLetT5csWUJ/7NatG01Y0HPq1KnkGKk4NMNfvzYBn+LHEydOkLOoXJC6b9y4EcvLww8/jJb33nsPHdiKCcuRwK0C7iAQ2yUDsWaraVhsMYTbe7Zt5CCwEa6mO0cPPfQQFnByjEonPDycdmOjGnUQon3kyJHjxo2jRZNLiE2WgUCzS08K2gkQwAkJCYsXL0YBzp8z4caZHD8225kCeyXRpGb3scwGshFgLAcayE3eHcOFaWLIDRbObetTdk8XC8vzzz9PjtET6wk5fvnll/Fs/bwxTp8+jVNwIu4EVuDly5ffddddS5cuReOuXbvat2/foPWv2gRuFXAHgdguGQg025q2c+dOpCRcT9tGDgIb4RyatsCxEyZMIMcobUJDQ2k3LqpXrFiBi9++fTttcQmByZJw0uzek4J2AFlPr169aD1oCzfO5DxpNNeZTvbKo0nN7mOZDWQjwFgOKJDd3B3DhWliyA0Wzu3ep0bj5+zkyZPQfObMGdqTbN+eOnWKbZ85cyZ59I8dO4Z2ukmMygWandxqCLmDQGyXDJw0O5kGo9DO/sfOV65csW2kxwQCG92EtNE4quFhLNSPP/549+7dnQoZJziZLA9bzQF5UtD+4osv4in6+OOPabst3DiT48dmO9PW3qCgSc3uY5l1iBFgLLsPZJd3x3Bhmhhyg4Vzu/epYXFreXk5lpSLFy/i+PDhw6hHkHWfO3cuJCSEfC/66quvxsXF0U3ZgoIClDZfffXVtWvX0BgbG2vrVgIBdxCI7ZKBk2aBaSUlJfn5+WfPnkUthgoFayZstG1kFVptrKmp2bBhg+EupIG6urrKyko8zefPn4f/16xZg8YZM2ZMnDiR9nEDJ5PlYas5UE/atqNew8P56KOP7msMood60nDnTOpJsGF9fX2znWlrb1DQpGb3scwFshFgLLsJZNwmwd3h0KRpYsgNFs795JNPVlVVsS2zZs0im+UERUVFr7zyCjlGTzya9NTly5cfeOCB+Pj4pKQkOJR2g7M6derUuXPnsrKyHTt2UP0XLlzAbejQoUNycjKKl0WLFm3atIlq44B4eO655/hWBmK7ZCDQ7GQa0pl58+bhQUGdkpeXR1532jaysNqIbnikjMauRpGCaCfHR44cAas2dL/1I3nxOmXKlIqKCrJThvuSm5sbUGEoMFkSTpoD8qRtO3lpYwXpTz1puHMm9SSeSdSSzXamk73yaFKz+1jmAtkIMJbdBLL47nBo0jQx5AbLze0G1p1XPFtcrkSBhDygDW8nqLNLrFlgGmB7yrbxNuCyHfhOJsQmy0CguRmeNJzbVYP3owm+k9BeSajTzMJ9LAcrkA1p0+QGy83tWaizS53m24xqO/CdTKgzWZ3m2wzejyb4TirtVae5xSFpmtxgubk9C3V2qdPsWagzWZ1mb0Kdveo0tzgkTZMbLDe3Z6HOLnWaPQt1JqvT7E2os1ed5haHpGlyg+Xm9izU2aVOs2ehzmR1mr0Jdfaq09zikDRNbrDc3J6FOrvUafYs1JmsTrM3oc5edZpbHJKmyQ2Wm9uzUGeXOs2ehTqT1Wn2JtTZq05zi0PSNLnBcnN7FursUqfZs1BnsjrN3oQ6e9VpbnFImiY1OCwsjPv/9VoBYBHs4luDBGiur6/nW1svYGxUVBTfGiS0ysfPCfqxbAbknSbFj9nZ2Vu2bOFbfQ5YBLv41iChvLy8urqa/W3fVgyYCWO537sIIlrl4+cE/Vg2A/JOk+LHAwcO5OTkhISEtGktgC2wiP2viYOLq1ev1tXVpaen8xO3RsBMGAuTeS8ECa3v8XOCfiybgaA4TYofNTQ0NFoxND9qaGho2EPzo4aGhoY9ND9qaGho2OP/AKO7iEE1pg4GAAAAAElFTkSuQmCC" />
</p>
<p>下記のBankAccount::transfer_ok()は、std::scoped_lockを使用して前述したデッドロックを回避したものである。</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/lock_ownership_wrapper_ut.cpp 225</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> transfer_ok<span class="op">(</span>BankAccount<span class="op">&amp;</span> to<span class="op">,</span> <span class="dt">int</span> amount<span class="op">)</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>scoped_lock lock<span class="op">{</span><span class="va">mtx_</span><span class="op">,</span> to<span class="op">.</span><span class="va">mtx_</span><span class="op">};</span>  <span class="co">// 複数のmutexを安全にロック</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// デッドロック回避アルゴリズムにより、常に同じ順序でロックを取得</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="va">balance_</span> <span class="op">&gt;=</span> amount<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>            <span class="va">balance_</span> <span class="op">-=</span> amount<span class="op">;</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>            to<span class="op">.</span><span class="va">balance_</span> <span class="op">+=</span> amount<span class="op">;</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h2 id="スマートポインタ">スマートポインタ <a id="SS_7_5"></a></h2>
<p>スマートポインタは、C++標準ライブラリが提供するメモリ管理クラス群を指す。
生のポインタの代わりに使用され、リソース管理を容易にし、
メモリリークや二重解放といった問題を防ぐことを目的としている。</p>
<p>スマートポインタは通常、所有権とスコープに基づいてメモリの解放を自動的に行う。
C++標準ライブラリでは、主に以下の3種類のスマートポインタが提供されている。</p>
<ul>
<li><a href="stdlib_and_concepts.html#SS_7_5_1">std::unique_ptr</a>
<ul>
<li><a
href="stdlib_and_concepts.html#SS_7_5_1_1">std::make_unique</a></li>
</ul></li>
<li><a href="stdlib_and_concepts.html#SS_7_5_2">std::shared_ptr</a>
<ul>
<li><a
href="stdlib_and_concepts.html#SS_7_5_2_1">std::make_shared</a></li>
<li><a
href="stdlib_and_concepts.html#SS_7_5_2_2">std::enable_shared_from_this</a></li>
<li><a href="stdlib_and_concepts.html#SS_7_5_3">std::weak_ptr</a></li>
</ul></li>
<li><a href="stdlib_and_concepts.html#SS_7_5_4">std::auto_ptr</a></li>
</ul>
<h3 id="stdunique_ptr">std::unique_ptr <a id="SS_7_5_1"></a></h3>
<p>std::unique_ptrは、C++11で導入されたスマートポインタの一種であり、std::shared_ptrとは異なり、
<a
href="cpp_idioms.html#SS_8_4_1">オブジェクトの排他所有</a>を表すために用いられる。所有権は一つのunique_ptrインスタンスに限定され、
他のポインタと共有することはできない。ムーブ操作によってのみ所有権を移譲でき、
スコープを抜けると自動的にリソースが解放されるため、メモリ管理の安全性と効率性が向上する。</p>
<h4 id="stdmake_unique">std::make_unique <a id="SS_7_5_1_1"></a></h4>
<p><a
href="https://cpprefjp.github.io/reference/memory/make_unique.html">std::make_unique&lt;T&gt;(Args…)</a>は、
クラスTをダイナミックに生成し、そのポインタを保持するshared_ptrオブジェクトを生成する。</p>
<p>使用例については、「<a
href="cpp_idioms.html#SS_8_4_1">オブジェクトの排他所有</a>」を参照せよ。</p>
<h3 id="stdshared_ptr">std::shared_ptr <a id="SS_7_5_2"></a></h3>
<p>std::shared_ptrは、同じくC++11で導入されたスマートポインタであり、<a
href="cpp_idioms.html#SS_8_4_2">オブジェクトの共有所有</a>を表すために用いられる。
複数のshared_ptrインスタンスが同じリソースを参照でき、
内部の参照カウントによって最後の所有者が破棄された時点でリソースが解放される。
<a
href="stdlib_and_concepts.html#SS_7_5_3">std::weak_ptr</a>は、shared_ptrと連携して使用されるスマートポインタであり、オブジェクトの非所有参照を表す。
参照カウントには影響せず、循環参照を防ぐために用いられる。weak_ptrから一時的にshared_ptrを取得するにはlock()を使用する。</p>
<h4 id="stdmake_shared">std::make_shared <a id="SS_7_5_2_1"></a></h4>
<p><a
href="https://cpprefjp.github.io/reference/memory/make_shared.html">std::make_shared&lt;T&gt;(Args…)</a>は、
クラスTをダイナミックに生成し、そのポインタを保持するshared_ptrオブジェクトを生成する。</p>
<p>使用例については、「<a
href="cpp_idioms.html#SS_8_4_2">オブジェクトの共有所有</a>」を参照せよ。</p>
<h4 id="stdenable_shared_from_this">std::enable_shared_from_this
<a id="SS_7_5_2_2"></a></h4>
<p><code>std::enable_shared_from_this</code>は、<code>shared_ptr</code>で管理されているオブジェクトが、
自分自身への<code>shared_ptr</code>を安全に取得するための仕組みである。</p>
<p>この<code>std::enable_shared_from_this</code>が存在しない場合に発生するであろう問題のあるコードを以下に示す。</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/enable_shared_from_this_ut.cpp 7</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> register_self<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;&gt;&amp;</span> vec<span class="op">)</span> <span class="op">{</span> vec<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;{</span><span class="kw">this</span><span class="op">});</span> <span class="op">}</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb39"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/enable_shared_from_this_ut.cpp 17</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sp1 <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>A<span class="op">&gt;();</span>  <span class="co">// Aのポインタを管理するshared_ptr(sp1)が作られる</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>                                       <span class="co">// sp1が管理するポインタを便宜上、sp1_pointerと呼ぶことにする</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;&gt;</span> vec<span class="op">;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    sp1<span class="op">-&gt;</span>register_self<span class="op">(</span>vec<span class="op">);</span>  <span class="co">// vecに登録されるのはsp1_pointerを管理するshared_ptrであるが、</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>                              <span class="co">// vecに保持された「sp1_pointerを管理するshared_ptr」は、</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>                              <span class="co">// sp1と個別に生成されたため、sp1とuseカウンタを共有しない</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ここまで来ると、</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// * sp1がスコープアウトするため、sp1がsp1_pointerを解放する。</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// * vecがスコープアウトするため、vecが保持するshared_ptrが、sp1_pointerを解放する。</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 以上によりsp1_pointer二重解放されるため、未定義動作につながる</span></span></code></pre></div>
<p>std::enable_shared_from_thisを継承し、<code>shared_from_this()</code>メソッドを使用し、この問題を解決したコード例を以下に示す。</p>
<p>std::enable_shared_from_thisは、内部にweak_ptrメンバを持っている。shared_ptrでオブジェクトが初めて管理される際、
shared_ptrのコンストラクタがenable_shared_from_thisの存在を検出し、内部のweak_ptrに制御ブロックへの参照を設定する。</p>
<p><code>shared_from_this()</code>メソッドはこの内部のweak_ptrをlock()することで、
元のshared_ptrと制御ブロックを共有する新しいshared_ptrを生成する。
これにより、同一オブジェクトへの複数のshared_ptrが正しく参照カウントを共有できる。</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/enable_shared_from_this_ut.cpp 38</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> A <span class="op">:</span> <span class="kw">public</span> <span class="bu">std::</span>enable_shared_from_this<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> register_self<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;&gt;&amp;</span> vec<span class="op">)</span> <span class="op">{</span> vec<span class="op">.</span>push_back<span class="op">(</span>shared_from_this<span class="op">());</span> <span class="op">}</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb41"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/enable_shared_from_this_ut.cpp 48</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sp1 <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>A<span class="op">&gt;();</span>  <span class="co">// Aのポインタを管理するstd::shread_ptr(sp1)が作られる</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>                                       <span class="co">// sp1が管理するポインタを便宜上、sp1_pointerと呼ぶことにする</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>A<span class="op">&gt;&gt;</span> vec<span class="op">;</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    sp1<span class="op">-&gt;</span>register_self<span class="op">(</span>vec<span class="op">);</span>  <span class="co">// shared_from_this()により、</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>                              <span class="co">// sp1と同じuseカウンタを共有する新しいshared_ptrが生成されvecに格納される。</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// スコープアウト時には参照カウントが正しく管理されているため、</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 最後のshared_ptrが破棄されるまでオブジェクトは解放されない</span></span></code></pre></div>
<p><strong>[使用上の注意点]</strong></p>
<ol type="1">
<li>コンストラクタ内での使用禁止<br />
コンストラクタ内でshared_from_this()を呼び出してはならない。なぜなら、コンストラクタ実行時点ではまだshared_ptrによる管理が完了しておらず、内部のweak_ptrが初期化されていないためである。この場合、std::bad_weak_ptr例外がスローされる。</li>
<li>shared_ptrでの管理が必須<br />
オブジェクトがshared_ptrで管理されていない状態(例えばスタック上のオブジェクトや生のnew)でshared_from_this()を呼び出すと、std::bad_weak_ptr例外がスローされるか、未定義動作となる。</li>
<li>make_sharedの使用推奨<br />
std::enable_shared_from_thisを継承したクラスのインスタンスは、必ずstd::make_sharedまたはshared_ptrのコンストラクタで生成する必要がある。</li>
</ol>
<p>C++17以降では、<code>weak_from_this()</code>メソッドも提供されている。これはshared_from_this()と同様の仕組みだが、
weak_ptrを返すため<a
href="cpp_idioms.html#SS_8_4_3">オブジェクトの循環所有</a>を避けたい場合に有用である。</p>
<h3 id="stdweak_ptr">std::weak_ptr <a id="SS_7_5_3"></a></h3>
<p>std::weak_ptrは、スマートポインタの一種である。</p>
<p>std::weak_ptrは参照カウントに影響を与えず、<a
href="stdlib_and_concepts.html#SS_7_5_2">std::shared_ptr</a>とオブジェクトを共有所有するのではなく、
その<code>shared_ptr</code>インスタンスとの関連のみを保持するのため、<a
href="cpp_idioms.html#SS_8_4_3">オブジェクトの循環所有</a>の問題を解決できる。</p>
<p><a
href="cpp_idioms.html#SS_8_4_3">オブジェクトの循環所有</a>で示した問題のあるクラスの修正版を以下に示す
(以下の例では、Xは前のままで、Yのみ修正した)。</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/weak_ptr_ut.cpp 9</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Y<span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> X <span class="kw">final</span> <span class="op">{</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> X<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="op">++</span>constructed_counter<span class="op">;</span> <span class="op">}</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>X<span class="op">()</span> <span class="op">{</span> <span class="op">--</span>constructed_counter<span class="op">;</span> <span class="op">}</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> Register<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Y<span class="op">&gt;</span> y<span class="op">)</span> <span class="op">{</span> <span class="va">y_</span> <span class="op">=</span> y<span class="op">;</span> <span class="op">}</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Y<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> ref_y<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">y_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 自身の状態を返す (&quot;X alone&quot; または &quot;X with Y&quot;)</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string WhoYouAre<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// y_が保持するオブジェクトの状態を返す (&quot;None&quot; またはY::WhoYouAre()に委譲)</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string WhoIsWith<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="dt">uint32_t</span> constructed_counter<span class="op">;</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>Y<span class="op">&gt;</span> <span class="va">y_</span><span class="op">{};</span>  <span class="co">// 初期化状態では、y_はオブジェクトを所有しない(use_count()==0)</span></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Y <span class="kw">final</span> <span class="op">{</span></span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> Y<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="op">++</span>constructed_counter<span class="op">;</span> <span class="op">}</span></span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>Y<span class="op">()</span> <span class="op">{</span> <span class="op">--</span>constructed_counter<span class="op">;</span> <span class="op">}</span></span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> Register<span class="op">(</span><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>X<span class="op">&gt;</span> x<span class="op">)</span> <span class="op">{</span> <span class="va">x_</span> <span class="op">=</span> x<span class="op">;</span> <span class="op">}</span></span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>weak_ptr<span class="op">&lt;</span>X<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> ref_x<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 自身の状態を返す (&quot;Y alone&quot; または &quot;Y with X&quot;)</span></span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string WhoYouAre<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// x_が保持するオブジェクトの状態を返す (&quot;None&quot; またはY::WhoYouAre()に委譲)</span></span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string WhoIsWith<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="dt">uint32_t</span> constructed_counter<span class="op">;</span></span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-42"><a href="#cb42-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb42-43"><a href="#cb42-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>weak_ptr<span class="op">&lt;</span>X<span class="op">&gt;</span> <span class="va">x_</span><span class="op">{};</span></span>
<span id="cb42-44"><a href="#cb42-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb42-45"><a href="#cb42-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-46"><a href="#cb42-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Xのメンバ定義</span></span>
<span id="cb42-47"><a href="#cb42-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string X<span class="op">::</span>WhoYouAre<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">y_</span> <span class="op">?</span> <span class="st">&quot;X with Y&quot;</span> <span class="op">:</span> <span class="st">&quot;X alone&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb42-48"><a href="#cb42-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string X<span class="op">::</span>WhoIsWith<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">y_</span> <span class="op">?</span> <span class="va">y_</span><span class="op">-&gt;</span>WhoYouAre<span class="op">()</span> <span class="op">:</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;None&quot;</span><span class="op">};</span> <span class="op">}</span></span>
<span id="cb42-49"><a href="#cb42-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span>    X<span class="op">::</span>constructed_counter<span class="op">;</span></span>
<span id="cb42-50"><a href="#cb42-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-51"><a href="#cb42-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Yのメンバ定義</span></span>
<span id="cb42-52"><a href="#cb42-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string Y<span class="op">::</span>WhoYouAre<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span><span class="op">.</span>use_count<span class="op">()</span> <span class="op">!=</span> <span class="dv">0</span> <span class="op">?</span> <span class="st">&quot;Y with X&quot;</span> <span class="op">:</span> <span class="st">&quot;Y alone&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb42-53"><a href="#cb42-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 注: weak_ptrはbool変換をサポートしないため、use_count() != 0 で有効性を判定</span></span>
<span id="cb42-54"><a href="#cb42-54" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string Y<span class="op">::</span>WhoIsWith<span class="op">()</span> <span class="at">const</span>  <span class="co">// 修正版Y::WhoIsWithの定義</span></span>
<span id="cb42-55"><a href="#cb42-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb42-56"><a href="#cb42-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> x <span class="op">=</span> <span class="va">x_</span><span class="op">.</span>lock<span class="op">();</span> x<span class="op">)</span> <span class="op">{</span>  <span class="co">// Xオブジェクトが解放されていた場合、xはstd::shared_ptr&lt;X&gt;{}となり、falseと評価される</span></span>
<span id="cb42-57"><a href="#cb42-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x<span class="op">-&gt;</span>WhoYouAre<span class="op">();</span></span>
<span id="cb42-58"><a href="#cb42-58" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb42-59"><a href="#cb42-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb42-60"><a href="#cb42-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;None&quot;</span><span class="op">;</span></span>
<span id="cb42-61"><a href="#cb42-61" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb42-62"><a href="#cb42-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-63"><a href="#cb42-63" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> Y<span class="op">::</span>constructed_counter<span class="op">;</span></span></code></pre></div>
<p>このコードからわかるように修正版YはXオブジェクトを参照するために、
<code>std::shared_ptr&lt;X&gt;</code>の代わりに<code>std::weak_ptr&lt;X&gt;</code>を使用する。
Xオブジェクトにアクセスする必要があるときに、
下記のY::WhoIsWith()関数の内部処理のようにすることで、<code>std::weak_ptr&lt;X&gt;</code>オブジェクトから、
それと紐づいた<code>std::shared_ptr&lt;X&gt;</code>オブジェクトを生成できる。</p>
<p>なお、上記コードは<a
href="core_lang_spec.html#SS_6_9_5_3">初期化付きif文</a>を使うことで、
生成した<code>std::shared_ptr&lt;X&gt;</code>オブジェクトのスコープを最小に留めている。</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/weak_ptr_ut.cpp 63</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string Y<span class="op">::</span>WhoIsWith<span class="op">()</span> <span class="at">const</span>  <span class="co">// 修正版Y::WhoIsWithの定義</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> x <span class="op">=</span> <span class="va">x_</span><span class="op">.</span>lock<span class="op">();</span> x<span class="op">)</span> <span class="op">{</span>  <span class="co">// Xオブジェクトが解放されていた場合、xはstd::shared_ptr&lt;X&gt;{}となり、falseと評価される</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> x<span class="op">-&gt;</span>WhoYouAre<span class="op">();</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;None&quot;</span><span class="op">;</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Xと修正版Yの単体テストによりメモリーリークが修正されたことを以下に示す。</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/weak_ptr_ut.cpp 82</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>X<span class="op">::</span>constructed_counter<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>Y<span class="op">::</span>constructed_counter<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> x0 <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>X<span class="op">&gt;();</span>       <span class="co">// Xオブジェクトを持つshared_ptrの生成</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>X<span class="op">::</span>constructed_counter<span class="op">,</span> <span class="dv">1</span><span class="op">);</span>  <span class="co">// Xオブジェクトは1つ生成された</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>x0<span class="op">.</span>use_count<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>x0<span class="op">-&gt;</span>WhoYouAre<span class="op">(),</span> <span class="st">&quot;X alone&quot;</span><span class="op">);</span>  <span class="co">// x0.y_は何も保持していないので、&quot;X alone&quot;</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>x0<span class="op">-&gt;</span>ref_y<span class="op">().</span>use_count<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// X::y_は何も持っていない</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> y0 <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>Y<span class="op">&gt;();</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>Y<span class="op">::</span>constructed_counter<span class="op">,</span> <span class="dv">1</span><span class="op">);</span>       <span class="co">// Yオブジェクトは1つ生成された</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>y0<span class="op">.</span>use_count<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>y0<span class="op">-&gt;</span>ref_x<span class="op">().</span>use_count<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span>      <span class="co">// y0.x_は何も持っていない</span></span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>y0<span class="op">-&gt;</span>WhoYouAre<span class="op">(),</span> <span class="st">&quot;Y alone&quot;</span><span class="op">);</span>      <span class="co">// y0.x_は何も持っていないので、&quot;Y alone&quot;</span></span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>            x0<span class="op">-&gt;</span>Register<span class="op">(</span>y0<span class="op">);</span>                           <span class="co">// これによりx0.y_はy0と同じオブジェクトを持つ</span></span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>x0<span class="op">-&gt;</span>WhoYouAre<span class="op">(),</span> <span class="st">&quot;X with Y&quot;</span><span class="op">);</span>     <span class="co">// x0.y_はYオブジェクトを持っている</span></span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a>            y0<span class="op">-&gt;</span>Register<span class="op">(</span>x0<span class="op">);</span>  <span class="co">// これによりy0.x_はx0と同じXオブジェクトを持つことができる</span></span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>y0<span class="op">-&gt;</span>WhoIsWith<span class="op">(),</span> <span class="st">&quot;X with Y&quot;</span><span class="op">);</span>     <span class="co">// y0.x_が持っているXオブジェクトはYを持っている</span></span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a>            <span class="co">// x0-&gt;Register(y0), y0-&gt;Register(x0)により Xオブジェクト、Yオブジェクトは相互参照できる状態となった</span></span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>X<span class="op">::</span>constructed_counter<span class="op">,</span> <span class="dv">1</span><span class="op">);</span>       <span class="co">// 新しいオブジェクトが生成されるわけではない</span></span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>Y<span class="op">::</span>constructed_counter<span class="op">,</span> <span class="dv">1</span><span class="op">);</span>       <span class="co">// 新しいオブジェクトが生成されるわけではない</span></span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>y0<span class="op">-&gt;</span>WhoYouAre<span class="op">(),</span> <span class="st">&quot;Y with X&quot;</span><span class="op">);</span>     <span class="co">// y0.x_はXオブジェクトを持っている</span></span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>x0<span class="op">-&gt;</span>WhoYouAre<span class="op">(),</span> <span class="st">&quot;X with Y&quot;</span><span class="op">);</span>     <span class="co">// x0.y_はYオブジェクトを持っている(再確認)</span></span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>y0<span class="op">-&gt;</span>WhoIsWith<span class="op">(),</span> <span class="st">&quot;X with Y&quot;</span><span class="op">);</span>     <span class="co">// y0が参照するXオブジェクトはYを持っている</span></span>
<span id="cb44-35"><a href="#cb44-35" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 現時点で、x0とy0がお互いを相互参照できることが確認できた</span></span>
<span id="cb44-36"><a href="#cb44-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-37"><a href="#cb44-37" aria-hidden="true" tabindex="-1"></a>            <span class="co">// weak_ptrを使用した効果によりXオブジェクトの参照カウントは増加しない</span></span>
<span id="cb44-38"><a href="#cb44-38" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>x0<span class="op">.</span>use_count<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span>               <span class="co">// y0.x_はweak_ptrなので参照カウントに影響しない</span></span>
<span id="cb44-39"><a href="#cb44-39" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>y0<span class="op">.</span>use_count<span class="op">(),</span> <span class="dv">2</span><span class="op">);</span>               <span class="co">// x0.y_はshared_ptrなので参照カウントが2</span></span>
<span id="cb44-40"><a href="#cb44-40" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>y0<span class="op">-&gt;</span>ref_x<span class="op">().</span>use_count<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span>      <span class="co">// y0.x_の参照カウントは1</span></span>
<span id="cb44-41"><a href="#cb44-41" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>x0<span class="op">-&gt;</span>ref_y<span class="op">().</span>use_count<span class="op">(),</span> <span class="dv">2</span><span class="op">);</span>      <span class="co">// x0.y_の参照カウントは2</span></span>
<span id="cb44-42"><a href="#cb44-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>  <span class="co">//ここでy0がスコープアウトするため、y0にはアクセスできないが、</span></span>
<span id="cb44-43"><a href="#cb44-43" aria-hidden="true" tabindex="-1"></a>           <span class="co">// x0を介して、y0が持っていたYオブジェクトにはアクセスできる</span></span>
<span id="cb44-44"><a href="#cb44-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-45"><a href="#cb44-45" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>x0<span class="op">-&gt;</span>ref_y<span class="op">().</span>use_count<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span>  <span class="co">// y0がスコープアウトしたため、Yオブジェクトの参照カウントが減った</span></span>
<span id="cb44-46"><a href="#cb44-46" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>x0<span class="op">-&gt;</span>ref_y<span class="op">()-&gt;</span>WhoYouAre<span class="op">(),</span> <span class="st">&quot;Y with X&quot;</span><span class="op">);</span>  <span class="co">// x0.y_はXオブジェクトを持っている</span></span>
<span id="cb44-47"><a href="#cb44-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// この次の行で、x0はスコープアウトし、以下の処理が実行される:</span></span>
<span id="cb44-48"><a href="#cb44-48" aria-hidden="true" tabindex="-1"></a>       <span class="co">//   1. x0のデストラクタが呼ばれ、x0.y_の参照カウントがデクリメント</span></span>
<span id="cb44-49"><a href="#cb44-49" aria-hidden="true" tabindex="-1"></a>       <span class="co">//   2. x0.y_の参照カウントが1→0になり、保持していたYオブジェクトを解放する</span></span>
<span id="cb44-50"><a href="#cb44-50" aria-hidden="true" tabindex="-1"></a>       <span class="co">//   3. Yオブジェクトのデストラクタ内でy_.x_(weak_ptr)が破棄されるが、weak_ptrなのでXオブジェクトの参照カウントには影響しない</span></span>
<span id="cb44-51"><a href="#cb44-51" aria-hidden="true" tabindex="-1"></a>       <span class="co">//   4. x0本体のデストラクタが完了し、Xオブジェクトの参照カウントが1→0になり、Xオブジェクトも解放される</span></span>
<span id="cb44-52"><a href="#cb44-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-53"><a href="#cb44-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 上記1-4によりダイナミックに生成されたオブジェクトは解放されたため、下記のテストが成立する</span></span>
<span id="cb44-54"><a href="#cb44-54" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>X<span class="op">::</span>constructed_counter<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb44-55"><a href="#cb44-55" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>Y<span class="op">::</span>constructed_counter<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<p>上記コード例で見てきたように<code>std::weak_ptr</code>を使用することで:</p>
<ul>
<li>循環参照によるメモリリークを防ぐことができる</li>
<li>必要に応じて<code>lock()</code>でオブジェクトにアクセスできる</li>
<li>オブジェクトが既に解放されている場合は<code>lock()</code>が空の<code>shared_ptr</code>を返すため、安全に処理できる</li>
</ul>
<h3 id="stdauto_ptr">std::auto_ptr <a id="SS_7_5_4"></a></h3>
<p><code>std::auto_ptr</code>はC++11以前に導入された初期のスマートポインタであるが、異常な<a
href="cpp_idioms.html#SS_8_5_2">copyセマンティクス</a>を持つため、
多くの誤用を生み出し、C++11から非推奨とされ、C++17から規格から排除された。</p>
<h2 id="polymorphic-memory-resourcepmr">Polymorphic Memory Resource(pmr)
<a id="SS_7_6"></a></h2>
<p>Polymorphic Memory Resource(pmr)は、
動的メモリ管理の柔軟性と効率性を向上させるための、C++17から導入された仕組みである。</p>
<p><a
href="stdlib_and_concepts.html#SS_7_6_2">std::pmr::polymorphic_allocator</a>はC++17で導入された標準ライブラリのクラスで、
C++のメモリリソース管理を抽象化するための機能を提供する。</p>
<p>例えば、std::vectorは以下のように宣言されていた。</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> std <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">,</span> <span class="kw">class</span> Allocator <span class="op">=</span> allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> vector<span class="op">;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>C++17では以下のエイリアスが追加された。</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> <span class="bu">std::</span>pmr <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> vector <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">,</span> polymorphic_allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;;</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>他のコンテナに関してもほぼ同様のエイリアスが追加された。</p>
<p>C++17で導入されたstd::pmr名前空間は、カスタマイズ可能なメモリ管理を提供し、
特に標準ライブラリのコンテナと連携して効率化を図るための統一フレームワークを提供する。
std::pmrは、
カスタマイズ可能なメモリ管理を標準ライブラリのデータ構造に統合するための統一的なフレームワークであり、
特に標準ライブラリのコンテナと連携して、動的メモリ管理を効率化することができる。</p>
<p>std::pmrは以下のようなメモリ管理のカスタマイズを可能にする。</p>
<ul>
<li>メモリアロケータをポリモーフィック(動的に選択可能)にする。</li>
<li>メモリ管理ポリシーをstd::pmr::memory_resourceで定義する。</li>
<li>メモリリソースを再利用して効率的な動的メモリ管理を実現する。</li>
</ul>
<p>std::pmrの主要なコンポーネントは以下の通りである。</p>
<ul>
<li><a
href="stdlib_and_concepts.html#SS_7_6_1">std::pmr::memory_resource</a><br />
</li>
<li><a
href="stdlib_and_concepts.html#SS_7_6_2">std::pmr::polymorphic_allocator</a><br />
</li>
<li><a href="stdlib_and_concepts.html#SS_7_6_3">pool_resource</a></li>
</ul>
<h3 id="stdpmrmemory_resource">std::pmr::memory_resource
<a id="SS_7_6_1"></a></h3>
<p>std::pmr::memory_resourceは、
ユーザー定義のメモリリソースをカスタマイズし、 <a
href="stdlib_and_concepts.html#SS_7_6_2">std::pmr::polymorphic_allocator</a>を通じて利用可能にする<a
href="core_lang_spec.html#SS_6_4_11">インターフェースクラス</a>である。</p>
<p>std::pmr::memory_resourceから派生した具象クラスの実装を以下に示す。</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/pmr_memory_resource_ut.cpp 64</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">uint32_t</span> MEM_SIZE<span class="op">&gt;</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> memory_resource_variable <span class="kw">final</span> <span class="op">:</span> <span class="kw">public</span> <span class="bu">std::</span>pmr::memory_resource <span class="op">{</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>        memory_resource_variable<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>            <span class="va">header_</span><span class="op">-&gt;</span>next    <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>            <span class="va">header_</span><span class="op">-&gt;</span>n_units <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span><span class="va">buff_</span><span class="op">)</span> <span class="op">/</span> Inner_<span class="op">::</span>unit_size<span class="op">;</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> get_count<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">unit_count_</span> <span class="op">*</span> Inner_<span class="op">::</span>unit_size<span class="op">;</span> <span class="op">}</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span>   is_valid<span class="op">(</span><span class="dt">void</span> <span class="at">const</span><span class="op">*</span> mem<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">(&amp;</span><span class="va">buff_</span> <span class="op">&lt;</span> mem<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>mem <span class="op">&lt;</span> <span class="op">&amp;</span><span class="va">buff_</span><span class="op">.</span>buffer<span class="op">[</span>ArrayLength<span class="op">(</span><span class="va">buff_</span><span class="op">.</span>buffer<span class="op">)]);</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="dt">header_t</span> <span class="op">=</span> Inner_<span class="op">::</span><span class="dt">header_t</span><span class="op">;</span></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>        Inner_<span class="op">::</span><span class="dt">buffer_t</span><span class="op">&lt;</span>MEM_SIZE<span class="op">&gt;</span> <span class="va">buff_</span><span class="op">{};</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">header_t</span><span class="op">*</span>                  <span class="va">header_</span><span class="op">{</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="dt">header_t</span><span class="op">*&gt;(</span><span class="va">buff_</span><span class="op">.</span>buffer<span class="op">)};</span></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>        <span class="at">mutable</span> SpinLock           <span class="va">spin_lock_</span><span class="op">{};</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span>                     <span class="va">unit_count_</span><span class="op">{</span><span class="kw">sizeof</span><span class="op">(</span><span class="va">buff_</span><span class="op">)</span> <span class="op">/</span> Inner_<span class="op">::</span>unit_size<span class="op">};</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span>                     <span class="va">unit_count_min_</span><span class="op">{</span><span class="kw">sizeof</span><span class="op">(</span><span class="va">buff_</span><span class="op">)</span> <span class="op">/</span> Inner_<span class="op">::</span>unit_size<span class="op">};</span></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span><span class="op">*</span> do_allocate<span class="op">(</span><span class="dt">size_t</span> size<span class="op">,</span> <span class="dt">size_t</span><span class="op">)</span> <span class="kw">override</span></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> n_units <span class="op">=</span> <span class="op">(</span>Roundup<span class="op">(</span>Inner_<span class="op">::</span>unit_size<span class="op">,</span> size<span class="op">)</span> <span class="op">/</span> Inner_<span class="op">::</span>unit_size<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> lock <span class="op">=</span> <span class="bu">std::</span>lock_guard<span class="op">{</span><span class="va">spin_lock_</span><span class="op">};</span></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> curr <span class="op">=</span> <span class="va">header_</span><span class="op">;</span></span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">header_t</span><span class="op">*</span> prev<span class="op">{</span><span class="kw">nullptr</span><span class="op">};</span> curr <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">;</span> prev <span class="op">=</span> curr<span class="op">,</span> curr <span class="op">=</span> curr<span class="op">-&gt;</span>next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> opt_next <span class="op">=</span> <span class="bu">std::</span>optional<span class="op">&lt;</span><span class="dt">header_t</span><span class="op">*&gt;{</span>sprit<span class="op">(</span>curr<span class="op">,</span> n_units<span class="op">)};</span></span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(!</span>opt_next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb47-43"><a href="#cb47-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-44"><a href="#cb47-44" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> next <span class="op">=</span> <span class="op">*</span>opt_next<span class="op">;</span></span>
<span id="cb47-45"><a href="#cb47-45" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>prev <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-46"><a href="#cb47-46" aria-hidden="true" tabindex="-1"></a>                    <span class="va">header_</span> <span class="op">=</span> next<span class="op">;</span></span>
<span id="cb47-47"><a href="#cb47-47" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb47-48"><a href="#cb47-48" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb47-49"><a href="#cb47-49" aria-hidden="true" tabindex="-1"></a>                    prev<span class="op">-&gt;</span>next <span class="op">=</span> next<span class="op">;</span></span>
<span id="cb47-50"><a href="#cb47-50" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb47-51"><a href="#cb47-51" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb47-52"><a href="#cb47-52" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb47-53"><a href="#cb47-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-54"><a href="#cb47-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>curr <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-55"><a href="#cb47-55" aria-hidden="true" tabindex="-1"></a>                <span class="va">unit_count_</span> <span class="op">-=</span> curr<span class="op">-&gt;</span>n_units<span class="op">;</span></span>
<span id="cb47-56"><a href="#cb47-56" aria-hidden="true" tabindex="-1"></a>                <span class="va">unit_count_min_</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span><span class="va">unit_count_</span><span class="op">,</span> <span class="va">unit_count_min_</span><span class="op">);</span></span>
<span id="cb47-57"><a href="#cb47-57" aria-hidden="true" tabindex="-1"></a>                <span class="op">++</span>curr<span class="op">;</span></span>
<span id="cb47-58"><a href="#cb47-58" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb47-59"><a href="#cb47-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-60"><a href="#cb47-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>curr <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-61"><a href="#cb47-61" aria-hidden="true" tabindex="-1"></a>                <span class="cf">throw</span> <span class="bu">std::</span>bad_alloc<span class="op">{};</span></span>
<span id="cb47-62"><a href="#cb47-62" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb47-63"><a href="#cb47-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-64"><a href="#cb47-64" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> curr<span class="op">;</span></span>
<span id="cb47-65"><a href="#cb47-65" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-66"><a href="#cb47-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-67"><a href="#cb47-67" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> do_deallocate<span class="op">(</span><span class="dt">void</span><span class="op">*</span> mem<span class="op">,</span> <span class="dt">size_t</span><span class="op">,</span> <span class="dt">size_t</span><span class="op">)</span> <span class="kw">noexcept</span> <span class="kw">override</span></span>
<span id="cb47-68"><a href="#cb47-68" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb47-69"><a href="#cb47-69" aria-hidden="true" tabindex="-1"></a>            <span class="dt">header_t</span><span class="op">*</span> to_free <span class="op">=</span> Inner_<span class="op">::</span>set_back<span class="op">(</span>mem<span class="op">);</span></span>
<span id="cb47-70"><a href="#cb47-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-71"><a href="#cb47-71" aria-hidden="true" tabindex="-1"></a>            to_free<span class="op">-&gt;</span>next <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb47-72"><a href="#cb47-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-73"><a href="#cb47-73" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> lock <span class="op">=</span> <span class="bu">std::</span>lock_guard<span class="op">{</span><span class="va">spin_lock_</span><span class="op">};</span></span>
<span id="cb47-74"><a href="#cb47-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-75"><a href="#cb47-75" aria-hidden="true" tabindex="-1"></a>            <span class="va">unit_count_</span> <span class="op">+=</span> to_free<span class="op">-&gt;</span>n_units<span class="op">;</span></span>
<span id="cb47-76"><a href="#cb47-76" aria-hidden="true" tabindex="-1"></a>            <span class="va">unit_count_min_</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span><span class="va">unit_count_</span><span class="op">,</span> <span class="va">unit_count_min_</span><span class="op">);</span></span>
<span id="cb47-77"><a href="#cb47-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-78"><a href="#cb47-78" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="va">header_</span> <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-79"><a href="#cb47-79" aria-hidden="true" tabindex="-1"></a>                <span class="va">header_</span> <span class="op">=</span> to_free<span class="op">;</span></span>
<span id="cb47-80"><a href="#cb47-80" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span><span class="op">;</span></span>
<span id="cb47-81"><a href="#cb47-81" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb47-82"><a href="#cb47-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-83"><a href="#cb47-83" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>to_free <span class="op">&lt;</span> <span class="va">header_</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-84"><a href="#cb47-84" aria-hidden="true" tabindex="-1"></a>                concat<span class="op">(</span>to_free<span class="op">,</span> <span class="va">header_</span><span class="op">);</span></span>
<span id="cb47-85"><a href="#cb47-85" aria-hidden="true" tabindex="-1"></a>                <span class="va">header_</span> <span class="op">=</span> to_free<span class="op">;</span></span>
<span id="cb47-86"><a href="#cb47-86" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span><span class="op">;</span></span>
<span id="cb47-87"><a href="#cb47-87" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb47-88"><a href="#cb47-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-89"><a href="#cb47-89" aria-hidden="true" tabindex="-1"></a>            <span class="dt">header_t</span><span class="op">*</span> curr <span class="op">=</span> <span class="va">header_</span><span class="op">;</span></span>
<span id="cb47-90"><a href="#cb47-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-91"><a href="#cb47-91" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(;</span> curr<span class="op">-&gt;</span>next <span class="op">!=</span> <span class="kw">nullptr</span><span class="op">;</span> curr <span class="op">=</span> curr<span class="op">-&gt;</span>next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-92"><a href="#cb47-92" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>to_free <span class="op">&lt;</span> curr<span class="op">-&gt;</span>next<span class="op">)</span> <span class="op">{</span>  <span class="co">// 常に curr &lt; to_free</span></span>
<span id="cb47-93"><a href="#cb47-93" aria-hidden="true" tabindex="-1"></a>                    concat<span class="op">(</span>to_free<span class="op">,</span> curr<span class="op">-&gt;</span>next<span class="op">);</span></span>
<span id="cb47-94"><a href="#cb47-94" aria-hidden="true" tabindex="-1"></a>                    concat<span class="op">(</span>curr<span class="op">,</span> to_free<span class="op">);</span></span>
<span id="cb47-95"><a href="#cb47-95" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb47-96"><a href="#cb47-96" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb47-97"><a href="#cb47-97" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb47-98"><a href="#cb47-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-99"><a href="#cb47-99" aria-hidden="true" tabindex="-1"></a>            concat<span class="op">(</span>curr<span class="op">,</span> to_free<span class="op">);</span></span>
<span id="cb47-100"><a href="#cb47-100" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-101"><a href="#cb47-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-102"><a href="#cb47-102" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> do_is_equal<span class="op">(</span><span class="at">const</span> memory_resource<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span> <span class="op">==</span> <span class="op">&amp;</span>other<span class="op">;</span> <span class="op">}</span></span>
<span id="cb47-103"><a href="#cb47-103" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<h3 id="stdpmrpolymorphic_allocator">std::pmr::polymorphic_allocator
<a id="SS_7_6_2"></a></h3>
<p>std::pmr::polymorphic_allocatorはC++17で導入された標準ライブラリのクラスで、
C++のメモリリソース管理を抽象化するための機能を提供する。 <a
href="stdlib_and_concepts.html#SS_7_6_1">std::pmr::memory_resource</a>を基盤とし、
コンテナやアルゴリズムにカスタムメモリアロケーション戦略を容易に適用可能にする。
std::allocatorと異なり、型に依存せず、
ポリモーフィズムを活用してメモリリソースを切り替えられる点が特徴である。</p>
<p>すでに示したmemory_resource_variable(<a
href="stdlib_and_concepts.html#SS_7_6_1">std::pmr::memory_resource</a>)の単体テストを以下に示すことにより、
polymorphic_allocatorの使用例とする。</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/pmr_memory_resource_ut.cpp 208</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint32_t</span>            max <span class="op">=</span> <span class="dv">1024</span><span class="op">;</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    memory_resource_variable<span class="op">&lt;</span>max<span class="op">&gt;</span> mrv<span class="op">;</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    memory_resource_variable<span class="op">&lt;</span>max<span class="op">&gt;</span> mrv2<span class="op">;</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>mrv<span class="op">,</span> mrv<span class="op">);</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_NE<span class="op">(</span>mrv<span class="op">,</span> mrv2<span class="op">);</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> remaings1 <span class="op">=</span> mrv<span class="op">.</span>get_count<span class="op">();</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>        ASSERT_GE<span class="op">(</span>max<span class="op">,</span> remaings1<span class="op">);</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// std::basic_stringにカスタムアロケータを適用</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> pmr_string <span class="op">=</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="bu">std::</span>char_traits<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;,</span> <span class="bu">std::</span>pmr::polymorphic_allocator<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;;</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>pmr::polymorphic_allocator<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> allocator<span class="op">(&amp;</span>mrv<span class="op">);</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// カスタムアロケータを使って文字列を作成</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>        pmr_string str<span class="op">(</span><span class="st">&quot;custom allocator!&quot;</span><span class="op">,</span> allocator<span class="op">);</span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span>       remaings2 <span class="op">=</span> mrv<span class="op">.</span>get_count<span class="op">();</span></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// アサーション: 文字列の内容を確認</span></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>        ASSERT_GT<span class="op">(</span>remaings1<span class="op">,</span> remaings2<span class="op">);</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;custom allocator!&quot;</span><span class="op">,</span> str<span class="op">);</span></span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>mrv<span class="op">.</span>is_valid<span class="op">(</span>str<span class="op">.</span>c_str<span class="op">()));</span>  <span class="co">// strの内部メモリがmrvの内部であることの確認</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> str3 <span class="op">=</span> str <span class="op">+</span> str <span class="op">+</span> str<span class="op">;</span></span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>str<span class="op">.</span>size<span class="op">()</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> str3<span class="op">.</span>size<span class="op">()</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>        ASSERT_THROW<span class="op">(</span>str3 <span class="op">=</span> pmr_string<span class="op">(</span><span class="dv">2000</span><span class="op">,</span> <span class="ch">&#39;a&#39;</span><span class="op">),</span> <span class="bu">std::</span>bad_alloc<span class="op">);</span>  <span class="co">// メモリの枯渇テスト</span></span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>    ASSERT_GE<span class="op">(</span>max<span class="op">,</span> mrv<span class="op">.</span>get_count<span class="op">());</span>  <span class="co">// 解放後のメモリの回復のテスト</span></span></code></pre></div>
<h3 id="pool_resource">pool_resource <a id="SS_7_6_3"></a></h3>
<p>pool_resourceは<a
href="stdlib_and_concepts.html#SS_7_6_1">std::pmr::memory_resource</a>を基底とする下記の2つの具象クラスである。</p>
<ul>
<li>std::pmr::synchronized_pool_resourceは下記のような特徴を持つメモリプールである。
<ul>
<li>非同期のメモリプールリソース</li>
<li>シングルスレッド環境での高速なメモリ割り当てに適する</li>
<li>排他制御のオーバーヘッドがない</li>
<li>以下に使用例を示す。</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb49"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/pool_resource_ut.cpp 10</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pmr::unsynchronized_pool_resource pool_resource<span class="op">(</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>pmr::pool_options<span class="op">{</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>max_blocks_per_chunk        <span class="op">=</span> <span class="dv">10</span><span class="op">,</span>   <span class="co">// チャンクあたりの最大ブロック数</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>largest_required_pool_block <span class="op">=</span> <span class="dv">1024</span>  <span class="co">// 最大ブロックサイズ</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">},</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>pmr::new_delete_resource<span class="op">()</span>  <span class="co">// フォールバックリソース</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// vectorを使用したメモリ割り当てのテスト</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>pmr::vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">{&amp;</span>pool_resource<span class="op">};</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ベクターへの要素追加</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>        vec<span class="op">.</span>push_back<span class="op">(</span><span class="dv">42</span><span class="op">);</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>        vec<span class="op">.</span>push_back<span class="op">(</span><span class="dv">100</span><span class="op">);</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// メモリ割り当てと要素の検証</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>vec<span class="op">.</span>size<span class="op">(),</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>vec<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="dv">42</span><span class="op">);</span></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>vec<span class="op">[</span><span class="dv">1</span><span class="op">],</span> <span class="dv">100</span><span class="op">);</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>std::pmr::unsynchronized_pool_resource
は下記のような特徴を持つメモリプールである。
<ul>
<li>スレッドセーフなメモリプールリソース</li>
<li>複数のスレッドから同時にアクセス可能</li>
<li>内部で排他制御を行う</li>
<li>以下に使用例を示す。</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb50"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/pool_resource_ut.cpp 38</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pmr::synchronized_pool_resource shared_pool<span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> thread_func <span class="op">=</span> <span class="op">[&amp;</span>shared_pool<span class="op">](</span><span class="dt">int</span> thread_id<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>pmr::vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> local_vec<span class="op">{&amp;</span>shared_pool<span class="op">};</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// スレッドごとに異なる要素を追加</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>        local_vec<span class="op">.</span>push_back<span class="op">(</span>thread_id <span class="op">*</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>        local_vec<span class="op">.</span>push_back<span class="op">(</span>thread_id <span class="op">*</span> <span class="dv">20</span><span class="op">);</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>local_vec<span class="op">.</span>size<span class="op">(),</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 複数スレッドでの同時使用</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t1<span class="op">(</span>thread_func<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>thread t2<span class="op">(</span>thread_func<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>    t1<span class="op">.</span>join<span class="op">();</span></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>    t2<span class="op">.</span>join<span class="op">();</span></span></code></pre></div>
<h2 id="コンテナ">コンテナ <a id="SS_7_7"></a></h2>
<p>データを格納し、
効率的に操作するための汎用的なデータ構造を提供するC++標準ライブラリの下記のようなクラス群である。</p>
<ul>
<li><a
href="stdlib_and_concepts.html#SS_7_7_1">シーケンスコンテナ(Sequence
Containers)</a></li>
<li>[連想コンテナ(Associative Containers)(—)</li>
<li><a
href="stdlib_and_concepts.html#SS_7_7_3">無順序連想コンテナ(Unordered
Associative Containers)</a></li>
<li><a href="stdlib_and_concepts.html#SS_7_7_4">コンテナアダプタ(Container
Adapters)</a></li>
<li><a href="stdlib_and_concepts.html#SS_7_7_5">特殊なコンテナ</a></li>
</ul>
<h3
id="シーケンスコンテナsequence-containers">シーケンスコンテナ(Sequence
Containers) <a id="SS_7_7_1"></a></h3>
<p>データが挿入順に保持され、順序が重要な場合に使用する。</p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="header">
<th>コンテナ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>std::vector</code></td>
<td>動的な配列で、ランダムアクセスが高速。末尾への挿入/削除が効率的</td>
</tr>
<tr class="even">
<td><code>std::deque</code></td>
<td>両端に効率的な挿入/削除が可能な動的配列</td>
</tr>
<tr class="odd">
<td><code>std::list</code></td>
<td>双方向リスト。要素の順序を維持し、中間の挿入/削除が効率的</td>
</tr>
<tr class="even">
<td><a
href="stdlib_and_concepts.html#SS_7_7_1_1">std::forward_list</a></td>
<td>単方向リスト。軽量だが、双方向の操作はできない</td>
</tr>
<tr class="odd">
<td><code>std::array</code></td>
<td>固定長配列で、サイズがコンパイル時に決まる</td>
</tr>
<tr class="even">
<td><code>std::string</code></td>
<td>可変長の文字列を管理するクラス(厳密には<code>std::basic_string</code>の特殊化)</td>
</tr>
</tbody>
</table>
<h4 id="stdforward_list">std::forward_list <a id="SS_7_7_1_1"></a></h4>
<div class="sourceCode" id="cb51"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/container_ut.cpp 14</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>forward_list<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> fl<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 要素の挿入</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>fl<span class="op">.</span>front<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    fl<span class="op">.</span>push_front<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>fl<span class="op">.</span>front<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> it <span class="op">=</span> fl<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(*++</span>it<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(*++</span>it<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(*++</span>it<span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span></code></pre></div>
<h3 id="連想コンテナassociative-containers">連想コンテナ(Associative
Containers) <a id="SS_7_7_2"></a></h3>
<p>データがキーに基づいて自動的にソートされ、検索が高速である。</p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th>コンテナ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>std::set</code></td>
<td>要素がソートされ、重複が許されない集合</td>
</tr>
<tr class="even">
<td><code>std::multiset</code></td>
<td>ソートされるが、重複が許される集合</td>
</tr>
<tr class="odd">
<td><code>std::map</code></td>
<td>ソートされたキーと値のペアを保持。キーは一意</td>
</tr>
<tr class="even">
<td><code>std::multimap</code></td>
<td>ソートされたキーと値のペアを保持。キーは重複可能</td>
</tr>
</tbody>
</table>
<h3
id="無順序連想コンテナunordered-associative-containers">無順序連想コンテナ(Unordered
Associative Containers) <a id="SS_7_7_3"></a></h3>
<p>ハッシュテーブルを基盤としたコンテナで、順序を保証しないが高速な検索を提供する。</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th>コンテナ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a
href="stdlib_and_concepts.html#SS_7_7_3_1">std::unordered_set</a></td>
<td>ハッシュテーブルベースの集合。重複は許されない</td>
</tr>
<tr class="even">
<td><code>std::unordered_multiset</code></td>
<td>ハッシュテーブルベースの集合。重複が許される</td>
</tr>
<tr class="odd">
<td><a
href="stdlib_and_concepts.html#SS_7_7_3_2">std::unordered_map</a></td>
<td>ハッシュテーブルベースのキーと値のペア。キーは一意</td>
</tr>
<tr class="even">
<td><code>std::unordered_multimap</code></td>
<td>ハッシュテーブルベースのキーと値のペア。キーは重複可能</td>
</tr>
<tr class="odd">
<td><a href="stdlib_and_concepts.html#SS_7_7_3_3">std::type_index</a></td>
<td>型情報型を連想コンテナのキーとして使用するためのクラス</td>
</tr>
</tbody>
</table>
<h4 id="stdunordered_set">std::unordered_set
<a id="SS_7_7_3_1"></a></h4>
<div class="sourceCode" id="cb52"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/container_ut.cpp 32</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> uset<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 要素の挿入</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    uset<span class="op">.</span>insert<span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    uset<span class="op">.</span>insert<span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 存在確認</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    EXPECT_NE<span class="op">(</span>uset<span class="op">.</span>find<span class="op">(</span><span class="dv">1</span><span class="op">),</span> uset<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    EXPECT_NE<span class="op">(</span>uset<span class="op">.</span>find<span class="op">(</span><span class="dv">4</span><span class="op">),</span> uset<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>uset<span class="op">.</span>find<span class="op">(</span><span class="dv">6</span><span class="op">),</span> uset<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// サイズの確認</span></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>uset<span class="op">.</span>size<span class="op">(),</span> <span class="dv">5</span><span class="op">);</span></span></code></pre></div>
<h4 id="stdunordered_map">std::unordered_map
<a id="SS_7_7_3_2"></a></h4>
<div class="sourceCode" id="cb53"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/container_ut.cpp 52</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> umap<span class="op">;</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 要素の挿入</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    umap<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;one&quot;</span><span class="op">;</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    umap<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;two&quot;</span><span class="op">;</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    umap<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;three&quot;</span><span class="op">;</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 要素の確認</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>umap<span class="op">[</span><span class="dv">1</span><span class="op">],</span> <span class="st">&quot;one&quot;</span><span class="op">);</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>umap<span class="op">[</span><span class="dv">2</span><span class="op">],</span> <span class="st">&quot;two&quot;</span><span class="op">);</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>umap<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="st">&quot;three&quot;</span><span class="op">);</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 存在確認</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    EXPECT_NE<span class="op">(</span>umap<span class="op">.</span>find<span class="op">(</span><span class="dv">1</span><span class="op">),</span> umap<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>umap<span class="op">.</span>find<span class="op">(</span><span class="dv">4</span><span class="op">),</span> umap<span class="op">.</span>end<span class="op">());</span></span></code></pre></div>
<h4 id="stdtype_index">std::type_index <a id="SS_7_7_3_3"></a></h4>
<p>std::type_indexはコンテナではないが、
型情報型を連想コンテナのキーとして使用するためのクラスであるため、この場所に掲載する。</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/container_ut.cpp 74</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="bu">std::</span>type_index<span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> type_map<span class="op">;</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::type_indexを使って型をキーとしてマッピング</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    type_map<span class="op">[</span><span class="kw">typeid</span><span class="op">(</span><span class="dt">int</span><span class="op">)]</span>         <span class="op">=</span> <span class="st">&quot;int&quot;</span><span class="op">;</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    type_map<span class="op">[</span><span class="kw">typeid</span><span class="op">(</span><span class="dt">double</span><span class="op">)]</span>      <span class="op">=</span> <span class="st">&quot;double&quot;</span><span class="op">;</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    type_map<span class="op">[</span><span class="kw">typeid</span><span class="op">(</span><span class="bu">std::</span>string<span class="op">)]</span> <span class="op">=</span> <span class="st">&quot;string&quot;</span><span class="op">;</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// マッピングの確認</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>type_map<span class="op">[</span><span class="kw">typeid</span><span class="op">(</span><span class="dt">int</span><span class="op">)],</span> <span class="st">&quot;int&quot;</span><span class="op">);</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>type_map<span class="op">[</span><span class="kw">typeid</span><span class="op">(</span><span class="dt">double</span><span class="op">)],</span> <span class="st">&quot;double&quot;</span><span class="op">);</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>type_map<span class="op">[</span><span class="kw">typeid</span><span class="op">(</span><span class="bu">std::</span>string<span class="op">)],</span> <span class="st">&quot;string&quot;</span><span class="op">);</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 存在しない型の確認</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>type_map<span class="op">.</span>find<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span><span class="dt">float</span><span class="op">)),</span> type_map<span class="op">.</span>end<span class="op">());</span></span></code></pre></div>
<h3 id="コンテナアダプタcontainer-adapters">コンテナアダプタ(Container
Adapters) <a id="SS_7_7_4"></a></h3>
<p>特定の操作のみを公開するためのラッパーコンテナ。</p>
<table>
<thead>
<tr class="header">
<th>コンテナ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>std::stack</code></td>
<td>LIFO(後入れ先出し)操作を提供するアダプタ</td>
</tr>
<tr class="even">
<td><code>std::queue</code></td>
<td>FIFO(先入れ先出し)操作を提供するアダプタ</td>
</tr>
<tr class="odd">
<td><code>std::priority_queue</code></td>
<td>優先度に基づく操作を提供するアダプタ</td>
</tr>
</tbody>
</table>
<h3 id="特殊なコンテナ">特殊なコンテナ <a id="SS_7_7_5"></a></h3>
<p>上記したようなコンテナとは一線を画すが、特定の用途や目的のために設計された一種のコンテナ。</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>コンテナ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>std::span</code></td>
<td>生ポインタや配列を抽象化し、安全に操作するための軽量ビュー</td>
</tr>
<tr class="even">
<td><code>std::bitset</code></td>
<td>固定長のビット集合を管理するクラス</td>
</tr>
<tr class="odd">
<td><code>std::basic_string</code></td>
<td>カスタム文字型をサポートする文字列コンテナ</td>
</tr>
</tbody>
</table>
<h2 id="stdoptional">std::optional <a id="SS_7_8"></a></h2>
<p>C++17から導入されたstd::optionalには、以下のような2つの用途がある。
以下の用途2から、
このクラスがオブジェクトのダイナミックなメモリアロケーションを行うような印象を受けるが、
そのようなことは行わない。
このクラスがオブジェクトのダイナミックな生成が必要になった場合、プレースメントnewを実行する。
ただし、std::optionalが保持する型自身がnewを実行する場合は、この限りではない。</p>
<ol type="1">
<li>関数の任意の型の<a
href="stdlib_and_concepts.html#SS_7_8_1">戻り値の無効表現</a>を持たせる</li>
<li><a
href="stdlib_and_concepts.html#SS_7_8_2">オブジェクトの遅延初期化</a>する(初期化処理が重く、
条件によってはそれが無駄になる場合にこの機能を使う)</li>
</ol>
<h3 id="戻り値の無効表現">戻り値の無効表現 <a id="SS_7_8_1"></a></h3>
<div class="sourceCode" id="cb55"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/optional_ut.cpp 11</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> 指定されたファイル名から拡張子を取得する。</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">filename</span><span class="co"> ファイル名（パスを含む場合も可）</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@return</span><span class="co"> 拡張子を文字列として返す。拡張子がない場合は std::nullopt を返す。</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> file_extension<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> filename<span class="op">)</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span> pos <span class="op">=</span> filename<span class="op">.</span>rfind<span class="op">(</span><span class="ch">&#39;.&#39;</span><span class="op">);</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>pos <span class="op">==</span> <span class="bu">std::</span>string::npos <span class="op">||</span> pos <span class="op">==</span> filename<span class="op">.</span>length<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>nullopt<span class="op">;</span>  <span class="co">// 値が存在しない</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> filename<span class="op">.</span>substr<span class="op">(</span>pos <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb56"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/optional_ut.cpp 28</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret0 <span class="op">=</span> file_extension<span class="op">(</span><span class="st">&quot;xxx.yyy&quot;</span><span class="op">);</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>ret0<span class="op">);</span>  <span class="co">// 値を保持している</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;yyy&quot;</span><span class="op">,</span> <span class="op">*</span>ret0<span class="op">);</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret1 <span class="op">=</span> file_extension<span class="op">(</span><span class="st">&quot;xxx&quot;</span><span class="op">);</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>ret1<span class="op">);</span>  <span class="co">// 値を保持していない</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_THROW(*ret1, std::exception);  // 未定義動作(エクセプションは発生しない)</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>ret1<span class="op">.</span>value<span class="op">(),</span> <span class="bu">std::</span>bad_optional_access<span class="op">);</span>  <span class="co">// 値非保持の場合、エクセプション発生</span></span></code></pre></div>
<h3 id="オブジェクトの遅延初期化">オブジェクトの遅延初期化
<a id="SS_7_8_2"></a></h3>
<div class="sourceCode" id="cb57"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/optional_ut.cpp 43</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> HeavyResource <span class="op">{</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>        HeavyResource<span class="op">()</span> <span class="op">:</span> <span class="va">large_erea_</span><span class="op">{</span><span class="bn">0xdeadbeaf</span><span class="op">}</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span>  <span class="co">// large_erea_[0]を44にする</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>            initialied <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span>     is_ready<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">large_erea_</span><span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="bn">0xdeadbeaf</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span> <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_t</span> index<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">large_erea_</span><span class="op">[</span>index<span class="op">];</span> <span class="op">}</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="dt">bool</span> initialied<span class="op">;</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span> <span class="va">large_erea_</span><span class="op">[</span><span class="dv">1024</span><span class="op">];</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> HeavyResource<span class="op">::</span>initialied<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb58"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/optional_ut.cpp 64</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>HeavyResource<span class="op">&gt;</span> resource<span class="op">;</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// resourceの内部のHeavyResourceは未初期化</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>resource<span class="op">.</span>has_value<span class="op">());</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>HeavyResource<span class="op">::</span>initialied<span class="op">);</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_NE<span class="op">(</span><span class="bn">0xdeadbeaf</span><span class="op">,</span> <span class="op">(*</span>resource<span class="op">)[</span><span class="dv">0</span><span class="op">]);</span>  <span class="co">// 未定義動作</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// resourceの内部のHeavyResourceの遅延初期化</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>    resource<span class="op">.</span>emplace<span class="op">();</span>  <span class="co">// std::optionalの内部でplacement newが実行される</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ここから下は定義動作</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>HeavyResource<span class="op">::</span>initialied<span class="op">);</span>  <span class="co">// resourceの内部のHeavyResourceは初期化済み</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>resource<span class="op">.</span>has_value<span class="op">());</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>resource<span class="op">-&gt;</span>is_ready<span class="op">());</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bn">0xdeadbeaf</span><span class="op">,</span> <span class="op">(*</span>resource<span class="op">)[</span><span class="dv">0</span><span class="op">]);</span></span></code></pre></div>
<h2 id="stdvariant">std::variant <a id="SS_7_9"></a></h2>
<p>std::variantは、C++17で導入された型安全なunionである。
このクラスは複数の型のうち1つの値を保持することができ、
従来のunionに伴う低レベルな操作の安全性の問題を解消するために設計された。</p>
<p>std::variant自身では、オブジェクトのダイナミックな生成が必要な場合でも通常のnewを実行せず、
代わりにプレースメントnewを用いる
(以下のコード例のようにstd::variantが保持する型自身がnewを実行する場合は、この限りではない)。</p>
<p>以下にstd::variantの典型的な使用例を示す。</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/variant_ut.cpp 13</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>variant<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span> var  <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>                                   var2 <span class="op">=</span> var<span class="op">;</span>  <span class="co">// コピーコンストラクタの呼び出し</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>var<span class="op">),</span> <span class="dv">10</span><span class="op">);</span>  <span class="co">// 型intの値を取り出す</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 型std::stringの値を取り出すが、その値は持っていないのでエクセプション発生</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>var<span class="op">),</span> <span class="bu">std::</span>bad_variant_access<span class="op">);</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> <span class="st">&quot;variant&quot;</span><span class="op">;</span>  <span class="co">// &quot;variant&quot;はstd::stringに変更され、varにムーブされる</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>var<span class="op">),</span> <span class="st">&quot;variant&quot;</span><span class="op">);</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_NE<span class="op">(</span>var<span class="op">,</span> var2<span class="op">);</span>  <span class="co">// 保持している値の型が違う</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>    var2<span class="op">.</span>emplace<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span><span class="st">&quot;variant&quot;</span><span class="op">);</span>  <span class="co">// &quot;variant&quot;からvar2の値を直接生成するため、</span></span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>                                           <span class="co">// 文字列代入より若干効率的</span></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>var<span class="op">,</span> var2<span class="op">);</span></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a>    ASSERT_FLOAT_EQ<span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;(</span>var<span class="op">),</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// 2番目の型の値を取得</span></span></code></pre></div>
<p>std::variantとstd::visit(<a
href="design_pattern.html#SS_3_2_5">Visitor</a>パターンの実装の一種)を組み合わせた場合の使用例を以下に示す。</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/variant_ut.cpp 37</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> output_from_variant<span class="op">(</span><span class="bu">std::</span>variant<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> var<span class="op">,</span> <span class="bu">std::</span>ostringstream<span class="op">&amp;</span> oss<span class="op">)</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>visit<span class="op">([&amp;</span>oss<span class="op">](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> arg<span class="op">)</span> <span class="op">{</span> oss<span class="op">.</span>str<span class="op">().</span>empty<span class="op">()</span> <span class="op">?</span> oss <span class="op">&lt;&lt;</span> arg <span class="op">:</span> oss <span class="op">&lt;&lt;</span> <span class="st">&quot;|&quot;</span> <span class="op">&lt;&lt;</span> arg<span class="op">;</span> <span class="op">},</span> var<span class="op">);</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb61"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/variant_ut.cpp 47</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostringstream                     oss<span class="op">;</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>variant<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> var <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    output_from_variant<span class="op">(</span>var<span class="op">,</span> oss<span class="op">);</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;42&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> <span class="fl">3.14</span><span class="op">;</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>    output_from_variant<span class="op">(</span>var<span class="op">,</span> oss<span class="op">);</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;42|3.14&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>    output_from_variant<span class="op">(</span>var<span class="op">,</span> oss<span class="op">);</span></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;42|3.14|Hello, world!&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span></code></pre></div>
<h2 id="オブジェクトの比較">オブジェクトの比較 <a id="SS_7_10"></a></h2>
<h3 id="stdrel_ops">std::rel_ops <a id="SS_7_10_1"></a></h3>
<p>クラスに<code>operator==</code>と<code>operator&lt;</code>の2つの演算子が定義されていれば、
それがメンバか否かにかかわらず、他の比較演算子 !=、&lt;=、&gt;、&gt;=
はこれらを基に自動的に導出できる。
std::rel_opsでは<code>operator==</code>と<code>operator&lt;=</code>
を基に他の比較演算子を機械的に生成する仕組みが提供されている。</p>
<p>次の例では、std::rel_opsを利用して、少ないコードで全ての比較演算子をサポートする例を示す。</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/comparison_stdlib_ut.cpp 12</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Integer <span class="op">{</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>        Integer<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">x_</span><span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// operator==とoperator&lt;だけを定義</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// メンバ関数の比較演算子</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Integer<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span> <span class="op">==</span> other<span class="op">.</span><span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="at">const</span> Integer<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span> <span class="op">&lt;</span> other<span class="op">.</span><span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="va">x_</span><span class="op">;</span></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb63"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/comparison_stdlib_ut.cpp 32</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>rel_ops<span class="op">;</span>  <span class="co">// std::rel_opsを使うために名前空間を追加</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> Integer<span class="op">{</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> Integer<span class="op">{</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> c <span class="op">=</span> Integer<span class="op">{</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::rel_opsとは無関係に直接定義</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>a <span class="op">==</span> c<span class="op">);</span>   <span class="co">// a == c</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>a <span class="op">==</span> b<span class="op">);</span>  <span class="co">// !(a == b)</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>a <span class="op">&lt;</span> b<span class="op">);</span>    <span class="co">// aはbより小さい</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>b <span class="op">&lt;</span> a<span class="op">);</span>   <span class="co">// bはaより小さくない</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::rel_ops による!=, &lt;=, &gt;, &gt;=の定義</span></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>a <span class="op">!=</span> b<span class="op">);</span>   <span class="co">// aとbは異なる</span></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>a <span class="op">&lt;=</span> b<span class="op">);</span>   <span class="co">// aはb以下</span></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>b <span class="op">&gt;</span> a<span class="op">);</span>    <span class="co">// bはaより大きい</span></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>a <span class="op">&gt;=</span> b<span class="op">);</span>  <span class="co">// aはb以上ではない</span></span></code></pre></div>
<p>なお、std::rel_opsはC++20から導入された<a
href="core_lang_spec.html#SS_6_6_4_1">&lt;=&gt;演算子</a>により不要になったため、
非推奨とされた。</p>
<h3
id="stdtuppleを使用した比較演算子の実装方法">std::tuppleを使用した比較演算子の実装方法
<a id="SS_7_10_2"></a></h3>
<p>クラスのメンバが多い場合、<a
href="core_lang_spec.html#SS_6_6_3">==演算子</a>で示したような方法は、
可読性、保守性の問題が発生する場合が多い。下記に示す方法はこの問題を幾分緩和する。</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/comparison_stdlib_ut.cpp 56</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Point<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>tie<span class="op">(</span>x<span class="op">,</span> y<span class="op">)</span> <span class="op">==</span> <span class="bu">std::</span>tie<span class="op">(</span>other<span class="op">.</span>x<span class="op">,</span> other<span class="op">.</span>y<span class="op">);</span> <span class="op">}</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="at">const</span> Point<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>tie<span class="op">(</span>x<span class="op">,</span> y<span class="op">)</span> <span class="op">&lt;</span> <span class="bu">std::</span>tie<span class="op">(</span>other<span class="op">.</span>x<span class="op">,</span> other<span class="op">.</span>y<span class="op">);</span> <span class="op">}</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb65"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/comparison_stdlib_ut.cpp 70</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> Point<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> Point<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> c <span class="op">=</span> Point<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>rel_ops<span class="op">;</span>  <span class="co">// std::rel_opsを使うために名前空間を追加</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>a <span class="op">==</span> c<span class="op">);</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>a <span class="op">!=</span> b<span class="op">);</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>a <span class="op">&lt;</span> b<span class="op">);</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>a <span class="op">&gt;</span> b<span class="op">);</span></span></code></pre></div>
<h2 id="その他">その他 <a id="SS_7_11"></a></h2>
<h3 id="ssosmall-string-optimization">SSO(Small String Optimization)
<a id="SS_7_11_1"></a></h3>
<p>一般にstd::stringで文字列を保持する場合、newしたメモリが使用される。
64ビット環境であれば、newしたメモリのアドレスを保持する領域は8バイトになる。
std::stringで保持する文字列が終端の’\0’も含め8バイト以下である場合、
アドレスを保持する領域をその文字列の格納に使用すれば、newする必要がない(当然deleteも不要)。
こうすることで、短い文字列を保持するstd::stringオブジェクトは効率的に動作できる。</p>
<p>SOOとはこのような最適化を指す。</p>
<h3 id="heap-allocation-elision">heap allocation elision
<a id="SS_7_11_2"></a></h3>
<p>C++11までの仕様では、new式によるダイナミックメモリアロケーションはコードに書かれた通りに、
実行されなければならず、ひとまとめにしたり省略したりすることはできなかった。
つまり、ヒープ割り当てに対する最適化は認められなかった。
ダイナミックメモリアロケーションの最適化のため、この制限は緩和され、
new/deleteの呼び出しをまとめたり省略したりすることができるようになった。</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/stdlib_and_concepts/heap_allocation_elision_ut.cpp 4</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> lump<span class="op">()</span>  <span class="co">// 実装によっては、ダイナミックメモリアロケーションをまとめらる場合がある</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">*</span> p1 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">*</span> p2 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">{</span><span class="dv">2</span><span class="op">};</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">*</span> p3 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">{</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 何らかの処理</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> p1<span class="op">;</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> p2<span class="op">;</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> p3<span class="op">;</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 上記のメモリアロケーションは、実装によっては下記のように最適化される場合がある</span></span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">*</span> p <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 何らかの処理</span></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> p<span class="op">;</span></span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="ex">emit</span><span class="op">()</span>  <span class="co">// ダイナミックメモリアロケーションの省略</span></span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">*</span> p <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">{</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span> p<span class="op">;</span></span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 上記のメモリアロケーションは、下記の用にスタックの変数に置き換える最適化が許される</span></span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb66-31"><a href="#cb66-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-32"><a href="#cb66-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb66-33"><a href="#cb66-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>この最適化により、std::make_sharedのようにstd::shared_ptrの参照カウントを管理するメモリブロックと、
オブジェクトの実体を1つのヒープ領域に割り当てることができ、
ダイナミックメモリアロケーションが1回に抑えられるため、メモリアクセスが高速化される。</p>
</body>
</html>
