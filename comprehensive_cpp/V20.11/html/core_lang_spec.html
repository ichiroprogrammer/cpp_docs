<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Comprehensive Knowledge of C++(V20.11)</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #303030; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */

    body {
        margin: 0 auto;
        max-width: none;
        width: 1000px;
        padding-left: 50px;
        padding-right: 50px;
        padding-top: 50px;
        padding-bottom: 50px;
        hyphens: auto;
        overflow-wrap: break-word;
        text-rendering: optimizeLegibility;
        font-kerning: normal;
    }

    table {
        border-collapse: collapse;
    }

    table, th, td {
        border: 2px solid black;
    }

    header {
        margin-bottom: 4em;
        text-align: center;
        color: white;
        background-color: lightblue;
    }

    h1:not(:first-of-type) {
        page-break-before: always;
    }

  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Comprehensive Knowledge of C++(V20.11)</h1>
<p class="author">autor:ichiroprogrammer</p>
</header>
<!-- essential/md/core_lang_spec.md -->
<h1 id="cコア言語仕様">C++コア言語仕様 <a id="SS_19"></a></h1>
<p>この章では、C++コア言語仕様について説明する。</p>
<hr />
<p><strong>この章の構成</strong></p>
<p>   <a
href="core_lang_spec.html#SS_19_1">型システムと算術の基礎</a><br />
    <a href="core_lang_spec.html#SS_19_1_1">基本型</a><br />
    <a href="core_lang_spec.html#SS_19_1_2">組み込み型</a><br />
    <a href="core_lang_spec.html#SS_19_1_3">算術型</a><br />
    <a href="core_lang_spec.html#SS_19_1_4">汎整数型</a><br />
    <a href="core_lang_spec.html#SS_19_1_5">整数型</a><br />
     <a
href="core_lang_spec.html#SS_19_1_5_1">ビットシフトにおける未定義動作</a></p>
<p>    <a href="core_lang_spec.html#SS_19_1_6">算術変換</a><br />
    <a href="core_lang_spec.html#SS_19_1_7">汎整数型昇格</a><br />
    <a href="core_lang_spec.html#SS_19_1_8">汎整数型拡張</a><br />
    <a href="core_lang_spec.html#SS_19_1_9">浮動小数点型昇格</a><br />
    <a href="core_lang_spec.html#SS_19_1_10">デフォルト引数昇格</a><br />
    <a href="core_lang_spec.html#SS_19_1_11">縮小型変換</a><br />
    <a href="core_lang_spec.html#SS_19_1_12">浮動小数点型</a><br />
     <a
href="core_lang_spec.html#SS_19_1_12_1">浮動小数点型のダイナミックレンジ</a><br />
     <a href="core_lang_spec.html#SS_19_1_12_2">浮動小数点の誤差</a><br />
     <a href="core_lang_spec.html#SS_19_1_12_3">イプシロン</a><br />
     <a
href="core_lang_spec.html#SS_19_1_12_4">浮動小数点の演算エラー</a></p>
<p>   <a href="core_lang_spec.html#SS_19_2">リテラル</a><br />
    <a href="core_lang_spec.html#SS_19_2_1">生文字列リテラル</a><br />
    <a href="core_lang_spec.html#SS_19_2_2">2進数リテラル</a><br />
    <a href="core_lang_spec.html#SS_19_2_3">数値リテラル</a><br />
    <a href="core_lang_spec.html#SS_19_2_4">ワイド文字列</a><br />
    <a
href="core_lang_spec.html#SS_19_2_5">16進浮動小数点数リテラル</a><br />
    <a href="core_lang_spec.html#SS_19_2_6">ユーザー定義リテラル</a><br />
     <a
href="core_lang_spec.html#SS_19_2_6_1">ユーザ定義リテラル演算子</a><br />
     <a
href="core_lang_spec.html#SS_19_2_6_2">std::string型リテラル</a><br />
     <a
href="core_lang_spec.html#SS_19_2_6_3">std::chronoのリテラル</a><br />
     <a
href="core_lang_spec.html#SS_19_2_6_4">std::complexリテラル</a></p>
<p>   <a href="core_lang_spec.html#SS_19_3">列挙型とバイト表現</a><br />
    <a href="core_lang_spec.html#SS_19_3_1">enum</a><br />
    <a href="core_lang_spec.html#SS_19_3_2">enum class</a><br />
    <a href="core_lang_spec.html#SS_19_3_3">スコープドenum</a><br />
    <a href="core_lang_spec.html#SS_19_3_4">underlying type</a><br />
    <a href="core_lang_spec.html#SS_19_3_5">std::byte</a><br />
    <a href="core_lang_spec.html#SS_19_3_6">using enum</a></p>
<p>   <a href="core_lang_spec.html#SS_19_4">型とインスタンス</a><br />
    <a href="core_lang_spec.html#SS_19_4_1">トリビアル型</a><br />
    <a
href="core_lang_spec.html#SS_19_4_2">トリビアルに破壊可能な型</a><br />
    <a href="core_lang_spec.html#SS_19_4_3">標準レイアウト型</a><br />
    <a href="core_lang_spec.html#SS_19_4_4">集成体</a><br />
    <a href="core_lang_spec.html#SS_19_4_5">POD</a><br />
    <a href="core_lang_spec.html#SS_19_4_6">不完全型</a><br />
    <a href="core_lang_spec.html#SS_19_4_7">完全型</a><br />
    <a
href="core_lang_spec.html#SS_19_4_8">ポリモーフィックなクラス</a><br />
    <a href="core_lang_spec.html#SS_19_4_9">RTTI</a><br />
     <a href="core_lang_spec.html#SS_19_4_9_1">dynamic_cast</a><br />
     <a href="core_lang_spec.html#SS_19_4_9_2">typeid</a><br />
     <a href="core_lang_spec.html#SS_19_4_9_3">std::type_info</a></p>
<p>    <a href="core_lang_spec.html#SS_19_4_10">Run-time Type
Information</a><br />
    <a
href="core_lang_spec.html#SS_19_4_11">インターフェースクラス</a><br />
    <a href="core_lang_spec.html#SS_19_4_12">constインスタンス</a></p>
<p>   <a
href="core_lang_spec.html#SS_19_5">定数式とコンパイル時評価</a><br />
    <a href="core_lang_spec.html#SS_19_5_1">constexpr</a><br />
    <a href="core_lang_spec.html#SS_19_5_2">constexpr定数</a><br />
    <a href="core_lang_spec.html#SS_19_5_3">constexpr関数</a><br />
    <a href="core_lang_spec.html#SS_19_5_4">コア定数式</a><br />
    <a href="core_lang_spec.html#SS_19_5_5">リテラル型</a><br />
    <a
href="core_lang_spec.html#SS_19_5_6">constexprインスタンス</a><br />
    <a href="core_lang_spec.html#SS_19_5_7">consteval</a><br />
    <a href="core_lang_spec.html#SS_19_5_8">constinit</a><br />
    <a href="core_lang_spec.html#SS_19_5_9">constexprラムダ</a></p>
<p>   <a
href="core_lang_spec.html#SS_19_6">オブジェクト生成と初期化</a><br />
    <a href="core_lang_spec.html#SS_19_6_1">特殊メンバ関数</a><br />
     <a
href="core_lang_spec.html#SS_19_6_1_1">初期化子リストコンストラクタ</a><br />
     <a
href="core_lang_spec.html#SS_19_6_1_2">継承コンストラクタ</a><br />
     <a href="core_lang_spec.html#SS_19_6_1_3">委譲コンストラクタ</a></p>
<p>    <a href="core_lang_spec.html#SS_19_6_2">explicit
コンストラクタと型変換制御</a><br />
     <a href="core_lang_spec.html#SS_19_6_2_1">explicit</a><br />
     <a href="core_lang_spec.html#SS_19_6_2_2">暗黙の型変換</a><br />
     <a href="core_lang_spec.html#SS_19_6_2_3">暗黙の型変換抑止</a><br />
     <a href="core_lang_spec.html#SS_19_6_2_4">explicit(COND)</a><br />
     <a href="core_lang_spec.html#SS_19_6_2_5">explicit type
operator()</a></p>
<p>    <a href="core_lang_spec.html#SS_19_6_3">==演算子</a><br />
     <a href="core_lang_spec.html#SS_19_6_3_1">メンバ==演算子</a><br />
     <a href="core_lang_spec.html#SS_19_6_3_2">非メンバ==演算子</a></p>
<p>    <a href="core_lang_spec.html#SS_19_6_4">比較演算子</a><br />
     <a href="core_lang_spec.html#SS_19_6_4_1">&lt;=&gt;演算子</a><br />
     <a href="core_lang_spec.html#SS_19_6_4_2">三方比較演算子</a><br />
     <a href="core_lang_spec.html#SS_19_6_4_3">spaceship operator</a></p>
<p>    <a href="core_lang_spec.html#SS_19_6_5">リスト初期化</a><br />
    <a href="core_lang_spec.html#SS_19_6_6">一様初期化</a><br />
    <a
href="core_lang_spec.html#SS_19_6_7">非静的なメンバ変数の初期化</a><br />
     <a href="core_lang_spec.html#SS_19_6_7_1">NSDMI</a><br />
     <a
href="core_lang_spec.html#SS_19_6_7_2">初期化子リストでの初期化</a><br />
     <a
href="core_lang_spec.html#SS_19_6_7_3">コンストラクタ内での非静的なメンバ変数の初期値の代入</a></p>
<p>    <a
href="core_lang_spec.html#SS_19_6_8">オブジェクトのライフタイム</a><br />
    <a href="core_lang_spec.html#SS_19_6_9">プレースメントnew</a><br />
    <a href="core_lang_spec.html#SS_19_6_10">new (std::nothrow)</a></p>
<p>   <a
href="core_lang_spec.html#SS_19_7">値カテゴリとリファレンス</a><br />
    <a href="core_lang_spec.html#SS_19_7_1">expression</a><br />
     <a href="core_lang_spec.html#SS_19_7_1_1">lvalue</a><br />
     <a href="core_lang_spec.html#SS_19_7_1_2">rvalue</a><br />
     <a href="core_lang_spec.html#SS_19_7_1_3">xvalue</a><br />
     <a href="core_lang_spec.html#SS_19_7_1_4">prvalue</a><br />
     <a href="core_lang_spec.html#SS_19_7_1_5">glvalue</a></p>
<p>    <a
href="core_lang_spec.html#SS_19_7_2">decltypeとexpression</a></p>
<p>   <a href="core_lang_spec.html#SS_19_8">リファレンス</a><br />
    <a href="core_lang_spec.html#SS_19_8_1">lvalueリファレンス</a><br />
    <a href="core_lang_spec.html#SS_19_8_2">rvalueリファレンス</a><br />
     <a href="core_lang_spec.html#SS_19_8_2_1">lvalueからの代入</a><br />
     <a href="core_lang_spec.html#SS_19_8_2_2">rvalueからの代入</a><br />
     <a
href="core_lang_spec.html#SS_19_8_2_3">std::move(lvalue)からの代入</a></p>
<p>    <a
href="core_lang_spec.html#SS_19_8_3">forwardingリファレンス</a><br />
    <a
href="core_lang_spec.html#SS_19_8_4">ユニバーサルリファレンス</a><br />
    <a href="core_lang_spec.html#SS_19_8_5">perfect forwarding</a><br />
    <a
href="core_lang_spec.html#SS_19_8_6">リファレンスcollapsing</a><br />
    <a href="core_lang_spec.html#SS_19_8_7">リファレンス修飾</a><br />
     <a href="core_lang_spec.html#SS_19_8_7_1">rvalue修飾</a><br />
     <a href="core_lang_spec.html#SS_19_8_7_2">lvalue修飾</a></p>
<p>   <a href="core_lang_spec.html#SS_19_9">構文と制御構造</a><br />
    <a href="core_lang_spec.html#SS_19_9_1">属性構文</a><br />
    <a href="core_lang_spec.html#SS_19_9_2">関数tryブロック</a><br />
    <a href="core_lang_spec.html#SS_19_9_3">範囲for文</a><br />
    <a href="core_lang_spec.html#SS_19_9_4">構造化束縛</a><br />
    <a
href="core_lang_spec.html#SS_19_9_5">初期化付きif/switch文</a><br />
     <a
href="core_lang_spec.html#SS_19_9_5_1">初期化付きfor文(従来のfor文)</a><br />
     <a
href="core_lang_spec.html#SS_19_9_5_2">初期化付きwhile文(従来のwhile文)</a><br />
     <a href="core_lang_spec.html#SS_19_9_5_3">初期化付きif文</a><br />
     <a href="core_lang_spec.html#SS_19_9_5_4">初期化付きswitch文</a></p>
<p>   <a href="core_lang_spec.html#SS_19_10">言語拡張機能</a><br />
    <a href="core_lang_spec.html#SS_19_10_1">コルーチン</a><br />
     <a href="core_lang_spec.html#SS_19_10_1_1">co_await</a><br />
     <a href="core_lang_spec.html#SS_19_10_1_2">co_return</a><br />
     <a href="core_lang_spec.html#SS_19_10_1_3">co_yield</a></p>
<p>    <a href="core_lang_spec.html#SS_19_10_2">モジュール</a><br />
    <a href="core_lang_spec.html#SS_19_10_3">ラムダ式</a><br />
     <a href="core_lang_spec.html#SS_19_10_3_1">クロージャ</a><br />
     <a href="core_lang_spec.html#SS_19_10_3_2">クロージャ型</a><br />
     <a href="core_lang_spec.html#SS_19_10_3_3">一時的ラムダ</a><br />
     <a href="core_lang_spec.html#SS_19_10_3_4">transient lambda</a></p>
<p>    <a href="core_lang_spec.html#SS_19_10_4">指示付き初期化</a></p>
<p>   <a
href="core_lang_spec.html#SS_19_11">テンプレートと型推論</a><br />
    <a href="core_lang_spec.html#SS_19_11_1">SFINAE</a><br />
    <a href="core_lang_spec.html#SS_19_11_2">メタ関数</a><br />
    <a href="core_lang_spec.html#SS_19_11_3">コンセプト</a><br />
    <a href="core_lang_spec.html#SS_19_11_4">パラメータパック</a><br />
    <a href="core_lang_spec.html#SS_19_11_5">畳み込み式</a><br />
    <a href="core_lang_spec.html#SS_19_11_6">ジェネリックラムダ</a><br />
    <a
href="core_lang_spec.html#SS_19_11_7">クラステンプレートのテンプレート引数の型推論</a><br />
    <a href="core_lang_spec.html#SS_19_11_8">CTAD(Class Template Argument
Deduction)</a><br />
    <a
href="core_lang_spec.html#SS_19_11_9">テンプレートの型推論ガイド</a><br />
    <a href="core_lang_spec.html#SS_19_11_10">変数テンプレート</a><br />
    <a
href="core_lang_spec.html#SS_19_11_11">エイリアステンプレート</a><br />
    <a href="core_lang_spec.html#SS_19_11_12">constexpr if文</a><br />
    <a
href="core_lang_spec.html#SS_19_11_13">autoパラメータによる関数テンプレートの簡易定義</a><br />
    <a href="core_lang_spec.html#SS_19_11_14">auto</a><br />
    <a href="core_lang_spec.html#SS_19_11_15">decltype</a><br />
    <a href="core_lang_spec.html#SS_19_11_16">decltype(auto)</a><br />
    <a
href="core_lang_spec.html#SS_19_11_17">戻り値型を後置する関数宣言</a><br />
    <a href="core_lang_spec.html#SS_19_11_18">関数の戻り値型auto</a><br />
    <a href="core_lang_spec.html#SS_19_11_19">後置戻り値型auto</a></p>
<p>   <a href="core_lang_spec.html#SS_19_12">name
lookupと継承構造</a><br />
    <a href="core_lang_spec.html#SS_19_12_1">ルックアップ</a><br />
    <a href="core_lang_spec.html#SS_19_12_2">name lookup</a><br />
    <a href="core_lang_spec.html#SS_19_12_3">two phase name
lookup</a><br />
    <a href="core_lang_spec.html#SS_19_12_4">実引数依存探索</a><br />
    <a href="core_lang_spec.html#SS_19_12_5">ADL</a><br />
    <a href="core_lang_spec.html#SS_19_12_6">関連名前空間</a><br />
    <a
href="core_lang_spec.html#SS_19_12_7">修飾付き関数呼び出し</a><br />
    <a href="core_lang_spec.html#SS_19_12_8">hidden-friend関数</a><br />
    <a href="core_lang_spec.html#SS_19_12_9">name-hiding</a><br />
    <a href="core_lang_spec.html#SS_19_12_10">ダイヤモンド継承</a><br />
    <a href="core_lang_spec.html#SS_19_12_11">仮想継承</a><br />
    <a href="core_lang_spec.html#SS_19_12_12">仮想基底</a><br />
    <a href="core_lang_spec.html#SS_19_12_13">ドミナンス</a><br />
     <a
href="core_lang_spec.html#SS_19_12_13_1">ダイヤモンド継承を含まない場合</a><br />
     <a
href="core_lang_spec.html#SS_19_12_13_2">ダイヤモンド継承かつそれが仮想継承でない場合</a><br />
     <a
href="core_lang_spec.html#SS_19_12_13_3">ダイヤモンド継承かつそれが仮想継承である場合</a></p>
<p>    <a href="core_lang_spec.html#SS_19_12_14">using宣言</a><br />
    <a href="core_lang_spec.html#SS_19_12_15">usingディレクティブ</a></p>
<p>   <a
href="core_lang_spec.html#SS_19_13">エクセプション安全性の保証</a><br />
    <a href="core_lang_spec.html#SS_19_13_1">no-fail保証</a><br />
    <a href="core_lang_spec.html#SS_19_13_2">強い安全性の保証</a><br />
    <a
href="core_lang_spec.html#SS_19_13_3">基本的な安全性の保証</a><br />
    <a href="core_lang_spec.html#SS_19_13_4">noexcept</a><br />
    <a href="core_lang_spec.html#SS_19_13_5">exception-unfriendly</a></p>
<p>   <a href="core_lang_spec.html#SS_19_14">言語仕様の定義要素</a><br />
    <a href="core_lang_spec.html#SS_19_14_1">ill-formed</a><br />
    <a href="core_lang_spec.html#SS_19_14_2">well-formed</a><br />
    <a href="core_lang_spec.html#SS_19_14_3">未定義動作</a><br />
    <a href="core_lang_spec.html#SS_19_14_4">未規定動作</a><br />
    <a
href="core_lang_spec.html#SS_19_14_5">未定義動作と未規定動作</a><br />
    <a href="core_lang_spec.html#SS_19_14_6">被修飾型</a><br />
    <a href="core_lang_spec.html#SS_19_14_7">実引数/仮引数</a><br />
    <a href="core_lang_spec.html#SS_19_14_8">単純代入</a><br />
    <a href="core_lang_spec.html#SS_19_14_9">one-definition rule</a><br />
    <a href="core_lang_spec.html#SS_19_14_10">ODR</a><br />
    <a href="core_lang_spec.html#SS_19_14_11">型特性キーワード</a><br />
     <a href="core_lang_spec.html#SS_19_14_11_1">alignof</a><br />
     <a href="core_lang_spec.html#SS_19_14_11_2">alignas</a><br />
     <a href="core_lang_spec.html#SS_19_14_11_3">addressof</a></p>
<p>    <a
href="core_lang_spec.html#SS_19_14_12">演算子のオペランドの評価順位</a></p>
<p>   <a href="core_lang_spec.html#SS_19_15">その他</a><br />
    <a href="core_lang_spec.html#SS_19_15_1">RVO(Return Value
Optimization)</a><br />
    <a href="core_lang_spec.html#SS_19_15_2">トライグラフ</a></p>
<p><a href="introduction.html#SS_1_4">インデックス</a>に戻る。</p>
<hr />
<h2 id="型システムと算術の基礎">型システムと算術の基礎
<a id="SS_19_1"></a></h2>
<h3 id="基本型">基本型 <a id="SS_19_1_1"></a></h3>
<p>基本型(fundamental types)は、C++の標準で定義されている型で、
特別なキーワードを使用して直接宣言できる型の総称である。 <a
href="core_lang_spec.html#SS_19_1_2">組み込み型</a>とも呼ばれることもある。</p>
<p>基本型は以下のに示した型によって構成される。</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_1_3">算術型</a></li>
<li><a href="core_lang_spec.html#SS_19_1_4">汎整数型</a></li>
<li><a href="core_lang_spec.html#SS_19_1_12">浮動小数点型</a></li>
<li>void</li>
<li>上記した型のポインタ型</li>
</ul>
<p>注:<br />
リファレンスは基本型に含まれない。</p>
<h3 id="組み込み型">組み込み型 <a id="SS_19_1_2"></a></h3>
<p>組み込み型(built-in types)は<a
href="core_lang_spec.html#SS_19_1_1">基本型</a>(fundamental
types)の別称。</p>
<h3 id="算術型">算術型 <a id="SS_19_1_3"></a></h3>
<p>算術型とは下記の型の総称である。</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_1_4">汎整数型</a>(bool, char, int,
unsigned int, long long等)</li>
<li><a
href="core_lang_spec.html#SS_19_1_12">浮動小数点型</a>(float、double、long
double)</li>
</ul>
<p>算術型のサイズは下記のように規定されている。</p>
<ul>
<li>1 == sizeof(bool) == sizeof(char)</li>
<li>sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;=
sizeof(long) &lt;= sizeof(long long)</li>
<li>4 &lt;= sizeof(long)</li>
<li>8 &lt;= sizeof(long long)</li>
<li>4 == sizeof(float)</li>
<li>8 == sizeof(double) &lt;= sizeof(long double)</li>
</ul>
<h3 id="汎整数型">汎整数型 <a id="SS_19_1_4"></a></h3>
<p>汎整数型とは下記の型の総称である。</p>
<ul>
<li>論理型(bool)</li>
<li>文字型(char、wchar_t等)</li>
<li><a href="core_lang_spec.html#SS_19_1_5">整数型</a>(int、unsigned
int、long等)</li>
</ul>
<h3 id="整数型">整数型 <a id="SS_19_1_5"></a></h3>
<p>整数型とは下記の型の総称である。</p>
<ul>
<li>signed char</li>
<li>unsigned char</li>
<li>short</li>
<li>unsigned short</li>
<li>int</li>
<li>unsigned int</li>
<li>long</li>
<li>unsigned long</li>
<li>long long</li>
<li>unsigned long long</li>
</ul>
<h4 id="ビットシフトにおける未定義動作">ビットシフトにおける未定義動作
<a id="SS_19_1_5_1"></a></h4>
<p><strong>[動作の分類]</strong></p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 29%" />
<col style="width: 20%" />
<col style="width: 22%" />
</colgroup>
<thead>
<tr class="header">
<th>条件</th>
<th style="text-align: left;">unsigned</th>
<th>signed (C++17以前)</th>
<th>signed (C++20以降)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>シフト量が負</td>
<td style="text-align: left;">未定義動作</td>
<td>未定義動作</td>
<td>未定義動作</td>
</tr>
<tr class="even">
<td>シフト量 ≥ ビット数</td>
<td style="text-align: left;">未定義動作</td>
<td>未定義動作</td>
<td>未定義動作</td>
</tr>
<tr class="odd">
<td>負の値の左シフト</td>
<td style="text-align: left;">N/A</td>
<td>未定義動作</td>
<td>未定義動作</td>
</tr>
<tr class="even">
<td>左シフトでオーバーフロー</td>
<td style="text-align: left;">定義済み(ラップアラウンド)</td>
<td>未定義動作</td>
<td>未定義動作</td>
</tr>
<tr class="odd">
<td>負の値の右シフト</td>
<td style="text-align: left;">N/A</td>
<td>実装定義</td>
<td>定義済み(算術シフト)</td>
</tr>
<tr class="even">
<td>正の値の右シフト</td>
<td style="text-align: left;">定義済み（論理シフト）</td>
<td>定義済み</td>
<td>定義済み</td>
</tr>
</tbody>
</table>
<p><strong>[具体例]</strong></p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 24%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>コード例</th>
<th>動作</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>x &lt;&lt; -1</code></td>
<td>未定義動作</td>
<td>負のシフト量(型に関わらず)</td>
</tr>
<tr class="even">
<td><code>x &lt;&lt; 32</code></td>
<td>未定義動作</td>
<td>シフト量がビット数以上(intが32ビットの場合)</td>
</tr>
<tr class="odd">
<td><code>int x = -1; x &lt;&lt; 1</code></td>
<td>未定義動作</td>
<td>負の値の左シフト</td>
</tr>
<tr class="even">
<td><code>int x = INT_MAX; x &lt;&lt; 1</code></td>
<td>未定義動作</td>
<td>オーバーフロー</td>
</tr>
<tr class="odd">
<td><code>unsigned x = UINT_MAX; x &lt;&lt; 1</code></td>
<td>定義済み</td>
<td>ラップアラウンド(結果は最大値の2倍を2^nで割った余り)</td>
</tr>
<tr class="even">
<td><code>int x = -8; x &gt;&gt; 1</code></td>
<td>実装定義(上記テーブル参照)</td>
<td>負の値の右シフト</td>
</tr>
<tr class="odd">
<td><code>unsigned x = 8; x &gt;&gt; 1</code></td>
<td>定義済み</td>
<td>論理シフト</td>
</tr>
</tbody>
</table>
<p><strong>[安全なビットシフトのガイドライン]</strong></p>
<table>
<thead>
<tr class="header">
<th>推奨事項</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>符号なし整数型を使用(注)</td>
<td>未定義動作を回避しやすい</td>
</tr>
<tr class="even">
<td>シフト量の範囲チェック</td>
<td>0 ≤ シフト量 &lt; ビット数を保証</td>
</tr>
<tr class="odd">
<td>負の値をシフトしない</td>
<td>未定義動作の原因</td>
</tr>
<tr class="even">
<td>オーバーフローの可能性を考慮</td>
<td>特にsigned型での左シフト</td>
</tr>
<tr class="odd">
<td>静的解析ツールを活用</td>
<td>コンパイル時に検出可能</td>
</tr>
</tbody>
</table>
<p>(注) 符号なし<a
href="core_lang_spec.html#SS_19_1_5">整数型</a>変数(us)をオペランドにした左ビットシフトがオーバーフローした場合、
usが整数昇格によりintに変換されるため、未定義動作になる可能性がある。</p>
<h3 id="算術変換">算術変換 <a id="SS_19_1_6"></a></h3>
<p>C++における算術変換とは、算術演算の1つのオペランドが他のオペランドと同じ型でない場合、
1つのオペランドを他のオペランドと同じ型に変換するプロセスのことを指す。</p>
<p>算術変換は、<a
href="core_lang_spec.html#SS_19_1_7">汎整数型昇格</a>と通常算術変換に分けられる。</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/integral_promotion_ut.cpp 11</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span>           bval<span class="op">{};</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span>           cval<span class="op">{};</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">short</span>          sval<span class="op">{};</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">short</span> usval<span class="op">{};</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>            ival<span class="op">{};</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span>   uival<span class="op">{};</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span>           lval<span class="op">{};</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span>  ulval<span class="op">{};</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span>          fval<span class="op">{};</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span>         dval<span class="op">{};</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret_0 <span class="op">=</span> <span class="fl">3.14159</span> <span class="op">+</span> <span class="ch">&#39;a&#39;</span><span class="op">;</span>  <span class="co">// &#39;a&#39;は汎整数拡張でintになった後、さらに通常算術変換でdoubleに</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ret_0<span class="op">),</span> <span class="dt">double</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret_1 <span class="op">=</span> dval <span class="op">+</span> ival<span class="op">;</span>  <span class="co">// ivalは通常算術変換でdoubleに</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ret_1<span class="op">),</span> <span class="dt">double</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret_2 <span class="op">=</span> dval <span class="op">+</span> fval<span class="op">;</span>  <span class="co">// fvalは通常算術変換でdoubleに</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ret_2<span class="op">),</span> <span class="dt">double</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret_3 <span class="op">=</span> ival <span class="op">=</span> dval<span class="op">;</span>  <span class="co">// dvalは通常算術変換でintに</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ret_3<span class="op">),</span> <span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    bval <span class="op">=</span> dval<span class="op">;</span>  <span class="co">// dvalは通常算術変換でboolに</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>bval<span class="op">);</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret_4 <span class="op">=</span> cval <span class="op">+</span> fval<span class="op">;</span>  <span class="co">// cvalは汎整数拡張でintになった後、さらに通常算術変換でfloatに</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ret_4<span class="op">),</span> <span class="dt">float</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret_5 <span class="op">=</span> sval <span class="op">+</span> cval<span class="op">;</span>  <span class="co">// svalとcvalは汎整数拡張でintに</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ret_5<span class="op">),</span> <span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret_6 <span class="op">=</span> cval <span class="op">+</span> lval<span class="op">;</span>  <span class="co">// cvalはは汎整数拡張でintになった後、通常算術変換でlongに</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ret_6<span class="op">),</span> <span class="dt">long</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret_7 <span class="op">=</span> ival <span class="op">+</span> ulval<span class="op">;</span>  <span class="co">// ivalは通常算術変換でunsigned longに</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ret_7<span class="op">),</span> <span class="dt">unsigned</span> <span class="dt">long</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret_8 <span class="op">=</span> usval <span class="op">+</span> ival<span class="op">;</span>  <span class="co">// usvalは汎整数拡張でintに</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>                                <span class="co">// ただし、この変換はunsigned shortとintのサイズに依存する</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ret_8<span class="op">),</span> <span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret_9 <span class="op">=</span> uival <span class="op">+</span> lval<span class="op">;</span>  <span class="co">// uivalは通常算術変換でlongに</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>                                <span class="co">// ただし、この変換はunsigned intとlongのサイズに依存する</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ret_9<span class="op">),</span> <span class="dt">long</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span></code></pre></div>
<p><a
href="core_lang_spec.html#SS_19_6_6">一様初期化</a>を使用することで、
変数定義時の算術変換による意図しない値の変換(<a
href="core_lang_spec.html#SS_19_1_11">縮小型変換</a>)を防ぐことができる。</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/integral_promotion_ut.cpp 62</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">{-</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// int8_t i8 {i};  縮小型変換によりコンパイル不可</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int8_t</span> i8 <span class="op">=</span> i<span class="op">;</span>  <span class="co">// intからint8_tへの型変換</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// これには問題ないが</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(-</span><span class="dv">1</span><span class="op">,</span> i8<span class="op">);</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// uint8_t ui8 {i};  縮小型変換によりコンパイル不可</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> ui8 <span class="op">=</span> i<span class="op">;</span>  <span class="co">// intからuint8_tへの型変換</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// おそらく意図通りではない</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">255</span><span class="op">,</span> ui8<span class="op">);</span></span></code></pre></div>
<p>以下に示すように、算術変換の結果は直感に反することがあるため、注意が必要である。</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/integral_promotion_ut.cpp 81</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>          i<span class="op">{-</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> ui<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_TRUE(i &lt; ui);</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>i <span class="op">&gt;</span> ui<span class="op">);</span>  <span class="co">// 算術変換の影響で、-1 &lt; 1が成立しない</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">signed</span> <span class="dt">short</span>   s<span class="op">{-</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">short</span> us<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>s <span class="op">&lt;</span> us<span class="op">);</span>  <span class="co">// 汎整数拡張により、-1 &lt; 1が成立</span></span></code></pre></div>
<h3 id="汎整数型昇格">汎整数型昇格 <a id="SS_19_1_7"></a></h3>
<p>bool、char、signed char、unsigned char、short、unsigned
short型の変数が、 算術のオペランドとして使用される場合、</p>
<ul>
<li>その変数の型の取り得る値全てがintで表現できるのならば、int型に変換される。</li>
<li>そうでなければ、その変数はunsigned int型に変換される。</li>
</ul>
<p>この変換を汎整数型昇格(integral promotion)と呼ぶ。</p>
<p>従って、sizof(short) &lt; sizeof(int)である処理系では、
bool、char、signed char、unsigned char、short、unsigned
short型の変数は、 下記のようにintに変換される。</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/integral_promotion_ut.cpp 100</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> bval<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>bval <span class="op">+</span> bval<span class="op">)&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> cval<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>cval <span class="op">+</span> cval<span class="op">)&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> ucval <span class="op">=</span> <span class="dv">128</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>ucval <span class="op">+</span> ucval<span class="op">)&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">256</span><span class="op">,</span> ucval <span class="op">+</span> ucval<span class="op">);</span>  <span class="co">// 汎整数拡張により256になる</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>cval <span class="op">+</span> ucval<span class="op">)&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">short</span> sval<span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>sval <span class="op">+</span> sval<span class="op">)&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">short</span> usval<span class="op">;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>usval <span class="op">+</span> usval<span class="op">)&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>sval <span class="op">+</span> usval<span class="op">)&gt;::</span>value<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span></code></pre></div>
<h3 id="汎整数型拡張">汎整数型拡張 <a id="SS_19_1_8"></a></h3>
<p>汎整数型拡張とは<a
href="core_lang_spec.html#SS_19_1_7">汎整数型昇格</a>と同じ概念を指す。</p>
<h3 id="浮動小数点型昇格">浮動小数点型昇格 <a id="SS_19_1_9"></a></h3>
<p>浮動小数点型昇格とは、float型とdouble型の演算で、
float型オブジェクトがdoulbe型に変換されることを指す。</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/integral_promotion_ut.cpp 126</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> d <span class="op">=</span> <span class="fl">0.05</span><span class="op">;</span>  <span class="co">// 0.05は循環少数</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span>  f <span class="op">=</span> <span class="fl">0.05</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> b1 <span class="op">=</span> d <span class="op">==</span> f<span class="op">;</span>  <span class="co">// fはdoubleに昇格</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>b1<span class="op">);</span>  <span class="co">// 0.05は循環少数であるため、0.5と0.5fは異なる。</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> b2 <span class="op">=</span> <span class="bu">std::</span>abs<span class="op">(</span>d <span class="op">-</span> f<span class="op">)</span> <span class="op">&lt;=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>d <span class="op">-</span> f<span class="op">)&gt;::</span>epsilon<span class="op">();</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>b2<span class="op">);</span>  <span class="co">// dとfの差はdoubleのイプシロンには収まらない。</span></span></code></pre></div>
<h3 id="デフォルト引数昇格">デフォルト引数昇格
<a id="SS_19_1_10"></a></h3>
<p>デフォルト引数昇格(Default Argument
Promotions)とは、可変長引数<code>(...)</code>や、
プロトタイプを持たない関数に<a
href="core_lang_spec.html#SS_19_1_3">算術型</a>引数を渡す際に適用される昇格ルールの総称である。</p>
<p>デフォルト引数昇格には以下が含まれる。</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_1_7">汎整数型昇格</a></li>
<li><a href="core_lang_spec.html#SS_19_1_9">浮動小数点型昇格</a></li>
</ul>
<h3 id="縮小型変換">縮小型変換 <a id="SS_19_1_11"></a></h3>
<p>縮小型変換(Narrowing Conversion)
とは、あるデータ型から別のデータ型に変換する際に、
変換先の型が元の型の表現範囲を完全にカバーしていない場合に発生する変換を指す。
主に<a href="core_lang_spec.html#SS_19_1_5">整数型</a>や<a
href="core_lang_spec.html#SS_19_1_12">浮動小数点型</a>などの値を小さな範囲の型に変換する際に起こる。</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/etc_ut.cpp 19</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> large  <span class="op">=</span> <span class="dv">300</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int8_t</span>  small  <span class="op">=</span> large<span class="op">;</span>  <span class="co">// 縮小型変換</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span>    b      <span class="op">=</span> large<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span>  d      <span class="op">=</span> large<span class="op">;</span>  <span class="co">// 単単なる型変換(縮小ではない)</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> large2 <span class="op">=</span> d<span class="op">;</span>      <span class="co">// 縮小型変換</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// large = int32_t{d};   縮小型変換回避のためリスト初期化の使用。コンパイルエラー</span></span></code></pre></div>
<p><a
href="core_lang_spec.html#SS_19_6_5">リスト初期化</a>を使うことで、このような変換によるバグの発生を防ぐことができる。</p>
<h3 id="浮動小数点型">浮動小数点型 <a id="SS_19_1_12"></a></h3>
<p>浮動小数点型は以下の型の総称である。</p>
<ul>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>long double</code></li>
</ul>
<p>浮動小数点の仕様は、IEEE 754標準に準拠している。
この標準は、浮動小数点演算の表現方法、精度、丸め方法、および例外処理を規定しており、
広く使用されている。</p>
<h4
id="浮動小数点型のダイナミックレンジ">浮動小数点型のダイナミックレンジ
<a id="SS_19_1_12_1"></a></h4>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 34%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">型</th>
<th style="text-align: left;">正の最小値</th>
<th style="text-align: left;">正の最大値</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>float</code></td>
<td style="text-align: left;">1.175494351 e-38</td>
<td style="text-align: left;">3.402823466 e+38</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>double</code></td>
<td style="text-align: left;">2.2250738585072014 e-308</td>
<td style="text-align: left;">1.7976931348623158 e+308</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>long double</code></td>
<td style="text-align: left;">3.36210314311209350626 e-4932</td>
<td style="text-align: left;">1.18973149535723176502 e+4932</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int32_t</code></td>
<td style="text-align: left;">-2,147,483,648</td>
<td style="text-align: left;">2,147,483,647</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>int64_t</code></td>
<td style="text-align: left;">-9,223,372,036,854,775,808</td>
<td style="text-align: left;">9,223,372,036,854,775,807</td>
</tr>
</tbody>
</table>
<p>ここで<code>long double</code>の最小値と最大値は、システムやコンパイラに依存して異なる場合がある点に留意する。</p>
<h4 id="浮動小数点の誤差">浮動小数点の誤差
<a id="SS_19_1_12_2"></a></h4>
<p>浮動小数点変数の10進数の表現が2進数では循環小数となる場合があり、
正確に表現できないことがある。これにより、計算結果がわずかに異なる値を返す場合がある。
浮動小数点誤差は、特に計算の繰り返しや桁数の多い計算で顕著になる。</p>
<p>以下のコードにより誤差が容易に発生することを示す。</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/float_ut.cpp 12</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記の0.01は2進数では循環小数となるため、実数の0.01とは異なる。</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> a <span class="op">=</span> <span class="fl">0.01</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000001010001111...</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> b <span class="op">=</span> <span class="fl">0.04</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000101000111101...</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  ASSERT_EQ(0.05F, a + b);  // NG  a + b == 0.05Fは一般には成立しない。</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_NE<span class="op">(</span><span class="fl">0.05</span><span class="bu">F</span><span class="op">,</span> a <span class="op">+</span> b<span class="op">);</span></span></code></pre></div>
<h4 id="イプシロン">イプシロン <a id="SS_19_1_12_3"></a></h4>
<p>イプシロン(epsilon)とは、ある浮動小数点数に対して「1」を加えた時に、
異なる値として識別できる最小の差分を指す。
つまり、イプシロンは浮動小数点数の精度を示す尺度である。</p>
<p>任意の浮動小数点変数a,
bがあり、<code>|a - b| &lt;= epsilon</code>であった場合、
浮動小数点の仕組みではa、bの差が無いものと考えて、aとbが同値であると考えることが一般的である。</p>
<p>イプシロンを使用した浮動小数点変数の同値判定のコード例を以下に示す。</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/float_ut.cpp 24</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記の0.01は2進数では循環小数となるため、実数の0.01とは異なる。</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> a <span class="op">=</span> <span class="fl">0.01</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000001010001111...</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> b <span class="op">=</span> <span class="fl">0.04</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000101000111101...</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_equal <span class="op">=</span> <span class="fl">0.05</span><span class="bu">F</span> <span class="op">==</span> <span class="op">(</span>a <span class="op">+</span> b<span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>is_equal<span class="op">);</span>  <span class="co">// is_equalはtrueにはならない</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_nearly_equal <span class="op">=</span> <span class="bu">std::</span>abs<span class="op">(</span><span class="fl">0.05</span><span class="bu">F</span> <span class="op">-</span> <span class="op">(</span>a <span class="op">+</span> b<span class="op">))</span> <span class="op">&lt;=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;::</span>epsilon<span class="op">();</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>is_nearly_equal<span class="op">);</span>  <span class="co">// 浮動小数点の同値はこのように判定する</span></span></code></pre></div>
<h4 id="浮動小数点の演算エラー">浮動小数点の演算エラー
<a id="SS_19_1_12_4"></a></h4>
<p>浮動小数点の演算は以下のようなエラーを生じることがある。</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 63%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">エラーの種類</th>
<th style="text-align: left;">説明</th>
<th style="text-align: left;">例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">丸め誤差</td>
<td
style="text-align: left;">有限桁数による四捨五入の誤差が発生し、正確な値とわずかに異なる場合がある。</td>
<td style="text-align: left;"><code>0.1 + 0.2 != 0.3</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">桁落ち</td>
<td
style="text-align: left;">非常に小さい数と大きい数の加算時に、小さい数が無視され、精度が低下する。</td>
<td style="text-align: left;"><code>1e20 + 1 - 1e20 == 0</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">累積誤差</td>
<td
style="text-align: left;">繰り返し演算で小さな誤差が積み重なり、最終的に大きなズレが生じることがある。</td>
<td style="text-align: left;">ループ内での浮動小数点の加算</td>
</tr>
<tr class="even">
<td style="text-align: left;">ゼロ除算</td>
<td
style="text-align: left;">0での除算により計算が定義されず、例外が発生または±無限大が返される。</td>
<td style="text-align: left;"><code>1.0 / 0.0</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">オーバーフロー</td>
<td
style="text-align: left;">型が表現可能な最大値を超えると無限大（<code>inf</code>）として扱われる。</td>
<td style="text-align: left;"><code>std::pow(10.0, 308)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">アンダーフロー</td>
<td
style="text-align: left;">型の最小値より小さい数値は0または非常に小さな値として表現され、精度が失われる。</td>
<td style="text-align: left;"><code>std::pow(10.0, -308)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">NaN</td>
<td style="text-align: left;">実数では表現できない。</td>
<td style="text-align: left;"><code>std::sqrt(-1)</code></td>
</tr>
</tbody>
</table>
<p>浮動小数点の演算エラーの検出コード例を以下に示す。</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/float_ut.cpp 43</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>feclearexcept<span class="op">(</span>FE_ALL_EXCEPT<span class="op">);</span>  <span class="co">// エラーをクリア</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    div<span class="op">(</span><span class="fl">1.0</span><span class="bu">F</span><span class="op">,</span> <span class="fl">0.0</span><span class="bu">F</span><span class="op">);</span>  <span class="co">// 関数の中で0除算するが、終了シグナルは発生しない</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span><span class="bu">std::</span>fetestexcept<span class="op">(</span>FE_ALL_EXCEPT<span class="op">)</span> <span class="op">&amp;</span> FE_DIVBYZERO<span class="op">);</span>  <span class="co">// 0除算</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>feclearexcept<span class="op">(</span>FE_ALL_EXCEPT<span class="op">);</span>  <span class="co">// エラーをクリア</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    div<span class="op">(</span><span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;::</span>max<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> excepts <span class="op">=</span> <span class="bu">std::</span>fetestexcept<span class="op">(</span>FE_ALL_EXCEPT<span class="op">);</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>excepts <span class="op">&amp;</span> FE_DIVBYZERO<span class="op">);</span>  <span class="co">// 0除算</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>excepts <span class="op">&amp;</span> FE_INEXACT<span class="op">);</span>     <span class="co">// 演算が不正確</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>excepts <span class="op">&amp;</span> FE_INVALID<span class="op">);</span>    <span class="co">// 不正な操作</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>excepts <span class="op">&amp;</span> FE_OVERFLOW<span class="op">);</span>    <span class="co">// 演算がオーバーフローを起こした</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>excepts <span class="op">&amp;</span> FE_UNDERFLOW<span class="op">);</span>  <span class="co">// 演算がアンダーフローを起こした</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>feclearexcept<span class="op">(</span>FE_ALL_EXCEPT<span class="op">);</span>  <span class="co">// エラーをクリア</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> a <span class="op">=</span> <span class="fl">1.0</span><span class="bu">F</span> <span class="op">/</span> global_zero<span class="op">;</span>  <span class="co">// global_zero == 0</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span><span class="bu">std::</span>isinf<span class="op">(</span>a<span class="op">));</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> b <span class="op">=</span> <span class="bu">std::</span>sqrt<span class="op">(-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> c <span class="op">=</span> <span class="bu">std::</span>sqrt<span class="op">(-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span><span class="bu">std::</span>isnan<span class="op">(</span>b<span class="op">));</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>b <span class="op">==</span> c<span class="op">);</span>  <span class="co">// NaN == NaNは常にfalse</span></span></code></pre></div>
<p>なお、上記のコードで使用した<code>std::fetestexcept</code>は一般にスレッドセーフである。
<code>std::fetestexcept</code>がスレッドセーフでない処理系では、浮動小数演算エラーの検出は、
実質的には不可能になってしまうため、
浮動小数演算を複数コンテキストで行うソフトウェアの開発する場合、
処理系の選択に注意が必要である。</p>
<h2 id="リテラル">リテラル <a id="SS_19_2"></a></h2>
<p>プログラムに具体的な値を与えるための基本的な即値を指す。 例えば、1,
2, 1.0, true/false, nullptr, “literal string”など。</p>
<h3 id="生文字列リテラル">生文字列リテラル <a id="SS_19_2_1"></a></h3>
<p>下記の例にあるように正規表現をそのまま文字列リテラルとして表現するために、
C++11から導入された導入されたリテラル。</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/literal_ut.cpp 15</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>regex raw_re<span class="op">{</span><span class="st">R&quot;(</span><span class="vs">\d+</span><span class="st">)&quot;</span><span class="op">};</span>     <span class="co">// 生文字リテラルで正規表現パターン。\のエスケープが不要</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>regex normal_re<span class="op">{</span><span class="st">&quot;(</span><span class="sc">\\</span><span class="st">d+)&quot;</span><span class="op">};</span>  <span class="co">// 生文字リテラルで正規表現パターン。\のエスケープが必要</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string test_str <span class="op">=</span> <span class="st">&quot;The year is 2024&quot;</span><span class="op">;</span>  <span class="co">// テスト対象の文字列</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>smatch match<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            ASSERT_TRUE<span class="op">(</span><span class="bu">std::</span>regex_search<span class="op">(</span>test_str<span class="op">,</span> match<span class="op">,</span> raw_re<span class="op">));</span>  <span class="co">// 正規表現で数字部分を検索</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>match<span class="op">.</span>str<span class="op">(),</span> <span class="st">&quot;2024&quot;</span><span class="op">);</span>  <span class="co">// マッチした部分が &quot;2024&quot; であることをチェック</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>smatch match<span class="op">;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            ASSERT_TRUE<span class="op">(</span><span class="bu">std::</span>regex_search<span class="op">(</span>test_str<span class="op">,</span> match<span class="op">,</span> normal_re<span class="op">));</span>  <span class="co">// 正規表現で数字部分を検索</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span>match<span class="op">.</span>str<span class="op">(),</span> <span class="st">&quot;2024&quot;</span><span class="op">);</span>  <span class="co">// マッチした部分が &quot;2024&quot; であることをチェック</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<h3 id="進数リテラル">2進数リテラル <a id="SS_19_2_2"></a></h3>
<p>C++14以降では、0bまたは 0B
をプレフィックスとして使うことで、2進数リテラルを表現できる。</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/literal_ut.cpp 36</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> bin_value <span class="op">=</span> <span class="bn">0b1101</span><span class="op">;</span>  <span class="co">// 2進数リテラル  2進数1101 は10進数で 13</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>bin_value<span class="op">,</span> <span class="dv">13</span><span class="op">);</span></span></code></pre></div>
<h3 id="数値リテラル">数値リテラル <a id="SS_19_2_3"></a></h3>
<p>C++14では区切り文字’を使用し、数値リテラルを記述できるようになった。</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/literal_ut.cpp 42</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 区切り文字を使った数値リテラル</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> large_number <span class="op">=</span> <span class="dv">1&#39;000&#39;000</span><span class="op">;</span>  <span class="co">// 10進数は3桁で区切るとわかりやすい</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>large_number<span class="op">,</span> <span class="dv">1000000</span><span class="op">);</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> bin_with_separator <span class="op">=</span> <span class="bn">0b1011&#39;0010</span><span class="op">;</span>  <span class="co">// 10進数は4桁で区切るとわかりやすい</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>bin_with_separator<span class="op">,</span> <span class="dv">178</span><span class="op">);</span>    <span class="co">// 2進数 1011 0010 は 10進数で 178</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> hex_with_separator <span class="op">=</span> <span class="bn">0x00&#39;00&#39;ff&#39;ff</span><span class="op">;</span>  <span class="co">// 16進数は2桁で区切るとわかりやすい</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>hex_with_separator<span class="op">,</span> <span class="dv">65535</span><span class="op">);</span>    <span class="co">// 16進数 0x00010011 == 65535</span></span></code></pre></div>
<h3 id="ワイド文字列">ワイド文字列 <a id="SS_19_2_4"></a></h3>
<p>ワイド文字列リテラルを保持する型は下記のように定義された。</p>
<ul>
<li>char16_t: UTF-16エンコーディングのコード単位を扱う型。 u”…”
というリテラルでUTF-16文字列を表す。</li>
<li>char32_t: UTF-32エンコーディングのコード単位を扱う型。 U”…”
というリテラルでUTF-32文字列を表す。</li>
<li>char8_t: UTF-8エンコーディングのコード単位を扱う型。 u8”…”
というリテラルでUTF-8文字列を表す。</li>
</ul>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/literal_ut.cpp 59</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// UTF-16 文字列リテラル（uプレフィックスを使用）</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char16_t</span>       utf16_str<span class="op">[]</span>  <span class="op">=</span> <span class="st">u&quot;こんにちは&quot;</span><span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>u16string utf16_string <span class="op">=</span> <span class="st">u&quot;こんにちは&quot;</span><span class="op">;</span>  <span class="co">// UTF-16 std::u16string 型</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// UTF-32 文字列リテラル（Uプレフィックスを使用）</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char32_t</span>       utf32_str<span class="op">[]</span>  <span class="op">=</span> <span class="st">U&quot;こんにちは&quot;</span><span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>u32string utf32_string <span class="op">=</span> <span class="st">U&quot;こんにちは&quot;</span><span class="op">;</span>  <span class="co">// UTF-32 std::u32string 型</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// UTF-8 文字列リテラル（u8プレフィックスを使用）</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">char8_t</span><span class="op">*</span> utf8_str    <span class="op">=</span> <span class="st">u8&quot;こんにちは&quot;</span><span class="op">;</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>u8string  utf8_string <span class="op">=</span> <span class="st">u8&quot;こんにちは&quot;</span><span class="op">;</span>  <span class="co">// UTF-8 std::string 型</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else </span><span class="co">// c++17</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// UTF-8 文字列リテラル（u8プレフィックスを使用）</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> utf8_str    <span class="op">=</span> <span class="st">&quot;こんにちは&quot;</span><span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string utf8_string <span class="op">=</span> <span class="st">&quot;こんにちは&quot;</span><span class="op">;</span>  <span class="co">// UTF-8 std::string 型</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span></code></pre></div>
<h3 id="進浮動小数点数リテラル">16進浮動小数点数リテラル
<a id="SS_19_2_5"></a></h3>
<p>16進浮動小数点数リテラルは、
C++17から導入された浮動小数点数を16進数で表現する方法である。
特に、ハードウェアや低レベルのプログラミングで、
浮動小数点数の内部表現を直接扱う際に便利である</p>
<pre><code>    一般的な形式:
        0x[数字].[数字]p[指数]
        0x: 16進数を表すプレフィックス
        [数字]: 16進数の数字 (0-9, a-f, A-F)
        .: 小数点
        p: 指数部を表す
        [指数]: 10進数の指数

    例:
        0x1.2p3は下記に解説する

    リテラルの構成:
        0x: 16進数の開始を示す。
        1.2: 仮数部を表す。この部分は16進数。
        p3: 指数部を表す。この場合、2の3乗を意味すため、つまり8。

        1.2(16進数) =  1 + 2 / 16 = 1.125(10進数)
        1.125 * 8 = 9.0</code></pre>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/literal_ut.cpp 87</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// float型</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> hex_float <span class="op">=</span> <span class="fl">0x1.2p3</span><span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    EXPECT_FLOAT_EQ<span class="op">(</span>hex_float<span class="op">,</span> <span class="fl">9.0</span><span class="bu">f</span><span class="op">);</span>  <span class="co">// 正しい期待値は9.0f</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// double型</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> hex_double <span class="op">=</span> <span class="fl">0x1.2p3</span><span class="op">;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    EXPECT_DOUBLE_EQ<span class="op">(</span>hex_double<span class="op">,</span> <span class="fl">9.0</span><span class="op">);</span>  <span class="co">// 正しい期待値は9.0</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指数部が負の場合 (double型)</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> negative_exp <span class="op">=</span> <span class="fl">0x1.2p-2</span><span class="op">;</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    EXPECT_DOUBLE_EQ<span class="op">(</span>negative_exp<span class="op">,</span> <span class="fl">0.28125</span><span class="op">);</span>  <span class="co">// 期待値は正しい</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 小数点以下の部分がない場合 (double型)</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> integer_part <span class="op">=</span> <span class="fl">0x1p3</span><span class="op">;</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    EXPECT_DOUBLE_EQ<span class="op">(</span>integer_part<span class="op">,</span> <span class="fl">8.0</span><span class="op">);</span>  <span class="co">// 期待値は正しい</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    EXPECT_FLOAT_EQ<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;(</span>hex_double<span class="op">),</span> hex_float<span class="op">);</span>  <span class="co">// double型をfloatにキャスト</span></span></code></pre></div>
<h3 id="ユーザー定義リテラル">ユーザー定義リテラル
<a id="SS_19_2_6"></a></h3>
<p><a
href="core_lang_spec.html#SS_19_2_6_1">ユーザ定義リテラル演算子</a>により定義されたリテラルを指す。</p>
<h4 id="ユーザ定義リテラル演算子">ユーザ定義リテラル演算子
<a id="SS_19_2_6_1"></a></h4>
<p>ユーザ定義リテラル演算子とは以下のようなものである。</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/user_defined_literal_ut.cpp 4</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int32_t</span> one_km <span class="op">=</span> <span class="dv">1000</span><span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ユーザ定義リテラル演算子の定義</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int32_t</span> <span class="kw">operator</span><span class="st">&quot;&quot;</span>_kilo_meter<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> num_by_mk<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> num_by_mk <span class="op">*</span> one_km<span class="op">;</span> <span class="op">}</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int32_t</span> <span class="kw">operator</span><span class="st">&quot;&quot;</span>_meter<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> num_by_m<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> num_by_m<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/user_defined_literal_ut.cpp 15</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> km <span class="op">=</span> <span class="dv">3</span><span class="op">_kilo_meter;</span>  <span class="co">// ユーザ定義リテラル演算子の利用</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> m  <span class="op">=</span> <span class="dv">3000</span><span class="op">_meter;</span>    <span class="co">// ユーザ定義リテラル演算子の利用</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>m<span class="op">,</span> km<span class="op">);</span></span></code></pre></div>
<h4 id="stdstring型リテラル">std::string型リテラル
<a id="SS_19_2_6_2"></a></h4>
<p>“xxx”sとすることで、std::string型のリテラルを作ることができる。</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/user_defined_literal_ut.cpp 26</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals::string_literals<span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="st">&quot;str&quot;</span><span class="bu">s</span><span class="op">;</span>  <span class="co">// aはstd::string</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> <span class="st">&quot;str&quot;</span><span class="op">;</span>   <span class="co">// bはconst char*</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">),</span> <span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;str&quot;</span><span class="op">},</span> a<span class="op">);</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>b<span class="op">),</span> <span class="dt">char</span> <span class="at">const</span><span class="op">*&gt;);</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_STREQ<span class="op">(</span><span class="st">&quot;str&quot;</span><span class="op">,</span> b<span class="op">);</span></span></code></pre></div>
<h4 id="stdchronoのリテラル">std::chronoのリテラル
<a id="SS_19_2_6_3"></a></h4>
<p>std::chronoのリテラルは以下のコードのように使用できる。</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/literal_ut.cpp 109</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>chrono_literals<span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">1</span><span class="bu">s</span> <span class="op">==</span> <span class="dv">1000</span><span class="bu">ms</span><span class="op">);</span>  <span class="co">// 1秒 (1s) は 1000 ミリ秒 (1000ms) と等しい</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">1</span><span class="bu">min</span> <span class="op">==</span> <span class="dv">60</span><span class="bu">s</span><span class="op">);</span>  <span class="co">// 1分 (1min) は 60秒 (60s) と等しい</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">1</span><span class="bu">h</span> <span class="op">==</span> <span class="dv">3600</span><span class="bu">s</span><span class="op">);</span>  <span class="co">// 1時間 (1h) は 3600秒 (3600s) と等しい</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="fl">1.5</span><span class="bu">s</span> <span class="op">==</span> <span class="dv">1500</span><span class="bu">ms</span><span class="op">);</span>  <span class="co">// 小数点を使った時間リテラル</span></span></code></pre></div>
<h4 id="stdcomplexリテラル">std::complexリテラル
<a id="SS_19_2_6_4"></a></h4>
<p>std::complexリテラル以下のコードのように使用できる。</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/literal_ut.cpp 124</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>complex_literals<span class="op">;</span>  <span class="co">// 複素数リテラルを使うための名前空間</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="fl">1.0</span> <span class="op">+</span> <span class="fl">2.0</span><span class="bu">i</span><span class="op">;</span>  <span class="co">// std::complex&lt;double&gt;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> <span class="fl">3.0</span> <span class="op">+</span> <span class="fl">4.0</span><span class="bu">i</span><span class="op">;</span>  <span class="co">// std::complex&lt;double&gt;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> result <span class="op">=</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>result<span class="op">.</span>real<span class="op">(),</span> <span class="fl">4.0</span><span class="op">);</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>result<span class="op">.</span>imag<span class="op">(),</span> <span class="fl">6.0</span><span class="op">);</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>result<span class="op">,</span> <span class="fl">4.0</span> <span class="op">+</span> <span class="fl">6.0</span><span class="bu">i</span><span class="op">);</span></span></code></pre></div>
<h2 id="列挙型とバイト表現">列挙型とバイト表現 <a id="SS_19_3"></a></h2>
<h3 id="enum">enum <a id="SS_19_3_1"></a></h3>
<p>C++03までのenumは定数を分かりやすい名前で定義するための記法である。
このドキュメントでは、<a
href="core_lang_spec.html#SS_19_3_3">スコープドenum</a>に対して、C++03までのenumを非スコープドenum、
通常のenum、あるいは単にenumと呼ぶことがある。
C++03までのenumには、以下のような問題があった。</p>
<ul>
<li>スコープの制限:
名前付きスコープ内に定義するためには、クラスのメンバとして定義しなければならない。</li>
<li>型安全性: enumの値は整数型と暗黙の変換が行われてしまう。</li>
<li>名前空間の汚染:
グローバルスコープに定義されたenumは、名前空間を汚染する。</li>
</ul>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/enum_ut.cpp 14</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> DayOfWeek <span class="op">{</span> Sunday<span class="op">,</span> Monday<span class="op">,</span> Tuesday<span class="op">,</span> Wednesday<span class="op">,</span> Thursday<span class="op">,</span> Friday<span class="op">,</span> Saturday <span class="op">};</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span><span class="dv">1</span> <span class="op">==</span> Monday<span class="op">);</span>  <span class="co">// intへの暗黙の変換</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> Color <span class="op">{</span> Red<span class="op">,</span> Green<span class="op">,</span> Blue <span class="op">};</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>Green <span class="op">==</span> Monday<span class="op">);</span>  <span class="co">// 別のenumが比較できてしまう</span></span></code></pre></div>
<h3 id="enum-class">enum class <a id="SS_19_3_2"></a></h3>
<p>enum classは通常の<a
href="core_lang_spec.html#SS_19_3_1">enum</a>の問題を解決するためにC++11から導入された。</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/enum_ut.cpp 29</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> DayOfWeek <span class="op">{</span> Sunday<span class="op">,</span> Monday<span class="op">,</span> Tuesday<span class="op">,</span> Wednesday<span class="op">,</span> Thursday<span class="op">,</span> Friday<span class="op">,</span> Saturday <span class="op">};</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_TRUE(1 == Monday);  // intへの暗黙の変換できないため、コンパイルエラー</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span><span class="dv">1</span> <span class="op">==</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>DayOfWeek<span class="op">::</span>Monday<span class="op">));</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> Color <span class="op">{</span> Red<span class="op">,</span> Green<span class="op">,</span> Blue <span class="op">};</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_TRUE(Green == Monday);  // 別のenumが比較できないため、コンパイルエラー</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span>DayOfWeek<span class="op">&gt;(</span>Color<span class="op">::</span>Green<span class="op">)</span> <span class="op">==</span> DayOfWeek<span class="op">::</span>Monday<span class="op">);</span></span></code></pre></div>
<div class="sourceCode" id="cb23"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/enum_ut.cpp 41</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// DayOfWeek d0 {0}; intからの暗黙の型変換は許可されないため、コンパイルエラー</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    DayOfWeek d0<span class="op">{</span><span class="kw">static_cast</span><span class="op">&lt;</span>DayOfWeek<span class="op">&gt;(</span><span class="dv">0</span><span class="op">)};</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    DayOfWeek d1<span class="op">{};</span>  <span class="co">// デフォルト初期化</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>d1<span class="op">,</span> DayOfWeek<span class="op">::</span>Sunday<span class="op">);</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    DayOfWeek d2<span class="op">{</span>DayOfWeek<span class="op">::</span>Tuesday<span class="op">};</span>  <span class="co">// 値あり初期化</span></span></code></pre></div>
<h3 id="スコープドenum">スコープドenum <a id="SS_19_3_3"></a></h3>
<p><a href="core_lang_spec.html#SS_19_3_2">enum
class</a>はスコープドenum(scoped enum)と呼ばれることがある。</p>
<h3 id="underlying-type">underlying type <a id="SS_19_3_4"></a></h3>
<p>underlying typeとは、enumやenum classの<a
href="core_lang_spec.html#SS_19_1_4">汎整数型</a>を指定できるようにするために、
C++11で導入されたシンタックスである。enumのサイズをユーザが定義できるため、
特定のバイナリプロトコルとの互換性が必要な場合や、特定のハードウェアと連携する際に特に有効である。</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/enum_ut.cpp 54</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> NormalEnum <span class="op">{</span>  <span class="co">// underlying typeの指定しない従来のenum</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> NormalEnumUnderlyingType <span class="op">:</span> <span class="dt">int8_t</span> <span class="op">{</span>  <span class="co">// enum underlying typeがint8_tに指定された従来のenum</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// enum class</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> EnumClass <span class="op">{</span>  <span class="co">// underlying typeの指定しないenum class</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> EnumClassUnderlyingType <span class="op">:</span> <span class="dt">int64_t</span> <span class="op">{</span>  <span class="co">// enum underlying typeがint64_tに指定されたenum</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>                                                    <span class="co">// class</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">4</span> <span class="op">==</span>  <span class="kw">sizeof</span><span class="op">(</span>NormalEnum<span class="op">));</span>  <span class="co">// 列挙子の値を表現するのに十分なサイズの整数型で処理系依存</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">4</span> <span class="op">==</span>  <span class="kw">sizeof</span><span class="op">(</span>EnumClass<span class="op">));</span>   <span class="co">// 列挙子の値を表現するのに十分なサイズの整数型で処理系依存</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int8_t</span><span class="op">)</span> <span class="op">==</span> <span class="kw">sizeof</span><span class="op">(</span>NormalEnumUnderlyingType<span class="op">));</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int64_t</span><span class="op">)</span> <span class="op">==</span> <span class="kw">sizeof</span><span class="op">(</span>EnumClassUnderlyingType<span class="op">));</span></span></code></pre></div>
<p>C++17までは、型安全の観点から、初期化においては、以下のコードコメントのような仕様であったが、
C++17から導入された<a
href="core_lang_spec.html#SS_19_3_5">std::byte</a>の利便性のため、
underlying typeを指定したenumやenum class変数のunderlying
typeインスタンスによる初期化が認められるようになった。</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/enum_ut.cpp 80</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> Color <span class="op">:</span> <span class="dt">int</span> <span class="op">{</span> Red<span class="op">,</span> Green<span class="op">,</span> Blue <span class="op">};</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color red{0}; C++14まではコンパイルエラー</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    Color red<span class="op">{</span><span class="dv">0</span><span class="op">};</span>  <span class="co">// underlying typeの効果でC++17からコンパイルできる。</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> a<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Color green{a};  // 縮小型変換が発生するため、コンパイルエラー</span></span></code></pre></div>
<p>上記コードにもあるが、underlying
typeインスタンスによる初期化を行う場合は、
意図しない縮小型変換によるバグの発生を防ぐためにも、 <a
href="core_lang_spec.html#SS_19_6_6">一様初期化</a>を使用するべきだろう。</p>
<p>一部の例外を除くとunderlying typeを指定しないenumやenum
classはコンパイル時にサイズが確定できないため、
前方宣言できないが、underlying typeを指定したenum、enum
classは前方宣言することができる。</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/enum_ut.cpp 97</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// in calender.h</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> DayOfWeek <span class="op">:</span> <span class="dt">int8_t</span><span class="op">;</span>  <span class="co">// DayOfWeekの前方宣言</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> calender<span class="op">(</span>DayOfWeek<span class="op">);</span>  <span class="co">// 前方宣言の効果でこのヘッダでの#include &quot;day_of_week.h&quot;が不要</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// in day_of_week.h</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> DayOfWeek <span class="op">:</span> <span class="dt">int8_t</span> <span class="op">{</span> Sunday<span class="op">,</span> Monday<span class="op">,</span> Tuesday<span class="op">,</span> Wednesday<span class="op">,</span> Thursday<span class="op">,</span> Friday<span class="op">,</span> Saturday <span class="op">};</span></span></code></pre></div>
<h3 id="stdbyte">std::byte <a id="SS_19_3_5"></a></h3>
<p>C++17で導入されたstd::byte型は、バイト単位のデータ操作に使用され、 <a
href="core_lang_spec.html#SS_19_1_5">整数型</a>としての意味を持たないため、型安全性を確保する。
uint8_t型と似ているが、uint8_t型の演算による<a
href="core_lang_spec.html#SS_19_1_7">汎整数型昇格</a>を発生させないため、
可読性、保守性の向上が見込める。</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/enum_ut.cpp 113</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> u8_0     <span class="op">=</span> <span class="bn">0x80</span><span class="op">;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>    result_0 <span class="op">=</span> u8_0 <span class="op">&lt;&lt;</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// 汎整数拡張のためresult_0の型はintになる</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>result_0<span class="op">),</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bn">0x100</span><span class="op">,</span> result_0<span class="op">);</span>  <span class="co">// これがわかりずらいバグにつながることがある</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> u8_1     <span class="op">=</span> <span class="bu">std::</span>byte<span class="op">{</span><span class="bn">0x80</span><span class="op">};</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> result_1 <span class="op">=</span> u8_1 <span class="op">&lt;&lt;</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// 汎整数拡張は発生せず、result_1の型はstd::byteになる</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>result_1<span class="op">),</span> <span class="bu">std::</span>byte<span class="op">&gt;);</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 整数型を取り出すためには、暗黙の型変換ではなく、</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 明示的なto_integerの呼び出しが必要になることもコードの安全性につながる</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bn">0x00</span><span class="op">,</span> <span class="bu">std::</span>to_integer<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>result_1<span class="op">));</span>  <span class="co">// 0x100はstd::byteでは0</span></span></code></pre></div>
<h3 id="using-enum">using enum <a id="SS_19_3_6"></a></h3>
<p>名前空間のように、</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">enum</span> EnumType<span class="op">;</span></span></code></pre></div>
<p>もしくは</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> EnumType<span class="op">::</span>enumerator</span></code></pre></div>
<p>とすることで、スコープによる修飾を省略するための記法である。</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/enum_ut.cpp 158</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> Color <span class="op">{</span> Red<span class="op">,</span> Green<span class="op">,</span> Yellow <span class="op">};</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="bu">std::</span>string_view to_str<span class="op">(</span>Color color<span class="op">)</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="kw">enum</span> Color<span class="op">;</span>       <span class="co">// 名前修飾の省略可能にする</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">switch</span> <span class="op">(</span>color<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Red<span class="op">:</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;Red&quot;</span><span class="op">;</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Green<span class="op">:</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;Green&quot;</span><span class="op">;</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Yellow<span class="op">:</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;Yellow&quot;</span><span class="op">;</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">switch</span> <span class="op">(</span>color<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Color<span class="op">::</span>Red<span class="op">:</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;Red&quot;</span><span class="op">;</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Color<span class="op">::</span>Green<span class="op">:</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;Green&quot;</span><span class="op">;</span></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Color<span class="op">::</span>Yellow<span class="op">:</span></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;Yellow&quot;</span><span class="op">;</span></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>        <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb31"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/enum_ut.cpp 194</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> Color<span class="op">::</span>Red<span class="op">;</span>  <span class="co">// Redに関しては名前修飾なしで使用する</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;Red&quot;</span><span class="op">,</span> to_str<span class="op">(</span>Red<span class="op">));</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;Yellow&quot;</span><span class="op">,</span> to_str<span class="op">(</span>Color<span class="op">::</span>Yellow<span class="op">));</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;Red&quot;</span><span class="op">,</span> to_str<span class="op">(</span>Color<span class="op">::</span>Red<span class="op">));</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;Yellow&quot;</span><span class="op">,</span> to_str<span class="op">(</span>Color<span class="op">::</span>Yellow<span class="op">));</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span></code></pre></div>
<div class="sourceCode" id="cb32"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/enum_ut.cpp 213</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Signal <span class="op">{</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> <span class="kw">class</span> Color <span class="op">{</span> Red<span class="op">,</span> Green<span class="op">,</span> Yellow <span class="op">};</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="kw">enum</span> Color<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> Set<span class="op">(</span>Color<span class="op">);</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/enum_ut.cpp 229</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    Signal s<span class="op">{};</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>Set<span class="op">(</span>Signal<span class="op">::</span>Color<span class="op">::</span>Red<span class="op">);</span>  <span class="co">// 名前修飾が長すぎる感じがする</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>Set<span class="op">(</span>Signal<span class="op">::</span>Red<span class="op">);</span>         <span class="co">// using enum colorがあるために、簡潔に書ける</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> Signal<span class="op">::</span>Red<span class="op">;</span>  <span class="co">// Redに関しては名前修飾なしで使用する</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>                        <span class="co">// この記述によりこの名前空間でのRed識別子が使えなくなる</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>Set<span class="op">(</span>Red<span class="op">);</span></span></code></pre></div>
<p>この記法は、簡潔に記述できるものの、一方では過度な使用は、
C++03までのenumが持っていた問題を再発生させてしまうため、
ブロックスコープ以外での使用に関しては控え目に使用するべきだろう。</p>
<h2 id="型とインスタンス">型とインスタンス <a id="SS_19_4"></a></h2>
<h3 id="トリビアル型">トリビアル型 <a id="SS_19_4_1"></a></h3>
<p>トリビアル型とは、</p>
<ul>
<li>全ての<a
href="core_lang_spec.html#SS_19_6_1">特殊メンバ関数</a>がデフォルトである。</li>
<li>バーチャル関数や仮想継承を持たない。</li>
<li>基底クラスがある場合、基底クラスもトリビアルである。</li>
</ul>
<p>である。その結果、トリビアル型とは、<a
href="core_lang_spec.html#SS_19_4_2">トリビアルに破壊可能な型</a>となる。</p>
<p>「型Tがトリビアルであること」と「以下の行がコンパイルできること」は等価である。</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_trivial_v<span class="op">&lt;</span>T<span class="op">&gt;);</span></span></code></pre></div>
<p>下記のコードはその使用例である。</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/trivial_ut.cpp 63</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_trivial_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_trivial_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;);</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_trivial_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">]&gt;);</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_trivial_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&gt;);</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> SizeUndefined <span class="op">{</span> su_0<span class="op">,</span> su_1 <span class="op">};</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Trivial <span class="op">{</span>      <span class="co">// トリビアルだが標準レイアウトではない</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">&amp;</span>          a<span class="op">;</span>  <span class="co">// リファレンスは標準レイアウトではない</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>        SizeUndefined b<span class="op">;</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_standard_layout_v<span class="op">&lt;</span>Trivial<span class="op">&gt;);</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_trivial_v<span class="op">&lt;</span>Trivial<span class="op">&gt;);</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_pod_v<span class="op">&lt;</span>Trivial<span class="op">&gt;);</span></span></code></pre></div>
<h3 id="トリビアルに破壊可能な型">トリビアルに破壊可能な型
<a id="SS_19_4_2"></a></h3>
<p>「トリビアルに破壊可能な型(Trivially
Destructible)」とは、以下の条件を満たす型を指す。</p>
<ul>
<li>デストラクタがユーザー定義されていない
(つまりコンパイラが生成したデフォルトのデストラクタを使用している)。</li>
<li>型に含まれるすべてのメンバ変数や基底クラスも「トリビアルに破壊可能」である。</li>
</ul>
<div class="sourceCode" id="cb36"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/trivial_ut.cpp 84</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_trivially_destructible_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_trivially_destructible_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;);</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_trivially_destructible_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">]&gt;);</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_trivially_destructible_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&gt;);</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> SizeUndefined <span class="op">{</span> su_0<span class="op">,</span> su_1 <span class="op">};</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Trivial <span class="op">{</span>  <span class="co">// トリビアルに破壊可能でないため、トリビアル型ではない</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>           a<span class="op">;</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>        SizeUndefined b<span class="op">;</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>Trivial<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_standard_layout_v<span class="op">&lt;</span>Trivial<span class="op">&gt;);</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_trivial_v<span class="op">&lt;</span>Trivial<span class="op">&gt;);</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_trivially_destructible_v<span class="op">&lt;</span>Trivial<span class="op">&gt;);</span></span></code></pre></div>
<h3 id="標準レイアウト型">標準レイアウト型 <a id="SS_19_4_3"></a></h3>
<p>「型Tが標準レイアウトであること」と「以下の行がコンパイルできること」は等価である。</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_standard_layout_v<span class="op">&lt;</span>T<span class="op">&gt;);</span></span></code></pre></div>
<p>下記のコードはその使用例である。</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/trivial_ut.cpp 42</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_standard_layout_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_standard_layout_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;);</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_standard_layout_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">]&gt;);</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_standard_layout_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&gt;);</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> SizeUndefined <span class="op">{</span> su_0<span class="op">,</span> su_1 <span class="op">};</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> StanderdLayout <span class="op">{</span>  <span class="co">// 標準レイアウトだがトリビアルではない</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>        StanderdLayout<span class="op">()</span> <span class="op">:</span> a<span class="op">{</span><span class="dv">0</span><span class="op">},</span> b<span class="op">{</span>SizeUndefined<span class="op">::</span>su_0<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>           a<span class="op">;</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>        SizeUndefined b<span class="op">;</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_standard_layout_v<span class="op">&lt;</span>StanderdLayout<span class="op">&gt;);</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_trivial_v<span class="op">&lt;</span>StanderdLayout<span class="op">&gt;);</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_pod_v<span class="op">&lt;</span>StanderdLayout<span class="op">&gt;);</span></span></code></pre></div>
<h3 id="集成体">集成体 <a id="SS_19_4_4"></a></h3>
<p>型Tが集成体であるための条件を以下に示す。</p>
<ul>
<li>型Tが<code>class</code>、<code>struct</code>、<code>union</code>であった場合、以下の条件を満たせばTは集成体である。
<ul>
<li>以下に示したユーザ定義による特殊関数が存在しない。
<ul>
<li>ユーザー定義のコンストラクタ(デフォルトコンストラクタ、コピーコンストラクタ、ムーブコンストラクタ)</li>
<li>デストラクタ</li>
<li>コピー代入演算子</li>
<li>ムーブ代入演算子</li>
</ul></li>
<li>すべての非静的メンバがpublicであるか、それらに外部からアクセスできる。</li>
<li>仮想関数や仮想基底クラスを持たないこと</li>
<li>仮想関数が定義されておらず、仮想基底クラス（仮想継承）を使用していない。</li>
<li>基底クラスを持たない。</li>
</ul></li>
<li>集成体の配列や、組み込み型の配列は集成体である。</li>
</ul>
<h3 id="pod">POD <a id="SS_19_4_5"></a></h3>
<p>PODとは、 Plain Old Dataの略語であり、
「型TがPODであること」と「以下の行がコンパイルできること」は等価である。</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_pod_v<span class="op">&lt;</span>T<span class="op">&gt;);</span>  <span class="co">// is_podはC++20から非推奨</span></span></code></pre></div>
<p>「型が<a href="core_lang_spec.html#SS_19_4_1">トリビアル型</a>且つ<a
href="core_lang_spec.html#SS_19_4_3">標準レイアウト型</a>であること」と
「型が<a
href="core_lang_spec.html#SS_19_4_5">POD</a>であること」は等価であるため、C++20では、
<a
href="https://cpprefjp.github.io/lang/cpp20/deprecate_pod.html">PODという用語は非推奨</a>となった。
従って、std::is_pod_vは以下のように置き換えられるべきである。</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/trivial_ut.cpp 9</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">// std::is_povはC++20から非推奨</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_pod_v <span class="op">=</span> <span class="bu">std::</span>is_trivial_v<span class="op">&lt;</span>T<span class="op">&gt;&amp;&amp;</span> <span class="bu">std::</span>is_standard_layout_v<span class="op">&lt;</span>T<span class="op">&gt;;</span></span></code></pre></div>
<p>下記のコードは置き換えられたstd::is_pod_vの使用例である。</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/trivial_ut.cpp 18</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_pod_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_pod_v<span class="op">&lt;</span><span class="dt">int</span> <span class="at">const</span><span class="op">&gt;);</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_pod_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;);</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_pod_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_pod_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&gt;);</span>  <span class="co">// リファレンスはPODではない</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Pod <span class="op">{};</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_pod_v<span class="op">&lt;</span>Pod<span class="op">&gt;);</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_pod_v<span class="op">&lt;</span>Pod <span class="at">const</span><span class="op">&gt;);</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_pod_v<span class="op">&lt;</span>Pod<span class="op">*&gt;);</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_pod_v<span class="op">&lt;</span>Pod<span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_pod_v<span class="op">&lt;</span>Pod<span class="op">&amp;&gt;);</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> NonPod <span class="op">{</span>  <span class="co">// コンストラクタがあるためPODではない</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>        NonPod<span class="op">();</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_pod_v<span class="op">&lt;</span>NonPod<span class="op">&gt;);</span></span></code></pre></div>
<p>上記からわかる通り、POD型とは概ね、C言語と互換性のある型を指すと思って良い。</p>
<h3 id="不完全型">不完全型 <a id="SS_19_4_6"></a></h3>
<p>不完全型とは、型のサイズや構造が不明な型を指す。
以下のis_completeで示したテンプレート定数で、不完全型か否かを判定できる。</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/incomplete_type_ut.cpp 4</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_complete <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">// sizeof(T) が有効であれば、Tは完全型であると判定</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_complete<span class="op">&lt;</span>T<span class="op">,</span> <span class="bu">std::</span>void_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>T<span class="op">))&gt;&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_complete_v <span class="op">=</span> is_complete<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb43"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/incomplete_type_ut.cpp 21</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> A<span class="op">;</span>  <span class="co">// Aの前方宣言</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>              <span class="co">// これ以降、Aは不完全型となる</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// auto a = sizeof(A);  Aが不完全型であるため、コンパイルエラー</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_complete_v<span class="op">&lt;</span>A<span class="op">&gt;);</span></span></code></pre></div>
<div class="sourceCode" id="cb44"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/incomplete_type_ut.cpp 31</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> A <span class="op">{</span>  <span class="co">// この宣言により、この行以降はAは完全型になる</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 何らかの宣言</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>A<span class="op">);</span>  <span class="co">// Aが完全型であるため、コンパイル可能</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_complete_v<span class="op">&lt;</span>A<span class="op">&gt;);</span></span></code></pre></div>
<h3 id="完全型">完全型 <a id="SS_19_4_7"></a></h3>
<p><a
href="core_lang_spec.html#SS_19_4_6">不完全型</a>ではない型を指す。</p>
<h3 id="ポリモーフィックなクラス">ポリモーフィックなクラス
<a id="SS_19_4_8"></a></h3>
<p>ポリモーフィックなクラスとは仮想関数を持つクラスや、
ポリモーフィックなクラスから派生したクラスを指す。
なお、純粋仮想関数を持つクラスは、 仮想クラスと呼ばれれる(「<a
href="core_lang_spec.html#SS_19_4_11">インターフェースクラス</a>」参照)。
ポリモーフィックなクラスと、 非ポリモーフィックなクラスは<a
href="core_lang_spec.html#SS_19_4_9">RTTI</a>との組み合わせで動作の違いが顕著となる。</p>
<p>非ポリモーフィックなクラスは非静的なメンバ変数が定義された順にメモリ上に配置されたレイアウトを持つ
(CPUアーキテクチャに依存したパディング領域が変数間に挿入されることもある)。
このようなクラスは<a href="core_lang_spec.html#SS_19_4_5">POD</a>
(C++20では、<a
href="https://cpprefjp.github.io/lang/cpp20/deprecate_pod.html">PODという用語は非推奨</a>
となり、<a href="core_lang_spec.html#SS_19_4_1">トリビアル型</a>と<a
href="core_lang_spec.html#SS_19_4_3">標準レイアウト型</a>に用語が分割された)とも呼ばれ、
C言語の構造体のレイアウトと互換性を持つことが一般的である。</p>
<p>ポリモーフィックなクラスは、 仮想関数呼び出しを行う(「<a
href="cpp_idioms.html#SS_21_8_1">オーバーライドとオーバーロードの違い</a>」参照)
ためのメモリレイアウトが必要になる。
それを示すために、まずは下記のようにクラスX、Y、Zを定義する。</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/class_layout_ut.cpp 4</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> X <span class="op">{</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">int64_t</span> GetX<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="op">~</span>X<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int64_t</span> <span class="va">x_</span><span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Y <span class="op">:</span> <span class="kw">public</span> X <span class="op">{</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">int64_t</span> GetX<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span> <span class="cf">return</span> X<span class="op">::</span>GetX<span class="op">()</span> <span class="op">+</span> <span class="va">y_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">int64_t</span> GetY<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">y_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="op">~</span>Y<span class="op">()</span> <span class="kw">override</span> <span class="op">{}</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int64_t</span> <span class="va">y_</span><span class="op">{</span><span class="dv">2</span><span class="op">};</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Z <span class="op">:</span> <span class="kw">public</span> Y <span class="op">{</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">int64_t</span> GetX<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span> <span class="cf">return</span> Y<span class="op">::</span>GetX<span class="op">()</span> <span class="op">+</span> <span class="va">z_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">int64_t</span> GetY<span class="op">()</span> <span class="kw">override</span> <span class="op">{</span> <span class="cf">return</span> Y<span class="op">::</span>GetY<span class="op">()</span> <span class="op">+</span> <span class="va">z_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">int64_t</span> GetZ<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">z_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="op">~</span>Z<span class="op">()</span> <span class="kw">override</span> <span class="op">{}</span></span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int64_t</span> <span class="va">z_</span><span class="op">{</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>通常のC++コンパイラが作り出すX、Y、Zの概念的なメモリレイアウトは下記のようになる。</p>
<p>下図中のvtbl(virtual table または virtual function table)とは、
仮想関数ポインタを保持するための構造体であり、仮想関数呼び出しを解決するための仕組みである。</p>
<!-- pu:essential/plant_uml/class_layout.pu-->
<p>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAAIwCAIAAADRYC9wAABcnElEQVR4Xuy9C1wV1d7/PxuEDWyQTSgIYYiUPGpiKh20svDKqeMlU1Hxije8EXFESfEa+qAiHC8o3jAFEenpqdPxOeCtkxl2+tm/18FrWubr0DHtmBlHDOWi/L+xavZuZoPszV4xM3zer8/L15rv+q41M3vWfFgOsxdCLQAAAEUiSAMAAACUAQwaAAAUismgHwAAAFAAMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoMGgAAFAoXAza29tbAEBJ0JiUDlMAFA8Xg6b7QewNACVAY7KsrKy8vLyioqKysrKmpkY6agFQHqYBLJakKdYDgwZKg8ZkaWnp9evXv//+e7Jp8mjpqAVAeZgGsFiSplgPDBooDRqTZ8+e/fLLL69evUoeTfNo6agFQHmYBrBYkqZYDwwaKA0ak8XFxSUlJeTRNI+mSbR01AKgPEwDWCxJU6wHBg2UBo3JwsJC8miaR5eWlpaVlUlHLQDKwzSAxZI0xXpg0EBp0JjMz88/dOjQqVOnaBL9/fffS0ctAMrDNIDFkjTFemDQQGnAoIEaMQ1gsSRNsR77GnR1dfUDswMFwAZg0ECNmAawWJKmWI99DZp6y8rKkkabwLFjx6jDK1euiJGqqqodO3bs2bPnAX4SaBQYNFAjpgEslqQp1qNwgz5//rybm1tYWBjNzVlk0aJFtJft27f/OhFoBxg0UCOmASyWpCnW0xSDrqysPHLkyL59+77++msWkRv05cuXc3JyCgsLaeYrBj/44AOaAl+4cMEs0XKQ2LVrF3W7bNkyKp88edLR0XHcuHGSHKAlYNBAjZgGsFiSpliPzQb93Xff9ejRQ6jD2dn5nXfeqZUZdHp6uoODA8sJDw9nHh0XF8ciOp1u3bp1LNNiUGT8+PGtWrU6duxYx44dO3XqdPv2bUkC0BICDBqoENMAFkvSFOsRbDXoWbNmGY1GuoVu3LgxYMCA6Ojo2l8bNNnxhAkTpkyZQglvv/02VR08eJDi7u7u8+bN++GHH7Zt20Yuz5ItBkXKy8ufeOIJmju7uLiUlJRIaoHGgEEDNWIawGJJmmI9Nhv0Y489lpiYyMr37t1jBXODrq07vKKioqSkpLFjx1IVmS8FIyIi2rdvv3///pqaGjHTYtAcsm/q4amnnqovAWgGGDRQI6YBLJakKdZjs0EbDIb09HRJUGLQr776Kk17aX49ffp0serWrVsUd3V1DQ8Pv3v3Lsu0GBShe1Wn0/Xv3586WbRokaQWaAwYNFAjpgEslqQp1mOzQffs2XPYsGGsfOHChY8//rhWZtCenp7JyclU+Oqrr8SqyspK+vfMmTMUeeutt1imxSDj2rVrbdu27dGjR1VV1eTJk8mp6dY1TwAaAwYN1IhpAIslaYr12GzQubm51Hb8+PFr164NCAjo0qVLTU2NxKAp+OSTT6alpVGBjHX16tUfffQRuW1iYiJ7ZHH48GFKsxhk3L9/PyIiQq/Xnzt3jjZv377dsWNHSv7mm2/EHKAxYNBAjZgGsFiSpliPzQZNZGZmBgcHu7m5vfjii+xNO4lBf/LJJ507d6aEKVOmREZGDhkypKysbObMmV5eXjS5TkhIYGkWg4xly5ZRn2TxYoS9affCCy/gYbRWgUEDNWIawGJJmmI9TTFoAHgAgwZqxDSAxZI0xXpg0EBpwKCBGjENYLEkTbEeGDRQGjBooEZMA1gsSVOsBwYNlAYMGqgR0wAWS9IU64FBA6UBgwZqxDSAxZI0xXpg0EBpwKCBGjENYLEkTbEeGDRQGjBooEZMA1gsSVOsx9vbWwBASRgMBhg0UB1cDJooKysrLS09e/ZscXFxYWFhPgDNDf6qN1AdvAy6vLz8+vXrNFUpKSmhu+IQAM0NjUMajTQmaWTS+JQOWQCUBy+DrqiooP9FXr16le4HmrOcAqC5oXFIo5HGJI1MGp/SIQuA8uBi0AajQfoIEIBmxWg0lpaW0tyZ3Jmmz5WVldJRC4Dy4GLQdD9s/2o7BClHNCZh0EB1wKChFiEYNFAjMGioRYjGJJ5BA9UBg4ZahGhM4i0OoDpg0FCLEI1Je70HPW7cuFu3bkmjAHAABg01SZGxka//7+vyOCnri6xtl7fJ480iwX5f9aau2rdv//7770srALA3MGhFaHzK+BWHV8jjEqX9v7Tlh5bL441UE5szSTqha00HL09ruOq3l30NmnBwcJg/f/7du3el1QDYDxi0ItRIL9O76RuTVp+a2JxJ0kkDR95A1W8vuxs0IzQ09PTp09IMAOwEDNr+IldKeT/lj3l/nPanaauPrzav2nJxS0JuwoxNM9Z+vFbeUGy+6oNVSw4umZo+NW533NZLW1l8asZU+mB/N+x3lLD+0/U/d/j5llfffJU6pImt2Jx2uvjPi8cuH2vereXmDR7PxP+eSJ2LmzHrYwbPGCzphDbHrRz3Ws5r8pMVWoBBE3q9fv369ffv35fmAdBkYND2F52+0dfI7t5WTq2mb5jO4hmfZQR2C/z5rnbTz8qaZd5E9DIq+z3ux9KIDqEdsr7Iorj3o6Y1Asl/KUIWGfBfASzi4u6S9HYSaz5w6kCdThfaP9T8qOTNGzgepu4DuxuMBvYTIuVvKZTm5ukm6YQK4hdHzU+WVbUEg2b079+/tLRUmgpA04BB2190+u5e7on5iRtKNvQd29ettRtZIcUjJkSQjS78n4W0GToglHyNEsQm5gbtYnCZs31O5vlMmkTTZvyeeHka6fno5wM6B9C8dXnRcq92XsG9glmOp49n4oFEmh3LD8y8eQPHwzR3x1xqEpcdR+XhfxzeyrkVZUo6oU0Pb4/5++dTFRm6eLLy3TWvBM4GLdR9mzwvL0+aDUATgEHbX3T6ryx8hZXXnFxDm+xBwSP+jwyeMZjF2YRUfIAg/NqgyQ1ZmebOtDlh9QR5Gsk7wPvZqGcpQurWr5vOQUemTDnPj3tezDGXpHkDx8NEe6f/CoQPD6ey/xP+Tw95Wt4JbY58feTPnbxf70k1uwT+2GDQWDld7dAVlF5UuwKDtr8EM2PadHYTbdJEeHvdr9dGLx4tj0uamJcbrnJ2dTaNlDpWfbCK/o1+I1rMMZekeQPHI+qluS9R2qJ3F1FtQm6CvBPzzQZOqtklcJ5B2/aIQ8DfHlI5dAXLysrKy8srKioqKytramqk17hpmHYklqQp1iO0eIMeEDOAleN2x9Eme1O4fZf2PQb3kMdZk/pcuIGqgM4BMetjWHnbl9vE39rVZ4uSqgaOR9Tq46t1Ol2H0A5t2rdhLzXLD0+chsfvia/vpJpdAjeDbsovCQUYtMoROK/xYtqRWJKmWI/Q4g2aTK3v2L4jFoxo3bZ1h+4dmLVNXjuZqp4Z9czL81/28PYI7hksfo9DqN+FzTdpMtv1+a7DEoaxXxtOXjfZycVpwJQBryx8hXqjfW08s1HS3FzS5vUfj7k6P9uZ0ijHYic/nazDzyfr6ePZsUdHiyfV7BL4GHQTX7MTYNAqR+C8xotpR2JJmmI9Qos3aLIwmnKSlz0Z8eSak2vEqqilURR3a+3W66Ve4rturEljDHpI3BBnV2ffjr7it1qoyjfI10nvFPRUUOKBRHlzc8mb13c85pqxaYaDo4P4Hp6kE9pdxIQI6sTF4BLaP9T8db0GjuS3l2Bvg7bLF1Vg0GpH4LzGi2lHYkmaYj0waOUYE29lXsi0OO9Wmuxr0Pb6qjcMWu0I9lvjxSKmHYklaYr1wKBbjkGrRXY0aDsulgSDVjt2HFcWMe1ILElTrKeFG/Tz455nTxsg5Yj3jWQbMGi1w3tcmXYklqQp1tPCDRpSoHjfSLbRLAadlJT0ySefSKO1tdXV1Q/MHMGckydP5uTkXLp0SVrR4uE9rkw7EkvSFOuBQUNKE+8byTZ+A4P+9ttvz507Zx6hnWZlZZlHGo4vW7ZMqCM8PPxBPQ5eH8eOHaM+r1y5Ikaqqqp27NixZ88ea7tSJrzHlWlHYkmaYj0waEhp4n0j2cZvYNAGg0Fiu/UZcX3xRx55JCYm5scff7x796607mGcP3/ezc0tLCyMpucssmjRop/8Yfv2XyeqFd7jyrQjsSRNsR4YNKQ08b6RbMO+Br1z586ioiJxMycnJzExkXYRHR1Nznvjxg0Wp8iWLVuOHj2al5dnPreVGzS5KkXEHm7dukXByspKmhcXFBR88803YiabJn/66aebN282ta9j165d1ANNw2vrHpU4OjqOGzdOkqNeeI8r047EkjTFerDCAFAaNJHkeiPZhmBXgx42bBjdelVVVVSmc6TOvby8xE+A3JOlUZkmxSzo7Oy8f/9+MS4x6PLycrG5UPeNjJs3b9J0mG3SR/rOO++IbRMSEnQ63ZAhQ8x7YIwfP75Vq1Zk6x07duzUqdPt27elGapFUKNBE2VlZaWlpXRFi4uLCwsL8wFobri+r2obgl0N+i9/+Qt1+Ne//pXKKSkper2e/FSQ2S5FfHx8jh8/Tm4yfPhwo9FIBRa3+IjDPD5nzpzWrVvTRJh6Hjp0KP08oE+S5fj5+Z04cYLm179qXAcZ/RNPPEFzZxcXl5KSEmm1mlGrQdMluX79Oh0xXQ+6Kw4B0Nxw/caXbdjXoGtqah599FGarlK5a9euY8eOrbVkuxRJS0tj5S+++II26cOxmMkwjz/22GOJiYmszCbpYtvY2FixiZx58+ZRzlNPPUUHKa1TM2o16IqKCjrWq1ev0kHTnOUUAM0N1zUTbMO+Bk0kJye7u7vTyVLPx44dq7Vku+aRO3fu0GZubq7FTIZ53GAwpKens7Kk7datW8UmEsi/dDpd//79KW3RokXSajWjSoN2dm4tAKAk6D/yXFcdsw3B3gZ95coVssKnn366Y8eOD+pub0FmuxRZsGABKx8+fJg22WvR8kyGeZymwCNGjGDlwsLCh7Ylrl271rZt2x49elRVVU2ePJkOj026tYGgRoOmgx49+igEKUcC52UhbcPuBk0MHDiQul29ejXbpDlvZGTkG2+8Ib7oJtSt9DRz5szU1FQ/P7/evXs/qMfKGebx3bt302ZMTAz17+Pj88wzzzTc9v79+xEREXq9nr2Lffv2bfrJQX5t/gaIqoFBQ5Ad1HIMuqCgwNHRUXTAZcuWubm5hYSEnD9/nkVop3PmzCGj9PDwGDJkyNWrV8W4RZOVxDds2EBt6X8ko0ePNn91z2Jb9iUX8ZF37S9v2r3wwgvaeBgNg4YgO0jgvG6vbfAw6IfClkiVRoFNwKAhyA4SOK/baxvNYtDAjsCgIcgOEjiv22sbMGi1A4OGIDuI941kGzBotcN7XJl2JJakKdYDg4aUJt43km3AoNUO73Fl2pFYkqZYDwwaUpp430i2AYNWO7zHlWlHYkmaYj0aM+iMjDNbt56PivqpPGnS33bs+HzJklPyNEjJ4n0j2QYMWu3wHlemHYklaYr1aMygN248Sx/Ltm0XqFxY+PW9ezXz5hXL0yAli/eNZBtY91Ht8F4lEQbdKJ06daO8vCo19R90dtnZF+UJkMIlKNKgH2DdR/XD9e0gGHSjNH36h7dvV9GpnT9/iz3rgNQlxRo01n1UO1zfr4dBN1anT/+0Zu7+/ZflVZDypViDxrqPaofrN1Rh0I1SZuZPS71cvPhDZeX9V189KU+AFC5lGrS3h4fpcSZQIbxXSYRBP1yzZn3044/VxcXXJ0364Nate2TTUVHH5GmQkiUo0qDpqGrfegtSrwTOi3DBoB+iqKijZ858f+dO9fTpH9JmWtpp+oj27r0kz4SULBg0xEMwaCVqx47PJcrMPCdPg5QjGDTEQwLnVRJh0LZI/KxEysoq5WmQcgSDhnhI4LxKougwMGhIy4JBQzwkcF4lEQYNtQjBoCEe4j2uYNBQixDvG8k2tGTQx1esyI+Pv5mdLUaOLV2aNWPGlcxMMVKVn78jNnbP3LkPCgrkPVhUxb59RYsX7549+2BS0n/27pUnSPTtzp3n0tNZ2S4H0LB4jysYNNQixPtGsg3NGHTi0KFCHe2Mxu9+8ejzGRluen1YcHB1fj6LLBoxgnK2z5wp78GiDicn+3p6sp4JV2fnzGnT5GnmMuj1ZMqs3PQDeKh4jysYNNQixPtGsg1BKwbt4eoaO2jQqdRUOqN9cXFifNesWRRZNmoUlU+mpDg6OIx79ll5c4s6nZbm4uQ0KDS0JC3tXl7el5s20S5CAwOvbd/OEih4KDm5ICGBZs0sQrum3UU/9xx59I1du2qbdgCNEe9xBYOGWoR430i2oRmDDvH3nxMZWZySQmd0ZMkS86rxffu2cnQ8tnRpR1/fTn5+t80eU/w0Kzb7BCSbI8PDqcndvDzz3kSR/5JZsyatXV3/vno1BQPbtmUR4tPUVJbZwAE0XQLncQWDhlqEeN9ItmHuR6pWxuTJZIJeBsOwsLD7BQXiIwVSeU7OE35+NHWl6TDNhc1bMSetb7ONh8fC4cNZuXL/fpoUM53PyKDIrEGDugcGXsnMPJueHuDt/WxIiNiJ+IiDqYEDaLp4jysuBo1VboHS4L1ur20ImjDoj1etMhoM5M46ne5wcjJFBnbrtnTkSDFh3u9/T2f6VIcONQcOyJvXJydHx/RJk1j5hzffFC8l898ObdtO69+fWfYfevZ00OnIxGstGXStrQfQGAlqNOgHWOUWKA+u76vahjYMumdQ0JBeve7l5Y0MD6dZ6qaYGJpN74yNZbWHkpPJuPs/+SSd7KIRI+TN61NHX98pERGSoOi/bnq9aNmMy5s3myeIsvkAGiNBpQaNVW6B0uD6jS/bEDRh0Honp9ToaCpU5+eP6t2bTsrH0/Ne3bPja9u3t23dukdQUFV+/uQXXiCjPFQ3xW6MXn/5ZZpEs4fLTLfq5tHMf7sHBu6dO5fF7xcUsF8J1soMuikH0Bip1aCxyi1QGlzXTLANbRh0iL+/l8GwMioqZcyYLgEBNH2m8yKnJj+N6NqV7Ju9mHx7716aFJNdfvPLaxhs5iv2I9ksz8khYyWPntqv3/qJE+cPHerv5eXp5vaPdeuo9s05c1ydneNfemnN+PHPhIS0MxrZb/8Men1k9+5vjBlDPy3IuBs+gKZLrQZdWVlJkxQ6XJqt0P8ovwSgueG66phtaMOgjy5dGhYcTHb5iLt7VJ8+FzdsID8lx4x78UU6wbSJE8VM9qLbC126sGfBDRt0bZ1HJw0fHuTjQzYd4O09e/Dgr7OyxFqaKXfy83Nxcgp/4okTK1ey4LJRo9z0evqZcT4jg8oNH0DTpVaDrqmpoXuA5il0M5SVlX0PQHND45BGI41JGpk0PqVDtjnQhkFb1J3cXHlQe1KrQQMAHoqGDbqFCAYNgGaBQatdMGgANAsMWu2CQQOgWWDQahcMGgDNAoNWu2DQAGgWGLTaBYMGQLNg1Rq1w3uNFxg0AM0JVq1RO1zXeIFBA9CcYNUatcN1jRcYNADNCVatUTtc13iBQQPQbHh7eEgfagJVYTQaua7xAoMGoNkQ8BaHykVXEAYNgDaBQatdMGgANAsMWu2iK4hn0ABoExi02kVXEG9xAKBNYNBqF11BvAcNgDaBQatdAr7qDYBW0YZBH1+xIj8+/mZ2thg5tnRp1owZVzIzxUhVfv6O2Ng9c+c+KCiQ9yBReU7O/vj477KzKZl128QO+QkGDYBm0YBBJw4dKtTRzmj87hePPp+R4abXhwUHV+fns8iiESMoZ/vMmfIe5BoZHk7JAd7eMwcO7Nu5c9M75CcYNACaRQMG7eHqGjto0KnUVDqXfXFxYnzXrFkUWTZqVO0vf6p13LPPyptb1J8XLLjwpz9N6NvXy2AoXLSo6R3yEwwaAM2iAYMO8fefExlZnJJC53JkyRLzqvF9+7ZydDy2dGlHX99Ofn639+4Vq9iku77N+tRAh80lGDQAmqUxrqRwZUyeTKZJU91hYWH3CwrERxC1dY+Sn/Dzo6mui5NTSVqaeSvbDLqBDptLMGgANEtjXEnJ+njVKqPBQO6s0+kOJydTZGC3bktHjhQT5v3+93SOT3XoUHPggLy5DbJ7h00UDBoAzaJ2g+4ZFDSkV697eXkjw8NpVrspJoZm0ztjY1ntoeRkMu7+Tz5Jp7loxAh5c2tl9w6bLhg0AJpF7Qatd3JKjY6mQnV+/qjevel0fDw9ya8pcm379ratW/cICqrKz5/8wgtkrIfqptg2y+4d2kUwaAA0i9oNOsTf38tgWBkVlTJmTJeAAJo+0xmRU996882Irl3Jvs+lp1Pa7b17O/r6kr1+s307a/jTI2drnkHfLyhouMPmEgwaAM3SsCspX0eXLg0LDnZ1dn7E3T2qT5+LGzasnzixndEY9+KLdGppEyeKmezFuBe6dGHPjq016GWjRjXcYXMJBg2AZmnYlVSqO7m58qBWBYMGQLNo0qBblGDQAGgWGLTaBYMGQLPAoNUuGDQAmgUGrXbBoAHQLDBotQsGDYBmgUGrXTBoADQLDFrtgkEDoFlg0GoXDBoAzeLt7S0ANWMwGGDQAGiWsrKy0tLSs2fPFhcXFxYW5gO1gb/qDYBmKS8vv379Ok2+SkpK6D4/BNQGXTW6dnQF6TrS1ZRe4KYBgwagOamoqKD/F1+9epXucJqFnQJqg64aXTu6gnQd6WpKL3DTgEED0JxUVlbStIvubZp/0f+RvwRqg64aXTu6gnQd6WpKL3DTgEED0JzU1NTQXU0zL7q9y8rKvgdqg64aXTu6gnQd6WpKL3DTgEEDAIBCgUEDAIBCgUEDAIBCgUEDAIBCgUEDAIBCgUEDAIBCgUEDAIBCgUEDAIBC4WLQWKMLKA0ak9JhCoDi4WLQdD+IvQGgBGhMcv3GFwA8MA1gsSRNsR4YNFAaNCa5rpkAAA9MA1gsSVOsBwYNlAaNSa6rjgHAA9MAFkvSFOuBQQOlQWOS67q9APDANIDFkjTFemDQQGnQmOT6ly8A4IFpAIslaYr1wKCB0hA4/3FPAHhgGsBiSZpiPTBooDRg0ECNmAawWJKmWI/dDbq6uvqB2bECYC0waKBGTANYLElTrMfuBk0dZmVlSaO28tlnn1FvZ86cESN0zNnZ2bt3736AHwMaBQYN1IhpAIslaYr1KNyg//3vf/v4+HTq1OnevXsssmXLFtpFWlrarxOBdoBBAzViGsBiSZpiPU006MrKyiNHjuzbt+/rr79mEblBX758OScnp7CwsKqqSgx+8MEHe/bsuXDhglmi5eB7771HfS5fvpzK169f9/T07Nev3wNMn7ULDBqoEdMAFkvSFOtpikF/9913PXr0EOpwdnZ+5513amUGnZ6e7uDgwHLCw8OZR8fFxbGITqdbt24dy7QYZEydOlWv11+8eHH06NFeXl7/+te/zGuBxhBg0ECFmAawWJKmWI/QBIOeNWuW0Wiku+jGjRsDBgyIjo6u/bVBkx1PmDBhypQplPD2229T1cGDBynu7u4+b968H374Ydu2beTyLNlikHH79u2goKDg4GDq4cCBA+ZVQHvAoIEaMQ1gsSRNsZ6mGPRjjz2WmJjIyuIzYnODrq07wqKioqSkpLFjx1IVmS8FIyIi2rdvv3///pqaGjHTYlDkxIkT1Jz9DADaBgYN1IhpAIslaYr1NMWgDQZDenq6JCgx6FdffdXR0ZHm19OnTxerbt26RXFXV9fw8PC7d++yTItBcyQ9A60CgwZqxDSAxZI0xXqaYtA9e/YcNmwYK1+4cOHjjz+uldmop6dncnIyFb766iuxqrKykv49c+YMRd566y2WaTFoDgy6hQCDBmrENIDFkjTFeppi0Lm5udR8/Pjxa9euDQgI6NKlS01NjcRGKfjkk0+mpaVRQafTrV69+qOPPmrbtm1iYuK8efMo+fDhw5RmMSgBBt1CgEEDNWIawGJJmmI9TTFoIjMzMzg42M3N7cUXX2Rv2kls9JNPPuncuTMlTJkyJTIycsiQIWVlZTNnzvTy8qLJdUJCAkuzGJQAg24hwKCBGjENYLEkTbGeJhr0b0lRUZH4tjXQMDBooEZMA1gsSVOsR0UGDVoIMGigRkwDWCxJU6wHBg2UBgwaqBHTABZL0hTrgUEDpQGDBmrENIDFkjTFemDQQGnAoIEaMQ1gsSRNsR4YNFAaMGigRkwDWCxJU6wHBg2UBgwaqBHTABZL0hTr8fb2FgBQEgaDAQYNVAcXgybKyspKS0vPnj1bXFxcWFiYD0Bzg7/qDVQHL4MuLy+/fv06TVVKSkrorjgEQHND45BGI41JGpk0PqVDFgDlwcugKyoq6H+RV69epfuB5iynAGhuaBzSaKQxSSOTxqd0yAKgPLgYtMFokD4CBKBZMRqNpaWlNHcmd6bpc2VlpXTUAqA8uBg03Q/bv9oOQcoRjUkYNFAdMGioRQgGDdQIDBpqEaIxiWfQQHXAoKEWIRqTeIsDqA4YNNQiRGPSXu9Bjxs37tatW9IoAByAQUNNUmRs5Ov/+7o8Tsr6Imvb5W3yeLNIsN9Xvamr9u3bv//++9IKAOwNDFoRGp8yfsXhFfK4RGn/L235oeXyeCPVxOZMkk7oWtPBy9MarvrtZV+DJhwcHObPn3/37l1pNQD2AwatCDXSy/Ru+sak1acmNmeSdNLAkTdQ9dvL7gbNCA0NPX36tDQDADsBg7a/yJVS3k/5Y94fp/1p2urjq82rtlzckpCbMGPTjLUfr5U3FJuv+mDVkoNLpqZPjdsdt/XSVhafmjGVPtjfDfsdJaz/dP3PHX6+5dU3X6UOaWIrNqedLv7z4rHLx5p3a7l5g8cz8b8nUufiZsz6mMEzBks6oc1xK8e9lvOa/GSFFmDQhF6vX79+/f3796V5ADQZGLT9Radv9DWyu7eVU6vpG6azeMZnGYHdAn++q930s7JmmTcRvYzKfo/7sTSiQ2iHrC+yKO79qGmNQPJfipBFBvxXAIu4uLskvZ3Emg+cOlCn04X2DzU/KnnzBo6HqfvA7gajgf2ESPlbCqW5ebpJOqGC+MVR85NlVS3BoBn9+/cvLS2VpgLQNGDQ9hedvruXe2J+4oaSDX3H9nVr7UZWSPGICRFkowv/ZyFthg4IJV+jBLGJuUG7GFzmbJ+TeT6TJtG0Gb8nXp5Gej76+YDOATRvXV603KudV3CvYJbj6eOZeCCRZsfyAzNv3sDxMM3dMZeaxGXHUXn4H4e3cm5FmZJOaNPD22P+/vlURYYunqx8d80rgbNBC3XfJs/Ly5NmA9AEYND2F53+KwtfYeU1J9fQJntQ8Ij/I4NnDGZxNiEVHyAIvzZockNWprkzbU5YPUGeRvIO8H426lmKkLr166Zz0JEpU87z454Xc8wlad7A8TDR3um/AuHDw6ns/4T/00OelndCmyNfH/lzJ+/Xe1LNLoE/Nhg0Vk5XO3QFpRfVrsCg7S/BzJg2nd1EmzQR3l7367XRi0fL45Im5uWGq5xdnU0jpY5VH6yif6PfiBZzzCVp3sDxiHpp7kuUtujdRVSbkJsg78R8s4GTanYJnGfQtj3iEPC3h1QOXcGysrLy8vKKiorKysqamhrpNW4aph2JJWmK9Qgt3qAHxAxg5bjdcbTJ3hRu36V9j8E95HHWpD4XbqAqoHNAzPoYVt725Tbxt3b12aKkqoHjEbX6+GqdTtchtEOb9m3YS83ywxOn4fF74us7qWaXwM2gm/JLQgEGrXIEzmu8mHYklqQp1iO0eIMmU+s7tu+IBSNat23doXsHZm2T106mqmdGPfPy/Jc9vD2CewaL3+MQ6ndh802azHZ9vuuwhGHs14aT1012cnEaMGXAKwtfod5oXxvPbJQ0N5e0ef3HY67Oz3amNMqx2MlPJ+vw88l6+nh27NHR4kk1uwQ+Bt3E1+wEGLTKETiv8WLakViSpliP0OINmiyMppzkZU9GPLnm5BqxKmppFMXdWrv1eqmX+K4ba9IYgx4SN8TZ1dm3o6/4rRaq8g3yddI7BT0VlHggUd7cXPLm9R2PuWZsmuHg6CC+hyfphHYXMSGCOnExuIT2DzV/Xa+BI/ntJdjboO3yRRUYtNoROK/xYtqRWJKmWA8MWjnGxFuZFzItzruVJvsatL2+6g2DVjuC/dZ4sYhpR2JJmmI9MOiWY9BqkR0N2o6LJcGg1Y4dx5VFTDsSS9IU62nhBv38uOfZ0wZIOeJ9I9kGDFrt8B5Xph2JJWmK9bRwg4YUKN43km00l0EnJSV98skn0mhtbXV19QMzUzDn5MmTOTk5ly5dkla0bHiPK9OOxJI0xXpg0JDSxPtGso3fxqC//fbbc+fOmUdov1lZWeaRhuPLli0T6ggPD39Qj4Nb5LPPPqMOz5w5I0aoeXZ29u7du63qR7HwHlemHYklaYr1wKAhpYn3jWQbv41BGwwGie3WZ8T1xR955JGYmJgff/zx7t270roG+fe//+3j49OpU6d79+6xyJYtP33ZNS0t7deJaoX3uDLtSCxJU6wHBg0pTbxvJNuwu0Hv3LmzqKhI3MzJyUlMTKS9REdHk/PeuHGDxSlCRnn06NG8vLwrV66I+XKDrq6upojYw61btyhYWVl57NixgoKCb775RsykWurq008/3bx5s6l9be17771HzZcvX07l69eve3p69uvX74Emps+1KjVorDAAlAbNIrneSLYh2Nughw0bRndfVVUVlek0qX8vLy/xQyD3ZGlUpkkxCzo7O+/fv1+MSwy6vLxcbC7UfSnj5s2bYWFhbJM+1XfeeUdsm5CQoNPphgwZYt4DMXXqVL1ef/HixdGjR9Px/Otf/5IkqBdBjQZNlJWVlZaW0uUsLi4uLCzMB6C54fq+qm0I9jbov/zlL9TnX//6VyqnpKSQLZKfCjLbpYiPj8/x48fJUIYPH240GqnA4hYfcZjH58yZ07p165MnT1LPQ4cOpZ8H9GGyHD8/vxMnTtD8+leNa2tv374dFBQUHBxMOQcOHJDUqhq1GjT94KX/ztARl5SU0F1xCIDmhus3vmzD7gZdU1Pz6KOPjh8/nspdu3YdO3ZsrSXbFcyeAn/xxRe0SZ+PxUyGefyxxx5LTExkZTZJF9vGxsaKTSSQcQt1z0mkFSpHrQZdUVFBx3r16lU6aJqznAKgueG6ZoJt2N2gieTkZHd3dzpf6vzYsWO1lmzXPHLnzh3azM3NtZjJMI8bDIb09HRWlrTdunWr2EROfZ2rGlUatLNzawEAJUH/i+e66phtCBwM+sqVKzqd7umnn+7YseODujtckDkjRRYsWMDKhw8fpk32WrQ8k2Eef+qpp0aMGMHKhYWFD20r8tAENSKo0aDpoEePPgpBypHAeVlI2+Bh0MTAgQOp59WrV7NNmvNGRka+8cYb1dXVLCLULfY0c+bM1NRUPz+/3r17P6jHyhnm8d27d9NmTEwM9e/j4/PMM8803FbkoQlqBAYNQXZQizLogoICR0dH8R24ZcuWubm5hYSEnD9/nkVov3PmzKEptoeHx5AhQ65evSrGLXqoJL5hwwZqS/8pGT16tPmrexbbijw0QY3AoCHIDhI4r9trG5wM+qGwVVKlUc4UFRV9/fXX0qjKgUFDkB0kcF631zaay6CBvYBBQ5AdJHBet9c2YNBqBwYNQXYQ7xvJNmDQaof3uDLtSCxJU6wHBg0pTbxvJNuAQasd3uPKtCOxJE2xHhg0pDTxvpFsAwatdniPK9OOxJI0xXo0ZtAZGWe2bj0fFfVTedKkv+3Y8fmSJafkaZCSxftGsg0YtNrhPa5MOxJL0hTr0ZhBb9x4lj6WbdsuULmw8Ot792rmzSuWp0FKFu8byTaw7qPa4b1KIgy6UTp16kZ5eVVq6j8e/PT3IC7KEyCFS1CkQT/Auo/qh+vbQTDoRmn69A9v366iUzt//hZ71gGpS4o1aKz7qHa4vl8Pg26sTp/+acHc/fsvy6sg5UuxBo11H9UO12+owqAbpczMn/7m5sWLP1RW3n/11ZPyBEjhUqZBe3t4mB5nAhXCe5VEGPTDNWvWRz/+WF1cfH3SpA9u3bpHNh0VdUyeBilZgiINmo6q9q23IPVK4LwIFwz6IYqKOnrmzPd37lRPn/4hbaalnaaPaO/eS/JMSMmCQUM8BINWonbs+FyizMxz8jRIOYJBQzwkcF4lEQZti8TPSqSsrFKeBilHMGiIhwTOqySKDgODhrQsGDTEQwLnVRJh0FCLEAwa4iHe4woGDbUI8b6RbENLBn18xYr8+Pib2dls87O1a7NmzDizfr2Y8KCgIHv27N2zZ1NB3tyiKvbtK1q8mJocTEr6z9698gSJvt2581x6OisfW7qUDuBKZqZYW5WfvyM2ds/cuY0/gIeK97iCQUMtQrxvJNvQjEEnDh0q1NHOaPyuzqP/vXOnj6dnJz+/e3l5LGfLtGmUkDZxory5RR1OTvb19GTdEq7OzpnTpsnTzGXQ68mUWfl8RoabXh8WHFydn88ii0aMoH62z5wpb2izeI8rGDTUIsT7RrINQSsG7eHqGjto0KnUVDqjfXFxLPjewoW0uXz0aCpf37HD082tX9eujZy9nk5Lc3FyGhQaWpKWRhb/5aZN1H9oYOC17dtZAgUPJScXJCTQrJlFaL+0u+jnniOPvrFrF0V2zZpFkWWjRlH5ZEqKo4PDuGefle+rKeI9rrgYNNboAkqD96pjtiFoxaBD/P3nREYWp6TQGR1ZskSMT+3XT+/kdHHDhtF9+ngZDP/KyhKr2HWpb3NkeHhHX9+7v8y+JSL/JbNmTVq7uv599WoKBrZtyyLEp6mpLHN8376tHB2PLV1KvdF0/nYjnpNYJUGNBv0Aa3QB5cH1t+22YW5JqlbG5Mnkg2TBw8LC7hcUiE8VyBCDfHyCfX3pTA+89pp5E+ak9W228fBYOHw4K1fu30+TYqbzGRkUmTVoUPfAwCuZmWfT0wO8vZ8NCRE7ER9xMJXn5Dzh50dzZ5qP02TcvMouUqtBY40uoDS4vq9qG9ow6I9XrTIaDOTOOp3ucHIyRQZ267Z05EhWe2LlSqHuyYO8YQNycnRMnzSJlX94801m36L/dmjbdlr//syy/9Czp4NORyZea8mgSfN+/3uKP9WhQ82BA/IdNVFqNWis0QWUBtdvfNmGNgy6Z1DQkF697uXljQwPp4nqppgYmk3vjI0VEyz6ZsPq6Os7JSJCEhT7cdPrRctmXN682TxB1KHkZPqx0f/JJ6lq0YgRkg6bLkGNBu3s3Fry8QHQvPBedcw2BE0YtN7JKTU6mgrV+fmjevemk/Lx9BRf3qi15JsP1esvv0yTaPZwmelW3Tya9dM9MHDv3Lksfr+ggP1KsFa2o2vbt7dt3bpHUFBVfv7kF14gpz5UN8G3owQ1GrSAtzgghUngvKiNbWjDoEP8/b0MhpVRUSljxnQJCKDpM50XOXXZnj0swaJBsx+c9W2W5+SQsZJHT+3Xb/3EifOHDvX38vJ0c/vHunVU++acOa7OzvEvvbRm/PhnQkLaGY3st38GvT6ye/c3xoyhHxVk3BFdu9IPD/ZmNCXQrJz8+ptf3gOxi2DQEGQHwaD56ejSpWHBweSYj7i7R/Xpc3HDBrJUMs2v6h471Npk0LV1Hp00fHiQjw/ZdIC39+zBg782ewmEOuzk5+fi5BT+xBMnVq5kwWWjRrnp9fQD43xGBpWFX792zd60e6FLFzs+jIZBQ5AdJHBedcw2tGHQFnUnN1csFy1ebO6tWhIMGoLsIIHzqmO2oWGDbiGCQUOQHSRwXnXMNmDQahcMGoLsIN43km3AoNUu3uMKBg21CPG+kWwDBq128R5XMGioRYj3jWQbMGi1i/e4gkE/XFu3nl+3rkTc3LjxrPkmpArxvpFsAwatdvEeVzDoh+v48WtVVfdjYo5Ted68YvqI8vK+lKdBShbvG8k2sO6j2uG9SiIM+uFasOAT+lh2775I5bffvkJmPW3ah/I0SMkSFGnQD7Duo/rh+nYQDLpROnfu1j//WR4VdfTGjbsnTlyXJ0AKl2INGus+qh2u79fDoBultWtL6JPJzr5I/y5Z8qk8AVK4FGvQWPdR7XD9hioMulGiufO1az+WlVXSPFpeCylfyjRobw8P0+NMoEJ4r5IIg26sdu/+afq8Y8cFeRWkfAmKNGgBb3GoXALnRbhg0I3Vn//8z4qK6okT/yavgpQvGDTEQzDo5tesWR8dOHC5uvr+//1fKYvs2PG5RJmZ5+QNIeUIBg3xkMB5lUQY9MM1d24xfVCnT38/ZcoHLCJ+ViJlZZXyhpByBIOGeEjgvEqi6DAw6IY0btz78iCkIsGgIR4SOK+SCIOGWoRg0BAP8R5XMGioRYj3jWQbmjHo4ytW5MfH38zOZpufrV2bNWPGmfXrxYQHBQXZs2fvnj2bCvLmEpXn5OyPj/8uO5uSqc8m9sZVvMcVDBpqEeJ9I9mGNgw6cehQoY52RuN3dR797507fTw9O/n5iX/be8u0acKv/0JgAxoZHk7JAd7eMwcO7Nu5cxN74yre4woGDbUI8b6RbEMbBu3h6ho7aNCp1FQ6nX1xcSz43sKFtLl89GgqX9+xw9PNrV/Xro2c8P55wYILf/rThL59vQyGwkWLmtgbV/EeVzBoqEWI941kG9ow6BB//zmRkcUpKXQ6R5YsEeNT+/XTOzld3LBhdJ8+ZLX/Mvu7sUId9W1aVAO9NaN4jysYNNQixPtGso2HupIqlDF5citHRzLNYWFh9wsKqvPzWfz23r1BPj7Bvr50mgdee828iQ0G3UBvzSje44qLQWOVW6A0eK/baxvCw1xJ+fp41SqjwUDurNPpDicnU2Rgt25LR45ktSdWrqRzjH7uOXlDG2Tf3uwiQY0G/QCr3ALlwfV9VdvQgEH3DAoa0qvXvby8keHhLk5Om2JiaDa9MzZWTKBzzJoxQ97QNtm3t6ZLrQaNVW6B0uD6jS/b0IBB652cUqOjqVCdnz+qd286Ix9PT/F1i1p7W6p9e2u61GrQWOUWKA2uaybYhgYMOsTf38tgWBkVlTJmTJeAAJo+00mRU5ft2cMSLFqqUEd9mw3IYm/NKLUadGVlJU1S6HBptkL/o/wSgOaG66pjttFIV1Kyji5dGhYc7Ors/Ii7e1SfPhc3bFg/cWI7o/GrzZtZgkVLhUE3El4GXVNTQ/cAzVPoZigrK/segOaGxiGNRhqTNDJpfEqHbHPQSFdSne7k5orlosWLv7bfK3H27a3pUqtBAwAeilYNuuUIBg2AZoFBq10waAA0Cwxa7YJBA6BZYNBqFwwaAM0Cg1a7YNAAaBYYtNoFgwZAs2DVGrXDe40XGDQAzQlWrVE7XNd4gUED0Jxg1Rq1w3WNFxg0AM0JVq1RO1zXeIFBA9BseHt4SB9qAlVhNBq5rvECgwag2RDwFofKRVcQBg2ANoFBq10waAA0Cwxa7aIriGfQAGgTGLTaRVcQb3EAoE1g0GoXXUG8Bw2ANoFBq10CvuoNgFbRmEEfX7EiPz7+ZnY22/xs7dqsGTPOrF8vJjwoKMiePXv37NlUkDe3qIp9+4oWL6YmB5OS/rN3rzxBom937jyXnl5rp70/VDBoADSLlgw6cehQoY52RuN3dR797507fTw9O/n5iX/ke8u0aZSQNnGivLlFHU5O9vX0ZN0Srs7OmdOmydPMZdDr2R8tbPreGyMYNACaRUsG7eHqGjto0KnUVDqpfXFxLPjewoW0uXz0aCpf37HD082tX9eujZzAnk5Lc3FyGhQaWpKWRib75aZN1H9oYOC17dtZAgUPJScXJCTQrJlFaL+0u+jnniOPvrFrV1P23kjBoAHQLFoy6BB//zmRkcUpKXRSR5YsEeNT+/XTOzld3LBhdJ8+XgbDv8z+5CubF9e3OTI8vKOv791f5r8Skf+SWbMmrV1d/756NQUD27ZlEeLT1NTaBvduFwkwaAC0irkfqV0Zkye3cnQkExwWFna/oKA6P5/Fb+/dG+TjE+zrSyd74LXXzJswJ61vs42Hx8Lhw1m5cv9+mhQznc/IoMisQYO6BwZeycw8m54e4O39bEiI2Al7xMHUwN7tIhg0AJpFMwb98apVRoOB3Fmn0x1OTqbIwG7dlo4cyWpPrFwp1D15kDdsQE6OjumTJrHyD2++yexb9N8ObdtO69+fWfYfevZ00OnIxGtlBl1r694bKRg0AJpFMwbdMyhoSK9e9/LyRoaHuzg5bYqJodn0zthYMUHumw9VR1/fKRERkqDYj5teL1o24/LmzeYJFlvZXQIMGgCtImjFoPVOTqnR0VSozs8f1bs3nZePp6f4+kStTRb5+ssv0ySaPVxmulU3j2b9dA8M3Dt3LovfLyi4sWsXK1vckcWgXQSDBkCzaMagQ/z9vQyGlVFRKWPGdAkIoOkznRo5ddmePSzBokXWTXzrfQZdnpPTIyiIPHpqv37rJ06cP3Sov5eXp5vbP9ato9o358xxdXaOf+mlNePHPxMS0s5ovF33lrRBr4/s3v2NMWPEh+D17d0ugkEDoFk0Y9BHly4NCw4mx3zE3T2qT5+LGzaQpZJpflX32KG2Hots2KBr6zw6afjwIB8fsukAb+/Zgwd/bfYaBnXYyc/Pxckp/IknTqxcyYLLRo1y0+vpBwb7XaLYs3zvdhEMGgDNohmDtqg7ubliuWjxYnNv/Y3Fb+8waAA0i7YNuiUIBg2AZoFBq10waAA0Cwxa7YJBA6BZYNBqFwwaAM0Cg1a7YNAAaBYYtNoFgwZAs8Cg1S4YNACaBQatdsGgAdAs3t7eAlAzBoMBBg2AZikrKystLT179mxxcXFhYWE+UBv4q94AaJby8vLr16/T5KukpITu80NAbdBVo2tHV5CuI11N6QVuGjBoAJqTiooK+n/x1atX6Q6nWdgpoDboqtG1oytI15GupvQCNw0YNADNSWVlJU276N6m+Rf9H/lLoDboqtG1oytI15GupvQCNw0YNADNSU1NDd3VNPOi27usrOx7oDboqtG1oytI15GupvQCNw0YNAAAKBQYNAAAKBQYNAAAKBQYNAAAKBQYNAAAKBQYNAAAKBQYNAAAKBQYNAAAKBQuBo01uoDSoDEpHaYAKB4uBk33g9gbAEqAxiTXb3wBwAPTABZL0hTrgUEDpUFjkuuaCQDwwDSAxZI0xXpg0EBp0JjkuuoYADwwDWCxJE2xHhg0UBo0Jrmu2wsAD0wDWCxJU6wHBg2UBo1Jrn/5AgAemAawWJKmWA8MGigNgfMf9wSAB6YBLJakKdYDgwZKAwYN1IhpAIslaYr12N2gq6urH5gdKwDWAoMGasQ0gMWSNMV67G7Q1GFWVpY02gRu3ryZJWPXrl3SPKAVYNBAjZgGsFiSpliP8g26pKSkVatW7u7ubdq0CQgIePzxx52cnIxGozQPaAUYNFAjpgEslqQp1tNEg66srDxy5Mi+ffu+/vprFpEb9OXLl3NycgoLC6uqqsTgBx98sGfPngsXLpglWg5K2LhxI+1i586d0gqgFWDQQI2YBrBYkqZYT1MM+rvvvuvRo4dQh7Oz8zvvvFMrM+j09HQHBweWEx4ezjw6Li6ORXQ63bp161imxaCEd999l2qnT58urQAaQoBBAxViGsBiSZpiPUITDHrWrFlGo5Huohs3bgwYMCA6Orr21wZNdjxhwoQpU6ZQwttvv01VBw8epLi7u/u8efN++OGHbdu2kcuzZItBcy5dutS6deuwsLB79+5J64CGgEEDNWIawGJJmmI9TTHoxx57LDExkZVF0zQ36Nq6IywqKkpKSho7dixVkflSMCIion379vv376+pqREzLQZF7ty507Vr1zZt2pSWlkrrgLaAQQM1YhrAYkmaYj1NMWiDwZCeni4JSgz61VdfdXR0pPn19OnTxapbt25R3NXVNTw8/O7duyzTYlAkKirKwcHhyJEjkjjQHjBooEZMA1gsSVOspykG3bNnz2HDhrHyhQsXPv7441qZQXt6eiYnJ1Phq6++EqsqKyvp3zNnzlDkrbfeYpkWgwz6MUDBNWvWmAeBVoFBAzViGsBiSZpiPU0x6NzcXGo+fvz4tWvXBgQEdOnSpaamRmLQFHzyySfT0tKooNPpVq9e/dFHH7Vt2zYxMXHevHmUfPjwYUqzGGR8+OGHrVq1evrpp4uKit577z3y7n379mVnZ+NZh1aBQQM1YhrAYkmaYj1NMWgiMzMzODjYzc3txRdfZG/aSQz6k08+6dy5MyVMmTIlMjJyyJAhZWVlM2fO9PLyosl1QkICS7MYZMTHxwuWYL9vBNpDgEEDFWIawGJJmmI9QtMMGgC7A4MGasQ0gMWSNMV6YNBAacCggRoxDWCxJE2xHhg0UBowaKBGTANYLElTrAcGDZQGDBqoEdMAFkvSFOuBQQOlAYMGasQ0gMWSNMV6YNBAacCggRoxDWCxJE2xHhg0UBowaKBGTANYLElTrMfb21sAQEkYDAYYNFAdXAyaKCsrKy0tPXv2bHFxcWFhYT4AzQ3+qjdQHbwMury8/Pr16zRVKSkpobviEADNDY1DGo00Jmlk0viUDlkAlAcvg66oqKD/RV69epXuB5qznAKguaFxSKORxiSNTBqf0iELgPLgYtAGo0H6CBCAZsVoNJaWltLcmdyZps+VlZXSUQuA8uBi0HQ/bP9qOwQpRzQmYdBAdcCgoRYhGDRQIzBoqEWIxiSeQQPVAYOGWoRoTOItDqA6YNBQixCNSXu9Bz1u3Lhbt25JowBwAAYNNUmRsZGv/+/r8jgp64usbZe3yePNIsF+X/Wmrtq3b//+++9LKwCwNzBoRWh8yvgVh1fI4xKl/b+05YeWy+ONVBObM0k6oWtNBy9Pa7jqt5d9DZpwcHCYP3/+3bt3pdUA2A8YtCLUSC/Tu+kbk1afmticSdJJA0feQNVvL7sbNCM0NPT06dPSDADsBAza/iJXSnk/5Y95f5z2p2mrj682r9pycUtCbsKMTTPWfrxW3lBsvuqDVUsOLpmaPjVud9zWS1tZfGrGVPpgfzfsd5Sw/tP1P3f4+ZZX33yVOqSJrdicdrr4z4vHLh9r3q3l5g0ez8T/nkidi5sx62MGzxgs6YQ2x60c91rOa/KTFVqAQRN6vX79+vX379+X5gHQZGDQ9hedvtHXyO7eVk6tpm+YzuIZn2UEdgv8+a5208/KmmXeRPQyKvs97sfSiA6hHbK+yKK496OmNQLJfylCFhnwXwEs4uLukvR2Ems+cOpAnU4X2j/U/KjkzRs4HqbuA7sbjAb2EyLlbymU5ubpJumECuIXR81PllW1BINm9O/fv7S0VJoKQNOAQdtfdPruXu6J+YkbSjb0HdvXrbUbWSHFIyZEkI0u/J+FtBk6IJR8jRLEJuYG7WJwmbN9Tub5TJpE02b8nnh5Gun56OcDOgfQvHV50XKvdl7BvYJZjqePZ+KBRJodyw/MvHkDx8M0d8dcahKXHUfl4X8c3sq5FWVKOqFND2+P+fvnUxUZuniy8t01rwTOBi3UfZs8Ly9Pmg1AE4BB2190+q8sfIWV15xcQ5vsQcEj/o8MnjGYxdmEVHyAIPzaoMkNWZnmzrQ5YfUEeRrJO8D72ahnKULq1q+bzkFHpkw5z497Xswxl6R5A8fDRHun/wqEDw+nsv8T/k8PeVreCW2OfH3kz528X+9JNbsE/thg0Fg5Xe3QFZReVLsCg7a/BDNj2nR2E23SRHh73a/XRi8eLY9LmpiXG65ydnU2jZQ6Vn2wiv6NfiNazDGXpHkDxyPqpbkvUdqidxdRbUJugrwT880GTqrZJXCeQdv2iEPA3x5SOXQFy8rKysvLKyoqKisra2pqpNe4aZh2JJakKdYjtHiDHhAzgJXjdsfRJntTuH2X9j0G95DHWZP6XLiBqoDOATHrY1h525fbxN/a1WeLkqoGjkfU6uOrdTpdh9AObdq3YS81yw9PnIbH74mv76SaXQI3g27KLwkFGLTKETiv8WLakViSpliP0OINmkyt79i+IxaMaN22dYfuHZi1TV47maqeGfXMy/Nf9vD2CO4ZLH6PQ6jfhc03aTLb9fmuwxKGsV8bTl432cnFacCUAa8sfIV6o31tPLNR0txc0ub1H4+5Oj/bmdIox2InP52sw88n6+nj2bFHR4sn1ewS+Bh0E1+zE2DQKkfgvMaLaUdiSZpiPUKLN2iyMJpykpc9GfHkmpNrxKqopVEUd2vt1uulXuK7bqxJYwx6SNwQZ1dn346+4rdaqMo3yNdJ7xT0VFDigUR5c3PJm9d3POaasWmGg6OD+B6epBPaXcSECOrExeAS2j/U/HW9Bo7kt5dgb4O2yxdVYNBqR+C8xotpR2JJmmI9MGjlGBNvZV7ItDjvVprsa9D2+qo3DFrtCPZb48Uiph2JJWmK9cCgW45Bq0V2NGg7LpYEg1Y7dhxXFjHtSCxJU6ynhRv08+OeZ08bIOWI941kGzBotcN7XJl2JJakKdbTwg0aUqB430i20VwGnZSU9Mknn0ijtbXV1dUPzEzBnJMnT+bk5Fy6dEla0bLhPa5MOxJL0hTrgUFDShPvG8k2fhuD/vbbb8+dO2ceof1mZWWZRxqOL1u2TKgjPDz8QT0OXh83b97MkrFr1y5pnjrhPa5MOxJL0hTrgUFDShPvG8k2fhuDNhgMWb+23fqMuL74I488EhMT8+OPP969e1da9zBKSkpatWrl7u7epk2bgICAxx9/3MnJyWg0SvPUCe9xZdqRWJKmWA8MGlKaeN9ItmF3g965c2dRUZG4mZOTk5iYSHuJjo4m571x4waLU2TLli1Hjx7Ny8u7cuWKmC836OrqaoqIPdy6dYuClZWVx44dKygo+Oabb8RMqqWuPv30082bN5vay9i48adX9ek4pRXqhPe4Mu1ILElTrAcrDAClQbNIrjeSbQj2Nuhhw4bR3VdVVUVlOk3q38vLS/wQyD1ZGpVpUsyCzs7O+/fvF+MSgy4vLxebC3Vfyrh582ZYWBjbpE/1nXfeEdsmJCTodLohQ4aY92DOu+++SwnTp0+XVqgWQY0GTZSVlZWWltLlLC4uLiwszAegueH6vqptCPY26L/85S/U51//+lcqp6Sk6PV68lNBZrsU8fHxOX78OBnK8OHDjUYjFVjc4iMO8/icOXNat2598uRJ6nno0KH084A+TJbj5+d34sQJml//qvEvXLp0iRqSud+7d09ap1rUatD0g/f69et0xCUlJXRXHAKgueH6jS/bsLtB19TUPProo+PHj6dy165dx44dW2vJdimSlpbGyl988QVt0udjMZNhHn/ssccSExNZmU3SxbaxsbFiEwl37tyh42nTpg39dJTWqRm1GnRFRQUd69WrV+mgac5yCoDmhuuaCbZhd4MmkpOT3d3d6Xyp82PHjtVasl3zCFknbebm5lrMZJjHDQZDeno6K0vabt26VWwiISoqysHB4ciRI9IKlaNKg3Z2bi0AoCTof/FcVx2zDYGDQV+5ckWn0z399NMdO3Z8UHeHCzLbpciCBQtY+fDhw7TJXouWZzLM40899dSIESNYubCw8KFtCTJ0ql2zZo20Qv0IajRoOujRo49CkHIkcF4W0jZ4GDQxcOBA6nn16tVsk+a8kZGRb7zxRnV1NYsIdYs9zZw5MzU11c/Pr3fv3g/qsXKGeXz37t20GRMTQ/37+Pg888wzDbf98MMPW7VqRT8wioqK3nvvvbfeemvfvn3Z2dnaeNYBg4YgO6hFGXRBQYGjo6P4DtyyZcvc3NxCQkLOnz/PIrTfOXPm0BTbw8NjyJAhV69eFeMWTVYS37BhA7Wl/5SMHj3a/NU9i23j439aJVzOwYMHpakqRIBBQ1DTJXBet9c2BD4G/VDYKqnSKLAeGDQE2UEC53V7baO5DBrYCxg0BNlBAud1e20DBq12YNAQZAfxvpFsAwatdniPK9OOxJI0xXpg0JDSxPtGsg0YtNrhPa5MOxJL0hTrgUFDShPvG8k2YNBqh/e4Mu1ILElTrEdjBp2RcWbr1vNRUT+VJ036244dny9ZckqeBilZvG8k24BBqx3e48q0I7EkTbEejRn0xo1n6WPZtu0ClQsLv753r2bevGJ5GqRk8b6RbAPrPqod3qskwqAbpVOnbpSXV6Wm/oPOLjv7ojwBUrgERRr0A6z7qH64vh0Eg26Upk//8PbtKjq18+dvsWcdkLqkWIPGuo9qh+v79TDoxur06Z8WzN2//7K8ClK+FGvQWPdR7XD9hioMulHKzPzpb25evPhDZeX9V189KU+AFC5lGrS3h4fpcSZQIbxXSYRBP1yzZn3044/VxcXXJ0364Nate2TTUVHH5GmQkiUo0qDpqGrfegtSrwTOi3DBoB+iqKijZ858f+dO9fTpH9JmWtpp+oj27r0kz4SULBg0xEMwaCVqx47PJcrMPCdPg5QjGDTEQwLnVRJh0LZI/KxEysoq5WmQcgSDhnhI4LxKougwMGhIy4JBQzwkcF4lEQYNtQjBoCEe4j2uYNBQixDvG8k2tGTQx1esyI+Pv5mdLUaonDVjhkS7Zs2St61PFfv2FS1evHv27INJSf/Zu1eeING3O3eeS09n5WNLl9LurmRmirVV+fk7YmP3zJ37oKBA3tY28R5XMGioRYj3jWQbmjHoxKFDhTraGY3f/eLRJWlprRwd3V1c2nh4BHh7P96unZOjo9FgkDe3qMPJyb6enqxbwtXZOXPaNHmauQx6PZkyK5/PyHDT68OCg6vz81lk0YgR1M/2mTPlDW0W73EFg4ZahHjfSLahGYP2cHWNHTToVGoqndG+uDh5AmljTAzV7oyNlVfJdTotzcXJaVBoKLn8vby8Lzdtov5DAwOvbd/OEih4KDm5ICGBZs0sQvul/qOfe448+sauXRSh2TpFlo0aReWTKSmODg7jnn1Wvq+miPe44mLQWKMLKA3eq47ZhqAVgw7x958TGVmckkJndGTJEnnCuwsW6HS66QMGiBF2XerbHBke3tHX925enrwrEvkvmTVr0trV9e+rV1MwsG1bFiE+TU1lmeP79qVZ/LGlS6m3Tn5+txvxnMQqCWo06AdYowsoD66/bbcNc0tStTImTyYf9DIYhoWF3S8oEJ8qMF3auJFsNCw4+J6Z4TInrW+zjYfHwuHDWbly/37xEfb5jAyKzBo0qHtg4JXMzLPp6QHe3s+GhIidiI84mMpzcp7w86O5M83HaTJuXmUXqdWgsUYXUBpc31e1DW0Y9MerVhkNBnJnmiMfTk6myMBu3ZaOHMlq7+Tmdm3fngy3dOtWedv65OTomD5pEiv/8OabzL5F/+3Qtu20/v2ZZf+hZ08HnY5MvNaSQZPm/f73FH+qQ4eaAwfkO2qi1GrQWKMLKA2u3/iyDW0YdM+goCG9etHseGR4OE1UN8XE0GxafNYc1acPGajF5x4NqKOv75SICElQ9F83vV60bMblzZvNE0QdSk6mHxv9n3ySqhaNGCHpsOkS1GjQzs6tJR8fAM0L71XHbEPQhEHrnZxSo6OpUJ2fP6p3bzopH09P9jSDZsG0uWb8eHmrhvX6yy/TJJo9XGa6VTePZv7bPTBw79y5LH6/oID9SrBWZtDXtm9v27p1j6Cgqvz8yS+8QE59qG6Cb0cJajRoAW9xQAqTwHlRG9vQhkGH+Pt7GQwro6JSxozpEhBA02c6L3LqwkWLqPx0cHDR4sXvLVz4VkLCvri47Nmz2bMO9oNT7ESyWZ6TQ8ZKHj21X7/1EyfOHzrU38vL083tH+vWUe2bc+a4OjvHv/QSWf8zISHtjEb22z+DXh/ZvfsbY8bQjwoy7oiuXemHB3szmhJoVk5+/c0v74HYRTBoCLKDYND8dHTp0rDgYHLMR9zdo/r0ubhhA1kqmeaUiAhmuxIOJiXVyhxZsllb59FJw4cH+fiQTQd4e88ePPjrrCyxlmbKnfz8XJycwp944sTKlSy4bNQoN72efmCcz8igMnWYNnGi2IS9afdCly52fBgtwKAhqOkSOK86ZhsSS9KS7uTmyoPaEwwaguwggfOqY7ahYYNuIYJBQ5AdJHBedcw2YNBqFwwaguwg3jeSbcCg1S7e4woGDbUI8b6RbAMGrXbxHlcwaKhFiPeNZBswaLWL97iCQT9cW7eeX7euRNzcuPGs+SakCvG+kWwDBq128R5XMOiH6/jxa1VV92NijlN53rxi+ojy8r6Up0FKFu8byTaw7qPa4b1KIgz64Vqw4BP6WHbvvkjlt9++QmY9bdqH8jRIyRIUadAPsO6j+uH6dhAMulE6d+7WP/9ZHhV19MaNuydOXJcnQAqXYg0a6z6qHa7v18OgG6W1a0vok8nOvkj/LlnyqTwBUrgUa9BY91HtcP2GKgy6UaK587VrP5aVVdI8Wl4LKV/KNGhvDw/T40ygQnivkgiDbqx27/5p+rxjxwV5FaR8CYo0aAFvcahcAudFuGDQjdWf//zPiorqiRP/Jq+ClC8YNMRDMOjm16xZHx04cLm6+v7//V8pi+zY8blEmZnn5A0h5QgGDfGQwHmVRBj0wzV3bjF9UKdPfz9lygcsIn5WImVllfKGkHIEg4Z4SOC8SqLoMDDohjRu3PvyIKQiwaAhHhI4r5IIg4ZahGDQEA/xHlcwaKhFiPeNZBuaMejjK1bkx8ffzM4WI1TOmjFDol2zZsnbylWek7M/Pv677OwHBQWsz6b0xlW8xxUMGmoR4n0j2YY2DDpx6FChjnZG43e/eHRJWlorR0d3F5c2Hh4B3t6Pt2vn5OhoNBjkzeUaGR5OvVGrmQMH9u3cuYm9cRXvcQWDhlqEeN9ItqENg/ZwdY0dNOhUaiqdzr64OHkCaWNMDNXujI2VV8n15wULLvzpTxP69vUyGAoXLZInWNUbV/EeV1wMGmt0AaXBe9Ux2xA0YdAh/v5zIiOLU1LodI4sWSJPeHfBAp1ON33AADHCLkp9mw1L3lszSlCjQT/AGl1AeXD9bbttNN6VlKyMyZNbOTrSbHdYWNj9goLq/Hzz2ksbN7Z2dQ0LDr6XlycGbTZoi701o9Rq0FijCygNru+r2kYjXUnJ+njVKqPBQO5Ms9rDyckUGdit29KRI1ntndzcru3bt/HwKN26Vd7WWtm3N7tIrQaNNbqA0uD6jS/b0IBB9wwKGtKrF81nR4aHuzg5bYqJodm0+HQ4qk8fB53O4nMPG2Tf3uwiVRq0s3Nr9n8WABQC71XHbENQv0HrnZxSo6OpUJ2fP6p3bzojH09P9vwhfdIk2lwzfry8lQ2yb2/2kqBGgxbwFgekMAmcF7WxDQ0YdIi/v5fBsDIqKmXMmC4BATR9ppMipy5ctIjKTwcHFy1e/N7ChW8lJOyLi8uePZs9nWA/NcVOJJtyfbhyZQO9NaNg0BBkB8GgOeno0qVhwcGuzs6PuLtH9elzccOG9RMntjMap0REMNuVcDApqVbmyJJNueJfesnUhRmst2aUAIOGoKZL4LzqmG0IDbqSenUnN1ce1KRg0BBkBwmcVx2zDa0adMsRDBqC7CCB86pjtgGDVrtg0BBkB/G+kWwDBq128R5XMGioRYj3jWQbMGi1i/e4gkFDLUK8byTbgEGrXbzHFQz64Zo584T5nx/ctAl/flB94n0j2QYMWu3iPa5g0A/X8uX/X1XV/fLyqps371ZX37927Ud5DqRw8b6RbAPrPqod3qskwqCt0Jo1/7h//8G6dSXyKkjhEhRp0A+w7qP64fp2EAy6sZo7t7iiovrYsavyKkj5UqxBY91HtcP1/XoYdKM0ZsyxixfLrl//ccKEv8lrIeVLsQaNdR/VDtdvqMKgG6W33vqquvr+4sWn5FWQKqRMg/b28DA9zgQqhPcqiTDoh2vJklP37z84fvza2rUlGzac2br1/Nixx+RpkJIlKNKgBbzFoXIJnBfhgkE/XEVFX4sfDmPiRDzoUJlg0BAPwaCVKPPXopkyM/FytKIFg4Z4SOC8SiIM2haJn5VIWVmlPA1SjmDQEA8JnFdJFB0GBg1pWTBoiIcEzqskwqChFiEYNMRDvMcVDBpqEeJ9I9mGxgz6+IoV+fHxN7OzxQiVs2bMkGjXrFnytvWpYt++osWLd8+efTAp6T9798oTJPp2585z6elU+GztWtrXmfXrxaoHBQXZs2dTV1SQN7RNvMcVDBpqEeJ9I9mGlgw6cehQoY52RuN3v3h0SVpaK0dHdxeXNh4eAd7ej7dr5+ToaDQY5M0t6nBysq+nJ+uWcHV2zpw2TZ5mLoNeT75MhX/v3Onj6dnJz4/9iXHSlmnTqJO0iRPlrWwW73EFg4ZahHjfSLahJYP2cHWNHTToVGoqndS+uDh5AmljTAzV7oyNlVfJdTotzcXJaVBoKLk8meyXmzZR/6GBgde2b2cJFDyUnFyQkECzZhah/VL/0c89Rx59Y9eu9xYupM3lo0dT1fUdOzzd3Pp17WrH6XMtDBqC7CLeN5JtaMmgQ/z950RGFqek0EkdWbJEnvDuggU6nW76gAFi5KdZsdknINkcGR7e0df37i/zX4nIf8msWZPWrq5/X72agoFt27II8WlqKkWm9uund3K6uGHD6D59vAyGf2VlybtqigTO4woGDbUI8b6RbMPcj9SujMmTWzk6kgkOCwu7X1BQnZ9vXntp40ay0bDgYPGBQ63MkSWbbTw8Fg4fzsqV+/eLj7DPZ2RQZNagQd0DA69kZp5NTw/w9n42JETshD3iYLq9d2+Qj0+wry/FD7z2mhi3l3iPKy4GjVVugdLgvW6vbQhaMeiPV60yGgzkzjRHPpycTJGB3botHTmS1d7Jze3avj0ZbunWrfK29cnJ0TF90iRW/uHNN8VLyfy3Q9u20/r3Z5b9h549HXQ6MvFamUGTTqxcKdQ995DvoukS1GjQD7DKLVAeXN9XtQ3NGHTPoKAhvXrR7HhkeLiLk9OmmBiaTYvPmqP69CEDtfjcowF19PWdEhEhCYr+66bXi5bNuLx5s3mCxVZ2l6BSg8Yqt0BpcP3Gl20IWjFovZNTanQ0Farz80f17k3n5ePpyZ5m0CyYNteMHy9v1bBef/llmkSzh8tMt+rm0cxquwcG7p07l8XvFxTc2LWLlS16scWgXaRWg8Yqt0BpcF0zwTY0Y9Ah/v5eBsPKqKiUMWO6BATQ9JlOjZy6cNEiKj8dHFy0ePF7Cxe+lZCwLy4ue/Zs9qyDzXzFTiSb5Tk5PYKCyKOn9uu3fuLE+UOH+nt5ebq5/WPdOqp9c84cV2fn+JdeIut/JiSkndF4u+4taYNeH9m9+xtjxpg/BIdBS6msrKRJCh0uzVbof5RfAtDccF11zDY0Y9BHly4NCw4mx3zE3T2qT5+LGzaQpZJpTomIYLYr4WBSUq3MkSWbtXUenTR8eJCPD9l0gLf37MGDvzZ7DYM8t5Ofn4uTU/gTT5xYuZIFl40a5abX0w8M9rtEsWcY9K+oqamhe4DmKXQzlJWVfQ9Ac0PjkEYjjUkamTQ+pUO2OZD4kcZ0JzdXHmwW0fzd3NntKLUaNADgoWjboFuCYNAAaBYYtNoFgwZAs8Cg1S4YNACaBQatdsGgAdAsMGi1CwYNgGaBQatdMGgANAtWrVE7vNd4gUED0Jxg1Rq1w3WNFxg0AM0JVq1RO1zXeIFBA9CcYNUatcN1jRcYNADNhreHh/ShJlAVRqOR6xovMGgAmg0Bb3GoXHQFYdAAaBMYtNoFgwZAs8Cg1S66gngGDYA2gUGrXXQF8RYHANoEBq120RXEe9AAaBMYtNol4KveAGgVjRn08RUr8uPjb2ZnixEqZ82YIdGuWbPkbetTxb59RYsX7549+2BS0n/q/upgw/p2585z6ems3PS9P1QwaAA0i5YMOnHoUKGOdkbjd794dElaWitHR3cXlzYeHgHe3o+3a+fk6Gg0GOTNLepwcrKvpyfrlnB1ds6cNk2eZi6DXi/++cEm7r0xgkEDoFm0ZNAerq6xgwadSk2lk9oXFydPIG2MiaHanbGx8iq5TqeluTg5DQoNJZ+9l5f35aZN1H9oYOC17dtZAgUPJScXJCTQrJlFaL/Uf/Rzz5FH39i1S9KhVXtvpGDQAGgWLRl0iL//nMjI4pQUOqkjS5bIE95dsECn000fMECMsHlxfZsjw8M7+vrezcuTd0Ui/yWzZk1au7r+ffVqCga2bcsixKepqeb58r3bRQIMGgCtYu5HalfG5MmtHB29DIZhYWH3Cwqq8/PNay9t3Eg2GhYcfM/McJmT1rfZxsNj4fDhrFy5f7/4EPl8RgZFZg0a1D0w8Epm5tn09ABv72dDQsROxEccoizu3S6CQQOgWTRj0B+vWmU0GMidaZZ6ODmZIgO7dVs6ciSrvZOb27V9ezLc0q1b5W3rk5OjY/qkSaz8w5tvMvsW/bdD27bT+vdnlv2Hnj0ddDoy8VpLBm3b3hspGDQAmkUzBt0zKGhIr140Px0ZHu7i5LQpJoZm0+LT3qg+fchALT73aEAdfX2nRERIgqL/uun1omUzLm/ebJ4gyra9N1ICDBoArSJoxaD1Tk6p0dFUqM7PH9W7N52Xj6cne55As2DaXDN+vLxVw3r95ZdpEs0eLjPdqptHM//9/9u7g5CmwzCO47voahNyDSRFEBk26CJBEXbSi4EgXmQ7CdFtioQEDgWD1U1EvHmKSIOwWwQr6FTs1KXBCIJOi8FOwWgxGCzsh4MVfyWiCT7v2/fDc9AN/CMP/+/eqeD4yMiTpaX24z8ODjq/EgwE+p+v/pdDoAFveRPo5NBQLBrNpVIP0+krw8M6PutbU6nza2v6+Hoi8Wp9/cXq6vOVlafLy48ymfZPG9on384XCXxa39u7OjqqRt+ZmtpaWLg3OzsUi12IRD5sburZx4uL53t7787MKL43k8lL/f3fjv5KOhoO3xoff5BO66XibS73h6ufyhBowFveBPrNxsa1RELFvNjXl5qY+LSzo6QqmrcnJ9vZDXiZzR4eK3Lg08OjRmfn5kYHBpTp4Xg8Mz39ZXe386xOypcHB8/19NwYG3uXy7UfvD8/HwmH9YLxcXtb+f51yd+0r34qEyLQgK9CvgT6xPm+v3/8Qc+GQAPe8jvQ/8MQaMBbBNr1IdCAtwi060OgAW8RaNeHQAPeItCuD4EGvEWgXR8CDXiLQLs+BBrwFoF2fQg04K14PB6Cy6LRKIEGvFWr1crlcqlUKhQK+Xz+GVzDf/UGvFWv16vVqg5fxWJR9/lruEZb0+60Qe1R2wwuuDsEGjhLjUZD74srlYrucJ3C3sM12pp2pw1qj9pmcMHdIdDAWWo2mzp26d7W+UvvkT/DNdqadqcNao/aZnDB3SHQwFlqtVq6q3Xy0u1dq9W+wjXamnanDWqP2mZwwd0h0ABgFIEGAKMINAAYRaABwCgCDQBGEWgAMIpAA4BRBBoAjCLQAGAUgQYAowg0ABhFoAHAKAINAEYRaAAwikADgFEEGgCMItAAYBSBBgCjCDQAGEWgAcAoAg0ARhFoADCKQAOAUQQaAIwi0ABgFIEGAKNOCDQAwBQCDQBGEWgAMOonYMmDAgxFjdMAAAAASUVORK5CYII=" />
</p>
<p>各クラスがvtblへのポインタを保持するため、このドキュメントで使用している<a
href="cpp_idioms.html#SS_21_10_1">g++</a>では、
sizeof(X)は8ではなく16、sizeof(Y)は16ではなく24、sizeof(Z)は24ではなく32となる。</p>
<p>g++の場合、以下のオプションを使用し、クラスのメモリレイアウトをファイルに出力することができる。</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/Makefile 23</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    CCFLAGS_ADD<span class="op">:=-</span>fdump<span class="op">-</span>lang<span class="op">-</span><span class="kw">class</span></span></code></pre></div>
<p>X、Y、Zのメモリレイアウトは以下の様に出力される。</p>
<pre><code>    Vtable for X
    X::_ZTV1X: 5 entries
    0     (int (*)(...))0
    8     (int (*)(...))(&amp; _ZTI1X)
    16    (int (*)(...))X::GetX
    24    (int (*)(...))X::~X
    32    (int (*)(...))X::~X

    Class X
       size=16 align=8
       base size=16 base align=8
    X (0x0x7f54bbc23a80) 0
        vptr=((&amp; X::_ZTV1X) + 16)

    Vtable for Y
    Y::_ZTV1Y: 6 entries
    0     (int (*)(...))0
    8     (int (*)(...))(&amp; _ZTI1Y)
    16    (int (*)(...))Y::GetX
    24    (int (*)(...))Y::~Y
    32    (int (*)(...))Y::~Y
    40    (int (*)(...))Y::GetY

    Class Y
       size=24 align=8
       base size=24 base align=8
    Y (0x0x7f54bbc3f000) 0
        vptr=((&amp; Y::_ZTV1Y) + 16)
      X (0x0x7f54bbc23d20) 0
          primary-for Y (0x0x7f54bbc3f000)

    Vtable for Z
    Z::_ZTV1Z: 7 entries
    0     (int (*)(...))0
    8     (int (*)(...))(&amp; _ZTI1Z)
    16    (int (*)(...))Z::GetX
    24    (int (*)(...))Z::~Z
    32    (int (*)(...))Z::~Z
    40    (int (*)(...))Z::GetY
    48    (int (*)(...))Z::GetZ

    Class Z
       size=32 align=8
       base size=32 base align=8
    Z (0x0x7f54bbc3f068) 0
        vptr=((&amp; Z::_ZTV1Z) + 16)
      Y (0x0x7f54bbc3f0d0) 0
          primary-for Z (0x0x7f54bbc3f068)
        X (0x0x7f54bbc43060) 0
            primary-for Y (0x0x7f54bbc3f0d0)</code></pre>
<p>このようなメモリレイアウトは、</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/class_layout_ut.cpp 40</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> z_ptr <span class="op">=</span> <span class="kw">new</span> Z<span class="op">;</span></span></code></pre></div>
<p>のようなオブジェクト生成に密接に関係する。その手順を下記の疑似コードにより示す。</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ステップ1  メモリアロケーション</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span><span class="op">*</span> ptr <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>Z<span class="op">));</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ステップ2  ZオブジェクトのX部分の初期化</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    X<span class="op">*</span> x_ptr <span class="op">=</span> <span class="op">(</span>X<span class="op">*)</span>ptr<span class="op">;</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    x_ptr<span class="op">-&gt;</span>vtbl <span class="op">=</span> <span class="op">&amp;</span>vtbl_for_X       <span class="co">// Xのコンストラクタ呼び出し処理</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    x_ptr<span class="op">-&gt;</span><span class="va">x_</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>                  <span class="co">// Xのコンストラクタ呼び出し処理</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ステップ3  ZオブジェクトのY部分の初期化</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    Y<span class="op">*</span> y_ptr <span class="op">=</span> <span class="op">(</span>Y<span class="op">*)</span>ptr<span class="op">;</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    y_ptr<span class="op">-&gt;</span>vtbl <span class="op">=</span> <span class="op">&amp;</span>vtbl_for_Y       <span class="co">// Yのコンストラクタ呼び出し処理</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    y_ptr<span class="op">-&gt;</span><span class="va">y_</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>                  <span class="co">// Yのコンストラクタ呼び出し処理</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ステップ4  ZオブジェクトのZ部分の初期化</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>    Z<span class="op">*</span> z_ptr <span class="op">=</span> <span class="op">(</span>Z<span class="op">*)</span>ptr<span class="op">;</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>    z_ptr<span class="op">-&gt;</span>vtbl <span class="op">=</span> <span class="op">&amp;</span>vtbl_for_Z       <span class="co">// Zのコンストラクタ呼び出し処理</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>    z_ptr<span class="op">-&gt;</span><span class="va">z_</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>                  <span class="co">// Zのコンストラクタ呼び出し処理</span></span></code></pre></div>
<p>オブジェクトの生成がこのように行われるため、Xのコンストラクタ内で仮想関数GetX()を呼び出した場合、
その時のvtblへのポインタはXのvtblを指しており(上記ステップ2)、X::GetX()の呼び出しとなる
(Z::GetX()の呼び出しとはならない)。</p>
<p>なお、オブジェクトの解放は生成とは逆の順番で行われる。</p>
<h3 id="rtti">RTTI <a id="SS_19_4_9"></a></h3>
<p>RTTI(Run-time Type
Information)とは、プログラム実行中のオブジェクトの型を導出するための機能であり、
具体的には下記の3つの要素を指す。</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_4_9_1">dynamic_cast</a></li>
<li><a href="core_lang_spec.html#SS_19_4_9_2">typeid</a></li>
<li><a href="core_lang_spec.html#SS_19_4_9_3">std::type_info</a></li>
</ul>
<h4 id="dynamic_cast">dynamic_cast <a id="SS_19_4_9_1"></a></h4>
<p>dynamic_castは、実行時の型チェックと安全なダウンキャストを行うためのキャスト演算子であるため、
<a
href="core_lang_spec.html#SS_19_4_8">ポリモーフィックなクラス</a>とは密接な関係を持つ。</p>
<p>下記のような<a
href="core_lang_spec.html#SS_19_4_8">ポリモーフィックなクラス</a>に対しては、</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 8</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Polymorphic_Base <span class="op">{</span>  <span class="co">// ポリモーフィックな基底クラス</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="op">~</span>Polymorphic_Base<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Polymorphic_Derived <span class="op">:</span> <span class="kw">public</span> Polymorphic_Base <span class="op">{</span>  <span class="co">// ポリモーフィックな派生クラス</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>dynamic_castは下記のように振舞う。</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 25</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> Polymorphic_Base<span class="op">{};</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> d <span class="op">=</span> Polymorphic_Derived<span class="op">{};</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    Polymorphic_Base<span class="op">&amp;</span> b_ref_d <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    Polymorphic_Base<span class="op">&amp;</span> b_ref_b <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ポインタへのdynamic_cast</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">*</span> d_ptr <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>Polymorphic_Derived<span class="op">*&gt;(&amp;</span>b_ref_d<span class="op">);</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>d_ptr<span class="op">,</span> <span class="op">&amp;</span>d<span class="op">);</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">*</span> d_ptr2 <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>Polymorphic_Derived<span class="op">*&gt;(&amp;</span>b_ref_b<span class="op">);</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>d_ptr2<span class="op">,</span> <span class="kw">nullptr</span><span class="op">);</span>  <span class="co">// キャストできない場合、nullptrが返る</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// リファレンスへのdynamic_cast</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> d_ref <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>Polymorphic_Derived<span class="op">&amp;&gt;(</span>b_ref_d<span class="op">);</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(&amp;</span>d_ref<span class="op">,</span> <span class="op">&amp;</span>d<span class="op">);</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// キャストできない場合、エクセプションのが発生する</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span><span class="kw">dynamic_cast</span><span class="op">&lt;</span>Polymorphic_Derived<span class="op">&amp;&gt;(</span>b_ref_b<span class="op">),</span> <span class="bu">std::</span>bad_cast<span class="op">);</span></span></code></pre></div>
<p>一方で、下記のような非<a
href="core_lang_spec.html#SS_19_4_8">ポリモーフィックなクラス</a>に対しては、</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 102</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> NonPolymorphic_Base <span class="op">{</span>  <span class="co">// 非ポリモーフィックな基底クラス</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> NonPolymorphic_Derived <span class="op">:</span> <span class="kw">public</span> NonPolymorphic_Base <span class="op">{</span>  <span class="co">// 非ポリモーフィックな派生クラス</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>dynamic_castは下記のように振舞う。</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 115</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> NonPolymorphic_Base<span class="op">{};</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> d <span class="op">=</span> NonPolymorphic_Derived<span class="op">{};</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    NonPolymorphic_Base<span class="op">&amp;</span> b_ref_d <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    NonPolymorphic_Base<span class="op">&amp;</span> b_ref_b <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if 0  </span><span class="co">// 非ポリモーフィックなクラスへのdynamic_castはill-formedになる</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a><span class="co">    auto* d_ptr = dynamic_cast&lt;NonPolymorphic_Derived*&gt;(&amp;b_ref_d);</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a><span class="co">    auto* d_ptr2 = dynamic_cast&lt;NonPolymorphic_Derived*&gt;(&amp;b_ref_b);</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a><span class="co">    //virtual関数を持たないため、リファレンスへのdynamic_castはコンパイルできない</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a><span class="co">    auto&amp; d_ref = dynamic_cast&lt;NonPolymorphic_Derived&amp;&gt;(b_ref_d);</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a><span class="co">    ASSERT_THROW(dynamic_cast&lt;NonPolymorphic_Derived&amp;&gt;(b_ref_b), std::bad_cast);</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a><span class="co">    </span><span class="pp">#endif</span></span></code></pre></div>
<h4 id="typeid">typeid <a id="SS_19_4_9_2"></a></h4>
<p>typeidは<a
href="core_lang_spec.html#SS_19_4_9">RTTI</a>オブジェクトの型情報 (<a
href="core_lang_spec.html#SS_19_4_9_3">std::type_info</a>)を実行時に取得するための演算子である。
dynamic_castとは違い、 typeidのオペランドは<a
href="core_lang_spec.html#SS_19_4_8">ポリモーフィックなクラス</a>のインスタンスでなくても良い。
以下の例では<a
href="core_lang_spec.html#SS_19_1_1">基本型</a>に対するtypeidが返す<a
href="core_lang_spec.html#SS_19_4_9_3">std::type_info</a>の振る舞いを表す。</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 52</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>   i<span class="op">{};</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span>  j<span class="op">{};</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> i_ref <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> type_info_i     <span class="op">=</span> <span class="kw">typeid</span><span class="op">(</span>i<span class="op">);</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> type_info_i_ref <span class="op">=</span> <span class="kw">typeid</span><span class="op">(</span>i_ref<span class="op">);</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_NE<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>i<span class="op">),</span> <span class="kw">typeid</span><span class="op">(</span>j<span class="op">));</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>type_info_i<span class="op">,</span> type_info_i_ref<span class="op">);</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_STREQ<span class="op">(</span>type_info_i<span class="op">.</span>name<span class="op">(),</span> <span class="st">&quot;i&quot;</span><span class="op">);</span>  <span class="co">// 実装定義の型名(clang++/g++ではintはi)</span></span></code></pre></div>
<p>下記のような<a
href="core_lang_spec.html#SS_19_4_8">ポリモーフィックなクラス</a>のインスタンスに関して、</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 8</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Polymorphic_Base <span class="op">{</span>  <span class="co">// ポリモーフィックな基底クラス</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Polymorphic_Base<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Polymorphic_Derived <span class="op">:</span> <span class="kw">public</span> Polymorphic_Base <span class="op">{</span>  <span class="co">// ポリモーフィックな派生クラス</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>typeidが返す<a
href="core_lang_spec.html#SS_19_4_9_3">std::type_info</a>オブジェクトは下記のように振舞う。</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 65</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> Polymorphic_Base<span class="op">{};</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> d <span class="op">=</span> Polymorphic_Derived<span class="op">{};</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    Polymorphic_Base<span class="op">&amp;</span> b_ref_d <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    Polymorphic_Base<span class="op">&amp;</span> b_ref_b <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ポリモーフィックなクラスインスタンスに対するtypeidが返す</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::type_infoオブジェクトが示す型は、オペランドの実際の型である。</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// * b_ref_dの表層の型:Polymorphic_Base</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// * b_ref_dの実際の型:Polymorphic_Derived</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記のアサーションはこのことを表す。</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>b_ref_d<span class="op">),</span> <span class="kw">typeid</span><span class="op">(</span>d<span class="op">));</span>  <span class="co">// b_ref_dとdの実際の型が同じであることを示す</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>b_ref_b<span class="op">),</span> <span class="kw">typeid</span><span class="op">(</span>b<span class="op">));</span>  <span class="co">// b_ref_bとbの表層の型が同じであることを示す</span></span></code></pre></div>
<p>一方で、下記のような非<a
href="core_lang_spec.html#SS_19_4_8">ポリモーフィックなクラス</a>に対しては、</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 102</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> NonPolymorphic_Base <span class="op">{</span>  <span class="co">// 非ポリモーフィックな基底クラス</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> NonPolymorphic_Derived <span class="op">:</span> <span class="kw">public</span> NonPolymorphic_Base <span class="op">{</span>  <span class="co">// 非ポリモーフィックな派生クラス</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>typeidが返す<a
href="core_lang_spec.html#SS_19_4_9_3">std::type_info</a>オブジェクトは下記のように振舞う。</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 139</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> NonPolymorphic_Base<span class="op">{};</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> d <span class="op">=</span> NonPolymorphic_Derived<span class="op">{};</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    NonPolymorphic_Base<span class="op">&amp;</span> b_ref_d <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>    NonPolymorphic_Base<span class="op">&amp;</span> b_ref_b <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 非ポリモーフィックなクラスインスタンスに対するtypeidが返す</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::type_infoオブジェクトが示す型は、オペランドの表層の型である。</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// * b_ref_dの表層の型:Polymorphic_Base</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// * b_ref_dの実際の型:Polymorphic_Derived</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記のアサーションはこのことを表す。</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>b_ref_d<span class="op">),</span> <span class="kw">typeid</span><span class="op">(</span>b<span class="op">));</span>  <span class="co">// b_ref_dとdの表層の型が同じであることを示す</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>b_ref_b<span class="op">),</span> <span class="kw">typeid</span><span class="op">(</span>b<span class="op">));</span>  <span class="co">// b_ref_bとbの表層の型が同じであることを示す</span></span></code></pre></div>
<p>従って、このような場合のtypeidは静的な型(表層の型)に対しての情報を返すため、
コンパイル時にのみ評価され、ランタイム時に評価されない。</p>
<p><a
href="core_lang_spec.html#SS_19_4_8">ポリモーフィックなクラス</a>のオブジェクトをオペランドとするtypeidの実行は、
そのオペランドの実際のオブジェクトの型を取得することはすでに示した。
このような場合、オペランド式は実行時に評価される。以下のコードはそのことを表している。</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 87</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    Polymorphic_Base    base<span class="op">;</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    Polymorphic_Derived derived<span class="op">;</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    Polymorphic_Base<span class="op">*</span>   base_ptr <span class="op">=</span> <span class="op">&amp;</span>derived<span class="op">;</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>Polymorphic_Derived<span class="op">),</span> <span class="kw">typeid</span><span class="op">(*</span>base_ptr<span class="op">));</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>Polymorphic_Base<span class="op">),</span> <span class="kw">typeid</span><span class="op">(*(</span>base_ptr <span class="op">=</span> <span class="op">&amp;</span>base<span class="op">)));</span>  <span class="co">// 注意</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ポリモーフィックなクラスは対しては、typeid内の式が実行される</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>base_ptr<span class="op">,</span> <span class="op">&amp;</span>base<span class="op">);</span>  <span class="co">// base_ptr = &amp;baseが実行される</span></span></code></pre></div>
<p>一方、非<a
href="core_lang_spec.html#SS_19_4_8">ポリモーフィックなクラス</a>のオブジェクトをオペランドとするtypeidのオペランド式は、
コンパイル時に処理されるため、その式は実行されない。以下のコードはそのことを表している。</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 161</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    NonPolymorphic_Base    base<span class="op">;</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    NonPolymorphic_Derived derived<span class="op">;</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    NonPolymorphic_Base<span class="op">*</span>   base_ptr <span class="op">=</span> <span class="op">&amp;</span>derived<span class="op">;</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_NE<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>NonPolymorphic_Derived<span class="op">),</span> <span class="kw">typeid</span><span class="op">(*</span>base_ptr<span class="op">));</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>NonPolymorphic_Base<span class="op">),</span> <span class="kw">typeid</span><span class="op">(*(</span>base_ptr <span class="op">=</span> <span class="op">&amp;</span>base<span class="op">)));</span>  <span class="co">// 注意</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 非ポリモーフィックなクラスに対しては、typeid内の式は実行されない</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>base_ptr<span class="op">,</span> <span class="op">&amp;</span>derived<span class="op">);</span>  <span class="co">// base_ptr = &amp;baseは実行されない</span></span></code></pre></div>
<h4 id="stdtype_info">std::type_info <a id="SS_19_4_9_3"></a></h4>
<p>type_infoクラスは、<a
href="----">typeid</a>演算子によって返される、型の情報が格納された型である。</p>
<p>std::type_infoはコンパイラの実装で定義された型名を含んでいる。
以下のコードで示したように<code>std::type_info::name()</code>によりその型名を取り出すことができる。</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 179</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> s <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;str&quot;</span><span class="op">};</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> <span class="bu">std::</span>string_view<span class="op">{</span><span class="st">&quot;str&quot;</span><span class="op">};</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> <span class="bu">std::</span>byte<span class="op">{</span><span class="bn">0b1001</span><span class="op">};</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_STREQ<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>s<span class="op">).</span>name<span class="op">(),</span> <span class="st">&quot;Ss&quot;</span><span class="op">);</span>       <span class="co">// 実装定義の型名</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_STREQ<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>b<span class="op">).</span>name<span class="op">(),</span> <span class="st">&quot;St4byte&quot;</span><span class="op">);</span>  <span class="co">// 実装定義の型名</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_STREQ<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>v<span class="op">).</span>name<span class="op">(),</span> <span class="st">&quot;St17basic_string_viewIcSt11char_traitsIcEE&quot;</span><span class="op">);</span></span></code></pre></div>
<p><code>std::type_info::name()</code>が返すCスタイルの文字列リテラルを、
「人間が認知できる元の型名に戻す関数」を通常のコンパイラは独自に提供する。
このドキュメントのコードのコンパイルに使用している<a
href="cpp_idioms.html#SS_21_10_1">g++</a>/<a
href="cpp_idioms.html#SS_21_10_2">clang++</a>では、
そのような関数は、<code>abi::__cxa_demangle</code>である。</p>
<p><code>std::type_info::name()</code>と<code>abi::__cxa_demangle</code>を利用して、
オブジェクトの<a
href="core_lang_spec.html#SS_19_14_6">被修飾型</a>名をstd::stringオブジェクトとして取り出す関数とその使用例を以下に示す。</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 191</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;cxxabi.h&gt;</span><span class="pp">  </span><span class="co">// g++/clang++実装依存ヘッダ abi::__cxa_demangleの宣言</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;memory&gt;</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string type2str<span class="op">(</span>T<span class="op">&amp;&amp;</span> obj<span class="op">)</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> status<span class="op">;</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// objに基づく型情報を取得</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> demangled <span class="op">=</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(&amp;</span><span class="bu">std::</span>free<span class="op">)&gt;{</span>abi<span class="op">::</span>__cxa_demangle<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>obj<span class="op">).</span>name<span class="op">(),</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">&amp;</span>status<span class="op">),</span></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>                                                                     <span class="op">&amp;</span><span class="bu">std::</span>free<span class="op">};</span></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> demangled <span class="op">?</span> demangled<span class="op">.</span>get<span class="op">()</span> <span class="op">:</span> <span class="st">&quot;unknown&quot;</span><span class="op">;</span></span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb63"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rtti_ut.cpp 213</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>   i<span class="op">{};</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>  s     <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;str&quot;</span><span class="op">};</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="va">s_ref</span> <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>  v     <span class="op">=</span> <span class="bu">std::</span>string_view<span class="op">{</span><span class="st">&quot;str&quot;</span><span class="op">};</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>type2str<span class="op">(</span>i<span class="op">),</span> <span class="st">&quot;int&quot;</span><span class="op">);</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>type2str<span class="op">(</span>s<span class="op">),</span> <span class="st">&quot;std::string&quot;</span><span class="op">);</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>type2str<span class="op">(</span><span class="va">s_ref</span><span class="op">),</span> <span class="st">&quot;std::string&quot;</span><span class="op">);</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>type2str<span class="op">(</span>v<span class="op">),</span> <span class="st">&quot;std::basic_string_view&lt;char, std::char_traits&lt;char&gt; &gt;&quot;</span><span class="op">);</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> Polymorphic_Base<span class="op">{};</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> d <span class="op">=</span> Polymorphic_Derived<span class="op">{};</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>    Polymorphic_Base<span class="op">&amp;</span> b_ref_d <span class="op">=</span> d<span class="op">;</span></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>    Polymorphic_Base<span class="op">&amp;</span> b_ref_b <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>type2str<span class="op">(</span>b_ref_d<span class="op">),</span> <span class="st">&quot;Polymorphic_Derived&quot;</span><span class="op">);</span>  <span class="co">// b_ref_dの実際の型はPolymorphic_Derived</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>type2str<span class="op">(</span>b_ref_b<span class="op">),</span> <span class="st">&quot;Polymorphic_Base&quot;</span><span class="op">);</span>     <span class="co">// b_ref_bの実際の型はPolymorphic_Base</span></span></code></pre></div>
<h3 id="run-time-type-information">Run-time Type Information
<a id="SS_19_4_10"></a></h3>
<p>「<a href="core_lang_spec.html#SS_19_4_9">RTTI</a>」を参照せよ。</p>
<h3 id="インターフェースクラス">インターフェースクラス
<a id="SS_19_4_11"></a></h3>
<p>インターフェースクラスとは、純粋仮想関数のみを持つ抽象クラスのことを指す。
インターフェースクラスは、クラスの実装を提供することなく、
クラスのインターフェースを定義するために使用される。
インターフェースクラスは、クラスの仕様を定義するために使用されるため、
多くの場合、抽象基底クラスとして使用される。</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/interface_class.cpp 8</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> InterfaceClass <span class="op">{</span>  <span class="co">// インターフェースクラス</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">void</span> DoSomething<span class="op">(</span><span class="dt">int32_t</span><span class="op">)</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">bool</span> IsXxx<span class="op">()</span> <span class="at">const</span>        <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="op">~</span>InterfaceClass<span class="op">()</span>         <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> NotInterfaceClass <span class="op">{</span>  <span class="co">// メンバ変数があるためインターフェースクラスではない</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>        NotInterfaceClass<span class="op">();</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">void</span> DoSomething<span class="op">(</span><span class="dt">int32_t</span><span class="op">)</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="dt">bool</span> IsXxx<span class="op">()</span> <span class="at">const</span>        <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="op">~</span>NotInterfaceClass<span class="op">()</span>      <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> <span class="va">num_</span><span class="op">;</span></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<h3 id="constインスタンス">constインスタンス
<a id="SS_19_4_12"></a></h3>
<p>constインスタンスは、ランタイムまたはコンパイル時に初期化され、
その後、状態が不変であるインスタンスである。
必ずしも以下に示すようにconstインスタンスがコンパイル時に値が定まっているわけではない。
<a
href="core_lang_spec.html#SS_19_5_6">constexprインスタンス</a>はconstインスタンスである。
C++03までのコンパイラに、
最適化の一環で<code>static const</code>インスタンスを<a
href="core_lang_spec.html#SS_19_5_6">constexprインスタンス</a>と扱うものもあった。</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/const_ut.cpp 12</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> str <span class="op">=</span> string<span class="op">{</span><span class="st">&quot;str&quot;</span><span class="op">};</span>  <span class="co">// strはプログラムがこの行を通過するときに初期化</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="at">const</span><span class="op">*</span> c_str <span class="op">=</span> str<span class="op">.</span>c_str<span class="op">();</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_const_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>c_str<span class="op">)&gt;);</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    c_str <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span>                                                  <span class="co">// c_strは変数としてconstではない</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_const_v<span class="op">&lt;</span><span class="dt">remove_reference_t</span><span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(*</span>c_str<span class="op">)&gt;&gt;);</span>  <span class="co">// *cは_strはconst</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="dt">char</span> <span class="at">const</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(*</span>c_str<span class="op">)&gt;);</span>          <span class="co">// *c_strはconstリファレンス</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="at">const</span><span class="op">*</span> <span class="at">const</span> cc_str <span class="op">=</span> c_str<span class="op">;</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_const_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>cc_str<span class="op">)&gt;);</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// cc_str = nullptr;  // cc_strは変数としてconstであるためコンパイルエラー</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_const_v<span class="op">&lt;</span><span class="dt">remove_reference_t</span><span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(*</span>cc_str<span class="op">)&gt;&gt;);</span>  <span class="co">// *cc_strはconst</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="dt">char</span> <span class="at">const</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(*</span>cc_str<span class="op">)&gt;);</span>          <span class="co">// *cc_strはconstリファレンス</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> c_int <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_const_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>c_int<span class="op">)&gt;);</span>  <span class="co">// c_intはcons</span></span></code></pre></div>
<h2 id="定数式とコンパイル時評価">定数式とコンパイル時評価
<a id="SS_19_5"></a></h2>
<h3 id="constexpr">constexpr <a id="SS_19_5_1"></a></h3>
<p>constexprはC++11で導入されたキーワードで、
関数や変数をコンパイル時に評価可能にする。
これにより、定数計算がコンパイル時に行われ、
実行時のパフォーマンスが向上し、コンパイル時にエラーを検出できることがある。</p>
<h3 id="constexpr定数">constexpr定数 <a id="SS_19_5_2"></a></h3>
<p>C++11以前で定数を定義する方法は、</p>
<ul>
<li>マクロ定数</li>
<li><a href="core_lang_spec.html#SS_19_3_1">enum</a></li>
<li>static
const(定数となるか否かは、コンパイラの実装依存に依存する)</li>
</ul>
<p>の方法があったが、それぞれの方法には下記のような問題がある。</p>
<ul>
<li>マクロにはスコープが無く、<code>#undef</code>できてしまう。</li>
<li>enumには整数の定義に限られる。</li>
<li>static constに関しては、コンパイラの実装依存に依存する。</li>
</ul>
<p>こういった問題を解決できるのがconstexpr定数である。constexpr定数とは下記のような定数を指す。</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 11</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">int</span> N<span class="op">&gt;</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Templ <span class="op">{</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="kw">auto</span> value <span class="op">=</span> N<span class="op">;</span>  <span class="co">// valueは定数</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb67"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 20</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>  <span class="co">// aは定数であるためかきのような使い方ができる</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>a <span class="op">==</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> b <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>  <span class="co">// bは定数でないため、下記のような使い方ができない</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// static_assert(b == 5);  // コンパイルエラー</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">double</span> PI<span class="op">{</span><span class="fl">3.14159265358979323846</span><span class="op">};</span>  <span class="co">// PIはconstexpr</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> templ <span class="op">=</span> Templ<span class="op">&lt;</span>a<span class="op">&gt;{};</span>  <span class="co">// aはconstexprなのでaの初期化が可能</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>templ<span class="op">.</span>value <span class="op">==</span> <span class="dv">5</span><span class="op">);</span></span></code></pre></div>
<p>constexpr定数がif文のオカレンスになる場合、<a
href="core_lang_spec.html#SS_19_11_12">constexpr if文</a>することで、 <a
href="core_lang_spec.html#SS_19_14_1">ill-formed</a>を使用した場合分けが可能になる。</p>
<h3 id="constexpr関数">constexpr関数 <a id="SS_19_5_3"></a></h3>
<p>関数に<code>constexpr</code>をつけて宣言することで定数を定義することができる。
constexpr関数の呼び出し式の値がコンパイル時に確定する場合、
その値はconstexpr定数となるため、関数呼び出しが発生しないため、実行効率が向上する。
一方で、constexpr関数の呼び出し式の値が、コンパイル時に確定しない場合、
通常の関数呼び出しと同じになる。</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 39</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">*</span> <span class="dv">3</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// aがconstexprならばf(a)もconstexpr</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> g<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">*</span> <span class="dv">3</span><span class="op">;</span> <span class="op">}</span>            <span class="co">// aがconstexprであってもg(a)は非constexpr</span></span></code></pre></div>
<div class="sourceCode" id="cb69"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 49</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> x <span class="op">=</span> <span class="dt">int</span><span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> a <span class="op">=</span> f<span class="op">(</span><span class="dv">3</span><span class="op">);</span>     <span class="co">// f(3)はconstexprなのでaの初期化が可能</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// constexpr auto b = f(x);  // xは非constexprなのでbの初期化はコンパイルエラー</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> c <span class="op">=</span> f<span class="op">(</span><span class="dv">3</span><span class="op">);</span>         <span class="co">// cはconstexpr定数と定義とすべき</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// constexpr auto d = g(3);  // g(3)は非constexprなのでdの初期化はコンパイルエラー</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> e <span class="op">=</span> g<span class="op">(</span>x<span class="op">);</span>         <span class="co">// eはここで初期化して、この後不変</span></span></code></pre></div>
<p>C++11の規約では、constexpr関数の制約は厳しく、
for/if文や条件分岐のような処理を含むことができなかったため、
下記のコード例で示した通り、条件演算子とリカーシブコールをうことが多かった。</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 64</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint64_t</span> bit_mask<span class="op">(</span><span class="dt">uint32_t</span> max<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> max <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> <span class="op">(</span><span class="dv">1</span><span class="bu">ULL</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>max <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">|</span> bit_mask<span class="op">(</span>max <span class="op">-</span> <span class="dv">1</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint64_t</span> bit_mask_0 <span class="op">=</span> bit_mask<span class="op">(</span><span class="dv">4</span><span class="op">);</span>  <span class="co">// C++11ではコンパイルエラー</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bn">0b1111</span> <span class="op">==</span> bit_mask_0<span class="op">);</span></span></code></pre></div>
<p>このため、可読性、保守性があったため、C++14で制約が緩和され、
さらにC++17では for/if文などの一般的な制御構文も使えるようになった。</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 70</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint64_t</span> bit_mask_for<span class="op">(</span><span class="dt">uint32_t</span> max<span class="op">)</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint64_t</span> ret <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">=</span> <span class="dv">0</span><span class="bu">u</span><span class="op">;</span> i <span class="op">&lt;</span> max<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>            ret <span class="op">|=</span> <span class="dv">1</span><span class="bu">ULL</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint64_t</span> bit_mask_1 <span class="op">=</span> bit_mask_for<span class="op">(</span><span class="dv">4</span><span class="op">);</span>  <span class="co">// C++17からサポート</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bn">0b1111</span> <span class="op">==</span> bit_mask_1<span class="op">);</span></span></code></pre></div>
<h3 id="コア定数式">コア定数式 <a id="SS_19_5_4"></a></h3>
<p>コア定数式(core constant
expression)とは以下の条件を満たす式である。</p>
<ol type="1">
<li>以下のいずれかに該当する式であること
<ul>
<li>リテラル</li>
<li>constexpr変数への参照</li>
<li>定数式で初期化された参照</li>
<li>constexprサブオブジェクトへの参照</li>
<li>constexpr関数呼び出し</li>
<li>sizeof演算子の適用結果</li>
<li>typeid演算子の適用結果(式の値が<a
href="core_lang_spec.html#SS_19_4_8">ポリモーフィックなクラス</a>である場合を除く)</li>
</ul></li>
<li>以下のすべてを満たすこと:
<ul>
<li>浮動小数点の比較演算を含まない</li>
<li>インクリメント/デクリメント演算を含まない</li>
<li>代入演算を含まない</li>
<li>動的メモリ割り当てを含まない</li>
<li>仮想関数の呼び出しを含まない</li>
<li>未定義動作を引き起こさない</li>
<li>エクセプションを投げない</li>
<li>アドレス取得演算子の使用が定数式の評価に限定される</li>
</ul></li>
<li>その式の評価において:
<ul>
<li>すべてのサブ式も定数式である</li>
<li>使用されるすべての変数は定数式で初期化されている</li>
<li>呼び出されるすべての関数はconstexpr関数である</li>
</ul></li>
</ol>
<p>このドキュメントでは慣用的に<a
href="core_lang_spec.html#SS_19_5_2">constexpr定数</a>と呼んでいる概念が、コア定数式である。</p>
<h3 id="リテラル型">リテラル型 <a id="SS_19_5_5"></a></h3>
<p>constexpr導入後のC++11の標準では、下記の条件を満たすクラスは、</p>
<ul>
<li>constexprコンストラクタを持つ</li>
<li>すべてのメンバ変数がリテラル型である</li>
<li>仮想関数や仮想基底クラスを持たない</li>
</ul>
<p>constexpr定数もしくはconstexprインスタンスをコンストラクタに渡すことにより、
<a
href="core_lang_spec.html#SS_19_5_6">constexprインスタンス</a>を生成できる。</p>
<p>このようなクラスは慣習的にリテラル型(literal type)と呼ばれる。</p>
<p>以下にリテラル型を例示する。</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 87</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Integer <span class="op">{</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> Integer<span class="op">(</span><span class="dt">int32_t</span> integer<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">integer_</span><span class="op">{</span>integer<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">operator</span> <span class="dt">int</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">integer_</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// constexprメンバ関数はconst</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="dt">int32_t</span> Allways2<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span>     <span class="co">// constexprメンバ関数はconst</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">int32_t</span> Allways3<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span> <span class="op">}</span>    <span class="co">// static関数のconstexpr化</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> <span class="va">integer_</span><span class="op">;</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb73"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 105</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> i5 <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>                <span class="co">// i5はconstexprインスタンス</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> int_5 <span class="op">=</span> Integer<span class="op">{</span>i5<span class="op">};</span>   <span class="co">// int_5はconstexprインスタンス</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>int_5 <span class="op">==</span> <span class="dv">5</span><span class="op">);</span>            <span class="co">// intへの暗黙の型変換</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> i3  <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>                         <span class="co">// i3はconstexpr定数ではない</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> int_3 <span class="op">=</span> Integer<span class="op">{</span>i3<span class="op">};</span>             <span class="co">// int_3はconstexprインスタンスではない</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// static_assert(int_3 == 5);         // int_3がconstexprではないため、コンパイルエラー</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>int_3<span class="op">.</span>Allways2<span class="op">()</span> <span class="op">==</span> <span class="dv">2</span><span class="op">);</span> <span class="co">// int_3はconstexprインスタンスではないが、</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>                                          <span class="co">// int_3.Allways2()はconstexprt定数</span></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>int_3<span class="op">.</span>Allways3<span class="op">()</span> <span class="op">==</span> <span class="dv">3</span><span class="op">);</span> <span class="co">// int_3はconstexprインスタンスではないが、</span></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>                                          <span class="co">// int_3.Allways3()はconstexprt定数</span></span></code></pre></div>
<h3 id="constexprインスタンス">constexprインスタンス
<a id="SS_19_5_6"></a></h3>
<p><a
href="core_lang_spec.html#SS_19_5_2">constexpr定数</a>を引数にして、<a
href="core_lang_spec.html#SS_19_5_5">リテラル型</a>のconstexprコンストラクタを呼び出せば、
constexprインスタンスを生成できる。このリテラル型を使用して下記のように<a
href="core_lang_spec.html#SS_19_2_6">ユーザー定義リテラル</a>
を定義することで、constexprインスタンスをより簡易に使用することができるようになる。</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 122</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> Integer <span class="kw">operator</span><span class="st">&quot;&quot;</span> _i<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> value<span class="op">)</span>  <span class="co">// ユーザ定義リテラルの定義</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Integer<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">&gt;(</span>value<span class="op">));</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb75"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 132</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> i <span class="op">=</span> <span class="dv">123</span><span class="op">_i;</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>i <span class="op">==</span> <span class="dv">123</span><span class="op">);</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>i<span class="op">),</span> Integer <span class="at">const</span><span class="op">&gt;);</span></span></code></pre></div>
<h3 id="consteval">consteval <a id="SS_19_5_7"></a></h3>
<p>constevalはC++20から導入されたキーワードであり、
呼び出しが必ずコンパイル時に評価されなければならない関数を定義するために使用される。
この関数は、コンパイル時に評価できない引数や式が与えられるとコンパイルエラーとなる。
constexpr関数が「コンパイル時に評価されることもできる」のに対し、
consteval関数は「必ずコンパイル時に評価されなければならない」という点で異なる。</p>
<p>この特性により、ランタイム評価を完全に排除した定数生成専用関数を記述でき、
パフォーマンスの最適化や定数検証（static_assertなど）に利用できる。
consteval関数の呼び出しは、その結果が定数式でなければコンパイルエラーとなる。</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 154</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">consteval</span> <span class="dt">uint64_t</span> bit_mask<span class="op">(</span><span class="dt">uint32_t</span> max<span class="op">)</span>  <span class="co">// コンパイル時、評価ができなければエラー</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else </span><span class="co">// C++17</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint64_t</span> bit_mask<span class="op">(</span><span class="dt">uint32_t</span> max<span class="op">)</span>  <span class="co">// コンパイル時、評価されるとは限らない</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>max <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">(</span><span class="dv">1</span><span class="bu">ULL</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>max <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">|</span> bit_mask<span class="op">(</span>max <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb77"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 176</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bn">0b1111&#39;1111</span> <span class="op">==</span> bit_mask<span class="op">(</span><span class="dv">8</span><span class="op">));</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// auto i = 8UL;         // bit_maskがconstevalであるため、コンパイルエラー</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> i <span class="op">=</span> <span class="dv">8</span><span class="bu">UL</span><span class="op">;</span>  <span class="co">// iがconstexprであるためbit_maskがコンパイル時評価されるため、</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> bm <span class="op">=</span> bit_mask<span class="op">(</span>i<span class="op">);</span>   <span class="co">// bit_mask(i)の呼び出しは効率的になる</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>                             <span class="co">// bmをconsexprにするとさらに効率的になる</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bn">0b1111&#39;1111</span><span class="op">,</span> bm<span class="op">);</span></span></code></pre></div>
<h3 id="constinit">constinit <a id="SS_19_5_8"></a></h3>
<p>constinitはC++20から導入されたキーワードであり、
静的記憶域期間（static、namespaceスコープ）またはthread_local変数が、
コンパイル時に初期化されることを保証するために使用される。
これにより、<a href="cpp_idioms.html#SS_21_9_11">Static Initialization
Order Fiasco(静的初期化順序問題)</a>を回避できる。</p>
<p>このキーワードを付与すると、初期化が動的である場合にはコンパイルエラーとなる。
ただし、constexprと異なり、変数自体がconstになるわけではないため、再代入は可能である。
また、constinitはローカル(自動変数)には意味を持たない。</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 192</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// constinit は静的・スレッドローカル変数の初期化が動的でないことを保証する。</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// この変数は const にはならず、後から変更可能である。</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constinit</span> <span class="dt">float</span> pi <span class="op">=</span> <span class="fl">3.14</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// C++17以前ではconstinitが存在しないため、constexprを使用する。</span></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ただしconstexprでは変数がconstになり、再代入はできない点が異なる。</span></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constinit</span> <span class="dt">uint32_t</span> mask <span class="op">=</span> bit_mask<span class="op">(</span><span class="dv">16</span><span class="op">);</span></span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// C++17</span></span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// C++17ではconstinitが存在しないため、constexprを代用する。</span></span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ただしconstexprでは変数がconstとなり、再代入はできない。</span></span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">float</span>    pi   <span class="op">=</span> <span class="fl">3.14</span><span class="bu">f</span><span class="op">;</span></span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint32_t</span> mask <span class="op">=</span> bit_mask<span class="op">(</span><span class="dv">16</span><span class="op">);</span></span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span></code></pre></div>
<h3 id="constexprラムダ">constexprラムダ <a id="SS_19_5_9"></a></h3>
<p>constexprラムダはC++17から導入された機能であり、以下の条件を満たした<a
href="core_lang_spec.html#SS_19_10_3">ラムダ式</a>である。</p>
<ul>
<li><p>引数やラムダ式内の処理がコンパイル時に評価可能である必要がある。
すべての処理はconstexpr関数のようにコンパイル時に確定する必要があり、
動的な処理やランタイムでしか決定できないものは含めることができない。</p></li>
<li><p>ラムダ内で使用される関数や式もconstexprでなければならない。
たとえば、関数の呼び出しや算術演算は、コンパイル時に評価可能なものであることが求められる。</p></li>
<li><p>ラムダキャプチャはconstexprに適合している必要がある。
キャプチャする変数もコンパイル時に確定できるものに限られる。
動的な変数をキャプチャすると、コンパイルエラーとなる。</p></li>
<li><p>エクセプション処理 (try/catch/throw) が禁止されている。
constexprラムダでは、エクセプション処理を含むことはできない。</p></li>
<li><p>動的メモリの割り当て(new/delete) が禁止されている。
これらの操作はコンパイル時には行えないため、constexprラムダでは使用できない。</p></li>
</ul>
<div class="sourceCode" id="cb79"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 217</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> factorial <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span>  <span class="co">// constexpr ラムダの定義</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>            result <span class="op">*=</span> i<span class="op">;</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> fact_5 <span class="op">=</span> factorial<span class="op">(</span><span class="dv">5</span><span class="op">);</span>  <span class="co">// コンパイル時に計算される</span></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>fact_5 <span class="op">==</span> <span class="dv">120</span><span class="op">);</span></span></code></pre></div>
<div class="sourceCode" id="cb80"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_ut.cpp 234</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> factorial <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span> self<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span>  <span class="co">// リカーシブconstexprラムダ</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> n <span class="op">*</span> self<span class="op">(</span>self<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> fact_5 <span class="op">=</span> factorial<span class="op">(</span>factorial<span class="op">,</span> <span class="dv">5</span><span class="op">);</span>  <span class="co">// コンパイル時の評価</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>fact_5 <span class="op">==</span> <span class="dv">120</span><span class="op">);</span></span></code></pre></div>
<h2 id="オブジェクト生成と初期化">オブジェクト生成と初期化
<a id="SS_19_6"></a></h2>
<h3 id="特殊メンバ関数">特殊メンバ関数 <a id="SS_19_6_1"></a></h3>
<p>特殊メンバ関数とは下記の関数を指す。</p>
<ul>
<li>デフォルトコンストラクタ</li>
<li>copyコンストラクタ</li>
<li>copy代入演算子</li>
<li>moveコンストラクタ</li>
<li>move代入演算子</li>
<li>デストラクタ</li>
</ul>
<p>以下のメンバ関数は特殊関数ではないが、C++20から特殊関数と同様に<code>=default</code>とすることで自動生成される。</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_6_3">==演算子</a><br />
クラス内のすべてのメンバが==をサポートしている場合、<code>= default</code>とすることで自動生成される。</li>
<li><a href="core_lang_spec.html#SS_19_6_4_1">&lt;=&gt;演算子</a><br />
すべてのメンバが<a
href="core_lang_spec.html#SS_19_6_4_1">&lt;=&gt;演算子</a>での比較可能である場合、<code>= default</code>とすることで自動生成される。</li>
</ul>
<p>ユーザがこれらを一切定義しない場合、または一部のみを定義する場合、
コンパイラは、下記のテーブル等で示すルールに従い、特殊関数メンバの宣言、定義の状態を定める。</p>
<p>左1列目がユーザによる各関数の宣言を表し、2列目以降はユーザ宣言の影響による各関数の宣言の状態を表す。<br />
下記表において、</p>
<ul>
<li>「<code>= default</code>」とは、「コンパイラによってその関数が<code>= default</code>と宣言された」状態であることを表す。</li>
<li>「<del>=
default</del>」とは、<code>= default</code>と同じであるが、バグが発生しやすいので推奨されない。</li>
<li>「宣言無し」とは、「コンパイラによってその関数が<code>= default</code>と宣言された状態ではない」ことを表す。
<ul>
<li>「moveコンストラクタが<code>= default</code>と宣言された状態ではない」且つ
「copyコンストラクタが宣言されている」場合、
rvalueを使用したオブジェクトの初期化には、
moveコンストラクタの代わりにcopyコンストラクタが使われる。</li>
<li>「move代入演算子が<code>= default</code>と宣言された状態ではない」且つ
「copy代入演算子が宣言されている」場合、
rvalueを使用したオブジェクトの代入には、
move代入演算子の代わりにcopy代入演算子が使われる。</li>
</ul></li>
<li>「= delete」とは「コンパイラによってその関数が=
deleteと宣言された」状態であることを表す。</li>
</ul>
<table style="width:100%;">
<colgroup>
<col style="width: 15%" />
<col style="width: 11%" />
<col style="width: 8%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">user-defined</th>
<th style="text-align: center;">default ctor</th>
<th style="text-align: center;">dtor</th>
<th style="text-align: center;">copy ctor</th>
<th style="text-align: center;">copy assign</th>
<th style="text-align: center;">move ctor</th>
<th style="text-align: center;">move assign</th>
<th style="text-align: center;"><code>==</code></th>
<th style="text-align: center;"><code>&lt;=&gt;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">undeclared</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">undeclared</td>
<td style="text-align: center;">undeclared</td>
</tr>
<tr class="even">
<td style="text-align: center;">non-default ctor</td>
<td style="text-align: center;">undeclared</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">undeclared</td>
<td style="text-align: center;">undeclared</td>
</tr>
<tr class="odd">
<td style="text-align: center;">default ctor</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">undeclared</td>
<td style="text-align: center;">undeclared</td>
</tr>
<tr class="even">
<td style="text-align: center;">dtor</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;"><del>= default</del></td>
<td style="text-align: center;"><del>= default</del></td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">undeclared</td>
<td style="text-align: center;">undeclared</td>
</tr>
<tr class="odd">
<td style="text-align: center;">copy ctor</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;"><del>= default</del></td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">undeclared</td>
<td style="text-align: center;">undeclared</td>
</tr>
<tr class="even">
<td style="text-align: center;">copy assign</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;"><del>= default</del></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">undeclared</td>
<td style="text-align: center;">undeclared</td>
</tr>
<tr class="odd">
<td style="text-align: center;">move ctor</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= delete</td>
<td style="text-align: center;">= delete</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">undeclared</td>
<td style="text-align: center;">undeclared</td>
</tr>
<tr class="even">
<td style="text-align: center;">move assign</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">= delete</td>
<td style="text-align: center;">= delete</td>
<td style="text-align: center;">= default</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">undeclared</td>
<td style="text-align: center;">undeclared</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>==</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">undeclared</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&lt;=&gt;</code></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">undeclared</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p><strong>テーブル注</strong></p>
<ul>
<li>C++14以前と、C++17以降での仕様の差は以下のようになる。
<ul>
<li>C++14以前では、コピーコンストラクタやコピー代入演算子をユーザ定義すると、
ムーブコンストラクタ／ムーブ代入演算子は自動生成されず<code>= delete</code>となる。</li>
<li>C++17以降では、コピー系をユーザ定義していても、ムーブ系は自動生成される(<code>= default</code>と同等になる)ことがある。
コンパイラは「コピー系の存在」だけではムーブ系を削除しない。
ただし、ムーブ不可能なメンバや基底がある場合は、結果的に<code>= delete</code>になる。</li>
<li>C++17以降では、<code>= default</code>された特殊メンバ関数は明示的に<code>noexcept</code>推定され、ムーブセマンティクスの活用がしやすくなる。</li>
<li>C++20以降では、比較演算子(<code>==, &lt;=&gt;</code>)も<code>= default</code>によって自動生成可能だが、特殊メンバ関数とは分類が異なるが、
上記テーブルでは同じように扱う。</li>
</ul></li>
<li>ctor: コンストラクタを指す。</li>
<li>dtor: デストラクタを指す。</li>
<li>assign: 代入演算子（assignment）を指す。</li>
<li>user-defined: この列の関数がユーザによって定義されていることを指す。
従って、non-default
ctorは、デフォルトコンストラクタでないコンストラクタが定義されている行を指す。</li>
<li>undeclared:
特定の特殊メンバ関数がユーザによって宣言されていないことを指し、
コンパイラによる自動生成もされていないことを指す。</li>
<li>「<del>=
default</del>」とは、<code>= default</code>と同様に自動生成されるが、
場合によっては不適切な挙動を引き起こす可能性があるため、推奨されない。</li>
</ul>
<p>上記表より、下記のようなことがわかる。</p>
<ul>
<li>ユーザが上記6メンバ関数を一切宣言しない場合、それらはコンパイラにより暗黙に宣言、定義される。</li>
<li>ユーザがcopyコンストラクタを宣言した場合、デフォルトコンストラクタは暗黙に宣言、定義されない。</li>
<li>moveコンストラクタ、move代入演算子は、
以下のいずれもが明示的に宣言されていない場合にのみ暗黙に宣言、定義される。
<ul>
<li>copyコンストラクタ</li>
<li>copy代入演算子(operator =)</li>
<li>moveコンストラクタ</li>
<li>move代入演算子</li>
<li>デストラクタ</li>
</ul></li>
<li>ユーザがmoveコンストラクタまたはmove代入演算子を宣言した場合、
copyコンストラクタ、copy代入演算子は<code>= delete</code>される。</li>
</ul>
<p>これらの特殊メンバ関数に対しての設計のガイドラインには、以下のようなものがある。</p>
<ul>
<li><a href="cpp_idioms.html#SS_21_5_1">ゼロの原則(Rule of Zero)</a></li>
<li><a href="cpp_idioms.html#SS_21_5_2">五の原則(Rule of Five)</a></li>
</ul>
<p>この2つの原則(ガイドライン)の使い分けに関しては、</p>
<ul>
<li>リソース管理を外部(<a href="design_pattern.html#SS_9_10">RAII(scoped
guard)</a>クラス)に任せられる場合:
ゼロの法則を採用し、特殊メンバ関数を明示的に定義しない。</li>
<li>リソースをクラス内で直接管理する場合:
五の法則を採用し、すべての特殊メンバ関数を適切に定義する。</li>
</ul>
<p>とすることで安全で保守性性の高いコードを設計できる。</p>
<h4 id="初期化子リストコンストラクタ">初期化子リストコンストラクタ
<a id="SS_19_6_1_1"></a></h4>
<p>初期化子リストコンストラクタ(<a
href="core_lang_spec.html#SS_19_6_5">リスト初期化</a>用のコンストラクタ)とは、
{}による<a
href="core_lang_spec.html#SS_19_6_5">リスト初期化</a>をサポートするためのコンストラクタである。
下記コードでは、
E::E(std::initializer_list&lt;uint32_t&gt;)が初期化子リストコンストラクタである。</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constructor_ut.cpp 6</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> E <span class="op">{</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>        E<span class="op">()</span> <span class="op">:</span> <span class="va">str_</span><span class="op">{</span><span class="st">&quot;default constructor&quot;</span><span class="op">}</span> <span class="op">{}</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 初期化子リストコンストラクタ</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> E<span class="op">(</span><span class="bu">std::</span>initializer_list<span class="op">&lt;</span><span class="dt">uint32_t</span><span class="op">&gt;)</span> <span class="op">:</span> <span class="va">str_</span><span class="op">{</span><span class="st">&quot;initializer list constructor&quot;</span><span class="op">}</span> <span class="op">{}</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> E<span class="op">(</span><span class="dt">uint32_t</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">)</span> <span class="op">:</span> <span class="va">str_</span><span class="op">{</span><span class="st">&quot;uint32_t uint32_t constructor&quot;</span><span class="op">}</span> <span class="op">{}</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> GetString<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">str_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="at">const</span> <span class="va">str_</span><span class="op">;</span></span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>    TEST<span class="op">(</span>Constructor<span class="op">,</span> initializer_list_constructor<span class="op">)</span></span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a>        E <span class="at">const</span> e0<span class="op">;</span></span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;default constructor&quot;</span><span class="op">,</span> e0<span class="op">.</span>GetString<span class="op">());</span></span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>        E <span class="at">const</span> e1<span class="op">{};</span></span>
<span id="cb81-24"><a href="#cb81-24" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;default constructor&quot;</span><span class="op">,</span> e1<span class="op">.</span>GetString<span class="op">());</span></span>
<span id="cb81-25"><a href="#cb81-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-26"><a href="#cb81-26" aria-hidden="true" tabindex="-1"></a>        E <span class="at">const</span> e2<span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span>  <span class="co">// E::E(uint32_t, uint32_t)の呼び出しと区別が困難</span></span>
<span id="cb81-27"><a href="#cb81-27" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;initializer list constructor&quot;</span><span class="op">,</span> e2<span class="op">.</span>GetString<span class="op">());</span></span>
<span id="cb81-28"><a href="#cb81-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-29"><a href="#cb81-29" aria-hidden="true" tabindex="-1"></a>        E <span class="at">const</span> e3<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span>  <span class="co">// E::E(std::initializer_list&lt;uint32_t&gt;)の呼び出しと区別が困難</span></span>
<span id="cb81-30"><a href="#cb81-30" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;uint32_t uint32_t constructor&quot;</span><span class="op">,</span> e3<span class="op">.</span>GetString<span class="op">());</span></span>
<span id="cb81-31"><a href="#cb81-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>デフォルトコンストラクタと初期化子リストコンストラクタが、
それぞれに定義されているクラスの初期化時に空の初期化子リストが渡された場合、
デフォルトコンストラクタが呼び出される。</p>
<p>初期化子リストコンストラクタと、
「その初期化子リストの要素型と同じ型の仮引数のみを受け取るコンストラクタ
(上記コードのE::E(uint32_t, uint32_t))」
の両方を持つクラスの初期化時にどちらでも呼び出せる初期化子リストが渡された場合({}を使った呼び出し)、
初期化子コンストラクタが呼び出される。</p>
<h4 id="継承コンストラクタ">継承コンストラクタ
<a id="SS_19_6_1_2"></a></h4>
<p>継承コンストラクタとは、基底クラスで定義したコンストラクタ群を、
派生クラスのインターフェースとしても使用できるようにするための機能である。
下記コードのように、継承コンストラクタは派生クラス内でusingを用いて宣言される。</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constructor_ut.cpp 40</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Base <span class="op">{</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> Base<span class="op">(</span><span class="dt">int32_t</span> b<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">b_</span><span class="op">{</span>b<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">virtual</span> <span class="op">~</span>Base<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Derived <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> Base<span class="op">::</span>Base<span class="op">;</span>  <span class="co">// 継承コンストラクタ</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if 0</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a><span class="co">        Derived(int32_t b) : Base{b} {}  // オールドスタイル</span></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a><span class="co">    </span><span class="pp">#endif</span></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>        Derived d<span class="op">{</span><span class="dv">1</span><span class="op">};</span>  <span class="co">// Derived::Derived(int32_t)が使える</span></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="委譲コンストラクタ">委譲コンストラクタ
<a id="SS_19_6_1_3"></a></h4>
<p>委譲コンストラクタとは、コンストラクタから同じクラスの他のコンストラクタに処理を委譲する機能である。
以下のコード中では、委譲コンストラクタを使い、
A::A(uint32_t)の処理をA::A(std::string const&amp;)へ委譲している。</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constructor_ut.cpp 72</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> A<span class="op">(</span><span class="bu">std::</span>string str<span class="op">)</span> <span class="op">:</span> <span class="va">str_</span><span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>str<span class="op">)}</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// ...</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> A<span class="op">(</span><span class="dt">uint32_t</span> num<span class="op">)</span> <span class="op">:</span> A<span class="op">{</span><span class="bu">std::</span>to_string<span class="op">(</span>num<span class="op">)}</span>  <span class="co">// 委譲コンストラクタ</span></span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="va">str_</span><span class="op">;</span></span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<h3 id="explicit-コンストラクタと型変換制御">explicit
コンストラクタと型変換制御 <a id="SS_19_6_2"></a></h3>
<h4 id="explicit">explicit <a id="SS_19_6_2_1"></a></h4>
<p>explicitは、コンストラクタに対して付与することで、
コンストラクタによる暗黙の型変換を禁止するためのキーワードである。
暗黙の型変換とは、ある型の値を別の型の値に自動的に変換する言語機能を指す。
explicitキーワードを付けることで、意図しない型変換を防ぎ、コードの堅牢性を高めることがでできる。</p>
<p>この節で説明するexplicitの機能は下記のような項目に渡って説明を行う。</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_6_2_2">暗黙の型変換</a></li>
<li><a href="core_lang_spec.html#SS_19_6_2_3">暗黙の型変換抑止</a></li>
<li><a href="core_lang_spec.html#SS_19_6_2_4">explicit(COND)</a></li>
<li><a href="core_lang_spec.html#SS_19_6_2_5">explicit type
operator()</a></li>
</ul>
<h4 id="暗黙の型変換">暗黙の型変換 <a id="SS_19_6_2_2"></a></h4>
<p>この節で扱う暗黙の型変換とは、
以下に示したような「非explicitなコンストラクタを持つクラス」による暗黙の型変換を指し、
<a href="core_lang_spec.html#SS_19_1_7">汎整数型昇格</a>や<a
href="core_lang_spec.html#SS_19_1_6">算術変換</a>等を指さない。</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/implicit_conversion_ut.cpp 8</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Person <span class="op">{</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>        Person<span class="op">(</span><span class="dt">char</span> <span class="at">const</span><span class="op">*</span> name<span class="op">,</span> <span class="dt">uint32_t</span> age <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">:</span> <span class="va">name_</span><span class="op">{</span>name<span class="op">},</span> <span class="va">age_</span><span class="op">{</span>age<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>        Person<span class="op">(</span>Person <span class="at">const</span><span class="op">&amp;)</span>            <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>        Person<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Person <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> GetName<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">name_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span>           GetAge<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">age_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="va">name_</span><span class="op">;</span>  <span class="co">// コピーをするため非const</span></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span>    <span class="va">age_</span><span class="op">;</span></span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &lt;= 201703L  </span><span class="co">// c++17</span></span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Person <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Person <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>tuple<span class="op">(</span>lhs<span class="op">.</span>GetName<span class="op">(),</span> lhs<span class="op">.</span>GetAge<span class="op">())</span> <span class="op">==</span> <span class="bu">std::</span>tuple<span class="op">(</span>rhs<span class="op">.</span>GetName<span class="op">(),</span> rhs<span class="op">.</span>GetAge<span class="op">());</span></span>
<span id="cb84-21"><a href="#cb84-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb84-22"><a href="#cb84-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-23"><a href="#cb84-23" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++20</span></span>
<span id="cb84-24"><a href="#cb84-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>Person <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Person <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb84-25"><a href="#cb84-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb84-26"><a href="#cb84-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>tuple<span class="op">(</span>lhs<span class="op">.</span>GetName<span class="op">(),</span> lhs<span class="op">.</span>GetAge<span class="op">())</span> <span class="op">&lt;=&gt;</span> <span class="bu">std::</span>tuple<span class="op">(</span>rhs<span class="op">.</span>GetName<span class="op">(),</span> rhs<span class="op">.</span>GetAge<span class="op">());</span></span>
<span id="cb84-27"><a href="#cb84-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb84-28"><a href="#cb84-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-29"><a href="#cb84-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// &lt;=&gt;から自動的に==が生成されないため、明示的に定義する必要がある</span></span>
<span id="cb84-30"><a href="#cb84-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Person <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Person <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>lhs <span class="op">&lt;=&gt;</span> rhs<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb84-31"><a href="#cb84-31" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span></code></pre></div>
<p>上記のクラスPersonを使用して、下記のようなコードをコンパイルできるようにする機能である。</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/implicit_conversion_ut.cpp 40</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span>Person <span class="at">const</span><span class="op">&amp;</span> person<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> using_implicit_coversion<span class="op">()</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>        f<span class="op">(</span><span class="st">&quot;Ohtani&quot;</span><span class="op">);</span>  <span class="co">// &quot;Ohtani&quot;はPerson型ではないが、コンパイル可能</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>この記法は下記コードの短縮形であり、コードの見た目をシンプルに保つ効果がある。</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/implicit_conversion_ut.cpp 54</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> not_using_implicit_coversion<span class="op">()</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>        f<span class="op">(</span>Person<span class="op">{</span><span class="st">&quot;Ohtani&quot;</span><span class="op">});</span>  <span class="co">// 本来は、fの引数はPerson型</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>この記法は下記のようにstd::string等のSTLでも多用され、その効果は十分に発揮されているものの、</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/implicit_conversion_ut.cpp 66</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> otani <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;Ohtani&quot;</span><span class="op">};</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>otani <span class="op">==</span> <span class="st">&quot;Ohtani&quot;</span><span class="op">)</span> <span class="op">{</span>  <span class="co">// 暗黙の型変換によりコンパイルできる</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>以下のようなコードがコンパイルできてしまうため、わかりづらいバグの元にもなる。</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/implicit_conversion_ut.cpp 80</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> otani <span class="op">=</span> Person<span class="op">{</span><span class="st">&quot;Ohtani&quot;</span><span class="op">,</span> <span class="dv">26</span><span class="op">};</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>otani <span class="op">==</span> <span class="st">&quot;Otani&quot;</span><span class="op">)</span> <span class="op">{</span>  <span class="co">// このコードがコンパイルされる。</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>otani <span class="op">==</span> Person<span class="op">{</span><span class="st">&quot;Otani&quot;</span><span class="op">})</span> <span class="op">{</span>  <span class="co">// 暗黙の型変換を使わない記法</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>下記のようにコンストラクタにexplicitを付けて宣言することにより、この問題を防ぐことができる。</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/implicit_conversion_ut.cpp 112</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Person <span class="op">{</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> Person<span class="op">(</span><span class="dt">char</span> <span class="at">const</span><span class="op">*</span> name<span class="op">,</span> <span class="dt">uint32_t</span> age <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">:</span> <span class="va">name_</span><span class="op">{</span>name<span class="op">},</span> <span class="va">age_</span><span class="op">{</span>age<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>        Person<span class="op">(</span>Person <span class="at">const</span><span class="op">&amp;)</span>            <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>        Person<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Person <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> prohibit_implicit_coversion<span class="op">()</span></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if 0  </span><span class="co">// explicit付きのコンストラクタを持つPersonと違い、コンパイルできない。</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a><span class="co">        f(&quot;Ohtani&quot;);</span></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a><span class="co">    </span><span class="pp">#else</span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>        f<span class="op">(</span>Person<span class="op">{</span><span class="st">&quot;Ohtani&quot;</span><span class="op">});</span></span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> otani <span class="op">=</span> Person<span class="op">{</span><span class="st">&quot;Ohtani&quot;</span><span class="op">,</span> <span class="dv">26</span><span class="op">};</span></span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if 0</span></span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a><span class="co">        if (otani == &quot;Otani&quot;) {  // このコードもコンパイルできない。</span></span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a><span class="co">            // ...</span></span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a><span class="co">        }</span></span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a><span class="co">    </span><span class="pp">#else</span></span>
<span id="cb89-29"><a href="#cb89-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>otani <span class="op">==</span> Person<span class="op">{</span><span class="st">&quot;Otani&quot;</span><span class="op">,</span> <span class="dv">26</span><span class="op">})</span> <span class="op">{</span>  <span class="co">// この記述を強制できる。</span></span>
<span id="cb89-30"><a href="#cb89-30" aria-hidden="true" tabindex="-1"></a>            <span class="co">// ...</span></span>
<span id="cb89-31"><a href="#cb89-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb89-32"><a href="#cb89-32" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb89-33"><a href="#cb89-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>std::stringは暗黙の型変換を許して良く、(多くの場合)Personには暗黙の型変換をしない方が良い理由は、</p>
<ul>
<li>std::stringの役割は文字列の管理と演算のみであるため、
std::stringを文字列リテラルと等価なもののように扱っても違和感がない</li>
<li>Personは、明らかに文字列リテラルと等価なものではない</li>
</ul>
<p>といった<a
href="cpp_idioms.html#SS_21_11_1">セマンティクス</a>的観点によるものである。</p>
<p>クラスPersonと同様に、
ほとんどのユーザ定義クラスには非explicitなコンストラクタによる暗黙の型変換は必要ない。</p>
<h4 id="暗黙の型変換抑止">暗黙の型変換抑止 <a id="SS_19_6_2_3"></a></h4>
<p>explicit宣言されていないコンストラクタを持つクラスは、
下記のコードのように<a
href="core_lang_spec.html#SS_19_6_2_2">暗黙の型変換</a>が起こる。</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 10</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>        A<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="op">:</span> x<span class="op">{</span>a<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>    A f<span class="op">(</span>A a<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a<span class="op">;</span> <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb91"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 21</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>    A a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// A::Aがexplicitでないため、iはA{1}に変換される</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>a<span class="op">.</span>x<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> f<span class="op">(</span><span class="dv">2</span><span class="op">);</span>  <span class="co">// A::Aがexplicitでないため、2はA{2}に変換される</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>b<span class="op">.</span>x<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span></code></pre></div>
<p>暗黙の型変換はわかりづらいバグを生み出してしまうことがあるため、
下記のように適切にexplicitを使うことで、このような変換を抑止することができる。</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 34</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> A<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="op">:</span> x<span class="op">{</span>a<span class="op">}</span> <span class="op">{}</span>  <span class="co">// 暗黙の型変換の抑止</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>    A f<span class="op">(</span>A a<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a<span class="op">;</span> <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb93"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 45</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A a = 1;    // A::Aがexplicitであるため、コンパイルエラー</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// auto b = f(2);  // A::Aがexplicitであるため、コンパイルエラー</span></span></code></pre></div>
<p>C++03までは、<a
href="core_lang_spec.html#SS_19_6_6">一様初期化</a>がサポートされていなかったため、
explicitは単一引数のコンストラクタに使用されることが一般的であった。</p>
<p>C++11からサポートされた<a
href="core_lang_spec.html#SS_19_6_6">一様初期化</a>を下記のように使用することで、
暗黙の型変換を使用できる。</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 56</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>        A<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">:</span> x<span class="op">{</span>a<span class="op">},</span> y<span class="op">{</span>b<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>    A    f<span class="op">(</span>A a<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a<span class="op">;</span> <span class="op">};</span></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>A lhs<span class="op">,</span> A rhs<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>tuple<span class="op">(</span>lhs<span class="op">.</span>x<span class="op">,</span> lhs<span class="op">.</span>x<span class="op">)</span> <span class="op">==</span> <span class="bu">std::</span>tuple<span class="op">(</span>rhs<span class="op">.</span>x<span class="op">,</span> rhs<span class="op">.</span>x<span class="op">);</span> <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb95"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 70</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>    A a <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span>  <span class="co">// A::Aがexplicitでないため、iはA{1, 2}に変換される</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>a<span class="op">,</span> <span class="op">(</span>A<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">}));</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> f<span class="op">({</span><span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">});</span>  <span class="co">// A::Aがexplicitでないため、2はA{2,1}に変換される</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>b<span class="op">,</span> <span class="op">(</span>A<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">}));</span></span></code></pre></div>
<p>以下に示す通り、コンストラクタの引数の数によらず、
C++11からは暗黙の型変換を抑止したい型のコンストラクタにはexplicit宣言することが一般的となっている。</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 82</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> A<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">:</span> x<span class="op">{</span>a<span class="op">},</span> y<span class="op">{</span>b<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>    A    f<span class="op">(</span>A a<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a<span class="op">;</span> <span class="op">};</span></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>A lhs<span class="op">,</span> A rhs<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>tuple<span class="op">(</span>lhs<span class="op">.</span>x<span class="op">,</span> lhs<span class="op">.</span>x<span class="op">)</span> <span class="op">==</span> <span class="bu">std::</span>tuple<span class="op">(</span>rhs<span class="op">.</span>x<span class="op">,</span> rhs<span class="op">.</span>x<span class="op">);</span> <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb97"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 96</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A a = {1, 2};  // A::Aがexplicitであるため、コンパイルエラー</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// auto b = f({2, 1});  // A::Aがexplicitであるため、コンパイルエラー</span></span></code></pre></div>
<h4 id="explicitcond">explicit(COND) <a id="SS_19_6_2_4"></a></h4>
<p>C++20から導入されたexplicit(COND)は、
コンストラクタや変換演算子に対して、
特定の条件下で暗黙の型変換を許可または禁止する機能である。
CONDには、型特性や定数式などの任意のconstexprな条件式を指定できる。
以下にこのシンタックスの単純な使用例を示す。</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 162</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">// Tが整数型の場合、暗黙の型変換を許可</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span><span class="op">(!</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;)</span> S<span class="op">(</span>T x<span class="op">)</span> <span class="op">:</span> value<span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// T が整数型でない場合に有効なコンストラクタ</span></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;!</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>U<span class="op">&gt;&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">&gt;</span></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> S<span class="op">(</span>U x<span class="op">)</span> <span class="op">:</span> value<span class="op">{</span>x<span class="op">}</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// T が整数型の場合に有効な非explicitコンストラクタ</span></span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// T が整数型の場合に有効な非explicitコンストラクタ</span></span>
<span id="cb98-15"><a href="#cb98-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>U<span class="op">&gt;&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">&gt;</span></span>
<span id="cb98-16"><a href="#cb98-16" aria-hidden="true" tabindex="-1"></a>        S<span class="op">(</span>U x<span class="op">)</span> <span class="op">:</span> value<span class="op">{</span>x<span class="op">}</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb98-17"><a href="#cb98-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb98-18"><a href="#cb98-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-19"><a href="#cb98-19" aria-hidden="true" tabindex="-1"></a>        T value<span class="op">;</span></span>
<span id="cb98-20"><a href="#cb98-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb98-21"><a href="#cb98-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-22"><a href="#cb98-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">// 推論ガイド</span></span>
<span id="cb98-23"><a href="#cb98-23" aria-hidden="true" tabindex="-1"></a>    S<span class="op">(</span>T<span class="op">)-&gt;</span>S<span class="op">&lt;</span>T<span class="op">&gt;;</span></span></code></pre></div>
<div class="sourceCode" id="cb99"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 190</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    S s <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>      <span class="co">// Tがintであるため、explicit宣言されていないため、暗黙の型変換は許可</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// S t = 1.0; // Tが整数型でないため暗黙の型変換は禁止であるため、コンパイルエラー</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>    S t<span class="op">{</span><span class="fl">1.0</span><span class="op">};</span>     <span class="co">// Tが整数型でないが、明示的な初期化は問題ない</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>s<span class="op">.</span>value<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>テンプレートのパラメータの型による暗黙の型変換の可否をコントロールする例を以下に示す。</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 203</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Optional <span class="op">{</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> <span class="bu">std::</span>nullptr_t<span class="op">&gt;)</span> Optional<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> value<span class="op">)</span></span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> <span class="va">has_value_</span><span class="op">(!</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> <span class="bu">std::</span>nullptr_t<span class="op">&gt;),</span> <span class="va">value_</span><span class="op">(</span>value<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Tがnullptr_tではない場合に有効なコンストラクタ</span></span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;!</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>U<span class="op">,</span> <span class="bu">std::</span>nullptr_t<span class="op">&gt;&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">&gt;</span></span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a>        Optional<span class="op">(</span><span class="at">const</span> U<span class="op">&amp;</span> value<span class="op">)</span> <span class="op">:</span> <span class="va">has_value_</span><span class="op">(</span><span class="kw">true</span><span class="op">),</span> <span class="va">value_</span><span class="op">(</span>value<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Tがnullptr_tの場合に有効なexplicitコンストラクタ</span></span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>U<span class="op">,</span> <span class="bu">std::</span>nullptr_t<span class="op">&gt;&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">&gt;</span></span>
<span id="cb100-16"><a href="#cb100-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> Optional<span class="op">(</span><span class="at">const</span> U<span class="op">&amp;</span> value<span class="op">)</span> <span class="op">:</span> <span class="va">has_value_</span><span class="op">(</span><span class="kw">false</span><span class="op">),</span> <span class="va">value_</span><span class="op">(</span>value<span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb100-17"><a href="#cb100-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb100-18"><a href="#cb100-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-19"><a href="#cb100-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">has_value_</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// bool型への変換</span></span>
<span id="cb100-20"><a href="#cb100-20" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">operator</span> T<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">value_</span><span class="op">;</span> <span class="op">}</span>         <span class="co">// T型への変換</span></span>
<span id="cb100-21"><a href="#cb100-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-22"><a href="#cb100-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb100-23"><a href="#cb100-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="va">has_value_</span><span class="op">;</span></span>
<span id="cb100-24"><a href="#cb100-24" aria-hidden="true" tabindex="-1"></a>        T    <span class="va">value_</span><span class="op">;</span></span>
<span id="cb100-25"><a href="#cb100-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb100-26"><a href="#cb100-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">// 推論ガイド</span></span>
<span id="cb100-27"><a href="#cb100-27" aria-hidden="true" tabindex="-1"></a>    Optional<span class="op">(</span>T<span class="op">)-&gt;</span>Optional<span class="op">&lt;</span>T<span class="op">&gt;;</span></span></code></pre></div>
<div class="sourceCode" id="cb101"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 235</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>    Optional a <span class="op">=</span> <span class="dv">2</span><span class="op">;</span>   <span class="co">// T == intであるため、暗黙の型変換を許可</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>a<span class="op">);</span>   <span class="co">// has_value_がtrueであるため</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>a<span class="op">,</span> <span class="dv">2</span><span class="op">);</span>  <span class="co">// T型への暗黙的変換をチェック</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Optional n = nullptr; // T == std::nullptr_tのため暗黙の型変換抑止により、コンパイルエラー</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>    Optional n<span class="op">{</span><span class="kw">nullptr</span><span class="op">};</span>  <span class="co">// 通常の初期化</span></span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>n<span class="op">);</span></span></code></pre></div>
<p>こういった工夫により、コードの過度な柔軟性を適度に保つことができ、
可読性の向上につながる。</p>
<h4 id="explicit-type-operator">explicit type operator()
<a id="SS_19_6_2_5"></a></h4>
<p>型変換演算子のオーバーロードの戻り値をさらに別の型に変換すると、
きわめてわかりづらいバグを生み出してしまうことがあるため、
この機能を使用すると型変換演算子のオーバーロードの型変換の抑止することができる。</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 110</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> A<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="op">:</span> x<span class="op">{</span>a<span class="op">}</span> <span class="op">{}</span>  <span class="co">// 暗黙の型変換の抑止</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">;</span> <span class="op">}</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb103"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 123</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> A<span class="op">{</span><span class="dv">2</span><span class="op">};</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> a<span class="op">);</span>  <span class="co">// aをboolに変換するとtrue、trueをintに変換すると1</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b <span class="op">=</span> a <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// aをboolに変換するとtrue、trueをintに変換すると1であるため、bは2</span></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>b<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span></code></pre></div>
<p>以下に示すようにexplicitを使うことで、このような暗黙の型変換を抑止できる。</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 137</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> A<span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="op">:</span> x<span class="op">{</span>a<span class="op">}</span> <span class="op">{}</span>  <span class="co">// 暗黙の型変換の抑止</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">;</span> <span class="op">}</span><span class="co">// 暗黙の型変換の抑止</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb105"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/explicit_ut.cpp 150</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> A<span class="op">{</span><span class="dv">2</span><span class="op">};</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_EQ(1, a);  // operator boolがexplicitであるため、コンパイルエラー</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// int b = a + 1;  // operator boolがexplicitであるため、コンパイルエラー</span></span></code></pre></div>
<h3 id="演算子">==演算子 <a id="SS_19_6_3"></a></h3>
<p>クラスの==演算子の実装方法には、 <a
href="core_lang_spec.html#SS_19_6_3_1">メンバ==演算子</a>、<a
href="core_lang_spec.html#SS_19_6_3_2">非メンバ==演算子</a>の2つの方法がある。</p>
<h4 id="メンバ演算子">メンバ==演算子 <a id="SS_19_6_3_1"></a></h4>
<p>メンバ==演算子には、<a
href="core_lang_spec.html#SS_19_6_3_2">非メンバ==演算子</a>に比べ、下記のようなメリットがある。</p>
<ul>
<li>メンバ変数へのアクセスが容易であるため、より実装が単純になりやすい。</li>
<li>メンバ変数へのアクセスが容易であるため、パフォーマンスが向上する。</li>
<li>インライン化し易い。</li>
</ul>
<div class="sourceCode" id="cb106"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/comparison_operator_old_ut.cpp 12</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Integer <span class="op">{</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>        Integer<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">x_</span><span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// operator==とoperator&lt;だけを定義</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// メンバ関数の比較演算子</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Integer<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span> <span class="op">==</span> other<span class="op">.</span><span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="at">const</span> Integer<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span> <span class="op">&lt;</span> other<span class="op">.</span><span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="va">x_</span><span class="op">;</span></span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>すべてのメンバ変数に==演算子が定義されている場合、
C++20以降より、<code>=default</code>により==演算子を自動生成させることができるようになった。</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/comparison_operator_ut.cpp 11</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Integer <span class="op">{</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>        Integer<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">x_</span><span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Integer<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span>  <span class="co">// 自動生成</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="va">x_</span><span class="op">;</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<h4 id="非メンバ演算子">非メンバ==演算子 <a id="SS_19_6_3_2"></a></h4>
<p>非メンバ==演算子には、<a
href="core_lang_spec.html#SS_19_6_3_1">メンバ==演算子</a>に比べ、下記のようなメリットがある。</p>
<ul>
<li>クラスをよりコンパクトに記述できるが、その副作用として、
アクセッサやfriend宣言が必要になることがある。</li>
</ul>
<div class="sourceCode" id="cb108"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/comparison_operator_old_ut.cpp 53</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Integer <span class="op">{</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>        Integer<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">x_</span><span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// operator==とoperator&lt;だけを定義</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// メンバ関数の比較演算子に見えるが、非メンバ関数</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Integer<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> Integer<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> lhs<span class="op">.</span><span class="va">x_</span> <span class="op">==</span> rhs<span class="op">.</span><span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="at">const</span> Integer<span class="op">&amp;</span> lhs<span class="op">,</span> <span class="at">const</span> Integer<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> lhs<span class="op">.</span><span class="va">x_</span> <span class="op">&lt;</span> rhs<span class="op">.</span><span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="va">x_</span><span class="op">;</span></span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<ul>
<li><a
href="core_lang_spec.html#SS_19_6_2_2">暗黙の型変換</a>を利用した以下に示すようなシンプルな記述ができる場合がある。</li>
</ul>
<div class="sourceCode" id="cb109"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/comparison_operator_old_ut.cpp 75</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> Integer<span class="op">{</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span><span class="dv">5</span> <span class="op">==</span> a<span class="op">);</span>  <span class="co">// 5がInteger{5}に型型変換される</span></span></code></pre></div>
<p>すべてのメンバ変数に==演算子が定義されている場合、
C++20以降より、<code>=default</code>により==演算子を自動生成させることができるようになった。</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/comparison_operator_ut.cpp 35</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Integer <span class="op">{</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>        Integer<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">x_</span><span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Integer <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Integer <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="va">x_</span><span class="op">;</span></span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb110-12"><a href="#cb110-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-13"><a href="#cb110-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Integer <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Integer <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span>  <span class="co">// 自動生成</span></span></code></pre></div>
<h3 id="比較演算子">比較演算子 <a id="SS_19_6_4"></a></h3>
<p>比較演算子とは、<a href="--">==演算子</a>の他に、!=、
&lt;=、&gt;、&gt;= &lt;、&gt;を指す。 C++20から導入された<a
href="core_lang_spec.html#SS_19_6_4_1">&lt;=&gt;演算子</a>の定義により、すべてが定義される。</p>
<h4 id="演算子-1">&lt;=&gt;演算子 <a id="SS_19_6_4_1"></a></h4>
<p>「<a
href="stdlib_and_concepts.html#SS_20_10_2">std::tuppleを使用した比較演算子の実装方法</a>」
で示した定型のコードはコンパイラが自動生成するのがC++規格のセオリーである。
このためC++20から導入されたのが&lt;=&gt;演算子<code>&lt;=&gt;</code>である。</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/comparison_operator_ut.cpp 61</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span><span class="at">const</span> Point<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span>  <span class="co">// 三方比較演算子 (C++20)</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 通常autoとするが、実際の戻り型はstd::strong_ordering</span></span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb112"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/comparison_operator_ut.cpp 74</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p1 <span class="op">=</span> Point<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p2 <span class="op">=</span> Point<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p3 <span class="op">=</span> Point<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>p1<span class="op">,</span> p2<span class="op">);</span>  <span class="co">// p1 == p2</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_NE<span class="op">(</span>p1<span class="op">,</span> p3<span class="op">);</span>  <span class="co">// p1 != p3</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>p1 <span class="op">&lt;</span> p3<span class="op">);</span></span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>p1 <span class="op">&gt;</span> p3<span class="op">);</span></span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> cmp_1_2 <span class="op">=</span> p1 <span class="op">&lt;=&gt;</span> p2<span class="op">;</span></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> cmp_1_3 <span class="op">=</span> p1 <span class="op">&lt;=&gt;</span> p3<span class="op">;</span></span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> cmp_3_1 <span class="op">=</span> p3 <span class="op">&lt;=&gt;</span> p1<span class="op">;</span></span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>strong_ordering<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>cmp_1_2<span class="op">)&gt;);</span></span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>strong_ordering::equal<span class="op">,</span> cmp_1_2<span class="op">);</span>    <span class="co">// 等しい</span></span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>strong_ordering::less<span class="op">,</span> cmp_1_3<span class="op">);</span>     <span class="co">// &lt;=&gt;の左オペランドが小さい</span></span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>strong_ordering::greater<span class="op">,</span> cmp_3_1<span class="op">);</span>  <span class="co">// &lt;=&gt;の左オペランドが大きい</span></span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-21"><a href="#cb112-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::strong_orderingの値</span></span>
<span id="cb112-22"><a href="#cb112-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_EQ(static_cast&lt;int32_t&gt;(cmp_1_2), 0); キャストできないのでコンパイルエラー</span></span>
<span id="cb112-23"><a href="#cb112-23" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>cmp_1_2 <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb112-24"><a href="#cb112-24" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>cmp_1_3 <span class="op">&lt;</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// cmp_1_3は実質的には-1</span></span>
<span id="cb112-25"><a href="#cb112-25" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>cmp_3_1 <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// cmp_3_1は実質的には1</span></span></code></pre></div>
<p>定型の比較演算子では不十分である場合、&lt;=&gt;演算子を実装する必要が出てくる。
そのような場合に備えて、上記の自動生成コードの内容を敢えて実装して、以下に示す。</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/comparison_operator_ut.cpp 105</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>strong_ordering <span class="kw">operator</span><span class="op">&lt;=&gt;(</span><span class="at">const</span> Point<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>tie<span class="op">(</span>x<span class="op">,</span> y<span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="bu">std::</span>tie<span class="op">(</span>other<span class="op">.</span>x<span class="op">,</span> other<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Point<span class="op">&amp;</span> other<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>tie<span class="op">(</span>x<span class="op">,</span> y<span class="op">)</span> <span class="op">==</span> <span class="bu">std::</span>tie<span class="op">(</span>other<span class="op">.</span>x<span class="op">,</span> other<span class="op">.</span>y<span class="op">);</span> <span class="op">}</span></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<h4 id="三方比較演算子">三方比較演算子 <a id="SS_19_6_4_2"></a></h4>
<p>三方比較演算子とは<a
href="core_lang_spec.html#SS_19_6_4_1">&lt;=&gt;演算子</a>を指す。</p>
<h4 id="spaceship-operator">spaceship operator
<a id="SS_19_6_4_3"></a></h4>
<p>spaceship operatorとは<a
href="core_lang_spec.html#SS_19_6_4_1">&lt;=&gt;演算子</a>を指す。
この名前は<code>&lt;=&gt;</code>が宇宙船に見えることに由来としている。</p>
<h3 id="リスト初期化">リスト初期化 <a id="SS_19_6_5"></a></h3>
<p>リスト初期化とは、C++11で導入された<code>{}</code>を使ったオブジェクトの初期化構文を指す。
以下にコード例を示す。</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/uniform_initialization_ut.cpp 12</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> X <span class="op">{</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>        X<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>    X x0<span class="op">(</span><span class="dv">0</span><span class="op">);</span>   <span class="co">// 通常従来のコンストラクタ呼び出し</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>    X x1 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// 暗黙の型変換を使用した従来のコンストラクタ呼び出し</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>    X x2<span class="op">{</span><span class="dv">0</span><span class="op">};</span>     <span class="co">// リスト初期化</span></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>    X x3 <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span>  <span class="co">// 暗黙の型変換を使用したリスト初期化</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Y <span class="op">{</span></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>        Y<span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> lamda <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">)</span> <span class="op">-&gt;</span> Y <span class="op">{</span></span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="fl">3.14</span><span class="op">,</span> <span class="st">&quot;hello&quot;</span><span class="op">};</span>  <span class="co">// 暗黙の型変換を使用したリスト初期化でのYの生成</span></span>
<span id="cb114-19"><a href="#cb114-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>変数による一様初期化が縮小型変換を起こす場合や、
リテラルによる一様初期化がその値を変更する場合、コンパイルエラーとなるため、
この機能を積極的に使用することで、縮小型変換による初期化のバグを未然に防ぐことができる。</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/uniform_initialization_ut.cpp 34</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">{</span><span class="dv">0</span><span class="op">};</span>  <span class="co">// リスト初期化</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> b0 <span class="op">=</span> <span class="dv">7</span><span class="op">;</span>  <span class="co">// 縮小型変換のため、b0の値はtrue(通常は1)となる</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>b0<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// bool b1{7};  // 縮小型変換のため、コンパイルエラー</span></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// bool b2{i};  // 縮小型変換のため、コンパイルエラー</span></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> u8_0 <span class="op">=</span> <span class="dv">256</span><span class="op">;</span>  <span class="co">// 縮小型変換のためu8_0は0となる</span></span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>u8_0<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// uint8_t u8_1{256};  // 縮小型変換のため、コンパイルエラー</span></span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// uint8_t u8_2{i};    // 縮小型変換のため、コンパイルエラー</span></span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> array0<span class="op">[</span><span class="dv">3</span><span class="op">]{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">255</span><span class="op">};</span>  <span class="co">// リスト初期化</span></span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// uint8_t array1[3] = {1, 2, 256};  // 縮小型変換のため、コンパイルエラー</span></span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// uint8_t array2[3]{1, 2, 256};     // 縮小型変換のため、コンパイルエラー</span></span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// uint8_t array2[3]{1, 2, i};       // 縮小型変換のため、コンパイルエラー</span></span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i0 <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span>  <span class="co">// 縮小型変換のため、i0の値は1</span></span>
<span id="cb115-23"><a href="#cb115-23" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>i0<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb115-24"><a href="#cb115-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-25"><a href="#cb115-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// int i1{1.0};  // 縮小型変換のため、コンパイルエラー</span></span>
<span id="cb115-26"><a href="#cb115-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-27"><a href="#cb115-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> d<span class="op">{</span><span class="dv">1</span><span class="op">};</span>  <span class="co">// 縮小型変換は起こらないのでコンパイル可能</span></span>
<span id="cb115-28"><a href="#cb115-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// int i2{d};  // 縮小型変換のため、コンパイルエラー</span></span></code></pre></div>
<h3 id="一様初期化">一様初期化 <a id="SS_19_6_6"></a></h3>
<p>一様初期化(Uniform Initialization)は 、 <a
href="core_lang_spec.html#SS_19_6_5">リスト初期化</a>による初期化方法がC++における初期化を統一的に扱えるように設計された概念を指さす。</p>
<h3 id="非静的なメンバ変数の初期化">非静的なメンバ変数の初期化
<a id="SS_19_6_7"></a></h3>
<p>非静的なメンバ変数の初期化には下記の3つの方法がある。</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_6_7_1">NSDMI</a></li>
<li><a
href="core_lang_spec.html#SS_19_6_7_2">初期化子リストでの初期化</a></li>
<li><a
href="core_lang_spec.html#SS_19_6_7_3">コンストラクタ内での非静的なメンバ変数の初期値の代入</a></li>
</ul>
<p>同一変数に対して、 「<a
href="core_lang_spec.html#SS_19_6_7_1">NSDMI</a>」と「<a
href="core_lang_spec.html#SS_19_6_7_2">初期化子リストでの初期化</a>」
が行われた場合、その変数に対するNSDMIは行われない。</p>
<h4 id="nsdmi">NSDMI <a id="SS_19_6_7_1"></a></h4>
<p>NSDMIとは、non-static data member initializerの略語であり、
下記のような非静的なメンバ変数の初期化子を指す。</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/nsdmi.cpp 11</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>        A<span class="op">()</span> <span class="op">:</span> <span class="va">a_</span><span class="op">{</span><span class="dv">1</span><span class="op">}</span>  <span class="co">// NSDMIではなく、非静的なメンバ初期化子による初期化</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span>     <span class="va">a_</span><span class="op">;</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span>     <span class="va">b_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>        <span class="co">// NSDMI</span></span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="va">str_</span><span class="op">{</span><span class="st">&quot;init&quot;</span><span class="op">};</span>  <span class="co">// NSDMI</span></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<h4 id="初期化子リストでの初期化">初期化子リストでの初期化
<a id="SS_19_6_7_2"></a></h4>
<p>「非静的メンバ変数をコンストラクタの本体よりも前に初期化する」言語機能である。
メンバ変数は宣言された順序で初期化されるため、
初期化子リストでの順序は、実際の初期化の順序とは関係がない。</p>
<p>この機能を使うことで、メンバ変数の初期化処理が簡素に記述できる。
constメンバ変数は、初期化子リストでの初期化か<a
href="core_lang_spec.html#SS_19_6_7_1">NSDMI</a>でしか初期化できない。</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/nsdmi.cpp 27</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>        A<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">:</span> <span class="va">v_</span><span class="op">{</span>a<span class="op">,</span> b<span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="va">a_</span><span class="op">{</span>a<span class="op">}</span>  <span class="co">// 非静的なメンバ初期化子による初期化</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">//                 ^^^^^^^^^^^^^ メンバ変数の初期化は</span></span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">//                                  - 宣言順に行われる。</span></span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">//                                  - 初期化リストの順番と、初期化の順番には関係がない。</span></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>              <span class="va">a_</span><span class="op">;</span></span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="va">v_</span><span class="op">;</span></span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<h4
id="コンストラクタ内での非静的なメンバ変数の初期値の代入">コンストラクタ内での非静的なメンバ変数の初期値の代入
<a id="SS_19_6_7_3"></a></h4>
<p>この方法は単なる代入でありメンバ変数の初期化ではない。</p>
<p><a href="core_lang_spec.html#SS_19_6_7_1">NSDMI</a>、 <a
href="core_lang_spec.html#SS_19_6_7_2">初期化子リストでの初期化</a>で初期化できない変数を未初期化でない状態にするための唯一の方法である。</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/nsdmi.cpp 45</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>        A<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">a_</span> <span class="op">=</span> b<span class="op">;</span>                     <span class="co">// 非静的なメンバのコンストラクタでの代入</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>            <span class="va">v_</span> <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">{</span>a<span class="op">,</span> b<span class="op">,</span> <span class="dv">3</span><span class="op">};</span>  <span class="co">// 非静的なメンバのコンストラクタでの代入</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>              <span class="va">a_</span><span class="op">;</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="va">v_</span><span class="op">;</span></span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<h3 id="オブジェクトのライフタイム">オブジェクトのライフタイム
<a id="SS_19_6_8"></a></h3>
<p>オブジェクトは、以下のような種類のライフタイムを持つ。</p>
<ul>
<li>静的に生成されたオブジェクトのライフタイム</li>
<li>thread_localに生成されたオブジェクトのライフタイム</li>
<li>newで生成されたオブジェクトのライフタイム</li>
<li>スタック上に生成されたオブジェクトのライフタイム</li>
<li>prvalue(「<a
href="core_lang_spec.html#SS_19_7_1_2">rvalue</a>」参照)のライフタイム</li>
</ul>
<p>なお、リファレンスの初期化をrvalueで行った場合、
そのrvalueはリファレンスがスコープを抜けるまで存続し続ける。</p>
<p>rvalueをバインドするリファレンスが存在しない状態で、
そのrvalueがメンバ変数へのリファレンスを返す関数を呼び出し、
そのリファレンスをバインドするリファレンス変数を初期化した場合、
リファレンスが指すオブジェクトはすでにライフタイムを終了している。
このような状態のリファレンスを<a
href="cpp_idioms.html#SS_21_8_2">danglingリファレンス</a>と呼ぶ。
同様に、このような状態のポインタを<a
href="cpp_idioms.html#SS_21_8_3">danglingポインタ</a>と呼ぶ。</p>
<h3 id="プレースメントnew">プレースメントnew <a id="SS_19_6_9"></a></h3>
<p>プレースメントnewは、既に確保済みの生ストレージ上で、
オブジェクトを生成するための
<code>new(raw_storage) T(args...)</code>のような構文である。
通常のnew演算子が「メモリ確保＋初期化」を同時に行うのに対し、プレースメントnewは「初期化のみ」を担当する。
これにより、メモリ確保の責務を呼び出し側に委ねることができ、
アロケーションコストの削減やメモリプールとの統合が可能となる。
また、リアルタイム処理や組込みソフトウェアなど、ヒープからの動的割り当てを避けたい場面でも有用である。</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/placement_new_ut.cpp 10</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> X <span class="op">{</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> X<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">:</span> <span class="va">str_</span><span class="op">{</span><span class="bu">std::</span>to_string<span class="op">(</span>v<span class="op">)}</span> <span class="op">{}</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> get_str<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">str_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>X<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="va">str_</span><span class="op">;</span></span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>上記クラスをプレースメントnewを使用して生成するコード例を以下に示す。</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/placement_new_ut.cpp 26</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">alignas</span><span class="op">(</span>X<span class="op">)</span> <span class="dt">uint8_t</span> <span class="va">memory_</span><span class="op">[</span><span class="kw">sizeof</span><span class="op">(</span>X<span class="op">)];</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// alignas(X)はXのアライメント要件(通常4や8バイト境界)に合わせる</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// これがないと、memory_が不適切な境界(例:奇数アドレス)に配置され、</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 一部のCPUアーキテクチャでクラッシュやパフォーマンス低下を引き起こす</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>    X<span class="op">*</span> x <span class="op">=</span> <span class="kw">new</span> <span class="op">(</span><span class="va">memory_</span><span class="op">)</span> X<span class="op">{</span><span class="dv">42</span><span class="op">};</span>  <span class="co">// X型オブジェクトをmemory_上に生成</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;42&quot;</span><span class="op">,</span> x<span class="op">-&gt;</span>get_str<span class="op">());</span>  <span class="co">// 正しく生成されたかどうかの確認</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... ここでエクセプションが発生して、</span></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... 以下のコードが実行できないとデストラクタが呼ばれないためメモリリークする可能性がある</span></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a>    x<span class="op">-&gt;~</span>X<span class="op">();</span>  <span class="co">// プレースメントしたオブジェクトの解放にはdeleteを使ってはならないため、</span></span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a>              <span class="co">// このように直接デストラクタを呼び出す必要がある</span></span></code></pre></div>
<p>このコードからわかる通り、プレースメントnewで生成したオブジェクトは手動でデストラクタを呼び出す必要があるため、
例外が発生した場合にリソースリークのリスクがある。
下記のようにstd::unique_ptrにカスタムデリータを指定することで、この問題を解決できる。</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/placement_new_ut.cpp 48</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">alignas</span><span class="op">(</span>X<span class="op">)</span> <span class="dt">uint8_t</span> <span class="va">memory_</span><span class="op">[</span><span class="kw">sizeof</span><span class="op">(</span>X<span class="op">)];</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> deleter <span class="op">=</span> <span class="op">[](</span>X<span class="op">*</span> p<span class="op">)</span> <span class="op">{</span>  <span class="co">// カスタムデリータの定義</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>            p<span class="op">-&gt;~</span>X<span class="op">();</span>  <span class="co">// デストラクタのみ呼び出し</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>X<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>deleter<span class="op">)&gt;</span> x<span class="op">{</span><span class="kw">new</span> <span class="op">(</span><span class="va">memory_</span><span class="op">)</span> X<span class="op">{</span><span class="dv">42</span><span class="op">},</span> deleter<span class="op">};</span></span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;42&quot;</span><span class="op">,</span> x<span class="op">-&gt;</span>get_str<span class="op">());</span></span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// xがスコープアウトするタイミングでカスタムデリータdeleterが呼ばれるため、~X()の呼び出し漏れが回避できる</span></span></code></pre></div>
<h3 id="new-stdnothrow">new (std::nothrow) <a id="SS_19_6_10"></a></h3>
<p><code>new (std::nothrow)</code>は、メモリ確保失敗時に例外を投げずnullptrを返すnewの形式である。
通常のnewはメモリ確保に失敗するとstd::bad_alloc例外を投げるが、
<code>new (std::nothrow)</code>はstd::nothrow_t型の引数を取ることで、失敗時にnullptrを返す動作に変更される。
この形式は例外を使わない環境(組み込みシステムなど)や、明示的なnullチェックによるエラー処理が望ましい場合に使用される。
解放方法は通常のnewと同じで、単一オブジェクトの場合はdelete、配列の場合はdelete[]を使用する。</p>
<h2 id="値カテゴリとリファレンス">値カテゴリとリファレンス
<a id="SS_19_7"></a></h2>
<p>ここでは、expression(式)の値カテゴリや、それに付随した機能についての解説を行う。</p>
<h3 id="expression">expression <a id="SS_19_7_1"></a></h3>
<p><a
href="https://ja.cppreference.com/w/cpp/language/expressions">expression</a>(式)とは、
「演算子とそのオペランドの並び」である(オペランドのみの記述も式である)。
演算子とは以下のようなものである。</p>
<ul>
<li>四則演算、代入(a = b、a += b …)、インクリメント、比較、論理式</li>
<li>明示的キャストや型変換</li>
<li>メンバアクセス(a.b、a-&gt;b、a[x]、 *a、&amp;a …)</li>
<li>関数呼び出し演算子(f(…))、sizeof、decltype等</li>
</ul>
<p>expressionは、</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_7_1_1">lvalue</a></li>
<li><a href="core_lang_spec.html#SS_19_7_1_2">rvalue</a></li>
<li><a href="core_lang_spec.html#SS_19_7_1_3">xvalue</a></li>
<li><a href="core_lang_spec.html#SS_19_7_1_5">glvalue</a></li>
<li><a href="core_lang_spec.html#SS_19_7_1_4">prvalue</a></li>
</ul>
に分類される。 <!-- pu:essential/plant_uml/rvalue.pu-->
<p>
<img src="data:image/png;base64,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" />
</p>
<p>expressionは、<a href="core_lang_spec.html#SS_19_7_1_1">lvalue</a>か<a
href="core_lang_spec.html#SS_19_7_1_2">rvalue</a>である。</p>
<h4 id="lvalue">lvalue <a id="SS_19_7_1_1"></a></h4>
<p>lvalueとは、</p>
<ul>
<li>名前を持つオブジェクト(識別子で参照可能)や関数を指す式</li>
<li>代入式の左辺になり得る式であるため、左辺値と呼ばれることがある。</li>
<li>constなlvalueは代入式の左辺にはなり得ないが、lvalueである。</li>
<li><a href="core_lang_spec.html#SS_19_7_1_2">rvalue</a>でない<a
href="core_lang_spec.html#SS_19_7_1">expression</a>がlvalueである。</li>
</ul>
<p><code>T const&amp;</code>は代入式の左辺になりは得ないがlvalueである。<a
href="core_lang_spec.html#SS_19_8_2">rvalueリファレンス</a>もlvalueである。</p>
<h4 id="rvalue">rvalue <a id="SS_19_7_1_2"></a></h4>
<p>rvalueとは、</p>
<ul>
<li>テンポラリな値を表す式(代入式の右辺値として使われることが多い)</li>
<li><a href="core_lang_spec.html#SS_19_7_1_3">xvalue</a>か<a
href="core_lang_spec.html#SS_19_7_1_4">prvalue</a>である。</li>
<li><a href="core_lang_spec.html#SS_19_7_1_1">lvalue</a>でない<a
href="core_lang_spec.html#SS_19_7_1">expression</a>がrvalueである。</li>
</ul>
<p><a
href="core_lang_spec.html#SS_19_8_2">rvalueリファレンス</a>(<code>T&amp;&amp;</code>型の変数)はlvalueである。
一方、その初期化に使われる式(例えばstd::move(x))は<a
href="core_lang_spec.html#SS_19_7_1_3">xvalue</a>である。</p>
<h4 id="xvalue">xvalue <a id="SS_19_7_1_3"></a></h4>
<p>xvalueとは以下のようなものである。</p>
<ul>
<li>戻り値の型がT&amp;&amp;(Tは任意の型)である関数の呼び出し式(std::move(x))</li>
<li>オブジェクトへのT&amp;&amp;へのキャスト式(static_cast&lt;char&amp;&amp;&gt;(x))</li>
<li>aを配列のxvalueとした場合のa[N]や、cをクラス型のrvalueとした場合のc.m(mはaの非staticメンバ)等</li>
</ul>
<h4 id="prvalue">prvalue <a id="SS_19_7_1_4"></a></h4>
<p>prvalueとは、オブジェクトやビットフィールドを初期化する、
もしくはオペランドの値を計算する式であり、以下のようなものである。</p>
<ul>
<li>文字列リテラルを除くリテラル</li>
<li>戻り値の型が非リファレンスである関数呼び出し式、
または前置++と前置–を除くオーバーロードされた演算子式(<code>path.string()</code>、<code>str1 + str2</code>、<code>it++</code>
…)</li>
<li>組み込み型インスタンスaの<code>a++</code>、<code>a--</code>(<code>++a</code>や<code>--a</code>はlvalue)</li>
<li>組み込み型インスタンスa、bに対する <code>a + b</code>、
<code>a % b</code>、 <code>a &amp; b</code>、
<code>a &amp;&amp; b</code>、 <code>a || b</code>、 <code>!a</code>、
<code>a &lt; b</code>、 <code>a == b</code>等</li>
<li>prvalue(もしくはrvalue)は、
<ul>
<li>アドレス演算子(&amp;)のオペランドになれない。</li>
<li>非constな<a
href="core_lang_spec.html#SS_19_8_1">lvalueリファレンス</a>ではバインドできないが、
constな<a href="core_lang_spec.html#SS_19_8_1">lvalueリファレンス</a>や<a
href="core_lang_spec.html#SS_19_8_2">rvalueリファレンス</a>でバインドできる。</li>
</ul></li>
</ul>
<p>つまり、prvalueとはいわゆるテンポラリオブジェクトのことである(下記の<code>std::string{}</code>で作られるようなオブジェクト)。
多くの場合、prvalueはテンポラリオブジェクトを生成するが、 C++17以降は<a
href="core_lang_spec.html#SS_19_15_1">RVO(Return Value
Optimization)</a>により、
テンポラリオブジェクトを生成せず、直接、初期化に使われる場合もある。<br />
また、正確にはprvalueと呼ぶべき場面でも単にrvalueと呼ばれることがある。
このドキュメントでも、そうなっていることもある。</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_lvalue_ut.cpp 10</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// str0を初期化するためにstd::string{}により生成されるオブジェクトはprvalue、 str0はlvalue</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//   ↓lvalue</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str0 <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{};</span>  <span class="co">// この式の左辺はテンポラリオブジェクト(つまりprvalue)</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="co">    auto* str0_ptr = &amp;std::string{};  // prvalueのアドレスの取得はできない</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a><span class="co">    ↑は、メッセージは error: taking address of rvalue でコンパイルエラー */</span></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a><span class="co">    std::string&amp; str1_ref = std::string{};  // prvalueを非constなlvalueリファレンスではバインドできない</span></span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a><span class="co">    ↑は、コンパイルエラーで、エラーメッセージは error: taking address of rvalue */</span></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> str2_ref <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{};</span>  <span class="co">// prvalueはconstなlvalueリファレンスでバインドできる</span></span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ↓のようにすればアドレスを取得できるが、このようなことはすべきではない。</span></span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="at">const</span><span class="op">*</span> str2_ptr <span class="op">=</span> <span class="op">&amp;</span>str2_ref<span class="op">;</span>  <span class="co">// str_ptrはprvalueのアドレスを指しているが、、、</span></span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-18"><a href="#cb122-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;&amp;</span> str3_ref <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{};</span>  <span class="co">// prvalueはprvalueリファレンスでバインドできる</span></span>
<span id="cb122-19"><a href="#cb122-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ↓のようにすればアドレスを取得できるが、このようなことはすべきではない。</span></span>
<span id="cb122-20"><a href="#cb122-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op">*</span> str3_ptr <span class="op">=</span> <span class="op">&amp;</span>str3_ref<span class="op">;</span>  <span class="co">// str_ptrはprvalueのアドレスを指しているが、、、</span></span></code></pre></div>
<h4 id="glvalue">glvalue <a id="SS_19_7_1_5"></a></h4>
<p>glvalueは、</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_7_1_1">lvalue</a>か<a
href="core_lang_spec.html#SS_19_7_1_3">xvalue</a>である。</li>
<li>“generalized lvalue”の略称</li>
</ul>
<p>オブジェクトや関数を参照する式を総称してglvalueと呼ぶ。
これにより、式が「場所を指す」か「一時的な値を表す」かを大きく分類できる。</p>
<h3 id="decltypeとexpression">decltypeとexpression
<a id="SS_19_7_2"></a></h3>
<p>エッセンシャルタイプがTであるlvalue、xvalue、prvalueに対して
(例えば、std::string
const&amp;のエッセンシャルタイプはstd::stringである)、
decltypeの算出結果は下表のようになる。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">decltype</th>
<th style="text-align: left;">算出された型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">decltype(lvalue)</td>
<td style="text-align: left;">T</td>
</tr>
<tr class="even">
<td style="text-align: left;">decltype((lvalue))</td>
<td style="text-align: left;">T&amp;</td>
</tr>
<tr class="odd">
<td style="text-align: left;">decltype(xvalue)</td>
<td style="text-align: left;">T&amp;&amp;</td>
</tr>
<tr class="even">
<td style="text-align: left;">decltype((xvalue))</td>
<td style="text-align: left;">T&amp;&amp;</td>
</tr>
<tr class="odd">
<td style="text-align: left;">decltype(prvalue)</td>
<td style="text-align: left;">T</td>
</tr>
<tr class="even">
<td style="text-align: left;">decltype((prvalue))</td>
<td style="text-align: left;">T</td>
</tr>
</tbody>
</table>
<p>この表の結果を使用した下記の関数型マクロ群により式を分類できる。
定義から明らかな通り、これらは <a
href="https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88%E3%83%A1%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">テンプレートメタプログラミング</a>
に有効に活用できる。</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/decltype_expression_ut.cpp 7</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define IS_LVALUE</span><span class="op">(</span>EXPR_<span class="op">)</span><span class="pp"> </span><span class="bu">std::</span>is_lvalue_reference_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">((</span>EXPR_<span class="op">))&gt;</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define IS_XVALUE</span><span class="op">(</span>EXPR_<span class="op">)</span><span class="pp"> </span><span class="bu">std::</span>is_rvalue_reference_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">((</span>EXPR_<span class="op">))&gt;</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define IS_PRVALUE</span><span class="op">(</span>EXPR_<span class="op">)</span><span class="pp"> </span><span class="op">!</span><span class="bu">std::</span>is_reference_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">((</span>EXPR_<span class="op">))&gt;</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define IS_RVALUE</span><span class="op">(</span>EXPR_<span class="op">)</span><span class="pp"> </span><span class="op">(</span>IS_PRVALUE<span class="op">(</span>EXPR_<span class="op">)</span><span class="pp"> </span><span class="op">||</span><span class="pp"> </span>IS_XVALUE<span class="op">(</span>EXPR_<span class="op">))</span></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{};</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>IS_LVALUE<span class="op">(</span>str<span class="op">),</span> <span class="st">&quot;EXPR_ must be lvalue&quot;</span><span class="op">);</span></span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>IS_RVALUE<span class="op">(</span>str<span class="op">),</span> <span class="st">&quot;EXPR_ must NOT be rvalue&quot;</span><span class="op">);</span></span>
<span id="cb123-12"><a href="#cb123-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-13"><a href="#cb123-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>IS_XVALUE<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>str<span class="op">)),</span> <span class="st">&quot;EXPR_ must be xvalue&quot;</span><span class="op">);</span></span>
<span id="cb123-14"><a href="#cb123-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>IS_PRVALUE<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>str<span class="op">)),</span> <span class="st">&quot;EXPR_ must NOT be prvalue&quot;</span><span class="op">);</span></span>
<span id="cb123-15"><a href="#cb123-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-16"><a href="#cb123-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>IS_PRVALUE<span class="op">(</span><span class="bu">std::</span>string<span class="op">{}),</span> <span class="st">&quot;EXPR_ must be prvalue&quot;</span><span class="op">);</span></span>
<span id="cb123-17"><a href="#cb123-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>IS_RVALUE<span class="op">(</span><span class="bu">std::</span>string<span class="op">{}),</span> <span class="st">&quot;EXPR_ must be rvalue&quot;</span><span class="op">);</span></span>
<span id="cb123-18"><a href="#cb123-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>IS_LVALUE<span class="op">(</span><span class="bu">std::</span>string<span class="op">{}),</span> <span class="st">&quot;EXPR_ must NOT be lvalue&quot;</span><span class="op">);</span></span></code></pre></div>
<h2 id="リファレンス">リファレンス <a id="SS_19_8"></a></h2>
<p>リファレンス(参照)とは、以下のいずれか、もしくはすべてを指すが、
単にリファレンスと呼ぶ場合、lvalueリファレンスを指すことが多い。</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_8_1">lvalueリファレンス</a></li>
<li><a href="core_lang_spec.html#SS_19_8_2">rvalueリファレンス</a></li>
<li><a
href="core_lang_spec.html#SS_19_8_3">forwardingリファレンス</a></li>
</ul>
<p>これらの概念と関わり強い、<a
href="core_lang_spec.html#SS_19_8_6">リファレンスcollapsing</a>についても併せて解説を行う。</p>
<h3 id="lvalueリファレンス">lvalueリファレンス
<a id="SS_19_8_1"></a></h3>
<p>lvalueリファレンスとは、</p>
<ul>
<li>C++98(もしくは03)から導入されたシンタックスであり、任意の型Tに対して<code>T&amp;</code>という形式で宣言される。</li>
<li>既存のオブジェクトに対する別名(エイリアス)であり、宣言時に必ず初期化が必要で、
一度初期化後は別のオブジェクトを参照することはできない。</li>
<li><a
href="core_lang_spec.html#SS_19_8_2">rvalueリファレンス</a>導入前のC++では、すべてのリファレンスはlvalueリファレンスであったため、
lvalueリファレンスを単にリファレンスと呼んでいた。</li>
<li>オブジェクトaのエイリアスとして、
リファレンスa_refが宣言されることを「a_refはaをバインドする」という。</li>
<li>以下のコード例で示すように、
<ul>
<li>非const lvalueリファレンスは<a
href="core_lang_spec.html#SS_19_7_1_2">rvalue</a>をバインドできないが、</li>
<li>const lvalueリファレンスは<a
href="core_lang_spec.html#SS_19_7_1_2">rvalue</a>をバインドできる。</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb124"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_lvalue_ut.cpp 40</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>  a     <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;</span> a_ref <span class="op">=</span> a<span class="op">;</span>  <span class="co">// a_refはaのリファレンス</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>                     <span class="co">// a_refはaをバインドする</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(&amp;</span>a<span class="op">,</span> <span class="op">&amp;</span>a_ref<span class="op">);</span>  <span class="co">// リファレンスは別名に過ぎないため、このテストが成立</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>    a_ref <span class="op">=</span> b<span class="op">;</span>  <span class="co">// 一見、a_refの再初期化に見えるが、実際は値の代入になるため、以下のテストが成立</span></span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span>  <span class="co">// リファレンスは別名に過ぎないため、このテストが成立</span></span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a><span class="co">    int&amp; t_ref = int{99};  非const lvalueリファレンスはrvalueをバインドできない */</span></span>
<span id="cb124-15"><a href="#cb124-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span><span class="op">&amp;</span> t_ref <span class="op">=</span> <span class="dt">int</span><span class="op">{</span><span class="dv">99</span><span class="op">};</span>  <span class="co">// 上記とは異なり、const lvalueリファレンスはrvalueをバインドできる</span></span>
<span id="cb124-16"><a href="#cb124-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>t_ref<span class="op">,</span> <span class="dv">99</span><span class="op">);</span></span></code></pre></div>
<p>このようなリファレンスのバインドの可否はオーバーロードにも影響を与える。</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_lvalue_ut.cpp 60</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span><span class="op">&amp;</span> <span class="op">)</span>        <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span>   <span class="co">// f-1</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> <span class="at">const</span> <span class="op">&amp;</span> <span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span>   <span class="co">// f-2</span></span></code></pre></div>
<div class="sourceCode" id="cb126"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_lvalue_ut.cpp 69</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>       a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span> b <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> f<span class="op">(</span>a<span class="op">));</span>  <span class="co">// f(a)は、f-2も呼び出せるが、デフォルトでは、f-1が呼ばれる</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> f<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span> <span class="at">const</span><span class="op">&amp;&gt;(</span>a<span class="op">)));</span>  <span class="co">// aをconstにキャストして、強制的にf-2の呼び出し</span></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> f<span class="op">(</span>b<span class="op">));</span>                           <span class="co">// constオブジェクトのバインド</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> f<span class="op">(</span><span class="dt">int</span><span class="op">{}));</span>                       <span class="co">// rvalueのバインド</span></span></code></pre></div>
<h3 id="rvalueリファレンス">rvalueリファレンス
<a id="SS_19_8_2"></a></h3>
<p>rvalueリファレンスは、</p>
<ul>
<li>C++11で導入されたシンタックスであり、任意の型Tに対して、<code>T&amp;&amp;</code>で宣言される。</li>
<li>「テンポラリオブジェクト(<a
href="core_lang_spec.html#SS_19_7_1_2">rvalue</a>)」をバインドできるリファレンス。</li>
<li>C++11の<a href="cpp_idioms.html#SS_21_3_3">moveセマンティクス</a>と<a
href="core_lang_spec.html#SS_19_8_5">perfect
forwarding</a>を実現するために導入された。</li>
<li><strong>注意1</strong>
型が<code>T&amp;&amp;</code>である変数の値カテゴリは<a
href="core_lang_spec.html#SS_19_7_1_1">lvalue</a>である。</li>
<li><strong>注意2</strong>
型が<code>T&amp;&amp;</code>である変数は、<code>T&amp;</code>でバインドできる。</li>
</ul>
<div class="sourceCode" id="cb127"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_lvalue_ut.cpp 87</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>        a      <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span><span class="op">&amp;</span> a_ref0 <span class="op">=</span> a<span class="op">;</span>        <span class="co">// const lvalueリファレンスはlvalueをバインドできる</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span><span class="op">&amp;</span> a_ref1 <span class="op">=</span> <span class="dt">int</span><span class="op">{</span><span class="dv">99</span><span class="op">};</span>  <span class="co">// const lvalueリファレンスはrvalueもバインドできる</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;&amp;</span> a_ref2 <span class="op">=</span> <span class="dt">int</span><span class="op">{</span><span class="dv">99</span><span class="op">};</span>       <span class="co">// rvalueリファレンスはテンポラリオブジェクトをバインドできる</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;</span> a_ref3 <span class="op">=</span> a_ref2<span class="op">;</span>         <span class="co">// rvalueリファレンス型の変数は、lvalueリファレンスでバインドできる</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a><span class="co">    int&amp;&amp; a_ref4 = a_ref2;       以下のメッセージでコンパイルエラー</span></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a><span class="co">                                 cannot bind rvalue reference of type ‘int&amp;&amp;’ to lvalue of type ‘int’ </span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a><span class="co">                                 rvalueリファレンス型の変数(lvalue)は、rvalueリファレンスでバインドできない */</span></span></code></pre></div>
<p>このようなリファレンスのバインドの可否はオーバーロードにも影響を与える。</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_lvalue_ut.cpp 118</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span><span class="op">&amp;)</span>       <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span> <span class="co">// f-1</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> <span class="at">const</span><span class="op">&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span> <span class="co">// f-2</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span><span class="op">&amp;&amp;)</span>      <span class="op">{</span> <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span> <span class="op">}</span> <span class="co">// f-3</span></span></code></pre></div>
<div class="sourceCode" id="cb129"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_lvalue_ut.cpp 129</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>       a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="at">const</span> b <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> f<span class="op">(</span>a<span class="op">));</span>                           <span class="co">// f-1の呼び出し</span></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> f<span class="op">(</span>b<span class="op">));</span>                           <span class="co">// f-2の呼び出し、constなlvalueリファレンスのバインド</span></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> f<span class="op">(</span><span class="dt">int</span><span class="op">{}));</span>                       <span class="co">// f-3の呼び出し(f-3が無ければ、f-2を呼ばれる)</span></span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> f<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span> <span class="at">const</span><span class="op">&amp;&gt;(</span>a<span class="op">)));</span>  <span class="co">// aをconstリファレンスにキャストして、強制的にf-2の呼び出し</span></span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> f<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&amp;&gt;(</span>a<span class="op">)));</span>       <span class="co">// aをrvalueリファレンスにキャストして、強制的にf-3の呼び出し</span></span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> f<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>a<span class="op">)));</span>                <span class="co">// f-3の呼び出し</span></span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-13"><a href="#cb129-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;&amp;</span> ref_ref <span class="op">=</span> <span class="dt">int</span><span class="op">{};</span></span>
<span id="cb129-14"><a href="#cb129-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-15"><a href="#cb129-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> f<span class="op">(</span>ref_ref<span class="op">));</span>                     <span class="co">// f-3ではなくf-1を呼び出す。従って間違いなくこのテストはパスする</span></span></code></pre></div>
<p>上記コードの最後の部分の抜粋である以下のコードについては、少々解説が必要だろう。</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_lvalue_ut.cpp 141</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">&amp;&amp;</span> ref_ref <span class="op">=</span> <span class="dt">int</span><span class="op">{};</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> f<span class="op">(</span>ref_ref<span class="op">));</span>                     <span class="co">// f-3ではなくf-1を呼び出す。従って間違いなくこのテストはパスする</span></span></code></pre></div>
<p>ref_refの型は<code>int &amp;&amp;</code>であるが、ref_refの値カテゴリは<a
href="core_lang_spec.html#SS_19_7_1_2">rvalue</a>ではなく、<a
href="core_lang_spec.html#SS_19_7_1_1">lvalue</a>である。
そのため、<code>f(ref_ref)</code>はlvalueリファレンスを引数とするf-1が選択される。</p>
<p>rvalueリファレンス型の仮引数（<code>T&amp;&amp;</code>）を持つ関数は、ムーブコンストラクタやムーブ代入演算子など頻繁に使用される。
しかし、関数内では仮引数は名前を持つため、常にlvalueとして扱われる。
この動作を理解することは、 <a
href="cpp_idioms.html#SS_21_3_3">moveセマンティクス</a>や<a
href="core_lang_spec.html#SS_19_8_5">perfect
forwarding</a>を正しく実装/使用するために極めて重要である。</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_lvalue_ut.cpp 150</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> g<span class="op">(</span><span class="dt">int</span><span class="op">&amp;&amp;</span> a<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> f<span class="op">(</span>a<span class="op">);</span> <span class="op">}</span>            <span class="co">// g-1    仮引数aはlvalue -&gt; f-1が呼ばれる</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> g<span class="op">(</span><span class="dt">int</span><span class="op">&amp;</span> a<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> f<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>a<span class="op">));</span> <span class="op">}</span>  <span class="co">// g-2    std::moveでrvalueに変換 -&gt; f-3が呼ばれる</span></span></code></pre></div>
<div class="sourceCode" id="cb132"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_lvalue_ut.cpp 158</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> g<span class="op">(</span><span class="dt">int</span><span class="op">{}));</span>  <span class="co">// int{}はrvalue -&gt; g-1が呼ばれ、内部でf-1が呼ばれる</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">{};</span></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> g<span class="op">(</span>a<span class="op">));</span>  <span class="co">// aはlvalue -&gt; g-2が呼ばれ、内部でf-3が呼ばれる</span></span></code></pre></div>
<hr />
<p>C++11でrvalueの概念の整理やrvalueリファレンス、
std::move()の導入が行われた目的はプログラム実行速度の向上である。
以下のパターンの代入式の処理がどのように違うのかを見ることでrvalueやstd::moveの効果について説明する。</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_8_2_1">lvalueからの代入</a></li>
<li><a href="core_lang_spec.html#SS_19_8_2_2">rvalueからの代入</a></li>
<li><a
href="core_lang_spec.html#SS_19_8_2_3">std::move(lvalue)からの代入</a></li>
</ul>
<h4 id="lvalueからの代入">lvalueからの代入 <a id="SS_19_8_2_1"></a></h4>
<p>下記コードにより「<a
href="core_lang_spec.html#SS_19_7_1_1">lvalue</a>からの代入」を説明する。</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_move_ut.cpp 10</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str0 <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{};</span>        <span class="co">// 行１   str0はlvalue</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str1 <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;hehe&quot;</span><span class="op">};</span>  <span class="co">// 行２   str1もlvalue</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>    str0      <span class="op">=</span> str1<span class="op">;</span>                 <span class="co">// 行３   lvalueからの代入</span></span></code></pre></div>
<ul>
<li><p>行１、２<br />
str0、str1がそれぞれ初期化される
(“hehe”を保持するバッファが生成され、それをstr1オブジェクトが所有する)。</p></li>
<li><p>行３<br />
str1が所有している文字列バッファと同じ内容を持つ新しいバッファが確保され、
その内容がコピーされstr0がそれを所有する。従って、“hehe”を保持するバッファが2つできる。この代入をcopy代入と呼ぶ。</p></li>
</ul>
<!-- pu:essential/plant_uml/rvalue_from_lvalue.pu-->
<p>
<img src="data:image/png;base64,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" />
</p>
<h4 id="rvalueからの代入">rvalueからの代入 <a id="SS_19_8_2_2"></a></h4>
<p>下記コードにより「<a
href="core_lang_spec.html#SS_19_7_1_2">rvalue</a>からの代入」を説明する。</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_move_ut.cpp 23</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str0 <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{};</span>        <span class="co">// 行１   str0はlvalue</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>    str0      <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;hehe&quot;</span><span class="op">};</span>  <span class="co">// 行２   rvalueからの代入</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>                                      <span class="co">// 行３   行２で生成されたテンポラリオブジェクト(rvalue)は解放</span></span></code></pre></div>
<ul>
<li><p>行１<br />
str0が「std::string()により作られたテンポラリオブジェクト」により初期化される。</p></li>
<li><p>行２の右辺<br />
「“hehe”を保持するをstd::stringテンポラリオブジェクトが生成される。</p></li>
<li><p>行２の左辺<br />
この例の場合、std::stringがmoveコンストラクタ／move代入演算子を提供しているため、
下記図のようなバッファの所有が移し替えられるだけである(この代入をmove代入と呼ぶ)。</p></li>
<li><p>行３<br />
テンポラリオブジェクトが解体されるが、heheバッファはstr0の所有になったためdeleteする必要がなく、
実際には何もしない。move代入によって、文字列バッファの生成と破棄の回数がそれぞれ1回少なくなったため、
実行速度は向上する(通常、new/deleteの処理コストは高い)。</p></li>
</ul>
<!-- pu:essential/plant_uml/rvalue_from_rvalue.pu-->
<p>
<img src="data:image/png;base64,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kMriGZOrVq3q27fvwoULP/zwQ/1crffee2/ChAkFBQXf//73586dG35qy5Ytp59++jXXXNO+ffsZM2b06tVr1KhRR44ckUtdffXVP/jBD0477bSrw8jbkle99NJL7777bk1NzR133DFv3jzZX0oGFxYWhl8ZOEXEJJDK4hmTlZWVb7/9tqTdnDlzBoYZMWKEVnndddeFx+Thw4fPOussydeDBw9mZmZK2pWVlXXr1k22j05Bbm5u5I8llN3kgw8+uHHjRumPHDly5cqV0rnkkkuKioq0SuBUEJNAKotnTH766aeyC/zlL38pIbe11i233HLjjTdqX0F85513unTpsm/fPjXy1ltvderUSfaOGzZsyMnJcQZvuummiRMnSueTTz5p3rz5v//7v48JEwqF8vLyfvSjHznxKW/X2cIOGDCgpKREXRk4dcQkkMriGZOy+ZO946RJk9SIZFj44dHazDvzzDNXr14dPvj666+fc845R2vrb731VmdwyJAhDz30UHV19f/7f/9P4nbp0qU/+9nPJCyX1pKdq9RMnz5dXrJq1SoVrrIHLS8vP3ZhIA6ISSCVxTMmxbx58+qJydLS0j59+ixZskT6sndU4wcOHGjfvv2aNWt69+6dn58vpx555JGWLVvu3r37iSee+Ld/+7fDhw87V5NcVK86WhuTd999d3Z29vr16++6665BgwadffbZ4QXAqSMmgVSWwJjcsGHD6NGjJb3U2WnTpqWnp7dq1app06Y/+MEP1Lh44YUXsrKyhg0btmnTpjPOOKNr167ON7tKZC5YsGBerR//+MdS4PRfeuklub7Eavfu3a+++uopU6aMHz/+qquukrcuyRp+ZeAUEZNAKotzTC5btkx9b86oUaMkC2Wfd3xJAw4dOvTaa68520fHrFmzJkX4y1/+smXLlqVLl37++eePP/74nXfeecsttzhftpT3Iex6wKkiJoFUFueYBOxDTAKpjJgEGkBMAqmMmAQaQEwCqYyYBBpATAKpjJgEGkBMAqmMmAQaQEwCqYyYBBpATAKpjJgEGkBMAqmMmAQaQEwCqYyYBBpATAKpzKqYzMrKCsBeMr/6lCdFwKOYbN+4kf4hgEW8ep4RK6tiUp48dRewj8xvKBSqqKiorKysrq6uqanRn4DECHgUk/J2y7/Xk2Zr8+p5RqzcJUj19BJzEJN2k/kNBoOl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" />
</p>
<h4 id="stdmovelvalueからの代入">std::move(lvalue)からの代入
<a id="SS_19_8_2_3"></a></h4>
<p>下記コードにより「std::move(lvalue)からの代入」を説明する。</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/rvalue_move_ut.cpp 36</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str0 <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{};</span>        <span class="co">// 行１   str0はlvalue</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str1 <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;hehe&quot;</span><span class="op">};</span>  <span class="co">// 行２   str1もlvalue</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>    str0      <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>str1<span class="op">);</span>      <span class="co">// 行３   str1への代入以外のアクセスは未規定である。</span></span></code></pre></div>
<ul>
<li><p>行１<br />
「<a
href="core_lang_spec.html#SS_19_8_2_1">lvalueからの代入</a>」の行１と同じである。</p></li>
<li><p>行２<br />
「<a
href="core_lang_spec.html#SS_19_8_2_1">lvalueからの代入</a>」の行２と同じである。</p></li>
<li><p>行３<br />
std::moveは単にrvalueリファレンスへのキャストを行うだけであり、ランタイム時の処理コストは発生しない。
この例の場合、std::stringがmoveコンストラクタ／move代入演算子を提供しているため、
下記図のようなバッファの所有が移し替えられるだけである(この代入もmove代入と呼ぶ)。
この動作は「<a
href="core_lang_spec.html#SS_19_8_2_2">rvalueからの代入</a>の行２の左辺」と同じであり、同様に速度が向上するが、その副作用として、
str1への代入以外のアクセスは<a
href="core_lang_spec.html#SS_19_14_4">未規定動作</a>であるため、避けるべきである
(多くの実装では、str1.size() ==
0となることが多いがこの動作は約束されない)。</p></li>
</ul>
<!-- pu:essential/plant_uml/rvalue_from_move.pu-->
<p>
<img src="data:image/png;base64,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" />
</p>
<h3 id="forwardingリファレンス">forwardingリファレンス
<a id="SS_19_8_3"></a></h3>
<p>関数テンプレートの型パラメータTに対して<code>T&amp;&amp;</code>として宣言された仮引数、
または型推論を伴うauto&amp;&amp;として宣言された変数を、forwardingリファレンスと呼ぶ
(この概念はC++14から存在し、慣用的にユニバーサルリファレンスと呼ばれていたが、
C++17から正式にforwardingリファレンスと命名された)。
forwardingリファレンスは一見rvalueリファレンスのように見えるが、
下記に示す通り、lvalueにもrvalueにもバインドできる (<a
href="core_lang_spec.html#SS_19_8_6">リファレンスcollapsing</a>により、このようなバインドが可能になる)。</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/universal_ref_ut.cpp 8</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span>T<span class="op">&amp;&amp;</span> t<span class="op">)</span> <span class="kw">noexcept</span>  <span class="co">// tはforwardingリファレンス</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> g<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;&amp;</span> t<span class="op">)</span> <span class="kw">noexcept</span>  <span class="co">// tはrvalueリファレンス</span></span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb137"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/universal_ref_ut.cpp 29</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>       vec  <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;lvalue&quot;</span><span class="op">};</span>   <span class="co">// vecはlvalue</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> cvec <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;clvalue&quot;</span><span class="op">};</span>  <span class="co">// cvecはconstなlvalue</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(</span>vec<span class="op">);</span>                                 <span class="co">// 引数はlvalue</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(</span>cvec<span class="op">);</span>                                <span class="co">// 引数はconstなlvalue</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;rvalue&quot;</span><span class="op">});</span>  <span class="co">// 引数はrvalue</span></span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// g(vec);  // 引数がlvalueなのでコンパイルエラー</span></span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// g(cvec); // 引数がconst lvalueなのでコンパイルエラー</span></span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a>    g<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;rvalue&quot;</span><span class="op">});</span>  <span class="co">// 引数はrvalue</span></span></code></pre></div>
<p>下記のコードは<a
href="core_lang_spec.html#SS_19_11_6">ジェネリックラムダ</a>の引数をforwardingリファレンスにした例である。</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/universal_ref_ut.cpp 47</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sはforwardingリファレンス</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="dt">value_type</span> <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> s<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>s<span class="op">)&gt;)</span> <span class="op">{</span></span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>s<span class="op">)&gt;)</span> <span class="op">{</span></span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&amp;&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>s<span class="op">)&gt;)</span> <span class="op">{</span></span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb138-14"><a href="#cb138-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb138-15"><a href="#cb138-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb138-16"><a href="#cb138-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-17"><a href="#cb138-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>       str  <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;lvalue&quot;</span><span class="op">};</span></span>
<span id="cb138-18"><a href="#cb138-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> cstr <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;const lvalue&quot;</span><span class="op">};</span></span>
<span id="cb138-19"><a href="#cb138-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-20"><a href="#cb138-20" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dt">value_type</span><span class="op">(</span>str<span class="op">));</span></span>
<span id="cb138-21"><a href="#cb138-21" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dt">value_type</span><span class="op">(</span>cstr<span class="op">));</span></span>
<span id="cb138-22"><a href="#cb138-22" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dt">value_type</span><span class="op">(</span><span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;rvalue&quot;</span><span class="op">}));</span></span></code></pre></div>
<p>通常、forwardingリファレンスはstd::forwardと組み合わせて使用される。</p>
<h3 id="ユニバーサルリファレンス">ユニバーサルリファレンス
<a id="SS_19_8_4"></a></h3>
<p>ユニバーサルリファレンスとは、「<a
href="core_lang_spec.html#SS_19_8_3">forwardingリファレンス</a>」の通称、もしくは旧称である。</p>
<h3 id="perfect-forwarding">perfect forwarding
<a id="SS_19_8_5"></a></h3>
<p>perfect forwarding(完全転送)とは、引数の<a
href="core_lang_spec.html#SS_19_7_1_2">rvalue</a>性や <a
href="core_lang_spec.html#SS_19_7_1_1">lvalue</a>性を損失することなく、
その引数を別の関数に転送する技術のことを指す。 通常は、<a
href="core_lang_spec.html#SS_19_8_3">forwardingリファレンス</a>である関数の仮引数をstd::forwardを用いて、
他の関数に渡すことで実現される。</p>
<p>perfect forwardingの使用例を以下に示す。</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/perfect_forwarding_ut.cpp 7</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Widget <span class="op">{</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> Widget<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> name<span class="op">)</span> <span class="op">:</span> <span class="va">name_</span><span class="op">{</span>name<span class="op">}</span> <span class="op">{}</span>        <span class="co">// lvalueによるコンストラクタ</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> Widget<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> name<span class="op">)</span> <span class="op">:</span> <span class="va">name_</span><span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>name<span class="op">)}</span> <span class="op">{}</span>  <span class="co">// rvalueによるコンストラクタ</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> GetName<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">name_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="va">name_</span><span class="op">;</span>  <span class="co">// コンストラクタの引数をcopy/move構築</span></span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-13"><a href="#cb139-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb139-14"><a href="#cb139-14" aria-hidden="true" tabindex="-1"></a>    Widget make_Widget<span class="op">(</span>T<span class="op">&amp;&amp;</span> str<span class="op">)</span></span>
<span id="cb139-15"><a href="#cb139-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>                                         <span class="co">// strはforwardingリファレンス</span></span>
<span id="cb139-16"><a href="#cb139-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Widget<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>str<span class="op">));</span>  <span class="co">// perfect forwarding</span></span>
<span id="cb139-17"><a href="#cb139-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb140"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/perfect_forwarding_ut.cpp 28</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string       str<span class="op">{</span><span class="st">&quot;lvalue ref&quot;</span><span class="op">};</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string <span class="at">const</span> cstr<span class="op">{</span><span class="st">&quot;lvalue const ref&quot;</span><span class="op">};</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>    Widget w0 <span class="op">=</span> make_Widget<span class="op">(</span>str<span class="op">);</span>  <span class="co">// make_Widget -&gt; Widget(std::string const&amp;)</span></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>w0<span class="op">.</span>GetName<span class="op">(),</span> str<span class="op">);</span></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a>    Widget w1 <span class="op">=</span> make_Widget<span class="op">(</span>cstr<span class="op">);</span>  <span class="co">// make_Widget -&gt; Widget(std::string const&amp;)</span></span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>w1<span class="op">.</span>GetName<span class="op">(),</span> cstr<span class="op">);</span></span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a>    Widget w2 <span class="op">=</span> make_Widget<span class="op">(</span><span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;rvalue ref&quot;</span><span class="op">});</span>  <span class="co">// make_Widget -&gt; Widget(std::string &amp;&amp;)</span></span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>w2<span class="op">.</span>GetName<span class="op">(),</span> <span class="st">&quot;rvalue ref&quot;</span><span class="op">);</span></span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true" tabindex="-1"></a>    Widget w3 <span class="op">=</span> make_Widget<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>str<span class="op">));</span>  <span class="co">// make_Widget -&gt; Widget(std::string &amp;&amp;)</span></span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>w3<span class="op">.</span>GetName<span class="op">(),</span> <span class="st">&quot;lvalue ref&quot;</span><span class="op">);</span>    <span class="co">// strはムーブされたのでアクセス不可</span></span></code></pre></div>
<h3 id="リファレンスcollapsing">リファレンスcollapsing
<a id="SS_19_8_6"></a></h3>
<p>Tを任意の型とし、TRを下記のように宣言した場合、</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> TR <span class="op">=</span> T<span class="op">&amp;;</span></span></code></pre></div>
<p>下記のようなコードは、C++03ではコンパイルエラーとなったが、
C++11からはエラーとならず、TRRはT&amp;となる。</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> TRR <span class="op">=</span> TR<span class="op">&amp;;</span></span></code></pre></div>
<p>2つの&amp;を1つに折り畳む、このような機能をリファレンスcollapsingと呼ぶ。</p>
<p>下記はTをintとした場合のリファレンスcollapsingの動きを示している。</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/ref_collapsing_ut.cpp 7</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> IR  <span class="op">=</span> <span class="dt">int</span><span class="op">&amp;;</span></span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> IRR <span class="op">=</span> IR<span class="op">&amp;;</span>  <span class="co">// IRRはint&amp; &amp;となり、int&amp;に変換される</span></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a>    IR  ir  <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a>    IRR irr <span class="op">=</span> ir<span class="op">;</span></span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>ir<span class="op">)&gt;);</span>   <span class="co">// lvalueリファレンス</span></span>
<span id="cb143-12"><a href="#cb143-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>irr<span class="op">)&gt;);</span>  <span class="co">// lvalueリファレンス</span></span></code></pre></div>
<p>リファレンスcollapsingは、型エイリアス、型であるテンプレートパラメータ、decltypeに対して行われる。
詳細な変換則は、下記のようになる。</p>
<pre><code>    T&amp; &amp;   -&gt; T&amp;
    T&amp; &amp;&amp;  -&gt; T&amp;
    T&amp;&amp; &amp;  -&gt; T&amp;
    T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp;</code></pre>
<p>下記のようなクラステンプレートを定義した場合、</p>
<div class="sourceCode" id="cb145"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/ref_collapsing_ut.cpp 26</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Ref <span class="op">{</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a>        T<span class="op">&amp;</span>  t<span class="op">;</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>        T<span class="op">&amp;&amp;</span> u<span class="op">;</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>下記のコードにより、テンプレートパラメータに対するこの変換則を確かめることができる。</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/ref_collapsing_ut.cpp 38</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>Ref<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>t<span class="op">)&gt;);</span>    <span class="co">// lvalueリファレンス</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>Ref<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>u<span class="op">)&gt;);</span>   <span class="co">// rvalueリファレンス</span></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>Ref<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&gt;::</span>t<span class="op">)&gt;);</span>   <span class="co">// lvalueリファレンス</span></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>Ref<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&gt;::</span>u<span class="op">)&gt;);</span>   <span class="co">// lvalueリファレンス</span></span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>Ref<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&amp;&gt;::</span>t<span class="op">)&gt;);</span>  <span class="co">// lvalueリファレンス</span></span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>Ref<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&amp;&gt;::</span>u<span class="op">)&gt;);</span> <span class="co">// rvalueリファレンス</span></span></code></pre></div>
<p>この機能がないC++03では、</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/ref_collapsing_ut.cpp 52</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> AddRef <span class="op">{</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> T<span class="op">&amp;;</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>ようなクラステンプレートに下記コードのようにリファレンス型を渡すとコンパイルエラーとなる。</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/ref_collapsing_ut.cpp 69</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> AddRef<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;&gt;::</span>type<span class="op">&gt;);</span></span></code></pre></div>
<p>この問題を回避するためには下記のようなテンプレートの特殊化が必要になる。</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/ref_collapsing_ut.cpp 59</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> AddRef<span class="op">&lt;</span>T<span class="op">&amp;&gt;</span> <span class="op">{</span></span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> T<span class="op">&amp;;</span></span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>上記したようなクラステンプレートでのメンバエイリアスの宣言は、 <a
href="https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88%E3%83%A1%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">テンプレートメタプログラミング</a>
で頻繁に使用されるため、
このようなテンプレートの特殊化を不要にするリファレンスcollapsingは、
有用な機能拡張であると言える。</p>
<h3 id="リファレンス修飾">リファレンス修飾 <a id="SS_19_8_7"></a></h3>
<p><a href="core_lang_spec.html#SS_19_8_7_1">rvalue修飾</a>と<a
href="core_lang_spec.html#SS_19_8_7_2">lvalue修飾</a>とを併せて、リファレンス修飾と呼ぶ。</p>
<h4 id="rvalue修飾">rvalue修飾 <a id="SS_19_8_7_1"></a></h4>
<p>下記GetString0()のような関数が返すオブジェクトの内部メンバに対する<a
href="cpp_idioms.html#SS_21_9_6">ハンドル</a>は、
オブジェクトのライフタイム終了後にもアクセスすることができるため、
そのハンドルを通じて、
ライフタイム終了後のオブジェクトのメンバオブジェクトにもアクセスできてしまう。</p>
<p>ライフタイム終了後のオブジェクトにアクセスすることは未定義動作であり、
特にそのオブジェクトがrvalueであった場合、さらにその危険性は高まる。</p>
<p>こういったコードに対処するためのシンタックスが、lvalue修飾、rvalue修飾である。</p>
<p>下記GetString1()、GetString3()、GetString4()のようにメンバ関数をlvalue修飾やrvalue修飾することで、
rvalueの内部ハンドルを返さないようにすることが可能となり、上記の危険性を緩和することができる。</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/ref_qualifiers_ut.cpp 8</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> C <span class="op">{</span></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> C<span class="op">(</span><span class="dt">char</span> <span class="at">const</span><span class="op">*</span> str<span class="op">)</span> <span class="op">:</span> <span class="va">str_</span><span class="op">{</span>str<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// lvalue修飾なし、rvalue修飾なし</span></span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string<span class="op">&amp;</span> GetString0<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">str_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-10"><a href="#cb150-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// lvalue修飾</span></span>
<span id="cb150-11"><a href="#cb150-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> GetString1<span class="op">()</span> <span class="at">const</span><span class="op">&amp;</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">str_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb150-12"><a href="#cb150-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-13"><a href="#cb150-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// rvalue修飾</span></span>
<span id="cb150-14"><a href="#cb150-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// *thisがrvalueの場合でのGetString1()の呼び出しは、この関数を呼び出すため、</span></span>
<span id="cb150-15"><a href="#cb150-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// class内部のハンドルを返してはならない。</span></span>
<span id="cb150-16"><a href="#cb150-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// また、それによりstd::stringを生成するため、noexcept指定してはならない。</span></span>
<span id="cb150-17"><a href="#cb150-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string GetString1<span class="op">()</span> <span class="at">const</span><span class="op">&amp;&amp;</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">str_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb150-18"><a href="#cb150-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-19"><a href="#cb150-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// lvalue修飾だが、const関数はrvalueからでも呼び出せる。</span></span>
<span id="cb150-20"><a href="#cb150-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// rvalueに対しての呼び出しを禁止したい場合には、GetString4のようにする。</span></span>
<span id="cb150-21"><a href="#cb150-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> GetString2<span class="op">()</span> <span class="at">const</span><span class="op">&amp;</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">str_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb150-22"><a href="#cb150-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-23"><a href="#cb150-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// lvalue修飾</span></span>
<span id="cb150-24"><a href="#cb150-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 非constなのでrvalueからは呼び出せない。</span></span>
<span id="cb150-25"><a href="#cb150-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> GetString3<span class="op">()</span> <span class="op">&amp;</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">str_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb150-26"><a href="#cb150-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-27"><a href="#cb150-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// lvalue修飾</span></span>
<span id="cb150-28"><a href="#cb150-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> GetString4<span class="op">()</span> <span class="at">const</span><span class="op">&amp;</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">str_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb150-29"><a href="#cb150-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-30"><a href="#cb150-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// rvalue修飾</span></span>
<span id="cb150-31"><a href="#cb150-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">// rvalueからこの関数を呼び出されるとrvalueオブジェクトの内部ハンドルを返してしまい、</span></span>
<span id="cb150-32"><a href="#cb150-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 危険なので=deleteすべき。</span></span>
<span id="cb150-33"><a href="#cb150-33" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> GetString4<span class="op">()</span> <span class="at">const</span><span class="op">&amp;&amp;</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb150-34"><a href="#cb150-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-35"><a href="#cb150-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb150-36"><a href="#cb150-36" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="va">str_</span><span class="op">;</span></span>
<span id="cb150-37"><a href="#cb150-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb151"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/ref_qualifiers_ut.cpp 49</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>        c    <span class="op">=</span> C<span class="op">{</span><span class="st">&quot;c0&quot;</span><span class="op">};</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> s0_0 <span class="op">=</span> c<span class="op">.</span>GetString0<span class="op">();</span>        <span class="co">// OK cが解放されるまでs0_0は有効</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>        s0_1 <span class="op">=</span> C<span class="op">{</span><span class="st">&quot;c1&quot;</span><span class="op">}.</span>GetString0<span class="op">();</span>  <span class="co">// NG 危険なコード</span></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// s0_1が指すオブジェクトは、次の行で無効になる</span></span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> s1_0 <span class="op">=</span> c<span class="op">.</span>GetString1<span class="op">();</span>        <span class="co">// OK GetString1()&amp;が呼び出される</span></span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> s1_1 <span class="op">=</span> C<span class="op">{</span><span class="st">&quot;c1&quot;</span><span class="op">}.</span>GetString1<span class="op">();</span>  <span class="co">// OK GetString1()&amp;&amp;が呼び出される</span></span>
<span id="cb151-10"><a href="#cb151-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// s1_0が指すrvalueはs1_0がスコープアウトするまで有効</span></span>
<span id="cb151-11"><a href="#cb151-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-12"><a href="#cb151-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> s2_0 <span class="op">=</span> c<span class="op">.</span>GetString2<span class="op">();</span>        <span class="co">// OK GetString2()&amp;が呼び出される</span></span>
<span id="cb151-13"><a href="#cb151-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> s2_1 <span class="op">=</span> C<span class="op">{</span><span class="st">&quot;c1&quot;</span><span class="op">}.</span>GetString2<span class="op">();</span>  <span class="co">// NG const関数はlvalue修飾しても呼び出し可能</span></span>
<span id="cb151-14"><a href="#cb151-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// s2_1が指すオブジェクトは、次の行で無効になる</span></span>
<span id="cb151-15"><a href="#cb151-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-16"><a href="#cb151-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> s3_0 <span class="op">=</span> c<span class="op">.</span>GetString3<span class="op">();</span>  <span class="co">// OK GetString3()&amp;が呼び出される</span></span>
<span id="cb151-17"><a href="#cb151-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// auto const&amp; s3_1 = C{&quot;c1&quot;}.GetString3();  // 危険なのでコンパイルさせない</span></span>
<span id="cb151-18"><a href="#cb151-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-19"><a href="#cb151-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> s4_0 <span class="op">=</span> c<span class="op">.</span>GetString4<span class="op">();</span>  <span class="co">// OK GetString4()&amp;が呼び出される</span></span>
<span id="cb151-20"><a href="#cb151-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// auto const&amp; s4_1 = C{&quot;c1&quot;}.GetString4();  // 危険なのでコンパイルさせない</span></span></code></pre></div>
<h4 id="lvalue修飾">lvalue修飾 <a id="SS_19_8_7_2"></a></h4>
<p><a
href="core_lang_spec.html#SS_19_8_7_1">rvalue修飾</a>を参照せよ。</p>
<h2 id="構文と制御構造">構文と制御構造 <a id="SS_19_9"></a></h2>
<h3 id="属性構文">属性構文 <a id="SS_19_9_1"></a></h3>
<p>C++14から導入されたの属性構文は、[[属性名]]の形式で記述され、
特定のコード要素に対する追加情報やコンパイラへの指示を与えるためのものである。</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 7%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>属性</th>
<th>C++Ver</th>
<th>効果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>[[noreturn]]</td>
<td>C++11</td>
<td>関数が決して返らないことを示す</td>
</tr>
<tr class="even">
<td>[[deprecated]]</td>
<td>C++14</td>
<td>関数や変数が非推奨であることを示しめす</td>
</tr>
<tr class="odd">
<td>[[maybe_unused]]</td>
<td>C++17</td>
<td>変数や関数が未使用である警告の抑止</td>
</tr>
<tr class="even">
<td>[[nodiscard]]</td>
<td>C++17</td>
<td>戻り値が無視されると警告</td>
</tr>
<tr class="odd">
<td>[[fallthrough]]</td>
<td>C++14</td>
<td>switch文のfallthroughの警告抑止</td>
</tr>
<tr class="even">
<td>[[no_unique_address]]</td>
<td>C++20</td>
<td>クラスや構造体のメンバに対して、メモリの最適化促進</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb152"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/attr_ut.cpp 10</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 非推奨の関数</span></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">[[</span><span class="at">deprecated</span><span class="op">(</span><span class="st">&quot;この関数は非推奨です。代わりに newFunction を使用してください。&quot;</span><span class="op">)]]</span>  <span class="co">// </span></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> oldFunction<span class="op">();</span>  <span class="co">// この関数を呼び出すと警告される</span></span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> newFunction<span class="op">();</span></span></code></pre></div>
<div class="sourceCode" id="cb153"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/attr_ut.cpp 20</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> processValues<span class="op">()</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">[[</span><span class="at">maybe_unused</span><span class="op">]]</span> <span class="dt">int</span> unusedValue <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>  <span class="co">// 使用しない変数でも警告が出ない</span></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// do something</span></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb154"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/attr_ut.cpp 28</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">int</span> computeResult<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">42</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/attr_ut.cpp 38</span></span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a>    computeResult<span class="op">();</span>               <span class="co">// 警告が出る：戻り値が無視されている</span></span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> computeResult<span class="op">();</span>  <span class="co">// これはOK</span></span></code></pre></div>
<div class="sourceCode" id="cb155"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/attr_ut.cpp 54</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// do something</span></span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">[[</span><span class="at">fallthrough</span><span class="op">]];</span>  <span class="co">// 明示的に fallthrough を宣言することができる</span></span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb155-8"><a href="#cb155-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// do something</span></span>
<span id="cb155-9"><a href="#cb155-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb155-10"><a href="#cb155-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb155-11"><a href="#cb155-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb155-12"><a href="#cb155-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="関数tryブロック">関数tryブロック <a id="SS_19_9_2"></a></h3>
<p>関数tryブロックとはtry-catchを本体とした下記のような関数のブロックを指す。</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/func_try_block.cpp 8</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> function_try_block<span class="op">()</span></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> <span class="op">{</span>  <span class="co">// 関数tryブロック</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 何らかの処理</span></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>length_error <span class="at">const</span><span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span>  <span class="co">// 関数tryブロックのエクセプションハンドラ</span></span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb156-11"><a href="#cb156-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>logic_error <span class="at">const</span><span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span>  <span class="co">// 関数tryブロックのエクセプションハンドラ</span></span>
<span id="cb156-12"><a href="#cb156-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb156-13"><a href="#cb156-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="範囲for文">範囲for文 <a id="SS_19_9_3"></a></h3>
<p>範囲for文は、</p>
<div class="sourceCode" id="cb157"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span> <span class="cf">for</span><span class="op">-</span>range<span class="op">-</span>declaration <span class="op">:</span> <span class="cf">for</span><span class="op">-</span>range<span class="op">-</span>initializer <span class="op">)</span> statement</span></code></pre></div>
<p>このような形式で表され、C++17までは下記のような疑似コードに展開される。</p>
<div class="sourceCode" id="cb158"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="op">&amp;&amp;</span> __range <span class="op">=</span> <span class="cf">for</span><span class="op">-</span>range<span class="op">-</span>initializer<span class="op">;</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span> <span class="kw">auto</span> __begin <span class="op">=</span> begin<span class="op">-</span>expr<span class="op">,</span> __end <span class="op">=</span> end<span class="op">-</span>expr<span class="op">;</span> __begin <span class="op">!=</span> __end<span class="op">;</span> <span class="op">++</span>__begin <span class="op">)</span> <span class="op">{</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">-</span>range<span class="op">-</span>declaration <span class="op">=</span> <span class="op">*</span>__begin<span class="op">;</span></span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>        statement</span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>単純な範囲for文の使用例は下記の通りである。</p>
<div class="sourceCode" id="cb159"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/range_for_ut.cpp 14</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> list <span class="op">=</span> <span class="bu">std::</span>list<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> oss  <span class="op">=</span> <span class="bu">std::</span>stringstream<span class="op">{};</span></span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> a <span class="op">:</span> list<span class="op">)</span> <span class="op">{</span>  <span class="co">// 範囲for文</span></span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> a<span class="op">;</span></span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>oss<span class="op">.</span>str<span class="op">(),</span> <span class="st">&quot;123&quot;</span><span class="op">);</span></span></code></pre></div>
<p>上記のコードは下記のように展開される。</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/range_for_ut.cpp 26</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> list <span class="op">=</span> <span class="bu">std::</span>list<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> oss  <span class="op">=</span> <span class="bu">std::</span>stringstream<span class="op">{};</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::begin(list)、std::end(list)の戻り型が同一</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>list<span class="op">)),</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>end<span class="op">(</span>list<span class="op">))&gt;);</span></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 上記の範囲for文は下記のように展開される</span></span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> <span class="bu">std::</span>begin<span class="op">(</span>list<span class="op">);</span> it <span class="op">!=</span> <span class="bu">std::</span>end<span class="op">(</span>list<span class="op">);</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> <span class="op">*</span>it<span class="op">;</span></span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb160-13"><a href="#cb160-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-14"><a href="#cb160-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>oss<span class="op">.</span>str<span class="op">(),</span> <span class="st">&quot;123&quot;</span><span class="op">);</span></span></code></pre></div>
<p>C++17以前は、上記のコードのコメントにある通り、<code>__begin</code>と<code>__end</code>が同一の型である前提であった。
C++17以降は、この規制が緩和されたため、以下のように展開されることになった。</p>
<div class="sourceCode" id="cb161"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="op">&amp;&amp;</span> __range <span class="op">=</span> <span class="cf">for</span><span class="op">-</span>range<span class="op">-</span>initializer<span class="op">;</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> __begin <span class="op">=</span> begin<span class="op">-</span>expr<span class="op">;</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> __end <span class="op">=</span> end<span class="op">-</span>expr<span class="op">;</span>     <span class="co">// C++17までは、__begin と __endは同一である前提</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span> <span class="op">;</span> __begin <span class="op">!=</span> __end<span class="op">;</span> <span class="op">++</span>__begin <span class="op">)</span> <span class="op">{</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">-</span>range<span class="op">-</span>declaration <span class="op">=</span> <span class="op">*</span>__begin<span class="op">;</span></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>            statement</span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>この規制緩和により、以下のようなコードが範囲for文で記述できるようになった。
下記のコードはこの緩和ルールの応用例である。</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/range_for_ut.cpp 73</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>    delimited_string<span class="op">&lt;</span><span class="ch">&#39;,&#39;</span><span class="op">&gt;</span> delimited_str<span class="op">{</span><span class="st">&quot;Hello,World&quot;</span><span class="op">};</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostringstream    oss<span class="op">;</span></span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// &#39;,&#39; を終了文字として &quot;Hello&quot; だけをループして出力</span></span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> c <span class="op">:</span> delimited_str<span class="op">)</span> <span class="op">{</span></span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> c<span class="op">;</span></span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;Hello&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span>  <span class="co">// 結果は &quot;Hello&quot; になるはず</span></span></code></pre></div>
<p>上記のコードは下記のように展開される。</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/range_for_ut.cpp 87</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>    delimited_string<span class="op">&lt;</span><span class="ch">&#39;,&#39;</span><span class="op">&gt;</span> delimited_str<span class="op">{</span><span class="st">&quot;Hello,World&quot;</span><span class="op">};</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostringstream    oss<span class="op">;</span></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// &#39;,&#39; を終了文字として&quot;Hello&quot; だけをループして出力</span></span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> delimited_str<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> delimited_str<span class="op">.</span>end<span class="op">();</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> <span class="op">*</span>it<span class="op">;</span></span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-11"><a href="#cb163-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;Hello&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span>  <span class="co">// 結果は &quot;Hello&quot; になるはず</span></span></code></pre></div>
<h3 id="構造化束縛">構造化束縛 <a id="SS_19_9_4"></a></h3>
<p>構造化束縛はC++17
から導入されたもので、std::tuppleやstd::pair、std::arrayなど、
構造体のメンバーを個別の変数に分解して簡潔に扱うことをできるようにするための機能である。</p>
<div class="sourceCode" id="cb164"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/structured_binding_ut.cpp 13</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// tupleでの構造化束縛の例</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> tobj<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="fl">2.5</span><span class="op">,</span> <span class="st">&quot;Hello&quot;</span><span class="op">);</span></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">[</span>i<span class="op">,</span> d<span class="op">,</span> s<span class="op">]</span> <span class="op">=</span> tobj<span class="op">;</span>  <span class="co">// 構造化束縛を使用してタプルを分解</span></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>i<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_DOUBLE_EQ<span class="op">(</span>d<span class="op">,</span> <span class="fl">2.5</span><span class="op">);</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;Hello&quot;</span><span class="op">,</span> s<span class="op">);</span></span></code></pre></div>
<div class="sourceCode" id="cb165"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/structured_binding_ut.cpp 28</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// pairでの構造化束縛の例</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> pobj<span class="op">(</span><span class="dv">42</span><span class="op">,</span> <span class="st">&quot;example&quot;</span><span class="op">);</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">[</span>i<span class="op">,</span> s<span class="op">]</span> <span class="op">=</span> pobj<span class="op">;</span>  <span class="co">// 構造化束縛を使用してペアを分解</span></span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>i<span class="op">,</span> <span class="dv">42</span><span class="op">);</span></span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;example&quot;</span><span class="op">,</span> s<span class="op">);</span></span></code></pre></div>
<div class="sourceCode" id="cb166"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/structured_binding_ut.cpp 42</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Person <span class="op">{</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>         age<span class="op">;</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true" tabindex="-1"></a>    Person person<span class="op">{</span><span class="st">&quot;Ichiro&quot;</span><span class="op">,</span> <span class="dv">30</span><span class="op">};</span>  <span class="co">// 構造体のインスタンス</span></span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-10"><a href="#cb166-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>name<span class="op">,</span> age<span class="op">]</span> <span class="op">=</span> person<span class="op">;</span>  <span class="co">// 構造化束縛を使用して構造体のメンバーを分解</span></span>
<span id="cb166-11"><a href="#cb166-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-12"><a href="#cb166-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>name<span class="op">),</span> <span class="bu">std::</span>string<span class="op">&gt;);</span>  <span class="co">// これは正しい</span></span>
<span id="cb166-13"><a href="#cb166-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// static_assert(std::is_same_v&lt;decltype(name), std::string&amp;&gt;); これはコンパイルエラー</span></span>
<span id="cb166-14"><a href="#cb166-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 上記がコンパイルエラーになる理由は以下の通り。</span></span>
<span id="cb166-15"><a href="#cb166-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb166-16"><a href="#cb166-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 変数宣言は、 autoを記述したあとに角カッコ内に変数名を列挙する。</span></span>
<span id="cb166-17"><a href="#cb166-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// それぞれの変数に対する型や修飾子の指定はできない。</span></span>
<span id="cb166-18"><a href="#cb166-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// autoの部分を const auto&amp;のように、全体に対してCV修飾や参照を付加することはできる。</span></span>
<span id="cb166-19"><a href="#cb166-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// それぞれの変数の型は、各要素をdecltypeしたものとなる。</span></span>
<span id="cb166-20"><a href="#cb166-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">//                        ^^^^^^^^^^^^^^ nameの型がstd::stringと評価された理由</span></span>
<span id="cb166-21"><a href="#cb166-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-22"><a href="#cb166-22" aria-hidden="true" tabindex="-1"></a>    name <span class="op">=</span> <span class="st">&quot;Taro&quot;</span><span class="op">;</span>  <span class="co">// nameはリファレンス</span></span>
<span id="cb166-23"><a href="#cb166-23" aria-hidden="true" tabindex="-1"></a>    age  <span class="op">=</span> <span class="dv">56</span><span class="op">;</span>      <span class="co">// ageはリファレンス</span></span>
<span id="cb166-24"><a href="#cb166-24" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>person<span class="op">.</span>name<span class="op">,</span> <span class="st">&quot;Taro&quot;</span><span class="op">);</span></span>
<span id="cb166-25"><a href="#cb166-25" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>person<span class="op">.</span>age<span class="op">,</span> <span class="dv">56</span><span class="op">);</span></span></code></pre></div>
<div class="sourceCode" id="cb167"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/structured_binding_ut.cpp 72</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> array <span class="op">=</span> <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">,</span> z<span class="op">]</span> <span class="op">=</span> array<span class="op">;</span>  <span class="co">// 構造化束縛を使って std::array の要素を分解</span></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>x<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>y<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>z<span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span></code></pre></div>
<h3 id="初期化付きifswitch文">初期化付きif/switch文
<a id="SS_19_9_5"></a></h3>
<p>C++17で、if文とswitc文に初期化を行う構文が導入された。
これにより、変数をそのスコープ内で初期化し、その変数を条件式の評価に使用できる。
初期化された変数は、if文やswitch文のスコープ内でのみ有効であり、他のスコープには影響を与えない。</p>
<p>この構文は、従来のfor文で使用されていた初期化ステートメントを、if/switch文に拡張したものである。
この類似性が理解しやすいように、本節では、
敢えて以下のコード例で同じ関数、同じクラスを使用し、
対比できるようにした。</p>
<ul>
<li><a
href="core_lang_spec.html#SS_19_9_5_1">初期化付きfor文(従来のfor文)</a></li>
<li><a
href="core_lang_spec.html#SS_19_9_5_2">初期化付きwhile文(従来のwhile文)</a></li>
<li><a href="core_lang_spec.html#SS_19_9_5_3">初期化付きif文</a></li>
<li><a href="core_lang_spec.html#SS_19_9_5_4">初期化付きswitch文</a></li>
</ul>
<h4 id="初期化付きfor文従来のfor文">初期化付きfor文(従来のfor文)
<a id="SS_19_9_5_1"></a></h4>
<p>下記の疑似コードは従来のfor文の構造を表す。</p>
<div class="sourceCode" id="cb168"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>init<span class="op">-</span>statement<span class="op">;</span> condition<span class="op">;</span> post<span class="op">-</span>statement<span class="op">)</span> <span class="op">{</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ループ処理</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>上記のと同様の実際のfor文のコードを以下に示す。</p>
<div class="sourceCode" id="cb169"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/if_switch_init_ut.cpp 8</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> OperationResult <span class="op">{</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> <span class="kw">class</span> ErrorCode <span class="op">{</span> NoError<span class="op">,</span> ErrorPattern1<span class="op">,</span> ErrorPattern2<span class="op">,</span> ErrorPattern3 <span class="op">};</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span>      IsError<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a>        ErrorCode Get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> IsError<span class="op">();</span> <span class="op">}</span></span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-10"><a href="#cb169-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb169-11"><a href="#cb169-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 何らかの定義</span></span>
<span id="cb169-12"><a href="#cb169-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb169-13"><a href="#cb169-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-14"><a href="#cb169-14" aria-hidden="true" tabindex="-1"></a>    OperationResult DoOperation<span class="op">();</span>                                 <span class="co">// 何らかの処理</span></span>
<span id="cb169-15"><a href="#cb169-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span>            RecoverOperation<span class="op">(</span>OperationResult<span class="op">::</span>ErrorCode<span class="op">);</span>  <span class="co">// リカバリ処理</span></span></code></pre></div>
<div class="sourceCode" id="cb170"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/if_switch_init_ut.cpp 33</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> result <span class="op">=</span> DoOperation<span class="op">();</span> result<span class="op">.</span>IsError<span class="op">();</span> result <span class="op">=</span> DoOperation<span class="op">())</span> <span class="op">{</span></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a>        RecoverOperation<span class="op">(</span>result<span class="op">.</span>Get<span class="op">());</span>  <span class="co">// エラー処理</span></span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 以下、成功時の処理</span></span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span></code></pre></div>
<h4 id="初期化付きwhile文従来のwhile文">初期化付きwhile文(従来のwhile文)
<a id="SS_19_9_5_2"></a></h4>
<p>下記の疑似コードこの節で説明しようとしているwhile文の構造を表す(従来からのwhile文)。</p>
<div class="sourceCode" id="cb171"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>type<span class="op">-</span>specifier<span class="op">-</span>seq declarator<span class="op">)</span> <span class="op">{</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 条件がtrueの場合の処理</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><a href="core_lang_spec.html#SS_19_9_5_3">初期化付きif文</a>/<a
href="core_lang_spec.html#SS_19_9_5_4">初期化付きswitch文</a>はC++17から導入されたシンタックスであるが、
それと同様のシンタックスはwhileには存在しないが、
以下のコード例のように従来の記法は広く知られているため、念とため紹介する。</p>
<div class="sourceCode" id="cb172"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/if_switch_init_ut.cpp 46</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="kw">auto</span> result <span class="op">=</span> DoOperation<span class="op">())</span> <span class="op">{</span>  <span class="co">// resultはboolへの暗黙の型変換が行われる</span></span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// エラー処理</span></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// resultはスコープアウトする</span></span></code></pre></div>
<h4 id="初期化付きif文">初期化付きif文 <a id="SS_19_9_5_3"></a></h4>
<p>下記の疑似コードこの節で説明しようとしているif文の構造を表す。</p>
<div class="sourceCode" id="cb173"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>init<span class="op">-</span>statement<span class="op">;</span> condition<span class="op">)</span> <span class="op">{</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 条件がtrueの場合の処理</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>上記と同様の構造を持つ実際のif文のコードを以下に示す。</p>
<div class="sourceCode" id="cb174"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/if_switch_init_ut.cpp 8</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> OperationResult <span class="op">{</span></span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> <span class="kw">class</span> ErrorCode <span class="op">{</span> NoError<span class="op">,</span> ErrorPattern1<span class="op">,</span> ErrorPattern2<span class="op">,</span> ErrorPattern3 <span class="op">};</span></span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span>      IsError<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a>        ErrorCode Get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb174-8"><a href="#cb174-8" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> IsError<span class="op">();</span> <span class="op">}</span></span>
<span id="cb174-9"><a href="#cb174-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-10"><a href="#cb174-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb174-11"><a href="#cb174-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 何らかの定義</span></span>
<span id="cb174-12"><a href="#cb174-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb174-13"><a href="#cb174-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-14"><a href="#cb174-14" aria-hidden="true" tabindex="-1"></a>    OperationResult DoOperation<span class="op">();</span>                                 <span class="co">// 何らかの処理</span></span>
<span id="cb174-15"><a href="#cb174-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span>            RecoverOperation<span class="op">(</span>OperationResult<span class="op">::</span>ErrorCode<span class="op">);</span>  <span class="co">// リカバリ処理</span></span></code></pre></div>
<div class="sourceCode" id="cb175"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/if_switch_init_ut.cpp 57</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> result <span class="op">=</span> DoOperation<span class="op">();</span> <span class="op">!</span>result<span class="op">.</span>IsError<span class="op">())</span> <span class="op">{</span></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 成功処理</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>        RecoverOperation<span class="op">(</span>result<span class="op">.</span>Get<span class="op">());</span>  <span class="co">// エラー処理</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// resultはスコープアウトする</span></span></code></pre></div>
<p>クラスの独自の<a
href="core_lang_spec.html#SS_19_6_4_1">&lt;=&gt;演算子</a>を定義する場合、下記のように使用することができる。</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/if_switch_init_ut.cpp 70</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> DoubleName <span class="op">{</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string name0<span class="op">;</span></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string name1<span class="op">;</span></span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>DoubleName <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> DoubleName <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>DoubleName <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> DoubleName <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// name0 を比較し、等しくなければその比較結果を返す</span></span>
<span id="cb176-12"><a href="#cb176-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> cmp <span class="op">=</span> lhs<span class="op">.</span>name0 <span class="op">&lt;=&gt;</span> rhs<span class="op">.</span>name0<span class="op">;</span> cmp <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb176-13"><a href="#cb176-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> cmp<span class="op">;</span></span>
<span id="cb176-14"><a href="#cb176-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb176-15"><a href="#cb176-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-16"><a href="#cb176-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lhs<span class="op">.</span>name1 <span class="op">&lt;=&gt;</span> rhs<span class="op">.</span>name1<span class="op">;</span>  <span class="co">// name0が等しければ name1を比較</span></span>
<span id="cb176-17"><a href="#cb176-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="初期化付きswitch文">初期化付きswitch文
<a id="SS_19_9_5_4"></a></h4>
<p>下記の疑似コードはこの節で説明しようとしているswitch文の構造を表す。</p>
<div class="sourceCode" id="cb177"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span>init<span class="op">-</span>statement<span class="op">;</span> condition<span class="op">)</span> <span class="op">{</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> value1<span class="op">:</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 条件が value1 の場合の処理</span></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> value2<span class="op">:</span></span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 条件が value2 の場合の処理</span></span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// その他のケース</span></span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>上記と同様の構造を持つ実際のswitch文のコードを以下に示す。</p>
<div class="sourceCode" id="cb178"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/if_switch_init_ut.cpp 8</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> OperationResult <span class="op">{</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> <span class="kw">class</span> ErrorCode <span class="op">{</span> NoError<span class="op">,</span> ErrorPattern1<span class="op">,</span> ErrorPattern2<span class="op">,</span> ErrorPattern3 <span class="op">};</span></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span>      IsError<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb178-7"><a href="#cb178-7" aria-hidden="true" tabindex="-1"></a>        ErrorCode Get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">;</span></span>
<span id="cb178-8"><a href="#cb178-8" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> IsError<span class="op">();</span> <span class="op">}</span></span>
<span id="cb178-9"><a href="#cb178-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-10"><a href="#cb178-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb178-11"><a href="#cb178-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 何らかの定義</span></span>
<span id="cb178-12"><a href="#cb178-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb178-13"><a href="#cb178-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-14"><a href="#cb178-14" aria-hidden="true" tabindex="-1"></a>    OperationResult DoOperation<span class="op">();</span>                                 <span class="co">// 何らかの処理</span></span>
<span id="cb178-15"><a href="#cb178-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span>            RecoverOperation<span class="op">(</span>OperationResult<span class="op">::</span>ErrorCode<span class="op">);</span>  <span class="co">// リカバリ処理</span></span></code></pre></div>
<div class="sourceCode" id="cb179"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/if_switch_init_ut.cpp 101</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">(</span><span class="kw">auto</span> result <span class="op">=</span> DoOperation<span class="op">();</span> result<span class="op">.</span>Get<span class="op">())</span> <span class="op">{</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> OperationResult<span class="op">::</span>ErrorCode<span class="op">::</span>ErrorPattern1<span class="op">:</span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>        RecoverOperation<span class="op">(</span>result<span class="op">.</span>Get<span class="op">());</span>  <span class="co">// エラー処理</span></span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// エラー処理のいくつかのパターン</span></span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> OperationResult<span class="op">::</span>ErrorCode<span class="op">::</span>NoError<span class="op">:</span></span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 成功処理</span></span>
<span id="cb179-10"><a href="#cb179-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb179-11"><a href="#cb179-11" aria-hidden="true" tabindex="-1"></a>        <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span>  <span class="co">// ここには来ないはず</span></span>
<span id="cb179-12"><a href="#cb179-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb179-13"><a href="#cb179-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// resultはスコープアウトする</span></span></code></pre></div>
<h2 id="言語拡張機能">言語拡張機能 <a id="SS_19_10"></a></h2>
<h3 id="コルーチン">コルーチン <a id="SS_19_10_1"></a></h3>
<p>コルーチンはC++20から導入された機能であり、以下の新しいキーワードによりサポートされる。</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_10_1_1">co_await</a></li>
<li><a href="core_lang_spec.html#SS_19_10_1_2">co_return</a></li>
<li><a href="core_lang_spec.html#SS_19_10_1_3">co_yield</a></li>
</ul>
<h4 id="co_await">co_await <a id="SS_19_10_1_1"></a></h4>
<p>co_awaitはコルーチンの非同期操作の一時停止と再開に使用される。
co_waitとco_returnを使用したコードを以下に示す。</p>
<div class="sourceCode" id="cb180"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/co_await_ut.cpp 12</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Task <span class="op">{</span>  <span class="co">// コルーチンが返す型</span></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@struct</span><span class="co"> </span><span class="cv">promise_type</span></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンのライフサイクルを管理する構造体</span></span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> <span class="dt">promise_type</span> <span class="op">{</span></span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンから Task 型のオブジェクトを返す関数</span></span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@return</span><span class="co"> Taskオブジェクト</span></span>
<span id="cb180-10"><a href="#cb180-10" aria-hidden="true" tabindex="-1"></a>            Task get_return_object<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> Task<span class="op">{</span><span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;::</span>from_promise<span class="op">(*</span><span class="kw">this</span><span class="op">)};</span> <span class="op">}</span></span>
<span id="cb180-11"><a href="#cb180-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-12"><a href="#cb180-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンの最初のサスペンドポイント</span></span>
<span id="cb180-13"><a href="#cb180-13" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@return</span><span class="co"> 常にサスペンドするオブジェクトを返す</span></span>
<span id="cb180-14"><a href="#cb180-14" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>suspend_always initial_suspend<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{};</span> <span class="op">}</span></span>
<span id="cb180-15"><a href="#cb180-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-16"><a href="#cb180-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンの最後のサスペンドポイント</span></span>
<span id="cb180-17"><a href="#cb180-17" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@return</span><span class="co"> 常にサスペンドするオブジェクトを返す</span></span>
<span id="cb180-18"><a href="#cb180-18" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>suspend_always final_suspend<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{};</span> <span class="op">}</span></span>
<span id="cb180-19"><a href="#cb180-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-20"><a href="#cb180-20" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチン内で例外が発生した場合に呼び出される</span></span>
<span id="cb180-21"><a href="#cb180-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@details</span><span class="co"> コルーチン内で未処理の例外が発生した場合に、プロセスを終了する</span></span>
<span id="cb180-22"><a href="#cb180-22" aria-hidden="true" tabindex="-1"></a>            <span class="dt">void</span> unhandled_exception<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb180-23"><a href="#cb180-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-24"><a href="#cb180-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンが終了した際に呼び出される</span></span>
<span id="cb180-25"><a href="#cb180-25" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@details</span><span class="co"> co_return で値が返されない場合に呼び出されるが、何も行わない</span></span>
<span id="cb180-26"><a href="#cb180-26" aria-hidden="true" tabindex="-1"></a>            <span class="dt">void</span> return_void<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb180-27"><a href="#cb180-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb180-28"><a href="#cb180-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-29"><a href="#cb180-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> Task のコンストラクタ</span></span>
<span id="cb180-30"><a href="#cb180-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">h</span><span class="co"> コルーチンハンドル</span></span>
<span id="cb180-31"><a href="#cb180-31" aria-hidden="true" tabindex="-1"></a>        Task<span class="op">(</span><span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span> h<span class="op">)</span> <span class="op">:</span> coro<span class="op">{</span>h<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb180-32"><a href="#cb180-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-33"><a href="#cb180-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンの呼び出し回数に基づいた文字列を返す</span></span>
<span id="cb180-34"><a href="#cb180-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@return</span><span class="co"> 呼び出し回数に応じた &quot;call X&quot; という文字列</span></span>
<span id="cb180-35"><a href="#cb180-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string get_value<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;call &quot;</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span>called<span class="op">);</span> <span class="op">}</span></span>
<span id="cb180-36"><a href="#cb180-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-37"><a href="#cb180-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンを再開する</span></span>
<span id="cb180-38"><a href="#cb180-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@details</span><span class="co"> コルーチンが終了していなければ再開し、呼び出し回数をカウントする</span></span>
<span id="cb180-39"><a href="#cb180-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@return</span><span class="co"> コルーチンが完了していなければ true、完了していれば false</span></span>
<span id="cb180-40"><a href="#cb180-40" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> resume<span class="op">()</span></span>
<span id="cb180-41"><a href="#cb180-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb180-42"><a href="#cb180-42" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span>called<span class="op">;</span>                 <span class="co">// コルーチンを呼び出した回数をカウント</span></span>
<span id="cb180-43"><a href="#cb180-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>coro<span class="op">.</span>done<span class="op">())</span> <span class="op">{</span>       <span class="co">// コルーチンが完了していなければ</span></span>
<span id="cb180-44"><a href="#cb180-44" aria-hidden="true" tabindex="-1"></a>                coro<span class="op">.</span>resume<span class="op">();</span>        <span class="co">// 再開</span></span>
<span id="cb180-45"><a href="#cb180-45" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="op">!</span>coro<span class="op">.</span>done<span class="op">();</span>  <span class="co">// 再開後も完了していなければ true を返す</span></span>
<span id="cb180-46"><a href="#cb180-46" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb180-47"><a href="#cb180-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// すでに完了している場合は false を返す</span></span>
<span id="cb180-48"><a href="#cb180-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb180-49"><a href="#cb180-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-50"><a href="#cb180-50" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> Task のデストラクタ</span></span>
<span id="cb180-51"><a href="#cb180-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@details</span><span class="co"> コルーチンハンドルが有効であれば破棄する</span></span>
<span id="cb180-52"><a href="#cb180-52" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>Task<span class="op">()</span></span>
<span id="cb180-53"><a href="#cb180-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb180-54"><a href="#cb180-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>coro<span class="op">)</span> coro<span class="op">.</span>destroy<span class="op">();</span></span>
<span id="cb180-55"><a href="#cb180-55" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb180-56"><a href="#cb180-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-57"><a href="#cb180-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb180-58"><a href="#cb180-58" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span> coro<span class="op">;</span>        <span class="co">///&lt; コルーチンハンドル</span></span>
<span id="cb180-59"><a href="#cb180-59" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span>                            called <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">///&lt; コルーチンが再開された回数</span></span>
<span id="cb180-60"><a href="#cb180-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb180-61"><a href="#cb180-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-62"><a href="#cb180-62" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンを生成する関数</span></span>
<span id="cb180-63"><a href="#cb180-63" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@return</span><span class="co"> Taskオブジェクト</span></span>
<span id="cb180-64"><a href="#cb180-64" aria-hidden="true" tabindex="-1"></a>    Task gen_coroutine<span class="op">()</span></span>
<span id="cb180-65"><a href="#cb180-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb180-66"><a href="#cb180-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">co_await</span> <span class="bu">std::</span>suspend_always<span class="op">{};</span>  <span class="co">// 最初のサスペンドポイント</span></span>
<span id="cb180-67"><a href="#cb180-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">co_await</span> <span class="bu">std::</span>suspend_always<span class="op">{};</span>  <span class="co">// 2回目のサスペンドポイント</span></span>
<span id="cb180-68"><a href="#cb180-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">co_return</span><span class="op">;</span>                       <span class="co">// コルーチン終了</span></span>
<span id="cb180-69"><a href="#cb180-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>以下単体テストコードによりに上記コルーチンの動作を示す。</p>
<div class="sourceCode" id="cb181"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/co_await_ut.cpp 85</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>    Task    task  <span class="op">=</span> gen_coroutine<span class="op">();</span>  <span class="co">// gen_coroutine から Task オブジェクトを生成</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> calls <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@test</span><span class="co"> コルーチンを resume() で再開し、完了するまでループする</span></span>
<span id="cb181-7"><a href="#cb181-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>task<span class="op">.</span>resume<span class="op">())</span> <span class="op">{</span>  <span class="co">// コルーチンが完了していない間、再開</span></span>
<span id="cb181-8"><a href="#cb181-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">switch</span> <span class="op">(</span>calls<span class="op">)</span> <span class="op">{</span></span>
<span id="cb181-9"><a href="#cb181-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span></span>
<span id="cb181-10"><a href="#cb181-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@test</span><span class="co"> コルーチンが1回目の再開後、&quot;call 1&quot; が返されることを確認</span></span>
<span id="cb181-11"><a href="#cb181-11" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span><span class="st">&quot;call 1&quot;</span><span class="op">,</span> task<span class="op">.</span>get_value<span class="op">());</span></span>
<span id="cb181-12"><a href="#cb181-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb181-13"><a href="#cb181-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb181-14"><a href="#cb181-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@test</span><span class="co"> コルーチンが2回目の再開後、&quot;call 2&quot; が返されることを確認</span></span>
<span id="cb181-15"><a href="#cb181-15" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span><span class="st">&quot;call 2&quot;</span><span class="op">,</span> task<span class="op">.</span>get_value<span class="op">());</span></span>
<span id="cb181-16"><a href="#cb181-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb181-17"><a href="#cb181-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb181-18"><a href="#cb181-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@test</span><span class="co"> コルーチンが3回目の再開後、&quot;call 3&quot; が返されることを確認</span></span>
<span id="cb181-19"><a href="#cb181-19" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span><span class="st">&quot;call 3&quot;</span><span class="op">,</span> task<span class="op">.</span>get_value<span class="op">());</span></span>
<span id="cb181-20"><a href="#cb181-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb181-21"><a href="#cb181-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb181-22"><a href="#cb181-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>calls<span class="op">;</span></span>
<span id="cb181-23"><a href="#cb181-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb181-24"><a href="#cb181-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-25"><a href="#cb181-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@test</span><span class="co"> コルーチンが 2 回 resume された後に終了していることを確認</span></span>
<span id="cb181-26"><a href="#cb181-26" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> calls<span class="op">);</span></span></code></pre></div>
<p>上記のコルーチンと同じ機能を持つクラスのco_await/co_returnを使わない実装を以下に示す。</p>
<div class="sourceCode" id="cb182"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/co_await_ut.cpp 115</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@enum</span><span class="co"> </span><span class="cv">CoroutineState</span></span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> ManualCoroutine の状態を表す enum 型</span></span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> CoroutineState <span class="op">{</span></span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a>        Start<span class="op">,</span>             <span class="co">///&lt; コルーチンが開始された状態</span></span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a>        FirstSuspension<span class="op">,</span>   <span class="co">///&lt; コルーチンが最初にサスペンドされた状態</span></span>
<span id="cb182-8"><a href="#cb182-8" aria-hidden="true" tabindex="-1"></a>        SecondSuspension<span class="op">,</span>  <span class="co">///&lt; コルーチンが2回目にサスペンドされた状態</span></span>
<span id="cb182-9"><a href="#cb182-9" aria-hidden="true" tabindex="-1"></a>        Finished           <span class="co">///&lt; コルーチンが完了した状態</span></span>
<span id="cb182-10"><a href="#cb182-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb182-11"><a href="#cb182-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-12"><a href="#cb182-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンの状態を保持し、進行を管理するためのクラス</span></span>
<span id="cb182-13"><a href="#cb182-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> ManualCoroutine <span class="op">{</span></span>
<span id="cb182-14"><a href="#cb182-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb182-15"><a href="#cb182-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンの代わりに状態を進行させる関数</span></span>
<span id="cb182-16"><a href="#cb182-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@details</span><span class="co"> コルーチンの状態に基づいて進行し、コルーチンのように振る舞う</span></span>
<span id="cb182-17"><a href="#cb182-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@return</span><span class="co"> コルーチンが継続可能なら true、終了していれば false を返す</span></span>
<span id="cb182-18"><a href="#cb182-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> resume<span class="op">()</span></span>
<span id="cb182-19"><a href="#cb182-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb182-20"><a href="#cb182-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span>called<span class="op">;</span>  <span class="co">// コルーチンの再開回数をカウント</span></span>
<span id="cb182-21"><a href="#cb182-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">switch</span> <span class="op">(</span>state<span class="op">)</span> <span class="op">{</span></span>
<span id="cb182-22"><a href="#cb182-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> CoroutineState<span class="op">::</span>Start<span class="op">:</span></span>
<span id="cb182-23"><a href="#cb182-23" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> CoroutineState<span class="op">::</span>FirstSuspension<span class="op">;</span></span>
<span id="cb182-24"><a href="#cb182-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>  <span class="co">// 継続可能</span></span>
<span id="cb182-25"><a href="#cb182-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-26"><a href="#cb182-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> CoroutineState<span class="op">::</span>FirstSuspension<span class="op">:</span></span>
<span id="cb182-27"><a href="#cb182-27" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> CoroutineState<span class="op">::</span>SecondSuspension<span class="op">;</span></span>
<span id="cb182-28"><a href="#cb182-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>  <span class="co">// 継続可能</span></span>
<span id="cb182-29"><a href="#cb182-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-30"><a href="#cb182-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> CoroutineState<span class="op">::</span>SecondSuspension<span class="op">:</span></span>
<span id="cb182-31"><a href="#cb182-31" aria-hidden="true" tabindex="-1"></a>                state <span class="op">=</span> CoroutineState<span class="op">::</span>Finished<span class="op">;</span></span>
<span id="cb182-32"><a href="#cb182-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// 終了</span></span>
<span id="cb182-33"><a href="#cb182-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-34"><a href="#cb182-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> CoroutineState<span class="op">::</span>Finished<span class="op">:</span></span>
<span id="cb182-35"><a href="#cb182-35" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// 既に終了している</span></span>
<span id="cb182-36"><a href="#cb182-36" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb182-37"><a href="#cb182-37" aria-hidden="true" tabindex="-1"></a>            <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span>  <span class="co">// 不正な状態（理論的には到達しないはず）</span></span>
<span id="cb182-38"><a href="#cb182-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb182-39"><a href="#cb182-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb182-40"><a href="#cb182-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-41"><a href="#cb182-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> 呼び出し回数に基づいた文字列を返す</span></span>
<span id="cb182-42"><a href="#cb182-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@return</span><span class="co"> &quot;call X&quot; という形式の文字列（X は呼び出し回数）</span></span>
<span id="cb182-43"><a href="#cb182-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string get_value<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;call &quot;</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span>called<span class="op">);</span> <span class="op">}</span></span>
<span id="cb182-44"><a href="#cb182-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-45"><a href="#cb182-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb182-46"><a href="#cb182-46" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span>       called <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>                      <span class="co">///&lt; コルーチンが再開された回数</span></span>
<span id="cb182-47"><a href="#cb182-47" aria-hidden="true" tabindex="-1"></a>        CoroutineState state  <span class="op">=</span> CoroutineState<span class="op">::</span>Start<span class="op">;</span>  <span class="co">///&lt; 現在のコルーチンの状態</span></span>
<span id="cb182-48"><a href="#cb182-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>このクラスは当然ながら、前記のコルーチンの単体テストコードとほぼ同じになる。</p>
<div class="sourceCode" id="cb183"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/co_await_ut.cpp 167</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>    manual_coroutine <span class="op">=</span> ManualCoroutine<span class="op">{};</span></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> calls            <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>manual_coroutine<span class="op">.</span>resume<span class="op">())</span> <span class="op">{</span>  <span class="co">// コルーチンを再開する</span></span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">switch</span> <span class="op">(</span>calls<span class="op">)</span> <span class="op">{</span></span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">0</span><span class="op">:</span></span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@test</span><span class="co"> 1回目の再開後に &quot;call 1&quot; が返されることを確認</span></span>
<span id="cb183-10"><a href="#cb183-10" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span><span class="st">&quot;call 1&quot;</span><span class="op">,</span> manual_coroutine<span class="op">.</span>get_value<span class="op">());</span></span>
<span id="cb183-11"><a href="#cb183-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb183-12"><a href="#cb183-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb183-13"><a href="#cb183-13" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@test</span><span class="co"> 2回目の再開後に &quot;call 2&quot; が返されることを確認</span></span>
<span id="cb183-14"><a href="#cb183-14" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span><span class="st">&quot;call 2&quot;</span><span class="op">,</span> manual_coroutine<span class="op">.</span>get_value<span class="op">());</span></span>
<span id="cb183-15"><a href="#cb183-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb183-16"><a href="#cb183-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb183-17"><a href="#cb183-17" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@test</span><span class="co"> 3回目の再開後に &quot;call 3&quot; が返されることを確認</span></span>
<span id="cb183-18"><a href="#cb183-18" aria-hidden="true" tabindex="-1"></a>            ASSERT_EQ<span class="op">(</span><span class="st">&quot;call 3&quot;</span><span class="op">,</span> manual_coroutine<span class="op">.</span>get_value<span class="op">());</span></span>
<span id="cb183-19"><a href="#cb183-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb183-20"><a href="#cb183-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb183-21"><a href="#cb183-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>calls<span class="op">;</span>  <span class="co">///&lt; コルーチンの再開回数をインクリメント</span></span>
<span id="cb183-22"><a href="#cb183-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb183-23"><a href="#cb183-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-24"><a href="#cb183-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@test</span><span class="co"> コルーチンが2回 resume された後に終了していることを確認</span></span>
<span id="cb183-25"><a href="#cb183-25" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> calls<span class="op">);</span></span></code></pre></div>
<p>C++20から導入されたco_await、co_return、TaskとC++17以前の機能のみを使用したコードの対比によって、
コルーチンのサポート機能により実装が容易になることが理解できるだろう。</p>
<h4 id="co_return">co_return <a id="SS_19_10_1_2"></a></h4>
<p>co_returnはコルーチンの終了時に値を返すために使用される。
co_returnは通常<a
href="core_lang_spec.html#SS_19_10_1_1">co_await</a>と同時に使われることが多い。</p>
<h4 id="co_yield">co_yield <a id="SS_19_10_1_3"></a></h4>
<p>co_yieldはコルーチンから値を返しつつ、
次の再開ポイントまで処理を中断する。これはジェネレーターの実装に便利である。</p>
<div class="sourceCode" id="cb184"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/co_yield_ut.cpp 12</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Generator <span class="op">{</span></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>        Generator<span class="op">(</span>Generator<span class="op">&amp;&amp;</span> other<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> coro<span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>other<span class="op">.</span>coro<span class="op">)}</span> <span class="op">{</span> other<span class="op">.</span>coro <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>        Generator<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Generator<span class="op">&amp;&amp;</span> other<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">!=</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">{</span></span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a>                coro       <span class="op">=</span> other<span class="op">.</span>coro<span class="op">;</span></span>
<span id="cb184-12"><a href="#cb184-12" aria-hidden="true" tabindex="-1"></a>                other<span class="op">.</span>coro <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb184-13"><a href="#cb184-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb184-14"><a href="#cb184-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb184-15"><a href="#cb184-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb184-16"><a href="#cb184-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-17"><a href="#cb184-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@struct</span><span class="co"> </span><span class="cv">promise_type</span></span>
<span id="cb184-18"><a href="#cb184-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンのライフサイクルを管理する構造体</span></span>
<span id="cb184-19"><a href="#cb184-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> <span class="dt">promise_type</span> <span class="op">{</span></span>
<span id="cb184-20"><a href="#cb184-20" aria-hidden="true" tabindex="-1"></a>            T current_value<span class="op">;</span></span>
<span id="cb184-21"><a href="#cb184-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-22"><a href="#cb184-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンから Generator 型のオブジェクトを返す関数</span></span>
<span id="cb184-23"><a href="#cb184-23" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@return</span><span class="co"> Generatorオブジェクト</span></span>
<span id="cb184-24"><a href="#cb184-24" aria-hidden="true" tabindex="-1"></a>            Generator get_return_object<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> Generator<span class="op">{</span><span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;::</span>from_promise<span class="op">(*</span><span class="kw">this</span><span class="op">)};</span> <span class="op">}</span></span>
<span id="cb184-25"><a href="#cb184-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-26"><a href="#cb184-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンの最初のサスペンドポイント</span></span>
<span id="cb184-27"><a href="#cb184-27" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@return</span><span class="co"> 常にサスペンドするオブジェクトを返す</span></span>
<span id="cb184-28"><a href="#cb184-28" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>suspend_always initial_suspend<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{};</span> <span class="op">}</span></span>
<span id="cb184-29"><a href="#cb184-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-30"><a href="#cb184-30" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンの最後のサスペンドポイント</span></span>
<span id="cb184-31"><a href="#cb184-31" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@return</span><span class="co"> 常にサスペンドするオブジェクトを返す</span></span>
<span id="cb184-32"><a href="#cb184-32" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>suspend_always final_suspend<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{};</span> <span class="op">}</span></span>
<span id="cb184-33"><a href="#cb184-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-34"><a href="#cb184-34" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンで値を生成するためのサスペンドポイント</span></span>
<span id="cb184-35"><a href="#cb184-35" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">value</span><span class="co"> 生成された値</span></span>
<span id="cb184-36"><a href="#cb184-36" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@return</span><span class="co"> 常にサスペンドするオブジェクトを返す</span></span>
<span id="cb184-37"><a href="#cb184-37" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>suspend_always yield_value<span class="op">(</span>T value<span class="op">)</span></span>
<span id="cb184-38"><a href="#cb184-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb184-39"><a href="#cb184-39" aria-hidden="true" tabindex="-1"></a>                current_value <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb184-40"><a href="#cb184-40" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb184-41"><a href="#cb184-41" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb184-42"><a href="#cb184-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-43"><a href="#cb184-43" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチン内で例外が発生した場合に呼び出される</span></span>
<span id="cb184-44"><a href="#cb184-44" aria-hidden="true" tabindex="-1"></a>            <span class="dt">void</span> unhandled_exception<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb184-45"><a href="#cb184-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-46"><a href="#cb184-46" aria-hidden="true" tabindex="-1"></a>            <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンの終了時に呼び出される</span></span>
<span id="cb184-47"><a href="#cb184-47" aria-hidden="true" tabindex="-1"></a>            <span class="dt">void</span> return_void<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb184-48"><a href="#cb184-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb184-49"><a href="#cb184-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-50"><a href="#cb184-50" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンを再開し、次の値を生成する</span></span>
<span id="cb184-51"><a href="#cb184-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@return</span><span class="co"> 次の値が生成された場合は true、終了した場合は false</span></span>
<span id="cb184-52"><a href="#cb184-52" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> move_next<span class="op">()</span></span>
<span id="cb184-53"><a href="#cb184-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb184-54"><a href="#cb184-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>coro <span class="op">&amp;&amp;</span> <span class="op">!</span>coro<span class="op">.</span>done<span class="op">())</span> <span class="op">{</span></span>
<span id="cb184-55"><a href="#cb184-55" aria-hidden="true" tabindex="-1"></a>                coro<span class="op">.</span>resume<span class="op">();</span></span>
<span id="cb184-56"><a href="#cb184-56" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="op">!</span>coro<span class="op">.</span>done<span class="op">();</span></span>
<span id="cb184-57"><a href="#cb184-57" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb184-58"><a href="#cb184-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb184-59"><a href="#cb184-59" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb184-60"><a href="#cb184-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-61"><a href="#cb184-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> 現在の値を取得する</span></span>
<span id="cb184-62"><a href="#cb184-62" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@return</span><span class="co"> 現在の値</span></span>
<span id="cb184-63"><a href="#cb184-63" aria-hidden="true" tabindex="-1"></a>        T current_value<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> coro<span class="op">.</span>promise<span class="op">().</span>current_value<span class="op">;</span> <span class="op">}</span></span>
<span id="cb184-64"><a href="#cb184-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-65"><a href="#cb184-65" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> Generator のコンストラクタ</span></span>
<span id="cb184-66"><a href="#cb184-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">h</span><span class="co"> コルーチンハンドル</span></span>
<span id="cb184-67"><a href="#cb184-67" aria-hidden="true" tabindex="-1"></a>        Generator<span class="op">(</span><span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span> h<span class="op">)</span> <span class="op">:</span> coro<span class="op">(</span>h<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb184-68"><a href="#cb184-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-69"><a href="#cb184-69" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> Generator のデストラクタ</span></span>
<span id="cb184-70"><a href="#cb184-70" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@details</span><span class="co"> コルーチンハンドルが有効であれば破棄する</span></span>
<span id="cb184-71"><a href="#cb184-71" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>Generator<span class="op">()</span></span>
<span id="cb184-72"><a href="#cb184-72" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb184-73"><a href="#cb184-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>coro<span class="op">)</span> coro<span class="op">.</span>destroy<span class="op">();</span></span>
<span id="cb184-74"><a href="#cb184-74" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb184-75"><a href="#cb184-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-76"><a href="#cb184-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb184-77"><a href="#cb184-77" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>coroutine_handle<span class="op">&lt;</span><span class="dt">promise_type</span><span class="op">&gt;</span> coro<span class="op">;</span></span>
<span id="cb184-78"><a href="#cb184-78" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb184-79"><a href="#cb184-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-80"><a href="#cb184-80" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> 偶数のみをフィルタリングする</span></span>
<span id="cb184-81"><a href="#cb184-81" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">input</span><span class="co"> フィルタ対象の Generator</span></span>
<span id="cb184-82"><a href="#cb184-82" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@return</span><span class="co"> フィルタ後の Generator</span></span>
<span id="cb184-83"><a href="#cb184-83" aria-hidden="true" tabindex="-1"></a>    Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filter_even<span class="op">(</span>Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> input<span class="op">)</span></span>
<span id="cb184-84"><a href="#cb184-84" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb184-85"><a href="#cb184-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>input<span class="op">.</span>move_next<span class="op">())</span> <span class="op">{</span></span>
<span id="cb184-86"><a href="#cb184-86" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>input<span class="op">.</span>current_value<span class="op">()</span> <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb184-87"><a href="#cb184-87" aria-hidden="true" tabindex="-1"></a>                <span class="cf">co_yield</span> input<span class="op">.</span>current_value<span class="op">();</span></span>
<span id="cb184-88"><a href="#cb184-88" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb184-89"><a href="#cb184-89" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb184-90"><a href="#cb184-90" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb184-91"><a href="#cb184-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-92"><a href="#cb184-92" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> 値を2倍に変換する</span></span>
<span id="cb184-93"><a href="#cb184-93" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">input</span><span class="co"> 変換対象の Generator</span></span>
<span id="cb184-94"><a href="#cb184-94" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@return</span><span class="co"> 変換後の Generator</span></span>
<span id="cb184-95"><a href="#cb184-95" aria-hidden="true" tabindex="-1"></a>    Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> double_values<span class="op">(</span>Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> input<span class="op">)</span></span>
<span id="cb184-96"><a href="#cb184-96" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb184-97"><a href="#cb184-97" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>input<span class="op">.</span>move_next<span class="op">())</span> <span class="op">{</span></span>
<span id="cb184-98"><a href="#cb184-98" aria-hidden="true" tabindex="-1"></a>            <span class="cf">co_yield</span> input<span class="op">.</span>current_value<span class="op">()</span> <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb184-99"><a href="#cb184-99" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb184-100"><a href="#cb184-100" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb184-101"><a href="#cb184-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-102"><a href="#cb184-102" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> 数値の範囲を生成する</span></span>
<span id="cb184-103"><a href="#cb184-103" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">start</span><span class="co"> 開始値</span></span>
<span id="cb184-104"><a href="#cb184-104" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">end</span><span class="co"> 終了値</span></span>
<span id="cb184-105"><a href="#cb184-105" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@return</span><span class="co"> 範囲内の数値を生成する Generator</span></span>
<span id="cb184-106"><a href="#cb184-106" aria-hidden="true" tabindex="-1"></a>    Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> generate_numbers<span class="op">(</span><span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> end<span class="op">)</span></span>
<span id="cb184-107"><a href="#cb184-107" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb184-108"><a href="#cb184-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> start<span class="op">;</span> i <span class="op">&lt;=</span> end<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb184-109"><a href="#cb184-109" aria-hidden="true" tabindex="-1"></a>            <span class="cf">co_yield</span> i<span class="op">;</span></span>
<span id="cb184-110"><a href="#cb184-110" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb184-111"><a href="#cb184-111" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>このテストを以下に示す。</p>
<div class="sourceCode" id="cb185"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/co_yield_ut.cpp 127</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 数値を生成し、それをパイプライン処理に通す</span></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> numbers         <span class="op">=</span> generate_numbers<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> even_numbers    <span class="op">=</span> filter_even<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>numbers<span class="op">));</span></span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> doubled_numbers <span class="op">=</span> double_values<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>even_numbers<span class="op">));</span></span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 結果を検証するために期待される値の配列を準備</span></span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> expected_values <span class="op">=</span> <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">20</span><span class="op">};</span></span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-11"><a href="#cb185-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 生成された値を順に取得し、期待される値と比較</span></span>
<span id="cb185-12"><a href="#cb185-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb185-13"><a href="#cb185-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>doubled_numbers<span class="op">.</span>move_next<span class="op">())</span> <span class="op">{</span></span>
<span id="cb185-14"><a href="#cb185-14" aria-hidden="true" tabindex="-1"></a>        ASSERT_LT<span class="op">(</span>index<span class="op">,</span> expected_values<span class="op">.</span>size<span class="op">());</span>  <span class="co">// インデックスが範囲内か確認</span></span>
<span id="cb185-15"><a href="#cb185-15" aria-hidden="true" tabindex="-1"></a>        EXPECT_EQ<span class="op">(</span>doubled_numbers<span class="op">.</span>current_value<span class="op">(),</span> expected_values<span class="op">[</span>index<span class="op">]);</span></span>
<span id="cb185-16"><a href="#cb185-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>index<span class="op">;</span></span>
<span id="cb185-17"><a href="#cb185-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb185-18"><a href="#cb185-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-19"><a href="#cb185-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 最終的にすべての期待される値が生成されたことを確認</span></span>
<span id="cb185-20"><a href="#cb185-20" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>index<span class="op">,</span> expected_values<span class="op">.</span>size<span class="op">());</span></span></code></pre></div>
<p><a
href="core_lang_spec.html#SS_19_10_1_1">co_await</a>、co_returnの例でみたように、
co_yieldを使用したコルーチンと同じ機能を持つクラスのco_yieldを使わない実装を以下に示す。</p>
<div class="sourceCode" id="cb186"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/co_yield_ut.cpp 152</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> コルーチンを使わずにデータを逐次的に提供するジェネレータークラス</span></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Generator <span class="op">{</span></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> コンストラクタ</span></span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">data</span><span class="co"> 生成対象のデータ</span></span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a>        Generator<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;&amp;</span> data<span class="op">)</span> <span class="op">:</span> <span class="va">data_</span><span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>data<span class="op">)),</span> <span class="va">current_index_</span><span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> 次の値があるかを確認し、次の値に進む</span></span>
<span id="cb186-12"><a href="#cb186-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@return</span><span class="co"> 次の値が存在する場合は true、存在しない場合は false</span></span>
<span id="cb186-13"><a href="#cb186-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> move_next<span class="op">()</span></span>
<span id="cb186-14"><a href="#cb186-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb186-15"><a href="#cb186-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="va">current_index_</span> <span class="op">&lt;</span> <span class="va">data_</span><span class="op">.</span>size<span class="op">())</span> <span class="op">{</span></span>
<span id="cb186-16"><a href="#cb186-16" aria-hidden="true" tabindex="-1"></a>                <span class="op">++</span><span class="va">current_index_</span><span class="op">;</span></span>
<span id="cb186-17"><a href="#cb186-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb186-18"><a href="#cb186-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb186-19"><a href="#cb186-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb186-20"><a href="#cb186-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb186-21"><a href="#cb186-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-22"><a href="#cb186-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> 現在の値を取得する</span></span>
<span id="cb186-23"><a href="#cb186-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@return</span><span class="co"> 現在の値</span></span>
<span id="cb186-24"><a href="#cb186-24" aria-hidden="true" tabindex="-1"></a>        T current_value<span class="op">()</span> <span class="at">const</span></span>
<span id="cb186-25"><a href="#cb186-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb186-26"><a href="#cb186-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="va">current_index_</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> <span class="va">current_index_</span> <span class="op">&lt;=</span> <span class="va">data_</span><span class="op">.</span>size<span class="op">())</span> <span class="op">{</span></span>
<span id="cb186-27"><a href="#cb186-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="va">data_</span><span class="op">[</span><span class="va">current_index_</span> <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb186-28"><a href="#cb186-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb186-29"><a href="#cb186-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>out_of_range<span class="op">(</span><span class="st">&quot;Invalid current value access&quot;</span><span class="op">);</span></span>
<span id="cb186-30"><a href="#cb186-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb186-31"><a href="#cb186-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-32"><a href="#cb186-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb186-33"><a href="#cb186-33" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="va">data_</span><span class="op">;</span>           <span class="co">///&lt; データを保持</span></span>
<span id="cb186-34"><a href="#cb186-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span>         <span class="va">current_index_</span><span class="op">;</span>  <span class="co">///&lt; 現在のインデックス</span></span>
<span id="cb186-35"><a href="#cb186-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb186-36"><a href="#cb186-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-37"><a href="#cb186-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> 偶数のみをフィルタリングする</span></span>
<span id="cb186-38"><a href="#cb186-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">input</span><span class="co"> フィルタ対象の Generator</span></span>
<span id="cb186-39"><a href="#cb186-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@return</span><span class="co"> フィルタ後の Generator</span></span>
<span id="cb186-40"><a href="#cb186-40" aria-hidden="true" tabindex="-1"></a>    Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filter_even<span class="op">(</span><span class="at">const</span> Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> input<span class="op">)</span></span>
<span id="cb186-41"><a href="#cb186-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb186-42"><a href="#cb186-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filtered<span class="op">;</span></span>
<span id="cb186-43"><a href="#cb186-43" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span>             gen <span class="op">=</span> input<span class="op">;</span></span>
<span id="cb186-44"><a href="#cb186-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-45"><a href="#cb186-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>gen<span class="op">.</span>move_next<span class="op">())</span> <span class="op">{</span></span>
<span id="cb186-46"><a href="#cb186-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>gen<span class="op">.</span>current_value<span class="op">()</span> <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb186-47"><a href="#cb186-47" aria-hidden="true" tabindex="-1"></a>                filtered<span class="op">.</span>push_back<span class="op">(</span>gen<span class="op">.</span>current_value<span class="op">());</span></span>
<span id="cb186-48"><a href="#cb186-48" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb186-49"><a href="#cb186-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb186-50"><a href="#cb186-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="bu">std::</span>move<span class="op">(</span>filtered<span class="op">));</span></span>
<span id="cb186-51"><a href="#cb186-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb186-52"><a href="#cb186-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-53"><a href="#cb186-53" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> 値を2倍に変換する</span></span>
<span id="cb186-54"><a href="#cb186-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">input</span><span class="co"> 変換対象の Generator</span></span>
<span id="cb186-55"><a href="#cb186-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@return</span><span class="co"> 変換後の Generator</span></span>
<span id="cb186-56"><a href="#cb186-56" aria-hidden="true" tabindex="-1"></a>    Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> double_values<span class="op">(</span><span class="at">const</span> Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> input<span class="op">)</span></span>
<span id="cb186-57"><a href="#cb186-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb186-58"><a href="#cb186-58" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> doubled<span class="op">;</span></span>
<span id="cb186-59"><a href="#cb186-59" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span>             gen <span class="op">=</span> input<span class="op">;</span></span>
<span id="cb186-60"><a href="#cb186-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-61"><a href="#cb186-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>gen<span class="op">.</span>move_next<span class="op">())</span> <span class="op">{</span></span>
<span id="cb186-62"><a href="#cb186-62" aria-hidden="true" tabindex="-1"></a>            doubled<span class="op">.</span>push_back<span class="op">(</span>gen<span class="op">.</span>current_value<span class="op">()</span> <span class="op">*</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb186-63"><a href="#cb186-63" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb186-64"><a href="#cb186-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="bu">std::</span>move<span class="op">(</span>doubled<span class="op">));</span></span>
<span id="cb186-65"><a href="#cb186-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb186-66"><a href="#cb186-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-67"><a href="#cb186-67" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> 数値の範囲を生成する</span></span>
<span id="cb186-68"><a href="#cb186-68" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">start</span><span class="co"> 開始値</span></span>
<span id="cb186-69"><a href="#cb186-69" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">end</span><span class="co"> 終了値</span></span>
<span id="cb186-70"><a href="#cb186-70" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@return</span><span class="co"> 範囲内の数値を生成する Generator</span></span>
<span id="cb186-71"><a href="#cb186-71" aria-hidden="true" tabindex="-1"></a>    Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> generate_numbers<span class="op">(</span><span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> end<span class="op">)</span></span>
<span id="cb186-72"><a href="#cb186-72" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb186-73"><a href="#cb186-73" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> numbers<span class="op">;</span></span>
<span id="cb186-74"><a href="#cb186-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> start<span class="op">;</span> i <span class="op">&lt;=</span> end<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb186-75"><a href="#cb186-75" aria-hidden="true" tabindex="-1"></a>            numbers<span class="op">.</span>push_back<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb186-76"><a href="#cb186-76" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb186-77"><a href="#cb186-77" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="bu">std::</span>move<span class="op">(</span>numbers<span class="op">));</span></span>
<span id="cb186-78"><a href="#cb186-78" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>このクラスは当然ながら、前記のコルーチンの単体テストコードとほぼ同じになる。</p>
<div class="sourceCode" id="cb187"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/co_yield_ut.cpp 234</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 数値を生成し、それをパイプライン処理に通す</span></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> numbers         <span class="op">=</span> generate_numbers<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> even_numbers    <span class="op">=</span> filter_even<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>numbers<span class="op">));</span></span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> doubled_numbers <span class="op">=</span> double_values<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>even_numbers<span class="op">));</span></span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-8"><a href="#cb187-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 結果を検証するために期待される値の配列を準備</span></span>
<span id="cb187-9"><a href="#cb187-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> expected_values <span class="op">=</span> <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">20</span><span class="op">};</span></span>
<span id="cb187-10"><a href="#cb187-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-11"><a href="#cb187-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 生成された値を順に取得し、期待される値と比較</span></span>
<span id="cb187-12"><a href="#cb187-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb187-13"><a href="#cb187-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>doubled_numbers<span class="op">.</span>move_next<span class="op">())</span> <span class="op">{</span></span>
<span id="cb187-14"><a href="#cb187-14" aria-hidden="true" tabindex="-1"></a>        ASSERT_LT<span class="op">(</span>index<span class="op">,</span> expected_values<span class="op">.</span>size<span class="op">());</span>  <span class="co">// インデックスが範囲内か確認</span></span>
<span id="cb187-15"><a href="#cb187-15" aria-hidden="true" tabindex="-1"></a>        EXPECT_EQ<span class="op">(</span>doubled_numbers<span class="op">.</span>current_value<span class="op">(),</span> expected_values<span class="op">[</span>index<span class="op">]);</span></span>
<span id="cb187-16"><a href="#cb187-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>index<span class="op">;</span></span>
<span id="cb187-17"><a href="#cb187-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb187-18"><a href="#cb187-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-19"><a href="#cb187-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 最終的にすべての期待される値が生成されたことを確認</span></span>
<span id="cb187-20"><a href="#cb187-20" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>index<span class="op">,</span> expected_values<span class="op">.</span>size<span class="op">());</span></span></code></pre></div>
<p>C++20から導入されたco_await、co_return、TaskとC++17以前の機能のみを使用したコードの対比によって、
コルーチンのサポート機能により実装が容易になることが理解できるだろう。</p>
<h3 id="モジュール">モジュール <a id="SS_19_10_2"></a></h3>
<p>モジュールはC++20から導入された機能であり、以下の新しいキーワードによりサポートされる。</p>
<ul>
<li>module:
モジュールを宣言する。独立した構造を持ち、名前の衝突を防ぐ。</li>
<li>export:
モジュール外部に公開する関数やクラスを指定する。公開しない要素はモジュール内に限定される。</li>
<li>import:
他のモジュールをインポートして利用できる。従来の#includeと異なり、依存関係を最適化し、ビルド時間を短縮する。</li>
</ul>
<p>以下にこれらのキーワードのコード例を示す。</p>
<p>まずは、同時に使われることが多い<code>module</code>と<code>export</code>の使用例を示す。</p>
<div class="sourceCode" id="cb188"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/module_cmake/type_traits.cppm 1</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">export</span> <span class="kw">module</span> type_traits<span class="op">;</span>  <span class="co">// モジュール宣言</span></span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> type_traits <span class="op">{</span>  <span class="co">// 通常の名前空間。モジュール名と同じにして良い</span></span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span>       <span class="co">// 内部実装であるためexportしない</span></span>
<span id="cb188-7"><a href="#cb188-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-8"><a href="#cb188-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// T == void</span></span>
<span id="cb188-9"><a href="#cb188-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb188-10"><a href="#cb188-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> is_void_sfinae_f_detector<span class="op">(</span><span class="dt">void</span> <span class="at">const</span><span class="op">*</span> v<span class="op">,</span> T <span class="at">const</span><span class="op">*</span> t<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb188-11"><a href="#cb188-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>t <span class="op">=</span> v<span class="op">,</span> <span class="dt">bool</span><span class="op">{})</span>  <span class="co">// T != voidの場合、t = vはill-formed</span></span>
<span id="cb188-12"><a href="#cb188-12" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">// T == voidの場合、well-formedでbool型生成</span></span>
<span id="cb188-13"><a href="#cb188-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb188-14"><a href="#cb188-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb188-15"><a href="#cb188-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb188-16"><a href="#cb188-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-17"><a href="#cb188-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// T != void</span></span>
<span id="cb188-18"><a href="#cb188-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb188-19"><a href="#cb188-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> is_void_sfinae_f_detector<span class="op">(</span><span class="dt">void</span> <span class="at">const</span><span class="op">*,</span> T <span class="at">const</span><span class="op">*)</span> <span class="kw">noexcept</span></span>
<span id="cb188-20"><a href="#cb188-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>T<span class="op">),</span> <span class="dt">bool</span><span class="op">{})</span>  <span class="co">// T != voidの場合、well-formedでbool型生成</span></span>
<span id="cb188-21"><a href="#cb188-21" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">// T == voidの場合、sizeof(T)はill-formed</span></span>
<span id="cb188-22"><a href="#cb188-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb188-23"><a href="#cb188-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb188-24"><a href="#cb188-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb188-25"><a href="#cb188-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb188-26"><a href="#cb188-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-27"><a href="#cb188-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">export</span></span>
<span id="cb188-28"><a href="#cb188-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// 纏めてexport</span></span>
<span id="cb188-29"><a href="#cb188-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb188-30"><a href="#cb188-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="dt">bool</span> is_void<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb188-31"><a href="#cb188-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb188-32"><a href="#cb188-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Inner_<span class="op">::</span>is_void_sfinae_f_detector<span class="op">(</span><span class="kw">nullptr</span><span class="op">,</span> <span class="kw">static_cast</span><span class="op">&lt;</span>T<span class="op">*&gt;(</span><span class="kw">nullptr</span><span class="op">));</span></span>
<span id="cb188-33"><a href="#cb188-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb188-34"><a href="#cb188-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb188-35"><a href="#cb188-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> is_void_v <span class="op">=</span> is_void<span class="op">&lt;</span>T<span class="op">&gt;();</span></span>
<span id="cb188-36"><a href="#cb188-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb188-37"><a href="#cb188-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace type_traits</span></span></code></pre></div>
<p>最後に<code>import</code>の使用例を示す。</p>
<div class="sourceCode" id="cb189"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/module_cmake/main.cpp 1</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">import</span> math<span class="op">;</span>        <span class="co">// モジュールのインポート</span></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">import</span> type_traits<span class="op">;</span> <span class="co">// モジュールのインポート</span></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;iostream&gt;</span><span class="pp">  </span><span class="co">// これまで同様のインクルード。stdのモジュール化はC++23から</span></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Add: &quot;</span> <span class="op">&lt;&lt;</span> math<span class="op">::</span>add<span class="op">(</span>a<span class="op">,</span> b<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Multiply: &quot;</span> <span class="op">&lt;&lt;</span> math<span class="op">::</span>multiply<span class="op">(</span>a<span class="op">,</span> b<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb189-12"><a href="#cb189-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-13"><a href="#cb189-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>boolalpha <span class="op">&lt;&lt;</span> type_traits<span class="op">::</span>is_void<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb189-14"><a href="#cb189-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>boolalpha <span class="op">&lt;&lt;</span> type_traits<span class="op">::</span>is_void_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">)&gt;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb189-15"><a href="#cb189-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>これらにより、モジュールは依存関係の管理、名前空間の分離、ビルド時間の短縮を実現し、
大規模プロジェクトでの保守性向上に貢献する。
が、一方ではC++のモジュールに対応してるビルドツールを使用することが望ましい。</p>
<h3 id="ラムダ式">ラムダ式 <a id="SS_19_10_3"></a></h3>
<p>ラムダ式に関する言葉の定義と例を示す。</p>
<ul>
<li>ラムダ式とは、その場で関数オブジェクトを定義する式。</li>
<li>クロージャ(オブジェクト)とは、ラムダ式から生成された関数オブジェクト。</li>
<li>クロージャ型とは、クロージャオブジェクトの型。</li>
<li>キャプチャとは、ラムダ式外部の変数をラムダ式内にコピーかリファレンスとして定義する機能。</li>
<li>ラムダ式からキャプチャできるのは、ラムダ式から可視である自動変数と仮引数(thisを含む)。</li>
<li><a
href="core_lang_spec.html#SS_19_5_9">constexprラムダ</a>とはクロージャ型の<a
href="core_lang_spec.html#SS_19_5_6">constexprインスタンス</a>。</li>
<li><a
href="core_lang_spec.html#SS_19_11_6">ジェネリックラムダ</a>とは、C++11のラムダ式を拡張して、
パラメータにautoを使用(型推測)できるようにした機能。</li>
</ul>
<div class="sourceCode" id="cb190"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/lambda.cpp 10</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// closureがクロージャ。それを初期化する式がラムダ式</span></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [a = a]がキャプチャ</span></span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [a = a]内の右辺aは上記で定義されたa</span></span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [a = a]内の左辺aは右辺aで初期化された変数。ラムダ式内で使用されるaは左辺a。</span></span>
<span id="cb190-9"><a href="#cb190-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> closure <span class="op">=</span> <span class="op">[</span>a <span class="op">=</span> a<span class="op">](</span><span class="dt">int32_t</span> b<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span> <span class="op">};</span></span>
<span id="cb190-10"><a href="#cb190-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-11"><a href="#cb190-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ret <span class="op">=</span> closure<span class="op">(</span><span class="dv">3</span><span class="op">);</span>  <span class="co">// クロージャの実行</span></span>
<span id="cb190-12"><a href="#cb190-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-13"><a href="#cb190-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// g_closureはジェネリックラムダ</span></span>
<span id="cb190-14"><a href="#cb190-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="va">g_closure</span> <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span> t0<span class="op">,</span> <span class="kw">auto</span> t1<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> t0 <span class="op">+</span> t1<span class="op">;</span> <span class="op">};</span></span>
<span id="cb190-15"><a href="#cb190-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-16"><a href="#cb190-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> i <span class="op">=</span> <span class="va">g_closure</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span>                                <span class="co">// t0、t1はint</span></span>
<span id="cb190-17"><a href="#cb190-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> s <span class="op">=</span> <span class="va">g_closure</span><span class="op">(</span><span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;1&quot;</span><span class="op">},</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;2&quot;</span><span class="op">});</span>  <span class="co">// t0、t1はstd::string</span></span></code></pre></div>
<h4 id="クロージャ">クロージャ <a id="SS_19_10_3_1"></a></h4>
<p>「<a
href="core_lang_spec.html#SS_19_10_3">ラムダ式</a>」を参照せよ。</p>
<h4 id="クロージャ型">クロージャ型 <a id="SS_19_10_3_2"></a></h4>
<p>「<a
href="core_lang_spec.html#SS_19_10_3">ラムダ式</a>」を参照せよ。</p>
<h4 id="一時的ラムダ">一時的ラムダ <a id="SS_19_10_3_3"></a></h4>
<p>一時的ラムダ(transient
lambda)とは下記のような使い方をするラムダ式指す慣用用語である。</p>
<p>複雑な初期化を必要とするconstオブジェクトの生成をするような場合に有用なテクニックである。</p>
<div class="sourceCode" id="cb191"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/transient_lambda_ut.cpp 9</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ラムダ式を即時実行するために () を追加</span></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> vec_act <span class="op">=</span> <span class="op">[&amp;</span>vec <span class="op">=</span> vec<span class="op">]()</span> <span class="op">{</span></span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="dt">arg_type</span> <span class="op">=</span> <span class="bu">std::</span>remove_reference_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>vec<span class="op">)&gt;;</span></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">arg_type</span> temp<span class="op">;</span></span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> val <span class="op">:</span> vec<span class="op">)</span> <span class="op">{</span></span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a>            temp<span class="op">.</span>push_back<span class="op">(</span>val <span class="op">*</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb191-12"><a href="#cb191-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> temp<span class="op">;</span>  <span class="co">// 変更後のベクターを返す</span></span>
<span id="cb191-13"><a href="#cb191-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}();</span></span>
<span id="cb191-14"><a href="#cb191-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-15"><a href="#cb191-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="at">const</span> vec_exp<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">};</span></span>
<span id="cb191-16"><a href="#cb191-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-17"><a href="#cb191-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>vec_act<span class="op">,</span> vec_exp<span class="op">);</span></span></code></pre></div>
<h4 id="transient-lambda">transient lambda
<a id="SS_19_10_3_4"></a></h4>
<p>「<a
href="core_lang_spec.html#SS_19_10_3_3">一時的ラムダ</a>」を参照せよ。</p>
<h3 id="指示付き初期化">指示付き初期化 <a id="SS_19_10_4"></a></h3>
<p>指示付き初期化(designated
initialization)とは、C++20から導入されたシンタックスであり、
構造体やクラスのメンバを明示的に指定して初期化できるようにする機能である。
この構文により、コードの可読性と安全性が向上し、初期化漏れや順序の誤りを防ぐことができる。</p>
<p>まずは、この機能を有効に使えるクラス例を以下に示す。</p>
<div class="sourceCode" id="cb192"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/designated_init_ut.cpp 11</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>  x<span class="op">;</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>  y<span class="op">;</span></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Point <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-9"><a href="#cb192-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Circl <span class="op">{</span></span>
<span id="cb192-10"><a href="#cb192-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb192-11"><a href="#cb192-11" aria-hidden="true" tabindex="-1"></a>        Circl<span class="op">(</span>Point center<span class="op">,</span> <span class="dt">uint32_t</span> radius<span class="op">)</span> <span class="op">:</span> <span class="va">center_</span><span class="op">{</span>center<span class="op">},</span> <span class="va">radius_</span><span class="op">{</span>radius<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb192-12"><a href="#cb192-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-13"><a href="#cb192-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string to_string<span class="op">()</span></span>
<span id="cb192-14"><a href="#cb192-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb192-15"><a href="#cb192-15" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>ostringstream oss<span class="op">;</span></span>
<span id="cb192-16"><a href="#cb192-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-17"><a href="#cb192-17" aria-hidden="true" tabindex="-1"></a>            oss <span class="op">&lt;&lt;</span> <span class="st">&quot;center x:&quot;</span> <span class="op">&lt;&lt;</span> <span class="va">center_</span><span class="op">.</span>x <span class="op">&lt;&lt;</span> <span class="st">&quot; y:&quot;</span> <span class="op">&lt;&lt;</span> <span class="va">center_</span><span class="op">.</span>y <span class="op">&lt;&lt;</span> <span class="st">&quot; radius:&quot;</span> <span class="op">&lt;&lt;</span> <span class="va">radius_</span><span class="op">;</span></span>
<span id="cb192-18"><a href="#cb192-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> oss<span class="op">.</span>str<span class="op">();</span></span>
<span id="cb192-19"><a href="#cb192-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb192-20"><a href="#cb192-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-21"><a href="#cb192-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Circl <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb192-22"><a href="#cb192-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-23"><a href="#cb192-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb192-24"><a href="#cb192-24" aria-hidden="true" tabindex="-1"></a>        Point <span class="at">const</span> <span class="va">center_</span><span class="op">;</span></span>
<span id="cb192-25"><a href="#cb192-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span>    <span class="va">radius_</span><span class="op">;</span></span>
<span id="cb192-26"><a href="#cb192-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb193"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/designated_init_ut.cpp 41</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point p0 <span class="op">{</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>        <span class="dv">10</span><span class="op">,</span> <span class="dv">20</span></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point p1 <span class="op">{</span></span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> <span class="op">.</span>y <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span>  <span class="co">// x、yを明示できるため、可読性向上が見込める</span></span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-10"><a href="#cb193-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>p0<span class="op">,</span> p1<span class="op">);</span></span>
<span id="cb193-11"><a href="#cb193-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-12"><a href="#cb193-12" aria-hidden="true" tabindex="-1"></a>    Circl circl_0<span class="op">{</span>p1<span class="op">,</span> <span class="dv">2</span><span class="bu">U</span><span class="op">};</span></span>
<span id="cb193-13"><a href="#cb193-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;center x:10 y:20 radius:2&quot;</span><span class="op">,</span> circl_0<span class="op">.</span>to_string<span class="op">());</span></span>
<span id="cb193-14"><a href="#cb193-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-15"><a href="#cb193-15" aria-hidden="true" tabindex="-1"></a>    Circl circl_1<span class="op">{{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">},</span> <span class="dv">2</span><span class="bu">U</span><span class="op">};</span>  <span class="co">// circl_2に比べると可読性に劣る</span></span>
<span id="cb193-16"><a href="#cb193-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;center x:10 y:20 radius:2&quot;</span><span class="op">,</span> circl_1<span class="op">.</span>to_string<span class="op">());</span></span>
<span id="cb193-17"><a href="#cb193-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-18"><a href="#cb193-18" aria-hidden="true" tabindex="-1"></a>    Circl circl_2<span class="op">{{.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> <span class="op">.</span>y <span class="op">=</span> <span class="dv">20</span><span class="op">},</span> <span class="dv">2</span><span class="bu">U</span><span class="op">};</span>  <span class="co">// x、yを明示できるため、可読性向上が見込める</span></span>
<span id="cb193-19"><a href="#cb193-19" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;center x:10 y:20 radius:2&quot;</span><span class="op">,</span> circl_2<span class="op">.</span>to_string<span class="op">());</span></span>
<span id="cb193-20"><a href="#cb193-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-21"><a href="#cb193-21" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>circl_1<span class="op">,</span> circl_2<span class="op">);</span></span></code></pre></div>
<p>下記に示すように、<a
href="stdlib_and_concepts.html#SS_20_6">Polymorphic Memory
Resource(pmr)</a>のpool_resourceの初期化には、
この機能を使うと可読性の改善が期待できる。</p>
<div class="sourceCode" id="cb194"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/designated_init_ut.cpp 68</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pmr::unsynchronized_pool_resource pool_resource<span class="op">(</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>pmr::pool_options<span class="op">{</span></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>max_blocks_per_chunk        <span class="op">=</span> <span class="dv">10</span><span class="op">,</span>   <span class="co">// チャンクあたりの最大ブロック数</span></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>largest_required_pool_block <span class="op">=</span> <span class="dv">1024</span>  <span class="co">// 最大ブロックサイズ</span></span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">},</span></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>pmr::new_delete_resource<span class="op">()</span>  <span class="co">// フォールバックリソース</span></span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-11"><a href="#cb194-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pmr::vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">{&amp;</span>pool_resource<span class="op">};</span>  <span class="co">// pmrを使用するベクタの定義</span></span></code></pre></div>
<p>指示付き初期化を使わない以下のコード例と上記を比べれば可読性の改善に議論の余地はないだろう。</p>
<div class="sourceCode" id="cb195"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/designated_init_ut.cpp 83</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 指示付き初期化を使わずにstd::pmr::unsynchronized_pool_resourceの初期化</span></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pmr::unsynchronized_pool_resource pool_resource<span class="op">(</span></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>pmr::pool_options<span class="op">{</span></span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a>            <span class="dv">10</span><span class="op">,</span>   <span class="co">// チャンクあたりの最大ブロック数</span></span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a>            <span class="dv">1024</span>  <span class="co">// 最大ブロックサイズ</span></span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">},</span></span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>pmr::new_delete_resource<span class="op">()</span>  <span class="co">// フォールバックリソース</span></span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">);</span></span>
<span id="cb195-11"><a href="#cb195-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-12"><a href="#cb195-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>pmr::vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">{&amp;</span>pool_resource<span class="op">};</span>  <span class="co">// pmrを使用するベクタの定義</span></span></code></pre></div>
<h2 id="テンプレートと型推論">テンプレートと型推論
<a id="SS_19_11"></a></h2>
<h3 id="sfinae">SFINAE <a id="SS_19_11_1"></a></h3>
<p><a
href="https://cpprefjp.github.io/lang/cpp11/sfinae_expressions.html">SFINAE</a>
(Substitution Failure Is Not An Errorの略称、スフィネェと読む)とは、
「テンプレートのパラメータ置き換えに失敗した(<a
href="core_lang_spec.html#SS_19_14_1">ill-formed</a>になった)際に、
即時にコンパイルエラーとはせず、置き換えに失敗したテンプレートを <a
href="core_lang_spec.html#SS_19_12_2">name lookup</a>の候補から除外する」
という言語機能である。</p>
<h3 id="メタ関数">メタ関数 <a id="SS_19_11_2"></a></h3>
<p>メタ関数とは、型を引数として型または値を返すテンプレートのことを指す。
通常の関数が実行時に値を返すのに対し、メタ関数はコンパイル時に型情報を生成または変換する。
主要なメタ関数は標準ライブラリの<a
href="stdlib_and_concepts.html#SS_20_2">type_traits</a>で定義されている。</p>
<h3 id="コンセプト">コンセプト <a id="SS_19_11_3"></a></h3>
<p>C++17までのテンプレートには以下のような問題があった。</p>
<ul>
<li><a
href="core_lang_spec.html#SS_19_11_1">SFINAE</a>による制約が複雑<br />
テンプレートの制約を行うために、
std::enable_ifやの仕組みを使う必要があり、コードが非常に複雑で難読になりがちだった。</li>
<li>エラーメッセージが不明瞭<br />
テンプレートのパラメータが不適切な型だった場合に、
コンパイルエラーのメッセージが非常にわかりにくく、問題の原因を特定するのが困難だった。</li>
<li>テンプレートの適用範囲が不明確<br />
テンプレートの使用可能な型の範囲がドキュメントやコメントでしか表現されず、
明確な制約がコードに反映されていなかったため、コードの意図が伝わりづらい。</li>
<li>部分特殊化やオーバーロードによる冗長性<br />
特定の型に対するテンプレートの処理を制限するために、
部分特殊化やテンプレートオーバーロードを行うことが多く、コードが冗長になりがちだった。</li>
</ul>
<p>C++20から導入された「コンセプト(concepts)」は、
テンプレートパラメータを制約する機能である。
この機能を使用することで、以下のようなプログラミングでのメリットが得られる。</p>
<ul>
<li>テンプレートの制約を明確に定義できる<br />
コンセプトを使うことで、テンプレートパラメータが満たすべき条件を宣言的に記述できるため、
コードの意図が明確にできる。</li>
<li>コンパイルエラーがわかりやすくなる<br />
コンセプトを使用すると、テンプレートの適用範囲外の型に対して、
より具体的でわかりやすいエラーメッセージが表示される。</li>
<li>コードの可読性が向上する<br />
コンセプトを利用することで、
テンプレート関数やクラスのインターフェースが明確になり、可読性が向上する。</li>
</ul>
<div class="sourceCode" id="cb196"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/concept_ut.cpp 12</span></span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// SFINAEを使用したc++17スタイル</span></span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="kw">typename</span> <span class="bu">std::</span>enable_if<span class="op">&lt;</span><span class="bu">std::</span>is_arithmetic<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">&gt;::</span>type<span class="op">&gt;</span></span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a>    T add<span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span></span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb196-7"><a href="#cb196-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb196-8"><a href="#cb196-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb196-9"><a href="#cb196-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-10"><a href="#cb196-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/concept_ut.cpp 24</span></span>
<span id="cb196-11"><a href="#cb196-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-12"><a href="#cb196-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>add<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">),</span> <span class="dv">30</span><span class="op">);</span>     <span class="co">// int型</span></span>
<span id="cb196-13"><a href="#cb196-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>add<span class="op">(</span><span class="fl">1.5</span><span class="op">,</span> <span class="fl">2.5</span><span class="op">),</span> <span class="fl">4.0</span><span class="op">);</span>  <span class="co">// double型</span></span>
<span id="cb196-14"><a href="#cb196-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-15"><a href="#cb196-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str1 <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;Hello, &quot;</span><span class="op">};</span></span>
<span id="cb196-16"><a href="#cb196-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str2 <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;World!&quot;</span><span class="op">};</span></span>
<span id="cb196-17"><a href="#cb196-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// add(str1, str2);  // これを試すとコンパイルエラー</span></span>
<span id="cb196-18"><a href="#cb196-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// concept_ut.cpp:10:3: note: candidate: ‘template&lt;class T, class&gt; T</span></span>
<span id="cb196-19"><a href="#cb196-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// {anonymous}::old_style::add(T, T)’</span></span>
<span id="cb196-20"><a href="#cb196-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">//    10 | T add(T a, T b) {</span></span>
<span id="cb196-21"><a href="#cb196-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">//       |   ^~~</span></span>
<span id="cb196-22"><a href="#cb196-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// concept_ut.cpp:10:3: note:   template argument deduction/substitution failed:</span></span>
<span id="cb196-23"><a href="#cb196-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// concept_ut.cpp:9:22: error: no type named ‘type’ in ‘struct std::enable_if&lt;false, void&gt;’</span></span>
<span id="cb196-24"><a href="#cb196-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">//     9 | template&lt;typename T, typename = typename</span></span>
<span id="cb196-25"><a href="#cb196-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">//     std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type&gt;</span></span>
<span id="cb196-26"><a href="#cb196-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">//       |                      ^~~~~~~~</span></span>
<span id="cb196-27"><a href="#cb196-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// エラーメッセージがわかりずらい</span></span></code></pre></div>
<div class="sourceCode" id="cb197"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/concept_ut.cpp 49</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// コンセプトを使用したC++20スタイル</span></span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> Arithmetic <span class="op">=</span> <span class="bu">std::</span>is_arithmetic_v<span class="op">&lt;</span>T<span class="op">&gt;;</span></span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span>Arithmetic T<span class="op">&gt;</span></span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true" tabindex="-1"></a>    T add<span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span></span>
<span id="cb197-9"><a href="#cb197-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb197-10"><a href="#cb197-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb197-11"><a href="#cb197-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb197-12"><a href="#cb197-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-13"><a href="#cb197-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/concept_ut.cpp 64</span></span>
<span id="cb197-14"><a href="#cb197-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-15"><a href="#cb197-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>add<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">),</span> <span class="dv">30</span><span class="op">);</span>     <span class="co">// int型</span></span>
<span id="cb197-16"><a href="#cb197-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>add<span class="op">(</span><span class="fl">1.5</span><span class="op">,</span> <span class="fl">2.5</span><span class="op">),</span> <span class="fl">4.0</span><span class="op">);</span>  <span class="co">// double型</span></span>
<span id="cb197-17"><a href="#cb197-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-18"><a href="#cb197-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str1 <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;Hello, &quot;</span><span class="op">};</span></span>
<span id="cb197-19"><a href="#cb197-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str2 <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;World!&quot;</span><span class="op">};</span></span>
<span id="cb197-20"><a href="#cb197-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// add(str1, str2);  // これを試すとコンパイルエラー</span></span>
<span id="cb197-21"><a href="#cb197-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// concept_ut.cpp:36:27: note: the expression ‘is_arithmetic_v&lt;T&gt; [with T =</span></span>
<span id="cb197-22"><a href="#cb197-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::basic_string&lt;char, std</span></span>
<span id="cb197-23"><a href="#cb197-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;]’ evaluated to ‘false’</span></span>
<span id="cb197-24"><a href="#cb197-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">//    36 | concept Arithmetic = std::is_arithmetic_v&lt;T&gt;;</span></span>
<span id="cb197-25"><a href="#cb197-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">//       |                      ~~~~~^~~~~~~~~~~~~~~~~~</span></span>
<span id="cb197-26"><a href="#cb197-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ↑  エラーメッセージがわかりよい。テンプレートTがコンセプトfalseとなる</span></span></code></pre></div>
<p>以下はテンプレートパラメータの制約にstatic_assertを使用した例である。</p>
<div class="sourceCode" id="cb198"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/concept_ut.cpp 85</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 制約のためにstatic_assertを使用したC++17スタイル</span></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> FLOAT_0<span class="op">,</span> <span class="kw">typename</span> FLOAT_1<span class="op">&gt;</span></span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_equal<span class="op">(</span>FLOAT_0 lhs<span class="op">,</span> FLOAT_1 rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_floating_point_v<span class="op">&lt;</span>FLOAT_0<span class="op">&gt;,</span> <span class="st">&quot;FLOAT_0 shoud be float or double.&quot;</span><span class="op">);</span></span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>FLOAT_0<span class="op">,</span> FLOAT_1<span class="op">&gt;,</span> <span class="st">&quot;FLOAT_0 and FLOAT_1 shoud be a same type.&quot;</span><span class="op">);</span></span>
<span id="cb198-9"><a href="#cb198-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-10"><a href="#cb198-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>lhs <span class="op">-</span> rhs<span class="op">)</span> <span class="op">&lt;=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>FLOAT_0<span class="op">&gt;::</span>epsilon<span class="op">();</span></span>
<span id="cb198-11"><a href="#cb198-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>以上の関数テンプレートをコンセプトを使用して改善した例である。</p>
<div class="sourceCode" id="cb199"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/concept_ut.cpp 113</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 標準コンセプト std::floating_point と std::same_as を使用</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>floating_point FLOAT_0<span class="op">,</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>FLOAT_0<span class="op">&gt;</span> FLOAT_1<span class="op">&gt;</span></span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_equal<span class="op">(</span>FLOAT_0 lhs<span class="op">,</span> FLOAT_1 rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb199-6"><a href="#cb199-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb199-7"><a href="#cb199-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>lhs <span class="op">-</span> rhs<span class="op">)</span> <span class="op">&lt;=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>FLOAT_0<span class="op">&gt;::</span>epsilon<span class="op">();</span></span>
<span id="cb199-8"><a href="#cb199-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>フレキシブルに制約を記述するためにrequiresを使用したコード例を下記する。</p>
<div class="sourceCode" id="cb200"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/concept_ut.cpp 138</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// requiresを使った関数テンプレートの制約</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> FLOAT_0<span class="op">,</span> <span class="kw">typename</span> FLOAT_1<span class="op">&gt;</span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="bu">std::</span>floating_point<span class="op">&lt;</span>FLOAT_0<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>FLOAT_0<span class="op">,</span> FLOAT_1<span class="op">&gt;</span></span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_equal<span class="op">(</span>FLOAT_0 lhs<span class="op">,</span> FLOAT_1 rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb200-10"><a href="#cb200-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>lhs <span class="op">-</span> rhs<span class="op">)</span> <span class="op">&lt;=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>FLOAT_0<span class="op">&gt;::</span>epsilon<span class="op">();</span></span>
<span id="cb200-11"><a href="#cb200-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb200-12"><a href="#cb200-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-13"><a href="#cb200-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb200-14"><a href="#cb200-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> FLOAT_0<span class="op">,</span> <span class="kw">typename</span> FLOAT_1<span class="op">&gt;</span></span>
<span id="cb200-15"><a href="#cb200-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_equal<span class="op">(</span>FLOAT_0 lhs<span class="op">,</span> FLOAT_1 rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb200-16"><a href="#cb200-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb200-17"><a href="#cb200-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>FLOAT_0<span class="op">,</span> FLOAT_1<span class="op">&gt;);</span></span>
<span id="cb200-18"><a href="#cb200-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>lhs <span class="op">-</span> rhs<span class="op">)</span> <span class="op">&lt;=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>FLOAT_0<span class="op">&gt;::</span>epsilon<span class="op">();</span></span>
<span id="cb200-19"><a href="#cb200-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb200-20"><a href="#cb200-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span></code></pre></div>
<h3 id="パラメータパック">パラメータパック <a id="SS_19_11_4"></a></h3>
<p>パラメータパック(parameter
pack)は、可変長テンプレート引数を表現するためにC++11で導入されたシンタックスである。
テンプレートの定義時に、任意個数のテンプレート引数または関数引数をまとめて受け取ることができる。</p>
<p>パラメータパックのシンタックスは以下のようなものである。</p>
<ul>
<li><code>typename... Args</code> - テンプレートパラメータパック</li>
<li><code>Args... args</code> - 関数パラメータパック</li>
<li><code>args...</code> - パック展開（pack expansion）</li>
<li><code>sizeof...(args)</code> - パック内の要素数を取得</li>
</ul>
<p>パラメータパックを使用した関数テンプレートは以下のように定義する。</p>
<div class="sourceCode" id="cb201"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/template_ut.cpp 70</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">)</span> <span class="op">{</span> os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="op">}</span></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> TAIL<span class="op">&gt;</span></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> print<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> HEAD head<span class="op">,</span> TAIL<span class="op">...</span> tail<span class="op">)</span></span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> head<span class="op">;</span></span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a>        print<span class="op">(</span>os<span class="op">,</span> tail<span class="op">...);</span>  <span class="co">// 残りの引数を再帰的に処理</span></span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-11"><a href="#cb201-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> <span class="kw">sizeof</span><span class="op">...(</span>tail<span class="op">);</span>  <span class="co">// headの1個 + tailの個数 = 全パラメータ数</span></span>
<span id="cb201-12"><a href="#cb201-12" aria-hidden="true" tabindex="-1"></a>                                     <span class="co">// sizeof...(tail)はパック内の要素数</span></span>
<span id="cb201-13"><a href="#cb201-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>以下の単体テストは上記の関数の使い方を示している。</p>
<div class="sourceCode" id="cb202"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/template_ut.cpp 87</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>stringstream os<span class="op">;</span></span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> parameter_pack_count <span class="op">=</span> print<span class="op">(</span>os<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;-&quot;</span><span class="op">,</span> <span class="st">&quot;c_str-&quot;</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;std::string&quot;</span><span class="op">});</span></span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-7"><a href="#cb202-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;1-c_str-std::string</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> os<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb202-8"><a href="#cb202-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">4</span><span class="op">,</span> parameter_pack_count<span class="op">);</span></span></code></pre></div>
<h3 id="畳み込み式">畳み込み式 <a id="SS_19_11_5"></a></h3>
<p>畳み式(fold expression)とは、C++17から導入された新機能であり、
可変引数テンプレートのパラメータパックに対して二項演算を累積的に行うためのものである。</p>
<p>畳み込み式のシンタックスの使用は下記のようなものである。</p>
<pre><code>( pack op ... )          // (1) 単項右畳み込み
( ... op pack )          // (2) 単項左畳み込み
( pack op ... op init )  // (3) 二項右畳み込み
( init op ... op pack )  // (4) 二項左畳み込み</code></pre>
<ol type="1">
<li>単項右畳み込み</li>
</ol>
<div class="sourceCode" id="cb204"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/flold_expression_ut.cpp 9</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> cpp14_style <span class="op">{</span>  <span class="co">// c++14までのスタイル</span></span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> all_true<span class="op">(</span>T arg<span class="op">)</span></span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb204-7"><a href="#cb204-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arg<span class="op">;</span></span>
<span id="cb204-8"><a href="#cb204-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb204-9"><a href="#cb204-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb204-10"><a href="#cb204-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> all_true<span class="op">(</span>T arg<span class="op">,</span> Args<span class="op">...</span> args<span class="op">)</span></span>
<span id="cb204-11"><a href="#cb204-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb204-12"><a href="#cb204-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arg <span class="op">&amp;&amp;</span> all_true<span class="op">(</span>args<span class="op">...);</span></span>
<span id="cb204-13"><a href="#cb204-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb204-14"><a href="#cb204-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace cpp14_style</span></span>
<span id="cb204-15"><a href="#cb204-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-16"><a href="#cb204-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> cpp17_style <span class="op">{</span>  <span class="co">// 畳み込み式を使用したスタイル</span></span>
<span id="cb204-17"><a href="#cb204-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb204-18"><a href="#cb204-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> all_true<span class="op">(</span>Ts<span class="op">...</span> args<span class="op">)</span></span>
<span id="cb204-19"><a href="#cb204-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb204-20"><a href="#cb204-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>args <span class="op">&amp;&amp;</span> <span class="op">...);</span>  <span class="co">// 単項右畳み込み</span></span>
<span id="cb204-21"><a href="#cb204-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb204-22"><a href="#cb204-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace cpp17_style</span></span>
<span id="cb204-23"><a href="#cb204-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-24"><a href="#cb204-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>cpp14_style<span class="op">::</span>all_true<span class="op">(</span><span class="kw">true</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> <span class="kw">true</span><span class="op">));</span></span>
<span id="cb204-25"><a href="#cb204-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>cpp17_style<span class="op">::</span>all_true<span class="op">(</span><span class="kw">true</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> <span class="kw">true</span><span class="op">));</span></span></code></pre></div>
<ol start="2" type="1">
<li>単項左畳み込み</li>
</ol>
<div class="sourceCode" id="cb205"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/flold_expression_ut.cpp 36</span></span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> cpp14_style <span class="op">{</span>  <span class="co">// c++14までのスタイル</span></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> any_true<span class="op">(</span>T arg<span class="op">)</span></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arg<span class="op">;</span></span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> any_true<span class="op">(</span>T arg<span class="op">,</span> Args<span class="op">...</span> args<span class="op">)</span></span>
<span id="cb205-10"><a href="#cb205-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb205-11"><a href="#cb205-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arg <span class="op">||</span> any_true<span class="op">(</span>args<span class="op">...);</span></span>
<span id="cb205-12"><a href="#cb205-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb205-13"><a href="#cb205-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace cpp14_style</span></span>
<span id="cb205-14"><a href="#cb205-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-15"><a href="#cb205-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> cpp17_style <span class="op">{</span>  <span class="co">// 畳み込み式を使用したスタイル</span></span>
<span id="cb205-16"><a href="#cb205-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb205-17"><a href="#cb205-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> any_true<span class="op">(</span>Ts<span class="op">...</span> args<span class="op">)</span></span>
<span id="cb205-18"><a href="#cb205-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb205-19"><a href="#cb205-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(...</span> <span class="op">||</span> args<span class="op">);</span>  <span class="co">// 単項左畳み込み</span></span>
<span id="cb205-20"><a href="#cb205-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb205-21"><a href="#cb205-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace cpp17_style</span></span>
<span id="cb205-22"><a href="#cb205-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>cpp14_style<span class="op">::</span>any_true<span class="op">(</span><span class="kw">false</span><span class="op">,</span> <span class="kw">false</span><span class="op">,</span> <span class="kw">true</span><span class="op">));</span></span>
<span id="cb205-23"><a href="#cb205-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>cpp17_style<span class="op">::</span>any_true<span class="op">(</span><span class="kw">false</span><span class="op">,</span> <span class="kw">false</span><span class="op">,</span> <span class="kw">true</span><span class="op">));</span></span></code></pre></div>
<ol start="3" type="1">
<li>二項右畳み込み</li>
</ol>
<div class="sourceCode" id="cb206"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/flold_expression_ut.cpp 61</span></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> cpp14_style <span class="op">{</span>  <span class="co">// c++14までのスタイル</span></span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> sum<span class="op">(</span>T arg<span class="op">)</span></span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arg<span class="op">;</span></span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb206-9"><a href="#cb206-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb206-10"><a href="#cb206-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> sum<span class="op">(</span>T arg<span class="op">,</span> Args<span class="op">...</span> args<span class="op">)</span></span>
<span id="cb206-11"><a href="#cb206-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb206-12"><a href="#cb206-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arg <span class="op">+</span> sum<span class="op">(</span>args<span class="op">...);</span></span>
<span id="cb206-13"><a href="#cb206-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb206-14"><a href="#cb206-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-15"><a href="#cb206-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace cpp14_style</span></span>
<span id="cb206-16"><a href="#cb206-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-17"><a href="#cb206-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> cpp17_style <span class="op">{</span>  <span class="co">// 畳み込み式を使用したスタイル</span></span>
<span id="cb206-18"><a href="#cb206-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb206-19"><a href="#cb206-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> sum<span class="op">(</span>Ts<span class="op">...</span> args<span class="op">)</span></span>
<span id="cb206-20"><a href="#cb206-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb206-21"><a href="#cb206-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>args <span class="op">+</span> <span class="op">...</span> <span class="op">+</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// 二項右畳み込み (初期値: 0)</span></span>
<span id="cb206-22"><a href="#cb206-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb206-23"><a href="#cb206-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace cpp17_style</span></span>
<span id="cb206-24"><a href="#cb206-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-25"><a href="#cb206-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>cpp14_style<span class="op">::</span>sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">));</span></span>
<span id="cb206-26"><a href="#cb206-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>cpp17_style<span class="op">::</span>sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">));</span></span></code></pre></div>
<ol start="4" type="1">
<li>二項左畳み込み</li>
</ol>
<div class="sourceCode" id="cb207"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/flold_expression_ut.cpp 89</span></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> cpp14_style <span class="op">{</span>  <span class="co">// c++14までのスタイル</span></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> product<span class="op">(</span>T arg<span class="op">)</span></span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arg<span class="op">;</span></span>
<span id="cb207-8"><a href="#cb207-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb207-9"><a href="#cb207-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb207-10"><a href="#cb207-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> product<span class="op">(</span>T arg<span class="op">,</span> Args<span class="op">...</span> args<span class="op">)</span></span>
<span id="cb207-11"><a href="#cb207-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb207-12"><a href="#cb207-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arg <span class="op">*</span> product<span class="op">(</span>args<span class="op">...);</span></span>
<span id="cb207-13"><a href="#cb207-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb207-14"><a href="#cb207-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace cpp14_style</span></span>
<span id="cb207-15"><a href="#cb207-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-16"><a href="#cb207-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> cpp17_style <span class="op">{</span>  <span class="co">// 畳み込み式を使用したスタイル</span></span>
<span id="cb207-17"><a href="#cb207-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb207-18"><a href="#cb207-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> product<span class="op">(</span>Ts<span class="op">...</span> args<span class="op">)</span></span>
<span id="cb207-19"><a href="#cb207-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb207-20"><a href="#cb207-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span><span class="dv">1</span> <span class="op">*</span> <span class="op">...</span> <span class="op">*</span> args<span class="op">);</span>  <span class="co">// 二項左畳み込み (初期値: 1)</span></span>
<span id="cb207-21"><a href="#cb207-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb207-22"><a href="#cb207-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace cpp17_style</span></span>
<span id="cb207-23"><a href="#cb207-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-24"><a href="#cb207-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>cpp14_style<span class="op">::</span>product<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">));</span></span>
<span id="cb207-25"><a href="#cb207-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>cpp17_style<span class="op">::</span>product<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">));</span></span></code></pre></div>
<p>上記したような単純な例では、畳み込み式の効果はわかりづらいため、
もっと複雑なで読解が困難な再帰構造を持ったコードを以下に示す。</p>
<div class="sourceCode" id="cb208"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/flold_expression_ut.cpp 117</span></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_some_of <span class="op">{</span></span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value<span class="op">{</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;</span> <span class="op">?</span> <span class="kw">true</span> <span class="op">:</span> is_same_some_of<span class="op">&lt;</span>T<span class="op">,</span> Us<span class="op">...&gt;::</span>value<span class="op">};</span></span>
<span id="cb208-5"><a href="#cb208-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb208-6"><a href="#cb208-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-7"><a href="#cb208-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb208-8"><a href="#cb208-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_some_of<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb208-9"><a href="#cb208-9" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value<span class="op">{</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;};</span></span>
<span id="cb208-10"><a href="#cb208-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb209"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/flold_expression_ut.cpp 128</span></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_some_of<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_some_of<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb209-5"><a href="#cb209-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_some_of<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">);</span></span></code></pre></div>
<p>畳み込み式を使うことで、この問題をある程度緩和したコードを下記する。</p>
<div class="sourceCode" id="cb210"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/flold_expression_ut.cpp 140</span></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_some_of <span class="op">{</span></span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value <span class="op">=</span> <span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;</span> <span class="op">||</span> <span class="op">...</span> <span class="op">||</span> <span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> Us<span class="op">&gt;);</span></span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb211"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/flold_expression_ut.cpp 146</span></span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_some_of<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb211-4"><a href="#cb211-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_some_of<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb211-5"><a href="#cb211-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_some_of<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">);</span></span></code></pre></div>
<h3 id="ジェネリックラムダ">ジェネリックラムダ
<a id="SS_19_11_6"></a></h3>
<p>ジェネリックラムダとは、C++11のラムダ式のパラメータの型にautoを指定できるようにした機能で、
C++14で導入された。</p>
<p>この機能により関数の中で関数テンプレートと同等のものが定義できるようになった。</p>
<p>ジェネリックラムダで定義されたクロージャは、通常のラムダと同様にオブジェクトであるため、
下記のように使用することもできる便利な記法である。</p>
<div class="sourceCode" id="cb212"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/generic_lambda_ut.cpp 4</span></span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> PUTTO<span class="op">&gt;</span></span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span>PUTTO<span class="op">&amp;&amp;</span> p<span class="op">)</span></span>
<span id="cb212-5"><a href="#cb212-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb212-6"><a href="#cb212-6" aria-hidden="true" tabindex="-1"></a>        p<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb212-7"><a href="#cb212-7" aria-hidden="true" tabindex="-1"></a>        p<span class="op">(</span><span class="fl">2.71</span><span class="op">);</span></span>
<span id="cb212-8"><a href="#cb212-8" aria-hidden="true" tabindex="-1"></a>        p<span class="op">(</span><span class="st">&quot;str&quot;</span><span class="op">);</span></span>
<span id="cb212-9"><a href="#cb212-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb212-10"><a href="#cb212-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-11"><a href="#cb212-11" aria-hidden="true" tabindex="-1"></a>    TEST<span class="op">(</span>Template<span class="op">,</span> generic_lambda<span class="op">)</span></span>
<span id="cb212-12"><a href="#cb212-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb212-13"><a href="#cb212-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ostringstream oss<span class="op">;</span></span>
<span id="cb212-14"><a href="#cb212-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-15"><a href="#cb212-15" aria-hidden="true" tabindex="-1"></a>        f<span class="op">([&amp;</span>oss<span class="op">](</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> elem<span class="op">)</span> <span class="op">{</span> oss <span class="op">&lt;&lt;</span> elem <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="op">});</span></span>
<span id="cb212-16"><a href="#cb212-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-17"><a href="#cb212-17" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1</span><span class="sc">\n</span><span class="st">2.71</span><span class="sc">\n</span><span class="st">str</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb212-18"><a href="#cb212-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>なお、上記のジェネリックラムダは下記クラスのインスタンスの動きと同じである。</p>
<div class="sourceCode" id="cb213"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/generic_lambda_ut.cpp 23</span></span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Closure <span class="op">{</span></span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a>        Closure<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">)</span> <span class="op">:</span> <span class="va">os_</span><span class="op">(</span>os<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb213-6"><a href="#cb213-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-7"><a href="#cb213-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb213-8"><a href="#cb213-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>T<span class="op">&amp;&amp;</span> t<span class="op">)</span></span>
<span id="cb213-9"><a href="#cb213-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb213-10"><a href="#cb213-10" aria-hidden="true" tabindex="-1"></a>            <span class="va">os_</span> <span class="op">&lt;&lt;</span> t <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb213-11"><a href="#cb213-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb213-12"><a href="#cb213-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-13"><a href="#cb213-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb213-14"><a href="#cb213-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="va">os_</span><span class="op">;</span></span>
<span id="cb213-15"><a href="#cb213-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb213-16"><a href="#cb213-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-17"><a href="#cb213-17" aria-hidden="true" tabindex="-1"></a>    TEST<span class="op">(</span>Template<span class="op">,</span> generic_lambda_like<span class="op">)</span></span>
<span id="cb213-18"><a href="#cb213-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb213-19"><a href="#cb213-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ostringstream oss<span class="op">;</span></span>
<span id="cb213-20"><a href="#cb213-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-21"><a href="#cb213-21" aria-hidden="true" tabindex="-1"></a>        Closure closure<span class="op">(</span>oss<span class="op">);</span></span>
<span id="cb213-22"><a href="#cb213-22" aria-hidden="true" tabindex="-1"></a>        f<span class="op">(</span>closure<span class="op">);</span></span>
<span id="cb213-23"><a href="#cb213-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-24"><a href="#cb213-24" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1</span><span class="sc">\n</span><span class="st">2.71</span><span class="sc">\n</span><span class="st">str</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb213-25"><a href="#cb213-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3
id="クラステンプレートのテンプレート引数の型推論">クラステンプレートのテンプレート引数の型推論
<a id="SS_19_11_7"></a></h3>
<p>C++17から、
「コンストラクタに渡される値によって、クラステンプレートのテンプレート引数を推論する」
機能が導入された。</p>
<p>この機能がないC++14までは以下のように記述する必要があった。</p>
<div class="sourceCode" id="cb214"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/template_ut.cpp 14</span></span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">),</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<p>これに対して、この機能により、以下のようにシンプルに記述できるようになった。</p>
<div class="sourceCode" id="cb215"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/template_ut.cpp 25</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">),</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span>  <span class="co">// テンプレート引数がintと推論</span></span></code></pre></div>
<h3 id="ctadclass-template-argument-deduction">CTAD(Class Template
Argument Deduction) <a id="SS_19_11_8"></a></h3>
<p>CTAD（Class Template Argument
Deduction、クラステンプレート実引数推論）は、C++17で導入された機能である。
この機能により、クラステンプレートのインスタンス化時にテンプレート引数を明示的に指定せず、
コンストラクタの引数から自動的に型を推論できるようになる。
クラステンプレートの型推論が不十分な場合、<a
href="core_lang_spec.html#SS_19_11_9">テンプレートの型推論ガイド</a>を追加することにより、
型推論を強化することができる。</p>
<h3 id="テンプレートの型推論ガイド">テンプレートの型推論ガイド
<a id="SS_19_11_9"></a></h3>
<p><a href="core_lang_spec.html#SS_19_11_8">CTAD(Class Template Argument
Deduction)</a>による型推論をカスタマイズするために、型推論ガイドを定義できる。
特にコンストラクタがテンプレートである場合など、暗黙の型推論では不十分な場合に有用である。</p>
<div class="sourceCode" id="cb216"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/deduction_guide_ut.cpp 8</span></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">// Tが整数型の場合、暗黙の型変換を許可</span></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// T が整数型でない場合に有効なコンストラクタ</span></span>
<span id="cb216-6"><a href="#cb216-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;!</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>U<span class="op">&gt;&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">&gt;</span></span>
<span id="cb216-7"><a href="#cb216-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> S<span class="op">(</span>U x<span class="op">)</span> <span class="op">:</span> value<span class="op">{</span>x<span class="op">}</span></span>
<span id="cb216-8"><a href="#cb216-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb216-9"><a href="#cb216-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb216-10"><a href="#cb216-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-11"><a href="#cb216-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// T が整数型の場合に有効な非explicitコンストラクタ</span></span>
<span id="cb216-12"><a href="#cb216-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U <span class="op">=</span> T<span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>U<span class="op">&gt;&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">&gt;</span></span>
<span id="cb216-13"><a href="#cb216-13" aria-hidden="true" tabindex="-1"></a>        S<span class="op">(</span>U x<span class="op">)</span> <span class="op">:</span> value<span class="op">{</span>x<span class="op">}</span></span>
<span id="cb216-14"><a href="#cb216-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb216-15"><a href="#cb216-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb216-16"><a href="#cb216-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-17"><a href="#cb216-17" aria-hidden="true" tabindex="-1"></a>        T value<span class="op">;</span></span>
<span id="cb216-18"><a href="#cb216-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>上記のクラステンプレートは、型推論ガイドがない場合、コンストラクタがテンプレートであるため、
<a href="core_lang_spec.html#SS_19_11_8">CTAD(Class Template Argument
Deduction)</a>による型推論ができない。
そのため、以下のように明示的にテンプレート引数を指定する必要がある。</p>
<div class="sourceCode" id="cb217"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/deduction_guide_ut.cpp 31</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 型推論ガイドがないため、下記はコンパイルできない</span></span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// S s1{42};   // エラー: テンプレート引数を推論できない</span></span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// S s2{1.0};  // エラー: テンプレート引数を推論できない</span></span>
<span id="cb217-6"><a href="#cb217-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-7"><a href="#cb217-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 上記の問題を回避するためには型推論ガイドを定義するか、テンプレート引数を指定しなければならない</span></span>
<span id="cb217-8"><a href="#cb217-8" aria-hidden="true" tabindex="-1"></a>    S<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span>    s1<span class="op">{</span><span class="dv">42</span><span class="op">};</span>   <span class="co">// 明示的にテンプレート引数を指定</span></span>
<span id="cb217-9"><a href="#cb217-9" aria-hidden="true" tabindex="-1"></a>    S<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> s2<span class="op">{</span><span class="fl">1.0</span><span class="op">};</span>  <span class="co">// 明示的にテンプレート引数を指定</span></span></code></pre></div>
<p>以上に示したクラステンプレートに以下の型推論ガイドを追加することにより、
テンプレート引数を型推論できるようになる。</p>
<div class="sourceCode" id="cb218"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/deduction_guide_ut.cpp 44</span></span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a>    S<span class="op">(</span>T<span class="op">)</span> <span class="op">-&gt;</span> S<span class="op">&lt;</span>T<span class="op">&gt;;</span></span></code></pre></div>
<div class="sourceCode" id="cb219"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/deduction_guide_ut.cpp 52</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>    S s1<span class="op">{</span><span class="dv">42</span><span class="op">};</span>   <span class="co">// 推論ガイドの効果</span></span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a>    S s2<span class="op">{</span><span class="fl">1.0</span><span class="op">};</span>  <span class="co">// 推論ガイドの効果</span></span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a>    S s3 <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>  <span class="co">// OK: S&lt;int&gt;のコンストラクタが非explicitのため、暗黙の変換が可能</span></span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// S    s4 = 1.0;  // S&lt;double&gt;のコンストラクタがexplicitであるため、暗黙の変換不可</span></span></code></pre></div>
<p>多くの場合、コンパイラは暗黙の型推論ガイドを生成するため、明示的に型推論ガイドを書く必要はない。
明示的な型推論ガイドが必要なのは、
上記の例のようにコンストラクタがテンプレートである場合や、
特殊な推論ルールが必要な場合である。</p>
<h3 id="変数テンプレート">変数テンプレート <a id="SS_19_11_10"></a></h3>
<p>変数テンプレートとは、下記のコード示したような機能である。</p>
<div class="sourceCode" id="cb220"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/template_ut.cpp 33</span></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void <span class="op">{</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb220-6"><a href="#cb220-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb220-7"><a href="#cb220-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-8"><a href="#cb220-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb220-9"><a href="#cb220-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb220-10"><a href="#cb220-10" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb220-11"><a href="#cb220-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb220-12"><a href="#cb220-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-13"><a href="#cb220-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_void<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb220-14"><a href="#cb220-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb220-15"><a href="#cb220-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 以上はC++14以前のスタイル</span></span>
<span id="cb220-16"><a href="#cb220-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-17"><a href="#cb220-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 以下はC++17から導入された</span></span>
<span id="cb220-18"><a href="#cb220-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb220-19"><a href="#cb220-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_v <span class="op">=</span> is_void<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">;</span></span>
<span id="cb220-20"><a href="#cb220-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-21"><a href="#cb220-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_void_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;);</span></span>
<span id="cb220-22"><a href="#cb220-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span></code></pre></div>
<p>なお、変数テンプレートはconstexprと定義されるが、
「定数テンプレート」ではなく変数テンプレートである。</p>
<h3 id="エイリアステンプレート">エイリアステンプレート
<a id="SS_19_11_11"></a></h3>
<p>エイリアステンプレート(alias templates)とはC++11から導入され、
下記のコード例で示したようにテンプレートによって型の別名を定義する機能である。</p>
<div class="sourceCode" id="cb221"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/template_ut.cpp 57</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> IntVector <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span>  <span class="co">// std::vector&lt;int&gt; のエイリアスを定義</span></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">//エイリアステンプレートを定義</span></span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> Vec <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;;</span></span>
<span id="cb221-7"><a href="#cb221-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb221-8"><a href="#cb221-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>IntVector<span class="op">,</span> Vec<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span>  <span class="co">// Vec&lt;int&gt; == std::vector&lt;int&gt;</span></span></code></pre></div>
<h3 id="constexpr-if文">constexpr if文 <a id="SS_19_11_12"></a></h3>
<p>C++17で導入された<a
href="https://cpprefjp.github.io/lang/cpp17/if_constexpr.html">constexpr
if文</a>とは、
文を条件付きコンパイルすることができるようにするための制御構文である。</p>
<p>まずは、この構文を使用しない例を示す。</p>
<div class="sourceCode" id="cb222"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_if_ut.cpp 9</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 配列のサイズ</span></span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> Length<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;)</span> <span class="op">-&gt;</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_array_v<span class="op">&lt;</span>T<span class="op">&gt;,</span> <span class="dt">size_t</span><span class="op">&gt;</span></span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>extent_v<span class="op">&lt;</span>T<span class="op">&gt;;</span></span>
<span id="cb222-8"><a href="#cb222-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb222-9"><a href="#cb222-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-10"><a href="#cb222-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// コンテナのサイズ</span></span>
<span id="cb222-11"><a href="#cb222-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb222-12"><a href="#cb222-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> Length<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;</span> t<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>t<span class="op">.</span>size<span class="op">())</span></span>
<span id="cb222-13"><a href="#cb222-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb222-14"><a href="#cb222-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> t<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb222-15"><a href="#cb222-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb222-16"><a href="#cb222-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-17"><a href="#cb222-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// その他のサイズ</span></span>
<span id="cb222-18"><a href="#cb222-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> Length<span class="op">(...)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb223"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_if_ut.cpp 31</span></span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> a<span class="op">[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>     v <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> SizeTest <span class="op">{</span></span>
<span id="cb223-6"><a href="#cb223-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> t<span class="op">;</span></span>
<span id="cb223-7"><a href="#cb223-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-8"><a href="#cb223-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">5</span><span class="op">,</span> Length<span class="op">(</span>a<span class="op">));</span></span>
<span id="cb223-9"><a href="#cb223-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> Length<span class="op">(</span>v<span class="op">));</span></span>
<span id="cb223-10"><a href="#cb223-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> Length<span class="op">(</span>t<span class="op">));</span></span>
<span id="cb223-11"><a href="#cb223-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-12"><a href="#cb223-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// C++17で、Lengthと同様の機能の関数テンプレートがSTLに追加された</span></span>
<span id="cb223-13"><a href="#cb223-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>size<span class="op">(</span>a<span class="op">),</span> Length<span class="op">(</span>a<span class="op">));</span></span>
<span id="cb223-14"><a href="#cb223-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>size<span class="op">(</span>v<span class="op">),</span> Length<span class="op">(</span>v<span class="op">));</span></span></code></pre></div>
<p>このような場合、<a
href="core_lang_spec.html#SS_19_11_1">SFINAE</a>によるオーバーロードが必須であったが、
この文を使用することで、下記のようにオーバーロードを使用せずに記述できるため、
条件分岐の可読性の向上が見込める。</p>
<div class="sourceCode" id="cb224"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_if_ut.cpp 52</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> helper <span class="op">{</span></span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>T <span class="at">const</span><span class="op">&amp;</span> t<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>t<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb224-6"><a href="#cb224-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb224-7"><a href="#cb224-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-8"><a href="#cb224-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb224-9"><a href="#cb224-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> Length<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb224-10"><a href="#cb224-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb224-11"><a href="#cb224-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="bu">std::</span>is_array_v<span class="op">&lt;</span>T<span class="op">&gt;)</span> <span class="op">{</span>  <span class="co">// Tが配列の場合</span></span>
<span id="cb224-12"><a href="#cb224-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Tが配列でない場合、他の条件のブロックはコンパイル対象外</span></span>
<span id="cb224-13"><a href="#cb224-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>extent_v<span class="op">&lt;</span>T<span class="op">&gt;;</span></span>
<span id="cb224-14"><a href="#cb224-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb224-15"><a href="#cb224-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="bu">std::</span>is_invocable_v<span class="op">&lt;</span>helper<span class="op">,</span> T<span class="op">&gt;)</span> <span class="op">{</span>  <span class="co">// T::Lengthが呼び出せる場合</span></span>
<span id="cb224-16"><a href="#cb224-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// T::Lengthが呼び出せない場合、他の条件のブロックはコンパイル対象外</span></span>
<span id="cb224-17"><a href="#cb224-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> t<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb224-18"><a href="#cb224-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb224-19"><a href="#cb224-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span>  <span class="co">// それ以外</span></span>
<span id="cb224-20"><a href="#cb224-20" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Tが配列でなく且つ、T::Lengthが呼び出ない場合、他の条件のブロックはコンパイル対象外</span></span>
<span id="cb224-21"><a href="#cb224-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb224-22"><a href="#cb224-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb224-23"><a href="#cb224-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>この構文は<a
href="core_lang_spec.html#SS_19_11_4">パラメータパック</a>の展開においても有用な場合がある。</p>
<div class="sourceCode" id="cb225"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_if_ut.cpp 93</span></span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// テンプレートパラメータで与えられた型のsizeofの値が最も大きな値を返す。</span></span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">&gt;</span></span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> MaxSizeof<span class="op">()</span></span>
<span id="cb225-6"><a href="#cb225-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb225-7"><a href="#cb225-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">sizeof</span><span class="op">(</span>HEAD<span class="op">);</span></span>
<span id="cb225-8"><a href="#cb225-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb225-9"><a href="#cb225-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-10"><a href="#cb225-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> TAILS<span class="op">&gt;</span></span>
<span id="cb225-11"><a href="#cb225-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> MaxSizeof<span class="op">()</span></span>
<span id="cb225-12"><a href="#cb225-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb225-13"><a href="#cb225-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>max<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>HEAD<span class="op">),</span> MaxSizeof<span class="op">&lt;</span>T<span class="op">,</span> TAILS<span class="op">...&gt;());</span></span>
<span id="cb225-14"><a href="#cb225-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb226"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_if_ut.cpp 111</span></span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">4</span> <span class="op">==</span> <span class="op">(</span>MaxSizeof<span class="op">&lt;</span><span class="dt">int8_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">int32_t</span><span class="op">&gt;()));</span></span>
<span id="cb226-4"><a href="#cb226-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">4</span> <span class="op">==</span> <span class="op">(</span>MaxSizeof<span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">int8_t</span><span class="op">&gt;()));</span></span>
<span id="cb226-5"><a href="#cb226-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="bu">std::</span>string<span class="op">)</span> <span class="op">==</span> MaxSizeof<span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">int8_t</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;());</span></span></code></pre></div>
<p>C++14までの構文を使用する場合、
上記のようなオーバーロードとリカーシブコールの組み合わせが必要であったが、
constexpr ifを使用することで、やや単純に記述できる。</p>
<div class="sourceCode" id="cb227"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/constexpr_if_ut.cpp 123</span></span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-3"><a href="#cb227-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// テンプレートパラメータで与えられた型のsizeofの値が最も大きな値を返す。</span></span>
<span id="cb227-4"><a href="#cb227-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> TAILS<span class="op">&gt;</span></span>
<span id="cb227-5"><a href="#cb227-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> MaxSizeof<span class="op">()</span></span>
<span id="cb227-6"><a href="#cb227-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb227-7"><a href="#cb227-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="kw">sizeof</span><span class="op">...(</span>TAILS<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span>  <span class="co">// TAILSが存在しない場合</span></span>
<span id="cb227-8"><a href="#cb227-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">sizeof</span><span class="op">(</span>HEAD<span class="op">);</span></span>
<span id="cb227-9"><a href="#cb227-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb227-10"><a href="#cb227-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb227-11"><a href="#cb227-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>max<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>HEAD<span class="op">),</span> MaxSizeof<span class="op">&lt;</span>TAILS<span class="op">...&gt;());</span></span>
<span id="cb227-12"><a href="#cb227-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb227-13"><a href="#cb227-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3
id="autoパラメータによる関数テンプレートの簡易定義">autoパラメータによる関数テンプレートの簡易定義
<a id="SS_19_11_13"></a></h3>
<p>この機能は、C++20から導入された。
下記のコードで示すように簡易的に関数テンプレートを定義するための機能である。</p>
<div class="sourceCode" id="cb228"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/abbreviated_func_template_ut.cpp 11</span></span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> add<span class="op">(</span><span class="kw">auto</span> lhs<span class="op">,</span> <span class="kw">auto</span> rhs<span class="op">)</span>  <span class="co">// c++20で導入された記法</span></span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lhs <span class="op">+</span> rhs<span class="op">;</span></span>
<span id="cb228-6"><a href="#cb228-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb229"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec20/abbreviated_func_template_ut.cpp 21</span></span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>add<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">),</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-5"><a href="#cb229-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_DOUBLE_EQ<span class="op">(</span>add<span class="op">(</span><span class="fl">1.5</span><span class="op">,</span> <span class="fl">2.5</span><span class="op">),</span> <span class="fl">4.0</span><span class="op">);</span></span>
<span id="cb229-6"><a href="#cb229-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-7"><a href="#cb229-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals::string_literals<span class="op">;</span></span>
<span id="cb229-8"><a href="#cb229-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-9"><a href="#cb229-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>add<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="bu">s</span><span class="op">,</span> <span class="st">&quot;world&quot;</span><span class="bu">s</span><span class="op">),</span> <span class="st">&quot;helloworld&quot;</span><span class="bu">s</span><span class="op">);</span></span></code></pre></div>
<h3 id="auto">auto <a id="SS_19_11_14"></a></h3>
<p>autoは、C++11で導入された型推論キーワードである。変数宣言時に明示的な型指定を省略し、
初期化式からコンパイラが型を自動的に推定する。
これにより、複雑な型やテンプレート使用時の記述が簡潔になり、
可読性と保守性が向上する。 コード例については、<a
href="core_lang_spec.html#SS_19_11_15">decltype</a>を参照せよ。</p>
<h3 id="decltype">decltype <a id="SS_19_11_15"></a></h3>
<p>decltypeはオペランドに<a
href="core_lang_spec.html#SS_19_7_1">expression</a>を取り、その型を算出する機能である。
下記のコードにあるようなautoの機能との微妙な差に気を付ける必要がある。</p>
<div class="sourceCode" id="cb230"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/decltype_ut.cpp 13</span></span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span>  x<span class="op">{</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span><span class="op">&amp;</span> r<span class="op">{</span>x<span class="op">};</span></span>
<span id="cb230-5"><a href="#cb230-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-6"><a href="#cb230-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>        a <span class="op">=</span> r<span class="op">;</span>  <span class="co">// aの型はint32_t</span></span>
<span id="cb230-7"><a href="#cb230-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decltype</span><span class="op">(</span>r<span class="op">)</span> b <span class="op">=</span> r<span class="op">;</span>  <span class="co">// bの型はint32_t&amp;</span></span>
<span id="cb230-8"><a href="#cb230-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-9"><a href="#cb230-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::is_sameはオペランドの型が同じか否かを返すメタ関数</span></span>
<span id="cb230-10"><a href="#cb230-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">),</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb230-11"><a href="#cb230-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>b<span class="op">),</span> <span class="dt">int</span><span class="op">&amp;&gt;);</span></span></code></pre></div>
<p>decltypeは、テンプレートプログラミングに多用されるが、
クロージャ型(「<a
href="core_lang_spec.html#SS_19_10_3">ラムダ式</a>」参照)
のような記述不可能な型をオブジェクトから算出できるため、
下記例のような場合にも有用である。</p>
<div class="sourceCode" id="cb231"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/decltype_ut.cpp 28</span></span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  本来ならばA::dataは、</span></span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      * A::Aでメモリ割り当て</span></span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      * A::~Aでメモリ解放</span></span>
<span id="cb231-6"><a href="#cb231-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  すべきだが、何らかの理由でそれが出来ないとする</span></span>
<span id="cb231-7"><a href="#cb231-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb231-8"><a href="#cb231-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span>   len<span class="op">;</span></span>
<span id="cb231-9"><a href="#cb231-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint8_t</span><span class="op">*</span> data<span class="op">;</span></span>
<span id="cb231-10"><a href="#cb231-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb231-11"><a href="#cb231-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-12"><a href="#cb231-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> do_something<span class="op">(</span><span class="dt">size_t</span> len<span class="op">)</span></span>
<span id="cb231-13"><a href="#cb231-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb231-14"><a href="#cb231-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> deallocate <span class="op">=</span> <span class="op">[](</span>A<span class="op">*</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb231-15"><a href="#cb231-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span><span class="op">[](</span>p<span class="op">-&gt;</span>data<span class="op">);</span></span>
<span id="cb231-16"><a href="#cb231-16" aria-hidden="true" tabindex="-1"></a>            <span class="kw">delete</span> p<span class="op">;</span></span>
<span id="cb231-17"><a href="#cb231-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb231-18"><a href="#cb231-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-19"><a href="#cb231-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> a_ptr <span class="op">=</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>A<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>deallocate<span class="op">)&gt;{</span><span class="kw">new</span> A<span class="op">,</span> deallocate<span class="op">};</span></span>
<span id="cb231-20"><a href="#cb231-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-21"><a href="#cb231-21" aria-hidden="true" tabindex="-1"></a>        a_ptr<span class="op">-&gt;</span>len  <span class="op">=</span> len<span class="op">;</span></span>
<span id="cb231-22"><a href="#cb231-22" aria-hidden="true" tabindex="-1"></a>        a_ptr<span class="op">-&gt;</span>data <span class="op">=</span> <span class="kw">new</span> <span class="dt">uint8_t</span><span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb231-23"><a href="#cb231-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-24"><a href="#cb231-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb231-25"><a href="#cb231-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// do something for a_ptr</span></span>
<span id="cb231-26"><a href="#cb231-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb231-27"><a href="#cb231-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-28"><a href="#cb231-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// a_ptrによるメモリの自動解放</span></span>
<span id="cb231-29"><a href="#cb231-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="decltypeauto">decltype(auto) <a id="SS_19_11_16"></a></h3>
<p>decltype(auto)はC++14から導入されたdecltypeの類似機能である。</p>
<p>auto、decltype、decltype(auto)では、以下に示す通りリファレンスの扱いが異なることに注意する必要がある。</p>
<div class="sourceCode" id="cb232"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/decltype_ut.cpp 63</span></span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span>  x<span class="op">{</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span><span class="op">&amp;</span> r<span class="op">{</span>x<span class="op">};</span></span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>           a <span class="op">=</span> r<span class="op">;</span>  <span class="co">// aの型はint32_t</span></span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decltype</span><span class="op">(</span>r<span class="op">)</span>    b <span class="op">=</span> r<span class="op">;</span>  <span class="co">// bの型はint32_t&amp;</span></span>
<span id="cb232-8"><a href="#cb232-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> c <span class="op">=</span> r<span class="op">;</span>  <span class="co">// cの型はint32_t&amp;   C++14からサポート</span></span>
<span id="cb232-9"><a href="#cb232-9" aria-hidden="true" tabindex="-1"></a>                           <span class="co">// decltype(auto)は、decltypeに右辺の式を与えるための構文</span></span>
<span id="cb232-10"><a href="#cb232-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-11"><a href="#cb232-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::is_sameはオペランドの型が同じか否かを返すメタ関数</span></span>
<span id="cb232-12"><a href="#cb232-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">),</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb232-13"><a href="#cb232-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>b<span class="op">),</span> <span class="dt">int</span><span class="op">&amp;&gt;);</span></span>
<span id="cb232-14"><a href="#cb232-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>c<span class="op">),</span> <span class="dt">int</span><span class="op">&amp;&gt;);</span></span></code></pre></div>
<h3 id="戻り値型を後置する関数宣言">戻り値型を後置する関数宣言
<a id="SS_19_11_17"></a></h3>
<p>関数の戻り値型後置構文は戻り値型をプレースホルダ(auto)にして、
実際の型を-&gt;で示して型推論させるシンタックスを指す。実際には関数テンプレートで使用されることが多い。
コード例を以下に示す。</p>
<div class="sourceCode" id="cb233"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/decltype_ut.cpp 82</span></span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> add<span class="op">(</span>T a<span class="op">,</span> U b<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>a <span class="op">+</span> b<span class="op">)</span></span>
<span id="cb233-5"><a href="#cb233-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb233-6"><a href="#cb233-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb233-7"><a href="#cb233-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb233-8"><a href="#cb233-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-9"><a href="#cb233-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>add<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">)),</span> <span class="dt">int</span><span class="op">&gt;);</span>         <span class="co">// addの戻り値型はintに型推論</span></span>
<span id="cb233-10"><a href="#cb233-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>add<span class="op">(</span><span class="dv">1</span><span class="bu">u</span><span class="op">,</span> <span class="dv">2</span><span class="bu">u</span><span class="op">)),</span> <span class="dt">uint32_t</span><span class="op">&gt;);</span>  <span class="co">// addの戻り値型はintに型推論</span></span>
<span id="cb233-11"><a href="#cb233-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>add<span class="op">(</span><span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;str&quot;</span><span class="op">},</span> <span class="st">&quot;2&quot;</span><span class="op">)),</span></span>
<span id="cb233-12"><a href="#cb233-12" aria-hidden="true" tabindex="-1"></a>                                 <span class="bu">std::</span>string<span class="op">&gt;);</span>  <span class="co">// addの戻り値型はstd::stringに型推論</span></span></code></pre></div>
<p>この構文をC++11から導入された理由は以下のコードを見れば明らかだろう。</p>
<div class="sourceCode" id="cb234"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/decltype_ut.cpp 97</span></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span>  <span class="co">// 戻り値型を後置する関数宣言</span></span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">+</span> <span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&gt;())</span> add<span class="op">(</span>T a<span class="op">,</span> U b<span class="op">)</span></span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb234-7"><a href="#cb234-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb234-8"><a href="#cb234-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-9"><a href="#cb234-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>add<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">)),</span> <span class="dt">int</span><span class="op">&gt;);</span>         <span class="co">// addの戻り値型はintに型推論</span></span>
<span id="cb234-10"><a href="#cb234-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>add<span class="op">(</span><span class="dv">1</span><span class="bu">u</span><span class="op">,</span> <span class="dv">2</span><span class="bu">u</span><span class="op">)),</span> <span class="dt">uint32_t</span><span class="op">&gt;);</span>  <span class="co">// addの戻り値型はintに型推論</span></span>
<span id="cb234-11"><a href="#cb234-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>add<span class="op">(</span><span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;str&quot;</span><span class="op">},</span> <span class="st">&quot;2&quot;</span><span class="op">)),</span></span>
<span id="cb234-12"><a href="#cb234-12" aria-hidden="true" tabindex="-1"></a>                                 <span class="bu">std::</span>string<span class="op">&gt;);</span>  <span class="co">// addの戻り値型はstd::stringに型推論</span></span></code></pre></div>
<h3 id="関数の戻り値型auto">関数の戻り値型auto
<a id="SS_19_11_18"></a></h3>
<p>C++14から導入された機能で、関数の戻り値の型をautoキーワードで宣言することで、
コンパイラがreturn文から自動的に型を推論してくれる機能である。
これにより、複雑な型の戻り値を持つ関数でも、より簡潔に記述できるようになる
(「<a
href="core_lang_spec.html#SS_19_11_13">autoパラメータによる関数テンプレートの簡易定義</a>」を参照)。</p>
<div class="sourceCode" id="cb235"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/decltype_ut.cpp 114</span></span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 戻り値型autoが使えないと下記のような宣言が必要</span></span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::vector&lt;std::string&gt; split(std::string_view str, char delimiter)</span></span>
<span id="cb235-5"><a href="#cb235-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> split<span class="op">(</span><span class="bu">std::</span>string_view str<span class="op">,</span> <span class="dt">char</span> delimiter<span class="op">)</span></span>
<span id="cb235-6"><a href="#cb235-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb235-7"><a href="#cb235-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> result<span class="op">;</span></span>
<span id="cb235-8"><a href="#cb235-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string              token<span class="op">;</span></span>
<span id="cb235-9"><a href="#cb235-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-10"><a href="#cb235-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">char</span> ch <span class="op">:</span> str<span class="op">)</span> <span class="op">{</span></span>
<span id="cb235-11"><a href="#cb235-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>ch <span class="op">==</span> delimiter<span class="op">)</span> <span class="op">{</span></span>
<span id="cb235-12"><a href="#cb235-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(!</span>token<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb235-13"><a href="#cb235-13" aria-hidden="true" tabindex="-1"></a>                    result<span class="op">.</span>emplace_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>token<span class="op">));</span></span>
<span id="cb235-14"><a href="#cb235-14" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb235-15"><a href="#cb235-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb235-16"><a href="#cb235-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb235-17"><a href="#cb235-17" aria-hidden="true" tabindex="-1"></a>                token <span class="op">+=</span> ch<span class="op">;</span></span>
<span id="cb235-18"><a href="#cb235-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb235-19"><a href="#cb235-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb235-20"><a href="#cb235-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-21"><a href="#cb235-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>token<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb235-22"><a href="#cb235-22" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>emplace_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>token<span class="op">));</span></span>
<span id="cb235-23"><a href="#cb235-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb235-24"><a href="#cb235-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-25"><a href="#cb235-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb235-26"><a href="#cb235-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb236"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/decltype_ut.cpp 144</span></span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> result <span class="op">=</span> split<span class="op">(</span><span class="st">&quot;hello,world&quot;</span><span class="op">,</span> <span class="ch">&#39;,&#39;</span><span class="op">);</span></span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>result<span class="op">.</span>size<span class="op">(),</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>result<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="st">&quot;hello&quot;</span><span class="op">);</span></span>
<span id="cb236-7"><a href="#cb236-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>result<span class="op">[</span><span class="dv">1</span><span class="op">],</span> <span class="st">&quot;world&quot;</span><span class="op">);</span></span></code></pre></div>
<h3 id="後置戻り値型auto">後置戻り値型auto <a id="SS_19_11_19"></a></h3>
<p>C++14から導入された<a
href="core_lang_spec.html#SS_19_11_18">関数の戻り値型auto</a>と似た、
関数の戻り値の型を関数本体の後に-&gt;
autoと書くことでができる機能である。
autoプレースホルダーとし、そのプレースホルダーを修飾することで、戻り値型の推論を補助できる。</p>
<div class="sourceCode" id="cb237"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/decltype_ut.cpp 154</span></span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int16_t</span> gvalue <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> getValue<span class="op">(</span><span class="dt">int16_t</span> a<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> gvalue <span class="op">+=</span> a<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb238"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/decltype_ut.cpp 163</span></span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>           ret1 <span class="op">=</span> getValue<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb238-4"><a href="#cb238-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decltype</span><span class="op">(</span><span class="kw">auto</span><span class="op">)</span> ret2 <span class="op">=</span> getValue<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb238-5"><a href="#cb238-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb238-6"><a href="#cb238-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>ret1<span class="op">,</span> <span class="dv">11</span><span class="op">);</span></span>
<span id="cb238-7"><a href="#cb238-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>ret2<span class="op">,</span> <span class="dv">11</span><span class="op">);</span></span>
<span id="cb238-8"><a href="#cb238-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb238-9"><a href="#cb238-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>gvalue<span class="op">,</span> <span class="dv">11</span><span class="op">);</span></span>
<span id="cb238-10"><a href="#cb238-10" aria-hidden="true" tabindex="-1"></a>    ret1 <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb238-11"><a href="#cb238-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>gvalue<span class="op">,</span> <span class="dv">11</span><span class="op">);</span></span>
<span id="cb238-12"><a href="#cb238-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb238-13"><a href="#cb238-13" aria-hidden="true" tabindex="-1"></a>    ret2 <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb238-14"><a href="#cb238-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>gvalue<span class="op">,</span> <span class="dv">12</span><span class="op">);</span></span></code></pre></div>
<h2 id="name-lookupと継承構造">name lookupと継承構造
<a id="SS_19_12"></a></h2>
<p>ここではname lookupとそれに影響を与える名前空間について解説する。</p>
<h3 id="ルックアップ">ルックアップ <a id="SS_19_12_1"></a></h3>
<p>このドキュメントでのルックアップとは<a
href="core_lang_spec.html#SS_19_12_2">name lookup</a>を指す。</p>
<h3 id="name-lookup">name lookup <a id="SS_19_12_2"></a></h3>
<p><a href="https://en.cppreference.com/w/cpp/language/lookup">name
lookup</a>
とはソースコードで名前が検出された時に、その名前をその宣言と関連付けることである。
以下、name lookupの例を上げる。</p>
<p>下記のようなコードがあった場合、</p>
<div class="sourceCode" id="cb239"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_lookup_ut.cpp 5</span></span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_LU <span class="op">{</span></span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> f<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_LU</span></span></code></pre></div>
<p>以下のコードでの関数呼び出しf()のname lookupは、</p>
<div class="sourceCode" id="cb240"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_lookup_ut.cpp 29</span></span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a>    NS_LU<span class="op">::</span>f<span class="op">();</span></span></code></pre></div>
<ol type="1">
<li>NS_LUをその前方で宣言された名前空間と関連付けする</li>
<li>f()呼び出しをその前方の名前空間NS_LUで宣言された関数fと関連付ける</li>
</ol>
<p>という手順で行われる。</p>
<p>下記のようなコードがあった場合、</p>
<div class="sourceCode" id="cb241"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_lookup_ut.cpp 11</span></span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_LU <span class="op">{</span></span>
<span id="cb241-4"><a href="#cb241-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> g<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> i <span class="op">&lt;</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb241-5"><a href="#cb241-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-6"><a href="#cb241-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> g<span class="op">(</span><span class="bu">std::</span>string_view str<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> str<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="op">}</span></span>
<span id="cb241-7"><a href="#cb241-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-8"><a href="#cb241-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb241-9"><a href="#cb241-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> g<span class="op">(</span>T <span class="at">const</span> <span class="op">(&amp;)[</span>N<span class="op">])</span> <span class="kw">noexcept</span></span>
<span id="cb241-10"><a href="#cb241-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb241-11"><a href="#cb241-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> N<span class="op">;</span></span>
<span id="cb241-12"><a href="#cb241-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>以下のコードでの関数呼び出しg()のname lookupは、</p>
<div class="sourceCode" id="cb242"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_lookup_ut.cpp 37</span></span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">]{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true" tabindex="-1"></a>    NS_LU<span class="op">::</span>g<span class="op">(</span>a<span class="op">);</span></span></code></pre></div>
<ol type="1">
<li>NS_LUをその前方で宣言された名前空間と関連付けする</li>
<li>名前空間NS_LU内で宣言された複数のgを見つける</li>
<li>g()呼び出しを、 すでに見つけたgの中からベストマッチしたg(T const
(&amp;)[N])と関連付ける</li>
</ol>
<p>という手順で行われる。</p>
<p>下記記のようなコードがあった場合、</p>
<div class="sourceCode" id="cb243"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_lookup_ut.cpp 44</span></span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// グローバル名前空間</span></span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToString<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>to_string<span class="op">(</span>i<span class="op">)</span> <span class="op">+</span> <span class="st">&quot; in Global&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_LU <span class="op">{</span></span>
<span id="cb243-7"><a href="#cb243-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> X <span class="op">{</span></span>
<span id="cb243-8"><a href="#cb243-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb243-9"><a href="#cb243-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb243-10"><a href="#cb243-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-11"><a href="#cb243-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToString<span class="op">(</span>X <span class="at">const</span><span class="op">&amp;</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>to_string<span class="op">(</span>x<span class="op">.</span>i<span class="op">)</span> <span class="op">+</span> <span class="st">&quot; in NS_LU&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb243-12"><a href="#cb243-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_LU</span></span>
<span id="cb243-13"><a href="#cb243-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-14"><a href="#cb243-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS2 <span class="op">{</span></span>
<span id="cb243-15"><a href="#cb243-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToString<span class="op">(</span>NS_LU<span class="op">::</span>X <span class="at">const</span><span class="op">&amp;</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>to_string<span class="op">(</span>x<span class="op">.</span>i<span class="op">)</span> <span class="op">+</span> <span class="st">&quot; in NS2&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb243-16"><a href="#cb243-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS2</span></span></code></pre></div>
<p>以下のコードでの関数呼び出しToString()のname lookupは、</p>
<div class="sourceCode" id="cb244"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_lookup_ut.cpp 65</span></span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> x <span class="op">=</span> NS_LU<span class="op">::</span>X<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;1 in NS_LU&quot;</span><span class="op">,</span> ToString<span class="op">(</span>x<span class="op">));</span></span></code></pre></div>
<ol type="1">
<li>ToString()呼び出しの引数xの型Xが名前空間NS_LUで定義されているため、
ToStringを探索する名前空間にNS_LUを組み入れる(「<a
href="core_lang_spec.html#SS_19_12_6">関連名前空間</a>」参照)</li>
<li>ToString()呼び出しより前方で宣言されたグローバル名前空間とNS_LUの中から、
複数のToStringの定義を見つける</li>
<li>ToString()呼び出しを、
すでに見つけたToStringの中からベストマッチしたNS_LU::ToStringと関連付ける</li>
</ol>
<p>という手順で行われる。</p>
<h3 id="two-phase-name-lookup">two phase name lookup
<a id="SS_19_12_3"></a></h3>
<p><a
href="https://en.cppreference.com/w/cpp/language/two-phase_lookup">two
phase name lookup</a>
とはテンプレートをインスタンス化するときに使用される、下記のような2段階でのname
lookupである。</p>
<ol type="1">
<li>テンプレート定義内でname lookupを行う(通常のname lookupと同じ)。
この時、テンプレートパラメータに依存した名前 (<a
href="https://en.cppreference.com/w/cpp/language/dependent_name">dependent_name</a>)は
name lookupの対象外となる(name lookupの対象が確定しないため)。</li>
<li>1の後、テンプレートパラメータを展開した関数内で、 <a
href="core_lang_spec.html#SS_19_12_6">関連名前空間</a>の宣言も含めたname
lookupを行う。</li>
</ol>
<p>以下の議論では、</p>
<ul>
<li>上記1のname lookupを1st name lookup</li>
<li>上記2のname lookupを2nd name lookup</li>
</ul>
<p>と呼ぶことにする。</p>
<p>下記のようなコードがあった場合、</p>
<div class="sourceCode" id="cb245"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 5</span></span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_TPLU <span class="op">{</span></span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> X <span class="op">{</span></span>
<span id="cb245-5"><a href="#cb245-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb245-6"><a href="#cb245-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb245-7"><a href="#cb245-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_TPLU</span></span>
<span id="cb245-8"><a href="#cb245-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-9"><a href="#cb245-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// グローバル名前空間</span></span>
<span id="cb245-10"><a href="#cb245-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="bu">std::</span>string ToType<span class="op">(</span>NS_TPLU<span class="op">::</span>X <span class="at">const</span><span class="op">&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;X in global&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb245-11"><a href="#cb245-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="bu">std::</span>string ToType<span class="op">(</span><span class="dt">int</span> <span class="at">const</span><span class="op">&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;int in global&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb245-12"><a href="#cb245-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-13"><a href="#cb245-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 再びNS_TPLU</span></span>
<span id="cb245-14"><a href="#cb245-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_TPLU <span class="op">{</span></span>
<span id="cb245-15"><a href="#cb245-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-16"><a href="#cb245-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string Header<span class="op">(</span><span class="dt">long</span><span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;type:&quot;</span><span class="op">;</span> <span class="op">}</span>  <span class="co">//  下記にもオーバーロードあり</span></span>
<span id="cb245-17"><a href="#cb245-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-18"><a href="#cb245-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb245-19"><a href="#cb245-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToType<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;)</span>  <span class="co">//  下記にもオーバーロードあり</span></span>
<span id="cb245-20"><a href="#cb245-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb245-21"><a href="#cb245-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;unknown&quot;</span><span class="op">;</span></span>
<span id="cb245-22"><a href="#cb245-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb245-23"><a href="#cb245-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-24"><a href="#cb245-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb245-25"><a href="#cb245-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string TypeName<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;</span> t<span class="op">)</span>  <span class="co">// オーバーロードなし</span></span>
<span id="cb245-26"><a href="#cb245-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb245-27"><a href="#cb245-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Header<span class="op">(</span><span class="dt">int</span><span class="op">{})</span> <span class="op">+</span> ToType<span class="op">(</span>t<span class="op">);</span></span>
<span id="cb245-28"><a href="#cb245-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb245-29"><a href="#cb245-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-30"><a href="#cb245-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string Header<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;TYPE:&quot;</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// 上記にもオーバーロードあり</span></span>
<span id="cb245-31"><a href="#cb245-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-32"><a href="#cb245-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToType<span class="op">(</span>X <span class="at">const</span><span class="op">&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;X&quot;</span><span class="op">;</span> <span class="op">}</span>      <span class="co">// 上記にもオーバーロードあり</span></span>
<span id="cb245-33"><a href="#cb245-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToType<span class="op">(</span><span class="dt">int</span> <span class="at">const</span><span class="op">&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;int&quot;</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// 上記にもオーバーロードあり</span></span>
<span id="cb245-34"><a href="#cb245-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_TPLU</span></span></code></pre></div>
<p>以下のコードでのTypeNameのインスタンス化に伴うname lookupは、</p>
<div class="sourceCode" id="cb246"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 44</span></span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> x <span class="op">=</span> NS_TPLU<span class="op">::</span>X<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;type:X&quot;</span><span class="op">,</span> TypeName<span class="op">(</span>x<span class="op">));</span></span></code></pre></div>
<ol type="1">
<li>TypeName()呼び出しの引数xの型Xが名前空間NS_TPLUで宣言されているため、
NS_TPLUをTypeNameを探索する<a
href="core_lang_spec.html#SS_19_12_6">関連名前空間</a>にする。</li>
<li>TypeName()呼び出しより前方で宣言されたグローバル名前空間とNS_TPLUの中からTypeNameを見つける。</li>
<li>TypeNameは関数テンプレートであるためtwo phase
lookupが以下のように行われる。
<ol type="1">
<li>TypeName内でのHeader(int{})の呼び出しは、1st name lookupにより、
Header(long)の宣言と関連付けられる。
Header(int)はHeader(long)よりもマッチ率が高い、
TypeNameの定義より後方で宣言されているため、name
lookupの対象外となる。</li>
<li>TypeName内でのToType(t)の呼び出しに対しては、2nd name
lookupが行われる。
このためTypeName定義より前方で宣言されたグローバル名前空間と、
tの型がNS_TPLU::Xであるため<a
href="core_lang_spec.html#SS_19_12_6">関連名前空間</a>となったNS_TPLUがname
lookupの対象となるが、 グローバル名前空間内のToTypeは、
NS_TPLU内でTypeNameより前に宣言されたtemplate&lt;&gt; ToTypeによって<a
href="core_lang_spec.html#SS_19_12_9">name-hiding</a>が起こり、
TypeNameからは非可視となるためname lookupの対象から外れる。
このため、ToType(t)の呼び出しは、NS_TPLU::ToType(X
const&amp;)の宣言と関連付けられる。</li>
</ol></li>
</ol>
<p>という手順で行われる。</p>
<p>上と同じ定義、宣言がある場合の以下のコードでのTypeNameのインスタンス化に伴うname
lookupは、</p>
<div class="sourceCode" id="cb247"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 50</span></span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-3"><a href="#cb247-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;type:unknown&quot;</span><span class="op">,</span> NS_TPLU<span class="op">::</span>TypeName<span class="op">(</span><span class="dt">int</span><span class="op">{}));</span></span></code></pre></div>
<ol type="1">
<li>NS_TPLUを名前空間と関連付けする (引数の型がintなのでNS_TPLUは<a
href="core_lang_spec.html#SS_19_12_6">関連名前空間</a>とならず、NS_TPLUを明示する必要がある)。</li>
<li>TypeName()呼び出しより前方で宣言されたNS_TPLUの中からTypeNameを見つける。</li>
<li>TypeNameは関数テンプレートであるためtwo phase
lookupが以下のように行われる。
<ol type="1">
<li>TypeName内でのHeader(int{})の呼び出しは、1st name lookupにより、
前例と同じ理由で、Header(long)の宣言と関連付けられる。</li>
<li>TypeName内でのToType(t)の呼び出しに対しては、2nd name
lookupが行われる。 tの型がintであるためNS_TPLUは<a
href="core_lang_spec.html#SS_19_12_6">関連名前空間</a>とならず、通常のname
lookupと同様に
ToType(t)の呼び出し前方のグローバル名前空間とNS_TPLUがname
lookupの対象になるが、 グローバル名前空間内のToTypeは、
NS_TPLU内でTypeNameより前に宣言されたtemplate&lt;&gt; ToTypeによって<a
href="core_lang_spec.html#SS_19_12_9">name-hiding</a>が起こり、
TypeNameからは非可視となるためname lookupの対象から外れる。
また、ToType(int
const&amp;)は、TypeNameの定義より後方で宣言されているため、 name
lookupの対象外となり、
その結果、ToType(t)の呼び出しは、NS_TPLU内のtemplate&lt;&gt;
ToTypeの宣言と関連付けられる。</li>
</ol></li>
</ol>
<p>という手順で行われる。</p>
<p>以上の理由から、先に示した例でのToTypeの戻り値は”X”となり、
後に示した例でのToTypeの戻り値は”unknown”となる。 これはtwo phase
lookupの結果であり、 two phase
lookupが実装されていないコンパイラ(こういったコンパイラは存在する)では、
結果が異なるため注意が必要である
(本ドキュメントではこのような問題をできる限り避けるために、
サンプルコードを<a href="cpp_idioms.html#SS_21_10_1">g++</a>と<a
href="cpp_idioms.html#SS_21_10_2">clang++</a>でコンパイルしている)。</p>
<p>以下に、two phase lookupにまつわるさらに驚くべきコード例を紹介する。
上と同じ定義、宣言がある場合の以下のコードの動作を考える。</p>
<div class="sourceCode" id="cb248"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 54</span></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;type:long&quot;</span><span class="op">,</span> NS_TPLU<span class="op">::</span>TypeName<span class="op">(</span><span class="dt">long</span><span class="op">{}));</span></span></code></pre></div>
<p>NS_TPLU::TypeName(int{})のintをlongにしただけなので、この単体テストはパスしないが、
この単体テストコードの後(実際にはこのファイルのコンパイル単位の中のNS_TPLU内で、
且つtemplate&lt;&gt; ToTypeの宣言の後方であればどこでもよい)
に以下のコードを追加するとパスしてしまう。</p>
<div class="sourceCode" id="cb249"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 61</span></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_TPLU <span class="op">{</span></span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToType<span class="op">&lt;</span><span class="dt">long</span><span class="op">&gt;(</span><span class="dt">long</span> <span class="at">const</span><span class="op">&amp;)</span></span>
<span id="cb249-6"><a href="#cb249-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb249-7"><a href="#cb249-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;long&quot;</span><span class="op">;</span></span>
<span id="cb249-8"><a href="#cb249-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb249-9"><a href="#cb249-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_TPLU</span></span></code></pre></div>
<p>この理由は、関数テンプレート内での2nd name
lookupで選択された名前が関数テンプレートであった場合、
その特殊化の検索範囲はコンパイル単位内になることがあるからである (<a
href="https://en.cppreference.com/w/cpp/language/template_specialization">template_specialization</a>
によるとこの動作は未定義のようだが、 <a
href="cpp_idioms.html#SS_21_10_1">g++</a>/<a
href="cpp_idioms.html#SS_21_10_2">clang++</a>両方ともこのコードを警告なしでコンパイルする)。</p>
<p>TypeName(long{})内でのtwo phase name
lookupは、TypeName(int{})とほぼ同様に進み、 template&lt;&gt;
ToTypeの宣言を探し出すが、
さらに前述したようにこのコンパイル単位のNS_TPLU内からその特殊化も探し出す。
その結果、ToType(t)の呼び出しは、NS_TPLU内のtemplate&lt;&gt;
ToType&lt;long&gt;の定義と関連付けられる。</p>
<p>以上の議論からわかる通り、関数テンプレートとその特殊化の組み合わせは、
そのインスタンス化箇所(この場合単体テストコード内)の後方から、 name
lookupでバインドされる関数を変更することができるため、
極めて分かりづらいコードを生み出す。ここから、</p>
<ul>
<li>関数テンプレートとその特殊化はソースコード上なるべく近い位置で宣言するべきである</li>
<li>STL関数テンプレートの特殊化は行うべきではない</li>
</ul>
<p>という教訓が得られる。</p>
<p>なお、関数とその関数オーバーロードのname
lookupの対象は、呼び出し箇所前方の宣言のみであるため、
関数テンプレートToType(T const&amp;
t)の代わりに、関数ToType(…)を使うことで、 上記問題は回避可能である。</p>
<p>次に示す例は、一見2nd name
lookupで関連付けされるように見える関数ToType(NS_TPLU2::Y const&amp;)が、
実際には関連付けされないコードである。</p>
<div class="sourceCode" id="cb250"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 71</span></span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_TPLU2 <span class="op">{</span></span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Y <span class="op">{</span></span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_TPLU2</span></span></code></pre></div>
<div class="sourceCode" id="cb251"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 79</span></span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// global名前空間</span></span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToType<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;)</span></span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb251-7"><a href="#cb251-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;unknown&quot;</span><span class="op">;</span></span>
<span id="cb251-8"><a href="#cb251-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb251-9"><a href="#cb251-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-10"><a href="#cb251-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb251-11"><a href="#cb251-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string TypeName<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb251-12"><a href="#cb251-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb251-13"><a href="#cb251-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;type:&quot;</span> <span class="op">+</span> ToType<span class="op">(</span>t<span class="op">);</span></span>
<span id="cb251-14"><a href="#cb251-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb251-15"><a href="#cb251-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-16"><a href="#cb251-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToType<span class="op">(</span>NS_TPLU2<span class="op">::</span>Y <span class="at">const</span><span class="op">&amp;)</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;Y&quot;</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>これは先に示したNS_TPLU::Xの例と極めて似ている。本質的な違いは、
TypeNameやToTypeがグローバル名前空間で宣言されていることのみである。
だが、下記の単体テストで示す通り、 TypeName内でのname
lookupで関数オーバーライドToType(NS_TPLU2::Y
const&amp;)が選択されないのである。</p>
<div class="sourceCode" id="cb252"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 100</span></span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> y <span class="op">=</span> NS_TPLU2<span class="op">::</span>Y<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb252-4"><a href="#cb252-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-5"><a href="#cb252-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_EQ(&quot;type:Y&quot;, TypeName(y));</span></span>
<span id="cb252-6"><a href="#cb252-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;type:unknown&quot;</span><span class="op">,</span> TypeName<span class="op">(</span>y<span class="op">));</span>  <span class="co">// ToType(NS_TPLU2::Y const&amp;)は使われない</span></span></code></pre></div>
<p>ここまでの現象を正確に理解するには、 「two phase
lookupの対象となる宣言」を下記のように、より厳密に認識する必要がある。</p>
<ul>
<li>TypeNameの中で行われる1st name
lookupの対象となる宣言は下記の積集合である。
<ul>
<li>TypeNameと同じ名前空間内かグローバル名前空間内の宣言</li>
<li>TypeName定義位置より前方の宣言</li>
</ul></li>
<li>TypeNameの中で行われる2nd name
lookupの対象となる宣言は下記の和集合である。
<ul>
<li>1st name lookupで使われた宣言</li>
<li>TypeName呼び出しより前方にある<a
href="core_lang_spec.html#SS_19_12_6">関連名前空間</a>内の宣言</li>
</ul></li>
</ul>
<p>この認識に基づくNS_TPLU2::Yに対するグローバルなTypeName内でのtwo
phase name lookupは、</p>
<ol type="1">
<li>TypeName内に1st name lookupの対象がないため何もしない。</li>
<li>TypeName内の2nd name lookupに使用される<a
href="core_lang_spec.html#SS_19_12_6">関連名前空間</a>NS_TPLU2は、
ToType(NS_TPLU2::Y const&amp;)の宣言を含まないため、この宣言は2nd name
lookupの対象とならない。
その結果、ToType(t)の呼び出しは関数テンプレートToType(T
const&amp;)と関連付けられる。</li>
</ol>
<p>という手順で行われる。</p>
<p>以上が、TypeNameからToType(NS_TPLU2::Y
const&amp;)が使われない理由である。</p>
<p>ここまでで示したようにtwo phase name lookupは理解しがたく、
理解したとしてもその使いこなしはさらに難しい。</p>
<p>次のコードは、この難解さに翻弄されるのが現場のプログラマのみではないことを示す。</p>
<div class="sourceCode" id="cb253"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 71</span></span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_TPLU2 <span class="op">{</span></span>
<span id="cb253-4"><a href="#cb253-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Y <span class="op">{</span></span>
<span id="cb253-5"><a href="#cb253-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb253-6"><a href="#cb253-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb253-7"><a href="#cb253-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_TPLU2</span></span></code></pre></div>
<div class="sourceCode" id="cb254"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 110</span></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// global名前空間</span></span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="kw">operator</span><span class="op">+(</span>T <span class="at">const</span><span class="op">&amp;,</span> <span class="dt">int</span> i<span class="op">)</span></span>
<span id="cb254-6"><a href="#cb254-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb254-7"><a href="#cb254-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb254-8"><a href="#cb254-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb254-9"><a href="#cb254-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-10"><a href="#cb254-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb254-11"><a href="#cb254-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> TypeNum<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb254-12"><a href="#cb254-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb254-13"><a href="#cb254-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> t <span class="op">+</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb254-14"><a href="#cb254-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb254-15"><a href="#cb254-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-16"><a href="#cb254-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="kw">operator</span><span class="op">+(</span>NS_TPLU2<span class="op">::</span>Y <span class="at">const</span><span class="op">&amp;</span> y<span class="op">,</span> <span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> y<span class="op">.</span>i <span class="op">+</span> i<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>上記の宣言、定義があった場合、operator+の単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb255"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 132</span></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> y <span class="op">=</span> NS_TPLU2<span class="op">::</span>Y<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-5"><a href="#cb255-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> y <span class="op">+</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// 2つ目のoperator+が選択される</span></span></code></pre></div>
<p>このテストは当然パスするが、次はどうだろう？</p>
<div class="sourceCode" id="cb256"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 142</span></span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> y <span class="op">=</span> NS_TPLU2<span class="op">::</span>Y<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb256-4"><a href="#cb256-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-5"><a href="#cb256-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> TypeNum<span class="op">(</span>y<span class="op">));</span>  <span class="co">// g++ではoperator+(NS_TPLU2::Y const&amp;, int i)がname lookupされる</span></span></code></pre></div>
<p>これまでのtwo phase name lookupの説明では、 operator+(NS_TPLU2::Y
const&amp; y, int i)はTypeNum内でのname lookupの対象にはならないため、
このテストはエラーとならなければならないが、<a
href="cpp_idioms.html#SS_21_10_1">g++</a>ではパスしてしまう。 2nd name
lookupのロジックにバグがあるようである。</p>
<p>有難いことに、<a
href="cpp_idioms.html#SS_21_10_2">clang++</a>では仕様通りこのテストはエラーとなり、
当然ながら以下のテストはパスする(つまり、g++ではエラーする)。</p>
<div class="sourceCode" id="cb257"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/two_phase_name_lookup_ut.cpp 151</span></span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> y <span class="op">=</span> NS_TPLU2<span class="op">::</span>Y<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> TypeNum<span class="op">(</span>y<span class="op">));</span>  <span class="co">// clang++ではoperator+(T const&amp;, int i)がname lookupされる</span></span></code></pre></div>
<p>なお、TypeNum内のコードである</p>
<div class="sourceCode" id="cb258"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t <span class="op">+</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>を下記のように変更することで</p>
<div class="sourceCode" id="cb259"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">operator</span><span class="op">+(</span>t<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<p>g++のname lookupはclang++と同じように動作するため、
記法に違和感があるものの、この方法はg++のバグのワークアランドとして使用できる。</p>
<p>また、operator+(NS_TPLU2::Y const&amp; y, int
i)をNS_TPLU2で宣言することで、
g++ではパスしたテストをclang++でもパスさせられるようになる(これは正しい動作)。
これにより、型とその2項演算子オーバーロードは同じ名前空間で宣言するべきである、
という教訓が得られる。</p>
<p>以上で見てきたようにtwo phase name
lookupは、現場プログラマのみではなく、
コンパイラを開発するプログラマをも混乱させるほど難解ではあるが、
STLを含むテンプレートメタプログラミングを支える重要な機能であるため、
C++プログラマには、最低でもこれを理解し、出来れば使いこなせるようになってほしい。</p>
<h3 id="実引数依存探索">実引数依存探索 <a id="SS_19_12_4"></a></h3>
<p>実引数依存探索とは、argument-dependent lookupの和訳語であり、
通常はその略語である<a
href="core_lang_spec.html#SS_19_12_5">ADL</a>と呼ばれる。</p>
<h3 id="adl">ADL <a id="SS_19_12_5"></a></h3>
<p>ADLとは、関数の実引数の型が宣言されている名前空間(これを<a
href="core_lang_spec.html#SS_19_12_6">関連名前空間</a>と呼ぶ)内の宣言が、
その関数の<a href="core_lang_spec.html#SS_19_12_2">name
lookup</a>の対象になることである。</p>
<p>下記のようなコードがあった場合、</p>
<div class="sourceCode" id="cb260"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_lookup_adl_ut.cpp 5</span></span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_ADL <span class="op">{</span></span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb260-5"><a href="#cb260-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb260-6"><a href="#cb260-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-7"><a href="#cb260-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToString<span class="op">(</span>A <span class="at">const</span><span class="op">&amp;</span> a<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;A:&quot;</span><span class="op">}</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span>a<span class="op">.</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb260-8"><a href="#cb260-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_ADL</span></span></code></pre></div>
<p>以下のコードでのToStringの呼び出しに対するのname lookupは、</p>
<div class="sourceCode" id="cb261"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_lookup_adl_ut.cpp 18</span></span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> NS_ADL<span class="op">::</span>A<span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-5"><a href="#cb261-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;A:0&quot;</span><span class="op">,</span> ToString<span class="op">(</span>a<span class="op">));</span>  <span class="co">// ADLの効果により、ToStringはNS_ADLを指定しなくても見つかる</span></span></code></pre></div>
<ul>
<li>ToStringの呼び出しより前方で行われているグローバル名前空間内の宣言</li>
<li>ToStringの呼び出しより前方で行われているNS_ADL内の宣言</li>
</ul>
<p>の両方を対象として行われる。
NS_ADL内の宣言がToStringの呼び出しに対するのname
lookupの対象になる理由は、
ToStringの呼び出しに使われている実引数aの型AがNS_ADLで宣言されているからである。
すでに述べたようにこれをADLと呼び、この場合のNS_ADLを<a
href="core_lang_spec.html#SS_19_12_6">関連名前空間</a>と呼ぶ。</p>
<p>ADLは思わぬname lookupによるバグを誘発することもあるが、
下記コードを見れば明らかなように、また、
多くのプログラマはそれと気づかずに使っていることからもわかる通り、
コードをより自然に、より簡潔に記述するための重要な機能となっている。</p>
<div class="sourceCode" id="cb262"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_lookup_adl_ut.cpp 28</span></span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-3"><a href="#cb262-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記operator &lt;&lt;は、std::operator&lt;&lt;(ostream&amp;, string const&amp;)であり、</span></span>
<span id="cb262-4"><a href="#cb262-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// namespace stdで定義されている。</span></span>
<span id="cb262-5"><a href="#cb262-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-6"><a href="#cb262-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ADLがあるため、operator &lt;&lt;は名前空間修飾無しで呼び出せる。</span></span>
<span id="cb262-7"><a href="#cb262-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>string<span class="op">{</span><span class="ot">__func__</span><span class="op">};</span></span>
<span id="cb262-8"><a href="#cb262-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-9"><a href="#cb262-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ADLが無いと下記のような呼び出しになる。</span></span>
<span id="cb262-10"><a href="#cb262-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>operator<span class="op">&lt;&lt;(</span><span class="bu">std::</span>cout<span class="op">,</span> <span class="bu">std::</span>string<span class="op">{</span><span class="ot">__func__</span><span class="op">});</span></span></code></pre></div>
<h3 id="関連名前空間">関連名前空間 <a id="SS_19_12_6"></a></h3>
<p>関連名前空間(associated namespace)とは、 <a
href="core_lang_spec.html#SS_19_12_5">ADL</a>(実引数依存探索)によってname
lookupの対象になった宣言を含む名前空間のことである。</p>
<h3 id="修飾付き関数呼び出し">修飾付き関数呼び出し
<a id="SS_19_12_7"></a></h3>
<p>修飾付き関数呼び出し(Qualified Call)は、
C++で関数やメンバ関数を明示的にスコープやクラス名で修飾して呼び出す方法である。
名前の曖昧性を回避し、特定の関数やクラスメンバを明確に選択する際に利用される。
これにより、意図しない<a href="core_lang_spec.html#SS_19_12_2">name
lookup</a>を回避することができるため、可読性と安全性が向上する。
一方で、<a
href="core_lang_spec.html#SS_19_12_5">ADL</a>が働かなくなるため、フレキシブルな<a
href="core_lang_spec.html#SS_19_12_2">name lookup</a>ができなくなる。</p>
<div class="sourceCode" id="cb263"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/etc_ut.cpp 40</span></span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">extern</span> <span class="dt">void</span> func<span class="op">();</span>  <span class="co">// グローバル名前空間での宣言</span></span>
<span id="cb263-4"><a href="#cb263-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-5"><a href="#cb263-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Base <span class="op">{</span></span>
<span id="cb263-6"><a href="#cb263-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> func<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{}</span></span>
<span id="cb263-7"><a href="#cb263-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb263-8"><a href="#cb263-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-9"><a href="#cb263-9" aria-hidden="true" tabindex="-1"></a>    A<span class="op">::</span>func<span class="op">();</span>  <span class="co">// 名前空間名による修飾</span></span>
<span id="cb263-10"><a href="#cb263-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-11"><a href="#cb263-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Derived <span class="op">:</span> Base <span class="op">{</span></span>
<span id="cb263-12"><a href="#cb263-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// void        func() { func(); /* funcの無限リカーシブコール */ }</span></span>
<span id="cb263-13"><a href="#cb263-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span>        func<span class="op">()</span> <span class="op">{</span> Base<span class="op">::</span>func<span class="op">();</span> <span class="co">/* クラス名での修飾 */</span> <span class="op">}</span></span>
<span id="cb263-14"><a href="#cb263-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span>        func<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span> <span class="op">::</span>func<span class="op">();</span> <span class="co">/* グローバル修飾 */</span> <span class="op">}</span></span>
<span id="cb263-15"><a href="#cb263-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span>        func<span class="op">(</span>Base<span class="op">)</span> <span class="op">{</span> <span class="kw">this</span><span class="op">-&gt;</span>func<span class="op">();</span> <span class="co">/* thisによる修飾 */</span> <span class="op">}</span></span>
<span id="cb263-16"><a href="#cb263-16" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="dt">void</span> func<span class="op">(</span><span class="bu">std::</span>string<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb263-17"><a href="#cb263-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb263-18"><a href="#cb263-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-19"><a href="#cb263-19" aria-hidden="true" tabindex="-1"></a>    Base b<span class="op">;</span></span>
<span id="cb263-20"><a href="#cb263-20" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>func<span class="op">();</span>        <span class="co">// 通常の関数呼び出し</span></span>
<span id="cb263-21"><a href="#cb263-21" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>Base<span class="op">::</span>func<span class="op">();</span>  <span class="co">// クラス名での修飾による関数呼び出し</span></span>
<span id="cb263-22"><a href="#cb263-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-23"><a href="#cb263-23" aria-hidden="true" tabindex="-1"></a>    Derived d<span class="op">;</span></span>
<span id="cb263-24"><a href="#cb263-24" aria-hidden="true" tabindex="-1"></a>    Derived<span class="op">::</span>func<span class="op">(</span><span class="st">&quot;str&quot;</span><span class="op">);</span>  <span class="co">// クラス名での修飾による関数呼び出し</span></span>
<span id="cb263-25"><a href="#cb263-25" aria-hidden="true" tabindex="-1"></a>    d<span class="op">.</span>func<span class="op">(</span><span class="st">&quot;str&quot;</span><span class="op">);</span>         <span class="co">// 通常の関数呼び出し</span></span></code></pre></div>
<h3 id="hidden-friend関数">hidden-friend関数
<a id="SS_19_12_8"></a></h3>
<p>hidden-friend関数(隠れたフレンド関数、あるいは単にhidden-friend)とは、</p>
<ul>
<li>クラスの内部で定義された、</li>
<li>名前空間スコープでの通常の<a
href="core_lang_spec.html#SS_19_12_2">name lookup</a>できず、<a
href="core_lang_spec.html#SS_19_12_5">ADL</a>のみでname lookupできる</li>
</ul>
<p>friend関数のことを指す。このような性質から、non-namespace-visible
friend関数と呼ばれることもある。</p>
<p>これにより、意図的に外部からのアクセスを制限し、
必要な場合にのみ利用されることを保証する設計が可能となる。</p>
<p>hidden-friend関数(隠れたフレンド関数)の目的は、</p>
<ul>
<li>カプセル化の強化：
クラスの内部実装を外部から隠しつつ、特定の操作だけを許可する。</li>
<li>名前空間汚染の防止：
関数が名前空間スコープに現れないため、他の名前と衝突しにくい。</li>
<li>最適化：
コンパイラによる最適化を妨げることなく、特定の機能を提供する。</li>
</ul>
<div class="sourceCode" id="cb264"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/hidden_friend_ut.cpp 7</span></span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS <span class="op">{</span></span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Person <span class="op">{</span></span>
<span id="cb264-5"><a href="#cb264-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb264-6"><a href="#cb264-6" aria-hidden="true" tabindex="-1"></a>        Person<span class="op">(</span><span class="bu">std::</span>string name<span class="op">,</span> <span class="dt">uint32_t</span> age<span class="op">)</span> <span class="op">:</span> <span class="va">name_</span><span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>name<span class="op">)},</span> <span class="va">age_</span><span class="op">{</span>age<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb264-7"><a href="#cb264-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-8"><a href="#cb264-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// hidden-friend関数</span></span>
<span id="cb264-9"><a href="#cb264-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> <span class="at">const</span> Person<span class="op">&amp;</span> person<span class="op">)</span></span>
<span id="cb264-10"><a href="#cb264-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb264-11"><a href="#cb264-11" aria-hidden="true" tabindex="-1"></a>            os <span class="op">&lt;&lt;</span> <span class="st">&quot;Name:&quot;</span> <span class="op">&lt;&lt;</span> person<span class="op">.</span><span class="va">name_</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;, Age:&quot;</span> <span class="op">&lt;&lt;</span> person<span class="op">.</span><span class="va">age_</span><span class="op">;</span></span>
<span id="cb264-12"><a href="#cb264-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb264-13"><a href="#cb264-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb264-14"><a href="#cb264-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-15"><a href="#cb264-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb264-16"><a href="#cb264-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="at">const</span> <span class="va">name_</span><span class="op">;</span></span>
<span id="cb264-17"><a href="#cb264-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uint32_t</span> <span class="at">const</span>    <span class="va">age_</span><span class="op">;</span></span>
<span id="cb264-18"><a href="#cb264-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb264-19"><a href="#cb264-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS</span></span></code></pre></div>
<div class="sourceCode" id="cb265"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/hidden_friend_ut.cpp 31</span></span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true" tabindex="-1"></a>    NS<span class="op">::</span>Person         alice<span class="op">(</span><span class="st">&quot;Alice&quot;</span><span class="op">,</span> <span class="dv">30</span><span class="op">);</span></span>
<span id="cb265-4"><a href="#cb265-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostringstream oss<span class="op">;</span></span>
<span id="cb265-5"><a href="#cb265-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-6"><a href="#cb265-6" aria-hidden="true" tabindex="-1"></a>    oss <span class="op">&lt;&lt;</span> alice<span class="op">;</span>  <span class="co">// フレンド関数を呼び出す(ADLによって見つかる)</span></span>
<span id="cb265-7"><a href="#cb265-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;Name:Alice, Age:30&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb265-8"><a href="#cb265-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-9"><a href="#cb265-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 以下はエラー（operator&lt;&lt;がNS名前空間スコープで見えない）</span></span>
<span id="cb265-10"><a href="#cb265-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// NS::Person::operator&lt;&lt;(oss, alice);</span></span>
<span id="cb265-11"><a href="#cb265-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 上記は以下のようなコンパイルエラーになる</span></span>
<span id="cb265-12"><a href="#cb265-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  error: ‘operator&lt;&lt;’ is not a member of ‘NS::Person’</span></span></code></pre></div>
<h3 id="name-hiding">name-hiding <a id="SS_19_12_9"></a></h3>
<p>name-hidingとは
「前方の識別子が、その後方に同一の名前をもつ識別子があるために、 <a
href="core_lang_spec.html#SS_19_12_2">name
lookup</a>の対象外になる」現象一般を指す通称である (<a
href="https://en.cppreference.com/w/cpp/language/namespace">namespace</a>参照)。</p>
<p>まずは、クラスとその派生クラスでのname-hidingの例を示す。</p>
<div class="sourceCode" id="cb266"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_hiding.cpp 4</span></span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-3"><a href="#cb266-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Base <span class="op">{</span></span>
<span id="cb266-4"><a href="#cb266-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> f<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb266-5"><a href="#cb266-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb266-6"><a href="#cb266-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-7"><a href="#cb266-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Derived <span class="op">:</span> Base <span class="op">{</span></span>
<span id="cb266-8"><a href="#cb266-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// void f(int) { f(); }     // f()では、Baseのf()をname lookupできないため、</span></span>
<span id="cb266-9"><a href="#cb266-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span> Base<span class="op">::</span>f<span class="op">();</span> <span class="op">}</span>  <span class="co">// Base::でf()を修飾した</span></span>
<span id="cb266-10"><a href="#cb266-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>上記の関数fは一見オーバーロードに見えるが、そうではない。下記のコードで示したように、
Base::f()には、修飾しない形式でのDerivedクラス経由のアクセスはできない。</p>
<div class="sourceCode" id="cb267"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_hiding.cpp 18</span></span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> d <span class="op">=</span> Derived<span class="op">{};</span></span>
<span id="cb267-5"><a href="#cb267-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if 0 </span></span>
<span id="cb267-6"><a href="#cb267-6" aria-hidden="true" tabindex="-1"></a><span class="co">        d.f(); // コンパイルできない</span></span>
<span id="cb267-7"><a href="#cb267-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span><span class="pp">#else</span></span>
<span id="cb267-8"><a href="#cb267-8" aria-hidden="true" tabindex="-1"></a>        d<span class="op">.</span>Base<span class="op">::</span>f<span class="op">();</span>  <span class="co">// Base::での修飾が必要</span></span>
<span id="cb267-9"><a href="#cb267-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb267-10"><a href="#cb267-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>これは前述したように、
Base::fがその後方にあるDerived::f(int)によりname-hidingされたために起こる現象である
(name
lookupによる探索には識別子が使われるため、シグネチャの違いはname-hidingに影響しない)。</p>
<p>下記のように<a
href="core_lang_spec.html#SS_19_12_14">using宣言</a>を使用することで、
修飾しない形式でのDerivedクラス経由のBase::f()へのアクセスが可能となる。</p>
<div class="sourceCode" id="cb268"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_hiding.cpp 34</span></span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Derived <span class="op">:</span> Base <span class="op">{</span></span>
<span id="cb268-4"><a href="#cb268-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> Base<span class="op">::</span>f<span class="op">;</span>        <span class="co">// using宣言によりDerivedにBase::fを導入</span></span>
<span id="cb268-5"><a href="#cb268-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{</span> f<span class="op">();</span> <span class="op">}</span>  <span class="co">// using Base::fの効果でfの名前修飾が不要になった</span></span>
<span id="cb268-6"><a href="#cb268-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb269"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_hiding.cpp 45</span></span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb269-3"><a href="#cb269-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> d <span class="op">=</span> Derived<span class="op">{};</span></span>
<span id="cb269-4"><a href="#cb269-4" aria-hidden="true" tabindex="-1"></a>    d<span class="op">.</span>f<span class="op">();</span>  <span class="co">// using宣言によりコンパイルできる</span></span></code></pre></div>
<p>下記コードは、名前空間でも似たような現象が起こることを示している。</p>
<div class="sourceCode" id="cb270"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_hiding.cpp 54</span></span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// global名前空間</span></span>
<span id="cb270-4"><a href="#cb270-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb270-5"><a href="#cb270-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-6"><a href="#cb270-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_A <span class="op">{</span></span>
<span id="cb270-7"><a href="#cb270-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb270-8"><a href="#cb270-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-9"><a href="#cb270-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> g<span class="op">()</span></span>
<span id="cb270-10"><a href="#cb270-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb270-11"><a href="#cb270-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if 0</span></span>
<span id="cb270-12"><a href="#cb270-12" aria-hidden="true" tabindex="-1"></a><span class="co">        f();  // NS_A::fによりname-hidingされたため、コンパイルできない</span></span>
<span id="cb270-13"><a href="#cb270-13" aria-hidden="true" tabindex="-1"></a><span class="co">    </span><span class="pp">#endif</span></span>
<span id="cb270-14"><a href="#cb270-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb270-15"><a href="#cb270-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_A</span></span></code></pre></div>
<p>この問題に対しては、下記のようにf(int)の定義位置を後方に移動することで回避できる。</p>
<div class="sourceCode" id="cb271"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_hiding.cpp 70</span></span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_A_fixed_0 <span class="op">{</span></span>
<span id="cb271-4"><a href="#cb271-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> g<span class="op">()</span></span>
<span id="cb271-5"><a href="#cb271-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb271-6"><a href="#cb271-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// グローバルなfの呼び出し</span></span>
<span id="cb271-7"><a href="#cb271-7" aria-hidden="true" tabindex="-1"></a>        f<span class="op">();</span>  <span class="co">// NS_A::fは後方に移動されたためコンパイルできる</span></span>
<span id="cb271-8"><a href="#cb271-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb271-9"><a href="#cb271-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-10"><a href="#cb271-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb271-11"><a href="#cb271-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_A_fixed_0</span></span></code></pre></div>
<p>また、先述のクラスでの方法と同様にusing宣言を使い、下記のようにすることもできる。</p>
<div class="sourceCode" id="cb272"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_hiding.cpp 82</span></span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-3"><a href="#cb272-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_A_fixed_1 <span class="op">{</span></span>
<span id="cb272-4"><a href="#cb272-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb272-5"><a href="#cb272-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-6"><a href="#cb272-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> g<span class="op">()</span></span>
<span id="cb272-7"><a href="#cb272-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb272-8"><a href="#cb272-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="op">::</span>f<span class="op">;</span></span>
<span id="cb272-9"><a href="#cb272-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-10"><a href="#cb272-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// グローバルなfの呼び出し</span></span>
<span id="cb272-11"><a href="#cb272-11" aria-hidden="true" tabindex="-1"></a>        f<span class="op">();</span>  <span class="co">// using宣言によりコンパイルできる</span></span>
<span id="cb272-12"><a href="#cb272-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb272-13"><a href="#cb272-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_A_fixed_1</span></span></code></pre></div>
<p>当然ながら、下記のようにf()の呼び出しを::で修飾することもできる。</p>
<div class="sourceCode" id="cb273"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_hiding.cpp 96</span></span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_A_fixed_2 <span class="op">{</span></span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb273-5"><a href="#cb273-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-6"><a href="#cb273-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> g<span class="op">()</span></span>
<span id="cb273-7"><a href="#cb273-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb273-8"><a href="#cb273-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// グローバルなfの呼び出し</span></span>
<span id="cb273-9"><a href="#cb273-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">::</span>f<span class="op">();</span>  <span class="co">// ::で修飾すればコンパイルできる</span></span>
<span id="cb273-10"><a href="#cb273-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb273-11"><a href="#cb273-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_A_fixed_2</span></span></code></pre></div>
<p>修飾の副作用として「<a href="core_lang_spec.html#SS_19_12_3">two phase
name lookup</a>」の例で示したような <a
href="core_lang_spec.html#SS_19_12_5">ADL</a>を利用した高度な静的ディスパッチが使用できなくなるが、
通常のソフトウェア開発では、ADLが必要な場面は限られているため、
デフォルトでは名前空間を使用して修飾を行うことにするのが、
無用の混乱をさけるための安全な記法であると言えるだろう。</p>
<p>次に、そういった混乱を引き起こすであろうコードを示す。</p>
<div class="sourceCode" id="cb274"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/name_hiding.cpp 108</span></span>
<span id="cb274-2"><a href="#cb274-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-3"><a href="#cb274-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_B <span class="op">{</span></span>
<span id="cb274-4"><a href="#cb274-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> S_in_B <span class="op">{};</span></span>
<span id="cb274-5"><a href="#cb274-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-6"><a href="#cb274-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span>S_in_B<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb274-7"><a href="#cb274-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb274-8"><a href="#cb274-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-9"><a href="#cb274-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> NS_B_Inner <span class="op">{</span></span>
<span id="cb274-10"><a href="#cb274-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> g<span class="op">()</span></span>
<span id="cb274-11"><a href="#cb274-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb274-12"><a href="#cb274-12" aria-hidden="true" tabindex="-1"></a>        f<span class="op">(</span><span class="dt">int</span><span class="op">{});</span>  <span class="co">// コンパイルでき、NS_B::f(int)が呼ばれる</span></span>
<span id="cb274-13"><a href="#cb274-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb274-14"><a href="#cb274-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-15"><a href="#cb274-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb274-16"><a href="#cb274-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-17"><a href="#cb274-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> h<span class="op">()</span></span>
<span id="cb274-18"><a href="#cb274-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb274-19"><a href="#cb274-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// f(int{});     // コンパイルできない</span></span>
<span id="cb274-20"><a href="#cb274-20" aria-hidden="true" tabindex="-1"></a>        NS_B<span class="op">::</span>f<span class="op">(</span><span class="dt">int</span><span class="op">{});</span>  <span class="co">// 名前空間で修飾することでコンパイルできる</span></span>
<span id="cb274-21"><a href="#cb274-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-22"><a href="#cb274-22" aria-hidden="true" tabindex="-1"></a>        f<span class="op">(</span>S_in_B<span class="op">{});</span>  <span class="co">// ADLによりコンパイルできる</span></span>
<span id="cb274-23"><a href="#cb274-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb274-24"><a href="#cb274-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_B_Inner</span></span>
<span id="cb274-25"><a href="#cb274-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace NS_B</span></span></code></pre></div>
<p>NS_B_Inner::g()内のf(int)の呼び出しはコンパイルできるが、
name-hidingが原因で、NS_B_Inner::h()内のf(int)の呼び出しはコンパイルできず、
名前空間で修飾することが必要になる。
一方で、ADLの効果で名前空間での修飾をしていないf(S_in_B)の呼び出しはコンパイルできる。</p>
<p>全チームメンバがこういったname
lookupを正しく扱えると確信できないのであれば、
前述の通り、デフォルトでは名前空間を使用して修飾を行うのが良いだろう。</p>
<h3 id="ダイヤモンド継承">ダイヤモンド継承 <a id="SS_19_12_10"></a></h3>
<p>ダイヤモンド継承(Diamond
Inheritance)とは、以下のような構造のクラス継承を指す。</p>
<ul>
<li>基底クラス(Base)が一つ存在し、その基底クラスから二つのクラス(Derived_0、Derived_1)が派生する。</li>
<li>Derived_0とDerived_1からさらに一つのクラス(DerivedDerived)が派生する。
したがって、DerivedDerivedはBaseの孫クラスとなる。</li>
</ul>
<p>この継承は、多重継承の一形態であり、クラス図で表すと下記のようになるため、
ダイヤモンド継承と呼ばれる。</p>
<!-- pu:essential/plant_uml/diamond_inheritance.pu-->
<p>
<img src="data:image/png;base64,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" />
</p>
<p>ダイヤモンド継承は、 <a
href="core_lang_spec.html#SS_19_12_11">仮想継承</a>(virtual
inheritance)を使ったものと、使わないものに分類できる。</p>
<p><a
href="core_lang_spec.html#SS_19_12_11">仮想継承</a>を使わないダイヤモンド継承のコードを以下に示す。</p>
<div class="sourceCode" id="cb275"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/diamond_inheritance_ut.cpp 6</span></span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Base <span class="op">{</span></span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb275-6"><a href="#cb275-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span>    set<span class="op">(</span><span class="dt">int32_t</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="va">x_</span> <span class="op">=</span> x<span class="op">;</span> <span class="op">}</span></span>
<span id="cb275-7"><a href="#cb275-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-8"><a href="#cb275-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb275-9"><a href="#cb275-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> <span class="va">x_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb275-10"><a href="#cb275-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb275-11"><a href="#cb275-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-12"><a href="#cb275-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Derived_0 <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{};</span></span>
<span id="cb275-13"><a href="#cb275-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-14"><a href="#cb275-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Derived_1 <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{};</span></span>
<span id="cb275-15"><a href="#cb275-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-16"><a href="#cb275-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> DerivedDerived <span class="op">:</span> <span class="kw">public</span> Derived_0<span class="op">,</span> <span class="kw">public</span> Derived_1 <span class="op">{};</span></span></code></pre></div>
<div class="sourceCode" id="cb276"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/diamond_inheritance_ut.cpp 26</span></span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> dd <span class="op">=</span> DerivedDerived<span class="op">{};</span></span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-5"><a href="#cb276-5" aria-hidden="true" tabindex="-1"></a>    Base<span class="op">&amp;</span> b0 <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span>Derived_0<span class="op">&amp;&gt;(</span>dd<span class="op">);</span>  <span class="co">// Derived_0::Baseのリファレンス</span></span>
<span id="cb276-6"><a href="#cb276-6" aria-hidden="true" tabindex="-1"></a>    Base<span class="op">&amp;</span> b1 <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span>Derived_1<span class="op">&amp;&gt;(</span>dd<span class="op">);</span>  <span class="co">// Derived_1::Baseのリファレンス</span></span>
<span id="cb276-7"><a href="#cb276-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-8"><a href="#cb276-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_NE<span class="op">(&amp;</span>b0<span class="op">,</span> <span class="op">&amp;</span>b1<span class="op">);</span>  <span class="co">// ddの中には、Baseインスタンスが2つできる</span></span></code></pre></div>
<p>これからわかるように、DerivedDerivedインスタンスの中に2つのBaseインスタンスが存在する。
この状態をオブジェクト図で表すと下記のようになる。</p>
<!-- pu:essential/plant_uml/diamond_inheritance_obj.pu-->
<p>
<img src="data:image/png;base64,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" />
</p>
<p>下記コードは、それが原因で名前解決が曖昧になりコンパイルできない。</p>
<div class="sourceCode" id="cb277"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/diamond_inheritance_ut.cpp 36</span></span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-3"><a href="#cb277-3" aria-hidden="true" tabindex="-1"></a>    Base<span class="op">&amp;</span> b <span class="op">=</span> dd<span class="op">;</span>  <span class="co">// Derived_0::Base or Derived_1::Base ?</span></span>
<span id="cb277-4"><a href="#cb277-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-5"><a href="#cb277-5" aria-hidden="true" tabindex="-1"></a>    dd<span class="op">.</span>get<span class="op">();</span>  <span class="co">// Derived_0::get or  Derived_1::get ?</span></span>
<span id="cb277-6"><a href="#cb277-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-7"><a href="#cb277-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記のようなエラーが発生する</span></span>
<span id="cb277-8"><a href="#cb277-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  diamond_inheritance_ut.cpp:37:15: error: ‘Base’ is an ambiguous base of ‘DerivedDerived’</span></span>
<span id="cb277-9"><a href="#cb277-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//     37 |     Base&amp; b = dd;  // Derived_0::Base or Derived_1::Base ?</span></span>
<span id="cb277-10"><a href="#cb277-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//        |               ^~</span></span>
<span id="cb277-11"><a href="#cb277-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  diamond_inheritance_ut.cpp:39:8: error: request for member ‘get’ is ambiguous</span></span>
<span id="cb277-12"><a href="#cb277-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">//     39 |     dd.get();  // Derived_0::get or  Derived_1::get ?</span></span>
<span id="cb277-13"><a href="#cb277-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//        |        ^~~</span></span></code></pre></div>
<p>この問題に対処するには、クラス名による修飾が必要になるが、
Baseインスタンスが2つ存在するため、下記に示すようなわかりづらいバグの温床となる。</p>
<div class="sourceCode" id="cb278"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/diamond_inheritance_ut.cpp 53</span></span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-3"><a href="#cb278-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> dd<span class="op">.</span>Derived_0<span class="op">::</span>get<span class="op">());</span>  <span class="co">// クラス名による名前修飾</span></span>
<span id="cb278-4"><a href="#cb278-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> dd<span class="op">.</span>Derived_1<span class="op">::</span>get<span class="op">());</span></span>
<span id="cb278-5"><a href="#cb278-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-6"><a href="#cb278-6" aria-hidden="true" tabindex="-1"></a>    dd<span class="op">.</span>Derived_0<span class="op">::</span>set<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb278-7"><a href="#cb278-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> dd<span class="op">.</span>Derived_0<span class="op">::</span>get<span class="op">());</span>  <span class="co">// Derived_0::Base::x_は1に変更</span></span>
<span id="cb278-8"><a href="#cb278-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> dd<span class="op">.</span>Derived_1<span class="op">::</span>get<span class="op">());</span>  <span class="co">// Derived_1::Base::x_は0のまま</span></span>
<span id="cb278-9"><a href="#cb278-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-10"><a href="#cb278-10" aria-hidden="true" tabindex="-1"></a>    dd<span class="op">.</span>Derived_1<span class="op">::</span>set<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb278-11"><a href="#cb278-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> dd<span class="op">.</span>Derived_0<span class="op">::</span>get<span class="op">());</span>  <span class="co">// Derived_0::Base::x_は1のまま</span></span>
<span id="cb278-12"><a href="#cb278-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> dd<span class="op">.</span>Derived_1<span class="op">::</span>get<span class="op">());</span>  <span class="co">// Derived_1::Base::x_は2に変更</span></span></code></pre></div>
<p>次に示すのは、<a
href="core_lang_spec.html#SS_19_12_11">仮想継承</a>を使用したダイヤモンド継承の例である。</p>
<div class="sourceCode" id="cb279"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/diamond_inheritance_ut.cpp 70</span></span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Base <span class="op">{</span></span>
<span id="cb279-4"><a href="#cb279-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb279-5"><a href="#cb279-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb279-6"><a href="#cb279-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span>    set<span class="op">(</span><span class="dt">int32_t</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="va">x_</span> <span class="op">=</span> x<span class="op">;</span> <span class="op">}</span></span>
<span id="cb279-7"><a href="#cb279-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-8"><a href="#cb279-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb279-9"><a href="#cb279-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> <span class="va">x_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb279-10"><a href="#cb279-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb279-11"><a href="#cb279-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-12"><a href="#cb279-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Derived_0 <span class="op">:</span> <span class="kw">public</span> <span class="kw">virtual</span> Base <span class="op">{};</span>  <span class="co">// 仮想継承</span></span>
<span id="cb279-13"><a href="#cb279-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-14"><a href="#cb279-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Derived_1 <span class="op">:</span> <span class="kw">public</span> <span class="kw">virtual</span> Base <span class="op">{};</span>  <span class="co">// 仮想継承</span></span>
<span id="cb279-15"><a href="#cb279-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-16"><a href="#cb279-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> DerivedDerived <span class="op">:</span> <span class="kw">public</span> Derived_0<span class="op">,</span> <span class="kw">public</span> Derived_1 <span class="op">{};</span></span></code></pre></div>
<div class="sourceCode" id="cb280"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/diamond_inheritance_ut.cpp 90</span></span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-3"><a href="#cb280-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> dd <span class="op">=</span> DerivedDerived<span class="op">{};</span></span>
<span id="cb280-4"><a href="#cb280-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-5"><a href="#cb280-5" aria-hidden="true" tabindex="-1"></a>    Base<span class="op">&amp;</span> b0 <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span>Derived_0<span class="op">&amp;&gt;(</span>dd<span class="op">);</span>  <span class="co">// Derived_0::Baseのリファレンス</span></span>
<span id="cb280-6"><a href="#cb280-6" aria-hidden="true" tabindex="-1"></a>    Base<span class="op">&amp;</span> b1 <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span>Derived_1<span class="op">&amp;&gt;(</span>dd<span class="op">);</span>  <span class="co">// Derived_1::Baseのリファレンス</span></span>
<span id="cb280-7"><a href="#cb280-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-8"><a href="#cb280-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(&amp;</span>b0<span class="op">,</span> <span class="op">&amp;</span>b1<span class="op">);</span>  <span class="co">// ddの中には、Baseインスタンスが1つできる</span></span></code></pre></div>
<p>仮想継承の効果で、DerivedDerivedインスタンスの中に存在するBaseインスタンスは1つになるため、
上で示した仮想継承を使わないダイヤモンド継承での問題は解消される (が、<a
href="core_lang_spec.html#SS_19_12_11">仮想継承</a>による別の問題が発生する)。</p>
<div class="sourceCode" id="cb281"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/diamond_inheritance_ut.cpp 99</span></span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true" tabindex="-1"></a>    Base<span class="op">&amp;</span> b <span class="op">=</span> dd<span class="op">;</span>  <span class="co">// Baseインスタンスは1つであるため、コンパイルできる</span></span>
<span id="cb281-4"><a href="#cb281-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-5"><a href="#cb281-5" aria-hidden="true" tabindex="-1"></a>    dd<span class="op">.</span>get<span class="op">();</span>  <span class="co">// Baseインスタンスは1つであるため、コンパイルできる</span></span>
<span id="cb281-6"><a href="#cb281-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-7"><a href="#cb281-7" aria-hidden="true" tabindex="-1"></a>    dd<span class="op">.</span>Derived_0<span class="op">::</span>set<span class="op">(</span><span class="dv">1</span><span class="op">);</span>               <span class="co">// クラス名による修飾</span></span>
<span id="cb281-8"><a href="#cb281-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> dd<span class="op">.</span>Derived_1<span class="op">::</span>get<span class="op">());</span>  <span class="co">// Derived_1::BaseとDerived_1::Baseは同一であるため</span></span>
<span id="cb281-9"><a href="#cb281-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-10"><a href="#cb281-10" aria-hidden="true" tabindex="-1"></a>    dd<span class="op">.</span>set<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb281-11"><a href="#cb281-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> dd<span class="op">.</span>get<span class="op">());</span></span></code></pre></div>
<p>この状態をオブジェクト図で表すと下記のようになる。</p>
<!-- pu:essential/plant_uml/diamond_inheritance_virtual_obj.pu-->
<p>
<img src="data:image/png;base64,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" />
</p>
<h3 id="仮想継承">仮想継承 <a id="SS_19_12_11"></a></h3>
<p>下記に示した継承方法を仮想継承、仮想継承の基底クラスを仮想基底クラスと呼ぶ。</p>
<div class="sourceCode" id="cb282"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/virtual_inheritance_ut.cpp 9</span></span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-3"><a href="#cb282-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Base <span class="op">{</span></span>
<span id="cb282-4"><a href="#cb282-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb282-5"><a href="#cb282-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> Base<span class="op">(</span><span class="dt">int32_t</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">x_</span><span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb282-6"><a href="#cb282-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb282-7"><a href="#cb282-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-8"><a href="#cb282-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb282-9"><a href="#cb282-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> <span class="va">x_</span><span class="op">;</span></span>
<span id="cb282-10"><a href="#cb282-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb282-11"><a href="#cb282-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-12"><a href="#cb282-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> DerivedVirtual <span class="op">:</span> <span class="kw">public</span> <span class="kw">virtual</span> Base <span class="op">{</span>  <span class="co">// 仮想継承</span></span>
<span id="cb282-13"><a href="#cb282-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb282-14"><a href="#cb282-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> DerivedVirtual<span class="op">(</span><span class="dt">int32_t</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> Base<span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb282-15"><a href="#cb282-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>仮想継承は、<a
href="core_lang_spec.html#SS_19_12_10">ダイヤモンド継承</a>の基底クラスのインスタンスを、
その継承ヒエラルキーの中で1つのみにするための言語機能である。</p>
<p>仮想継承の独特の動作を示すため、
上記コードに加え、仮想継承クラス、通常の継承クラス、
それぞれを通常の継承したクラスを下記のように定義する。</p>
<div class="sourceCode" id="cb283"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/virtual_inheritance_ut.cpp 25</span></span>
<span id="cb283-2"><a href="#cb283-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb283-3"><a href="#cb283-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> DerivedDerivedVirtual <span class="op">:</span> <span class="kw">public</span> DerivedVirtual <span class="op">{</span>  <span class="co">// 仮想継承を通常の継承</span></span>
<span id="cb283-4"><a href="#cb283-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb283-5"><a href="#cb283-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 注: DerivedDerivedVirtualのコンストラクタは、Baseのデフォルトコンストラクタを呼び出す</span></span>
<span id="cb283-6"><a href="#cb283-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> DerivedDerivedVirtual<span class="op">(</span><span class="dt">int32_t</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> DerivedVirtual<span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb283-7"><a href="#cb283-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb283-8"><a href="#cb283-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb283-9"><a href="#cb283-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> DerivedNormal <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{</span>  <span class="co">// 通常の継承</span></span>
<span id="cb283-10"><a href="#cb283-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb283-11"><a href="#cb283-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> DerivedNormal<span class="op">(</span><span class="dt">int32_t</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> Base<span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb283-12"><a href="#cb283-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb283-13"><a href="#cb283-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb283-14"><a href="#cb283-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> DerivedDerivedNormal <span class="op">:</span> <span class="kw">public</span> DerivedNormal <span class="op">{</span>  <span class="co">// 通常継承を通常の継承</span></span>
<span id="cb283-15"><a href="#cb283-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb283-16"><a href="#cb283-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> DerivedDerivedNormal<span class="op">(</span><span class="dt">int32_t</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> DerivedNormal<span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb283-17"><a href="#cb283-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>この場合、継承ヒエラルキーに仮想継承を含むクラスと、含まないクラスでは、
以下に示したような違いが発生する。</p>
<div class="sourceCode" id="cb284"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/virtual_inheritance_ut.cpp 46</span></span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb284-3"><a href="#cb284-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> dv <span class="op">=</span> DerivedVirtual<span class="op">{</span><span class="dv">1</span><span class="op">};</span>  <span class="co">// 仮想継承クラス</span></span>
<span id="cb284-4"><a href="#cb284-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> dn <span class="op">=</span> DerivedNormal<span class="op">{</span><span class="dv">1</span><span class="op">};</span>   <span class="co">// 通常の継承クラス</span></span>
<span id="cb284-5"><a href="#cb284-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb284-6"><a href="#cb284-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> dv<span class="op">.</span>get<span class="op">());</span>  <span class="co">// これは非仮想継承と同じ動作</span></span>
<span id="cb284-7"><a href="#cb284-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> dn<span class="op">.</span>get<span class="op">());</span></span>
<span id="cb284-8"><a href="#cb284-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb284-9"><a href="#cb284-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ddv <span class="op">=</span> DerivedDerivedVirtual<span class="op">{</span><span class="dv">1</span><span class="op">};</span>  <span class="co">// 仮想継承クラスを継承したクラス Base::Base()が呼ばれる</span></span>
<span id="cb284-10"><a href="#cb284-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ddn <span class="op">=</span> DerivedDerivedNormal<span class="op">{</span><span class="dv">1</span><span class="op">};</span>   <span class="co">// 通常継承クラスを継承したクラス Base::Base(1)が呼ばれる</span></span>
<span id="cb284-11"><a href="#cb284-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb284-12"><a href="#cb284-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> ddv<span class="op">.</span>get<span class="op">());</span>  <span class="co">// ddvのBaseインスタンスはのデフォルトコンストラクタで初期化されている</span></span>
<span id="cb284-13"><a href="#cb284-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> ddn<span class="op">.</span>get<span class="op">());</span></span></code></pre></div>
<p>この動作は、下記の仕様に起因している
(引数なしで呼び出せる基底クラスのコンストラクタがない場合はコンパイルエラー)。</p>
<p><strong>「仮想継承クラスを継承したクラスが、仮想継承クラスの基底クラスのコンストラクタを明示的に呼び出さない場合、
引数なしで呼び出せる基底クラスのコンストラクタが呼ばれる」</strong></p>
<p>以下では、これを「仮想継承のコンストラクタ呼び出し」仕様と呼ぶことにする。</p>
<p>仮想継承クラスが、基底クラスのコンストラクタを呼び出したとしても、この仕様が優先されるため、
上記コードのような動作となる。</p>
<p>これを通常の継承クラスと同様な動作にするには、下記のようにしなければならない。</p>
<div class="sourceCode" id="cb285"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/virtual_inheritance_ut.cpp 62</span></span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-3"><a href="#cb285-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> DerivedDerivedVirtualFixed <span class="op">:</span> <span class="kw">public</span> DerivedVirtual <span class="op">{</span>  <span class="co">// DerivedDerivedNormalと同じように動作</span></span>
<span id="cb285-4"><a href="#cb285-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb285-5"><a href="#cb285-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> DerivedDerivedVirtualFixed<span class="op">(</span><span class="dt">int32_t</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> Base<span class="op">{</span>x<span class="op">},</span> DerivedVirtual<span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb285-6"><a href="#cb285-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">//                     基底クラスのコンストラクタ呼び出し ^^^^^^^</span></span>
<span id="cb285-7"><a href="#cb285-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb286"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/virtual_inheritance_ut.cpp 73</span></span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a>    DerivedDerivedVirtual      ddv<span class="op">{</span><span class="dv">1</span><span class="op">};</span>   <span class="co">// 仮想継承クラスを継承したクラス</span></span>
<span id="cb286-4"><a href="#cb286-4" aria-hidden="true" tabindex="-1"></a>    DerivedDerivedVirtualFixed ddvf<span class="op">{</span><span class="dv">1</span><span class="op">};</span>  <span class="co">// 上記クラスのコンストラクタを修正したクラス</span></span>
<span id="cb286-5"><a href="#cb286-5" aria-hidden="true" tabindex="-1"></a>    DerivedDerivedNormal       ddn<span class="op">{</span><span class="dv">1</span><span class="op">};</span>   <span class="co">// 通常の継承クラスを継承したクラス</span></span>
<span id="cb286-6"><a href="#cb286-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-7"><a href="#cb286-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> ddv<span class="op">.</span>get<span class="op">());</span>  <span class="co">// 仮想継承独特の動作</span></span>
<span id="cb286-8"><a href="#cb286-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> ddvf<span class="op">.</span>get<span class="op">());</span></span>
<span id="cb286-9"><a href="#cb286-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> ddn<span class="op">.</span>get<span class="op">());</span></span></code></pre></div>
<p>「仮想継承のコンストラクタ呼び出し」仕様は、 <a
href="core_lang_spec.html#SS_19_12_10">ダイヤモンド継承</a>での基底クラスのコンストラクタ呼び出しを一度にするために存在する。</p>
<p>もし、この機能がなければ、下記のコードでの基底クラスのコンストラクタ呼び出しは2度になるため、
デバッグ困難なバグが発生してしまうことは容易に想像できるだろう。</p>
<div class="sourceCode" id="cb287"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/virtual_inheritance_ut.cpp 88</span></span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-3"><a href="#cb287-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> base_called<span class="op">;</span></span>
<span id="cb287-4"><a href="#cb287-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-5"><a href="#cb287-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Base <span class="op">{</span></span>
<span id="cb287-6"><a href="#cb287-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb287-7"><a href="#cb287-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> Base<span class="op">(</span><span class="dt">int32_t</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">x_</span><span class="op">{</span>x<span class="op">}</span> <span class="op">{</span> <span class="op">++</span>base_called<span class="op">;</span> <span class="op">}</span></span>
<span id="cb287-8"><a href="#cb287-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">x_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb287-9"><a href="#cb287-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-10"><a href="#cb287-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb287-11"><a href="#cb287-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> <span class="va">x_</span><span class="op">;</span></span>
<span id="cb287-12"><a href="#cb287-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb287-13"><a href="#cb287-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-14"><a href="#cb287-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Derived_0 <span class="op">:</span> <span class="kw">public</span> <span class="kw">virtual</span> Base <span class="op">{</span>  <span class="co">// 仮想継承</span></span>
<span id="cb287-15"><a href="#cb287-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb287-16"><a href="#cb287-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> Derived_0<span class="op">(</span><span class="dt">int32_t</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> Base<span class="op">{</span>x<span class="op">}</span> <span class="op">{</span> <span class="ot">assert</span><span class="op">(</span>base_called <span class="op">==</span> <span class="dv">1</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb287-17"><a href="#cb287-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb287-18"><a href="#cb287-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-19"><a href="#cb287-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Derived_1 <span class="op">:</span> <span class="kw">public</span> <span class="kw">virtual</span> Base <span class="op">{</span>  <span class="co">// 仮想継承</span></span>
<span id="cb287-20"><a href="#cb287-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb287-21"><a href="#cb287-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> Derived_1<span class="op">(</span><span class="dt">int32_t</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> Base<span class="op">{</span>x<span class="op">}</span> <span class="op">{</span> <span class="ot">assert</span><span class="op">(</span>base_called <span class="op">==</span> <span class="dv">1</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb287-22"><a href="#cb287-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb287-23"><a href="#cb287-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-24"><a href="#cb287-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> DerivedDerived <span class="op">:</span> <span class="kw">public</span> Derived_0<span class="op">,</span> <span class="kw">public</span> Derived_1 <span class="op">{</span></span>
<span id="cb287-25"><a href="#cb287-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb287-26"><a href="#cb287-26" aria-hidden="true" tabindex="-1"></a>        DerivedDerived<span class="op">(</span><span class="dt">int32_t</span> x0<span class="op">,</span> <span class="dt">int32_t</span> x1<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> Derived_0<span class="op">{</span>x0<span class="op">},</span> Derived_1<span class="op">{</span>x1<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb287-27"><a href="#cb287-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 「仮想継承のコンストラクタ呼び出し」仕様がなければ、このコンストラクタは、</span></span>
<span id="cb287-28"><a href="#cb287-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">//    Base::Base -&gt; Derived_0::Derived_0 -&gt;</span></span>
<span id="cb287-29"><a href="#cb287-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      Base::Base -&gt; Derived_0::Derived_0 -&gt;</span></span>
<span id="cb287-30"><a href="#cb287-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">//        DerivedDerived::DerivedDerived</span></span>
<span id="cb287-31"><a href="#cb287-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  という呼び出しになるため、Base::Baseが2度呼び出されてしまう。</span></span>
<span id="cb287-32"><a href="#cb287-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb288"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/virtual_inheritance_ut.cpp 124</span></span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> base_called<span class="op">);</span></span>
<span id="cb288-4"><a href="#cb288-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-5"><a href="#cb288-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> dd <span class="op">=</span> DerivedDerived<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span>  <span class="co">// Base::Baseが最初に呼ばれないとassertion failする</span></span>
<span id="cb288-6"><a href="#cb288-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-7"><a href="#cb288-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> base_called<span class="op">);</span>  <span class="co">// 「仮想継承のコンストラクタ呼び出し」仕様のため</span></span>
<span id="cb288-8"><a href="#cb288-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> dd<span class="op">.</span>get<span class="op">());</span>     <span class="co">// Baseのデフォルトコンストラクタは、x_を0にする</span></span></code></pre></div>
<p>基底クラスのコンストラクタ呼び出しは、下記のコードのようにした場合でも、
単体テストが示すように、一番最初に行われる。</p>
<div class="sourceCode" id="cb289"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/virtual_inheritance_ut.cpp 139</span></span>
<span id="cb289-2"><a href="#cb289-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-3"><a href="#cb289-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> DerivedDerived <span class="op">:</span> <span class="kw">public</span> Derived_0<span class="op">,</span> <span class="kw">public</span> Derived_1 <span class="op">{</span></span>
<span id="cb289-4"><a href="#cb289-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb289-5"><a href="#cb289-5" aria-hidden="true" tabindex="-1"></a>        DerivedDerived<span class="op">(</span><span class="dt">int32_t</span> x0<span class="op">,</span> <span class="dt">int32_t</span> x1<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> Derived_0<span class="op">{</span>x0<span class="op">},</span> Derived_1<span class="op">{</span>x1<span class="op">},</span> Base<span class="op">{</span><span class="dv">1</span><span class="op">}</span> <span class="op">{}</span></span>
<span id="cb289-6"><a href="#cb289-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb290"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/virtual_inheritance_ut.cpp 151</span></span>
<span id="cb290-2"><a href="#cb290-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-3"><a href="#cb290-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">0</span><span class="op">,</span> base_called<span class="op">);</span></span>
<span id="cb290-4"><a href="#cb290-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-5"><a href="#cb290-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> dd <span class="op">=</span> DerivedDerived<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span>  <span class="co">// Base::Baseが最初に呼ばれないとassertion failする</span></span>
<span id="cb290-6"><a href="#cb290-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-7"><a href="#cb290-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> base_called<span class="op">);</span>  <span class="co">// 「仮想継承のコンストラクタ呼び出し」仕様のため</span></span>
<span id="cb290-8"><a href="#cb290-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> dd<span class="op">.</span>get<span class="op">());</span>     <span class="co">// Base{1}呼び出しの効果</span></span></code></pre></div>
<p>このため、基底クラスのコンストラクタ呼び出しは下記のような順番で行うべきである。</p>
<div class="sourceCode" id="cb291"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/virtual_inheritance_ut.cpp 164</span></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-3"><a href="#cb291-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> DerivedDerived <span class="op">:</span> <span class="kw">public</span> Derived_0<span class="op">,</span> <span class="kw">public</span> Derived_1 <span class="op">{</span></span>
<span id="cb291-4"><a href="#cb291-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb291-5"><a href="#cb291-5" aria-hidden="true" tabindex="-1"></a>        DerivedDerived<span class="op">(</span><span class="dt">int32_t</span> x0<span class="op">,</span> <span class="dt">int32_t</span> x1<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> Base<span class="op">{</span><span class="dv">1</span><span class="op">},</span> Derived_0<span class="op">{</span>x0<span class="op">},</span> Derived_1<span class="op">{</span>x1<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb291-6"><a href="#cb291-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<h3 id="仮想基底">仮想基底 <a id="SS_19_12_12"></a></h3>
<p>仮想基底(クラス)とは、<a
href="core_lang_spec.html#SS_19_12_11">仮想継承</a>の基底クラス指す。</p>
<h3 id="ドミナンス">ドミナンス <a id="SS_19_12_13"></a></h3>
<p><a
href="https://en.wikipedia.org/wiki/Dominance_(C%2B%2B)">ドミナンス(Dominance、支配性)</a>とは、
「探索対称の名前が継承の中にも存在するような場合の<a
href="core_lang_spec.html#SS_19_12_2">name lookup</a>の仕様の一部」
を指す慣用句である。</p>
<p>以下に</p>
<ul>
<li><a
href="core_lang_spec.html#SS_19_12_13_1">ダイヤモンド継承を含まない場合</a></li>
<li><a
href="core_lang_spec.html#SS_19_12_13_2">ダイヤモンド継承かつそれが仮想継承でない場合</a></li>
<li><a
href="core_lang_spec.html#SS_19_12_13_3">ダイヤモンド継承かつそれが仮想継承である場合</a></li>
</ul>
<p>のドミナンスについてのコードを例示する。</p>
<p>この例で示したように、<a
href="core_lang_spec.html#SS_19_12_10">ダイヤモンド継承</a>を通常の継承で行うか、
<a
href="core_lang_spec.html#SS_19_12_11">仮想継承</a>で行うかでは結果が全く異なるため、注意が必要である。</p>
<h4 id="ダイヤモンド継承を含まない場合">ダイヤモンド継承を含まない場合
<a id="SS_19_12_13_1"></a></h4>
<div class="sourceCode" id="cb292"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/dominance_ut.cpp 9</span></span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> f<span class="op">(</span><span class="dt">double</span><span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-5"><a href="#cb292-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Base <span class="op">{</span></span>
<span id="cb292-6"><a href="#cb292-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> f<span class="op">(</span><span class="dt">int32_t</span><span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb292-7"><a href="#cb292-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> f<span class="op">(</span><span class="dt">double</span><span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb292-8"><a href="#cb292-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb292-9"><a href="#cb292-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-10"><a href="#cb292-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Derived <span class="op">:</span> Base <span class="op">{</span></span>
<span id="cb292-11"><a href="#cb292-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> f<span class="op">(</span><span class="dt">int32_t</span><span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// Base::fを隠蔽する(name-hiding)</span></span>
<span id="cb292-12"><a href="#cb292-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb292-13"><a href="#cb292-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-14"><a href="#cb292-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> DerivedDerived <span class="op">:</span> Derived <span class="op">{</span></span>
<span id="cb292-15"><a href="#cb292-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> g<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> f<span class="op">(</span><span class="fl">2.14</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb292-16"><a href="#cb292-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb293"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/dominance_ut.cpp 29</span></span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-3"><a href="#cb293-3" aria-hidden="true" tabindex="-1"></a>    Base b<span class="op">;</span></span>
<span id="cb293-4"><a href="#cb293-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-5"><a href="#cb293-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> b<span class="op">.</span>f<span class="op">(</span><span class="fl">2.14</span><span class="op">));</span>  <span class="co">// オーバーロード解決により、B::f(double)が呼ばれる</span></span>
<span id="cb293-6"><a href="#cb293-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-7"><a href="#cb293-7" aria-hidden="true" tabindex="-1"></a>    DerivedDerived dd<span class="op">;</span></span>
<span id="cb293-8"><a href="#cb293-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-9"><a href="#cb293-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Derivedのドミナンスにより、B::fは、DerivedDerived::gでのfのname lookupの対象にならず、</span></span>
<span id="cb293-10"><a href="#cb293-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// DerivedDerived::gはDerived::fを呼び出す。</span></span>
<span id="cb293-11"><a href="#cb293-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> dd<span class="op">.</span>g<span class="op">());</span></span></code></pre></div>
<p>この<a href="core_lang_spec.html#SS_19_12_2">name
lookup</a>については、<a
href="core_lang_spec.html#SS_19_12_9">name-hiding</a>で説明した通りである。</p>
<h4
id="ダイヤモンド継承かつそれが仮想継承でない場合">ダイヤモンド継承かつそれが仮想継承でない場合
<a id="SS_19_12_13_2"></a></h4>
<div class="sourceCode" id="cb294"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/dominance_ut.cpp 45</span></span>
<span id="cb294-2"><a href="#cb294-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb294-3"><a href="#cb294-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Base <span class="op">{</span></span>
<span id="cb294-4"><a href="#cb294-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> f<span class="op">(</span><span class="dt">int32_t</span><span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb294-5"><a href="#cb294-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> f<span class="op">(</span><span class="dt">double</span><span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb294-6"><a href="#cb294-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb294-7"><a href="#cb294-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb294-8"><a href="#cb294-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Derived_0 <span class="op">:</span> Base <span class="op">{</span></span>
<span id="cb294-9"><a href="#cb294-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> f<span class="op">(</span><span class="dt">int32_t</span><span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// Base::fを隠蔽する(name-hiding)</span></span>
<span id="cb294-10"><a href="#cb294-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb294-11"><a href="#cb294-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb294-12"><a href="#cb294-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Derived_1 <span class="op">:</span> Base <span class="op">{};</span></span>
<span id="cb294-13"><a href="#cb294-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb294-14"><a href="#cb294-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> DerivedDerived <span class="op">:</span> Derived_0<span class="op">,</span> Derived_1 <span class="op">{</span></span>
<span id="cb294-15"><a href="#cb294-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> g<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> f<span class="op">(</span><span class="fl">2.14</span><span class="op">);</span> <span class="op">}</span>  <span class="co">// Derived_0::f or Derived_1::f ?</span></span>
<span id="cb294-16"><a href="#cb294-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb294-17"><a href="#cb294-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb294-18"><a href="#cb294-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// dominance_ut.cpp:58:41: error: reference to ‘f’ is ambiguous</span></span>
<span id="cb294-19"><a href="#cb294-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">//    58 |     int32_t g() const noexcept { return f(2.14); }  // Derived_0::f or Derived_1::f ?</span></span>
<span id="cb294-20"><a href="#cb294-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">//       |                                         ^</span></span></code></pre></div>
<p>上記コードはコードブロック内のコメントのようなメッセージが原因でコンパイルできない。</p>
<p>Derived_0のドミナンスにより、DerivedDerived::gはDerived_0::fを呼び出すように見えるが、
もう一つの継承元であるDerived_1が導入したDerived_1::f(実際には、Derived_1::Base::f)があるため、
Derived_1によるドミナンスも働き、その結果として、呼び出しが曖昧(ambiguous)になることで、
このような結果となる。</p>
<h4
id="ダイヤモンド継承かつそれが仮想継承である場合">ダイヤモンド継承かつそれが仮想継承である場合
<a id="SS_19_12_13_3"></a></h4>
<div class="sourceCode" id="cb295"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/dominance_ut.cpp 71</span></span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Base <span class="op">{</span></span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> f<span class="op">(</span><span class="dt">int32_t</span><span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb295-5"><a href="#cb295-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> f<span class="op">(</span><span class="dt">double</span><span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb295-6"><a href="#cb295-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb295-7"><a href="#cb295-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-8"><a href="#cb295-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Derived_0 <span class="op">:</span> <span class="kw">virtual</span> Base <span class="op">{</span></span>
<span id="cb295-9"><a href="#cb295-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> f<span class="op">(</span><span class="dt">int32_t</span><span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// Base::fを隠蔽する(name-hiding)</span></span>
<span id="cb295-10"><a href="#cb295-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb295-11"><a href="#cb295-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-12"><a href="#cb295-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Derived_1 <span class="op">:</span> <span class="kw">virtual</span> Base <span class="op">{};</span></span>
<span id="cb295-13"><a href="#cb295-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-14"><a href="#cb295-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> DerivedDerived <span class="op">:</span> Derived_0<span class="op">,</span> Derived_1 <span class="op">{</span></span>
<span id="cb295-15"><a href="#cb295-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> g<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> f<span class="op">(</span><span class="fl">2.14</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb295-16"><a href="#cb295-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb296"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/dominance_ut.cpp 92</span></span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-3"><a href="#cb296-3" aria-hidden="true" tabindex="-1"></a>    DerivedDerived dd<span class="op">;</span></span>
<span id="cb296-4"><a href="#cb296-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-5"><a href="#cb296-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Derived_0のドミナンスと仮想継承の効果により、</span></span>
<span id="cb296-6"><a href="#cb296-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// B::fは、DerivedDerived::gでのfのname lookupの対象にならず、</span></span>
<span id="cb296-7"><a href="#cb296-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// DerivedDerived::gはDerived_0::fを呼び出す。</span></span>
<span id="cb296-8"><a href="#cb296-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> dd<span class="op">.</span>g<span class="op">());</span></span></code></pre></div>
<p>これまでと同様にDerived_0のドミナンスによりBase::fは<a
href="core_lang_spec.html#SS_19_12_9">name-hiding</a>されることになる。
この時、Derived_0、Derived_1がBaseから<a
href="core_lang_spec.html#SS_19_12_11">仮想継承</a>した効果により、
この継承ヒエラルキーの中でBaseは１つのみ存在することになるため、
Derived_1により導入されたBase::fも併せて<a
href="core_lang_spec.html#SS_19_12_9">name-hiding</a>される。
結果として、曖昧性は排除され、コンパイルエラーにはならず、このような結果となる。</p>
<h3 id="using宣言">using宣言 <a id="SS_19_12_14"></a></h3>
<p>using宣言とは、“using XXX::func”のような記述である。
この記述が行われたスコープでは、この記述後の行から名前空間XXXでの修飾をすることなく、
funcが使用できる。</p>
<div class="sourceCode" id="cb297"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/namespace_ut.cpp 6</span></span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> XXX <span class="op">{</span></span>
<span id="cb297-3"><a href="#cb297-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> func<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{}</span></span>
<span id="cb297-4"><a href="#cb297-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> gunc<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{}</span></span>
<span id="cb297-5"><a href="#cb297-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace XXX</span></span></code></pre></div>
<div class="sourceCode" id="cb298"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/namespace_ut.cpp 12</span></span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-3"><a href="#cb298-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// global namespace</span></span>
<span id="cb298-4"><a href="#cb298-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> using_declaration<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb298-5"><a href="#cb298-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb298-6"><a href="#cb298-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> XXX<span class="op">::</span>func<span class="op">;</span>  <span class="co">// using宣言</span></span>
<span id="cb298-7"><a href="#cb298-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-8"><a href="#cb298-8" aria-hidden="true" tabindex="-1"></a>        func<span class="op">();</span>       <span class="co">// XXX::不要</span></span>
<span id="cb298-9"><a href="#cb298-9" aria-hidden="true" tabindex="-1"></a>        XXX<span class="op">::</span>gunc<span class="op">();</span>  <span class="co">// XXX::必要</span></span>
<span id="cb298-10"><a href="#cb298-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="usingディレクティブ">usingディレクティブ
<a id="SS_19_12_15"></a></h3>
<p>usingディレクティブとは、“using namespace XXX”のような記述である。
この記述が行われたスコープでは、下記例のように、この記述後から名前空間XXXでの修飾をすることなく、
XXXの識別子が使用できる。</p>
<div class="sourceCode" id="cb299"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/namespace_ut.cpp 6</span></span>
<span id="cb299-2"><a href="#cb299-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> XXX <span class="op">{</span></span>
<span id="cb299-3"><a href="#cb299-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> func<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{}</span></span>
<span id="cb299-4"><a href="#cb299-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> gunc<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{}</span></span>
<span id="cb299-5"><a href="#cb299-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace XXX</span></span></code></pre></div>
<div class="sourceCode" id="cb300"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/namespace_ut.cpp 24</span></span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-3"><a href="#cb300-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// global namespace</span></span>
<span id="cb300-4"><a href="#cb300-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> using_directive<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb300-5"><a href="#cb300-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb300-6"><a href="#cb300-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="kw">namespace</span> XXX<span class="op">;</span>  <span class="co">// usingディレクティブ</span></span>
<span id="cb300-7"><a href="#cb300-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-8"><a href="#cb300-8" aria-hidden="true" tabindex="-1"></a>        func<span class="op">();</span>  <span class="co">// XXX::不要</span></span>
<span id="cb300-9"><a href="#cb300-9" aria-hidden="true" tabindex="-1"></a>        gunc<span class="op">();</span>  <span class="co">// XXX::不要</span></span>
<span id="cb300-10"><a href="#cb300-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>より多くの識別子が名前空間の修飾無しで使えるようになる点において、 <a
href="core_lang_spec.html#SS_19_12_14">using宣言</a>よりも危険であり、また、
下記のように<a
href="core_lang_spec.html#SS_19_12_9">name-hiding</a>された識別子の導入には効果がない。</p>
<div class="sourceCode" id="cb301"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/namespace_ut.cpp 6</span></span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> XXX <span class="op">{</span></span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> func<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{}</span></span>
<span id="cb301-4"><a href="#cb301-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> gunc<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{}</span></span>
<span id="cb301-5"><a href="#cb301-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace XXX</span></span></code></pre></div>
<div class="sourceCode" id="cb302"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/namespace_ut.cpp 35</span></span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-3"><a href="#cb302-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> XXX_Inner <span class="op">{</span></span>
<span id="cb302-4"><a href="#cb302-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> func<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{}</span></span>
<span id="cb302-5"><a href="#cb302-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> using_declaration<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb302-6"><a href="#cb302-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb302-7"><a href="#cb302-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if 0</span></span>
<span id="cb302-8"><a href="#cb302-8" aria-hidden="true" tabindex="-1"></a><span class="co">        using namespace XXX;  // name-hidingのため効果がない</span></span>
<span id="cb302-9"><a href="#cb302-9" aria-hidden="true" tabindex="-1"></a><span class="co">    </span><span class="pp">#else</span></span>
<span id="cb302-10"><a href="#cb302-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> XXX<span class="op">::</span>func<span class="op">;</span>  <span class="co">// using宣言</span></span>
<span id="cb302-11"><a href="#cb302-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb302-12"><a href="#cb302-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-13"><a href="#cb302-13" aria-hidden="true" tabindex="-1"></a>        func<span class="op">();</span>  <span class="co">// XXX::不要</span></span>
<span id="cb302-14"><a href="#cb302-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>従って、usingディレクティブの使用は避けるべきである。</p>
<h2 id="エクセプション安全性の保証">エクセプション安全性の保証
<a id="SS_19_13"></a></h2>
<p>関数のエクセプション発生時の安全性の保証には以下の3つのレベルが規定されている。</p>
<ul>
<li><a href="core_lang_spec.html#SS_19_13_1">no-fail保証</a></li>
<li><a href="core_lang_spec.html#SS_19_13_2">強い安全性の保証</a></li>
<li><a href="core_lang_spec.html#SS_19_13_3">基本的な安全性の保証</a></li>
</ul>
<h3 id="no-fail保証">no-fail保証 <a id="SS_19_13_1"></a></h3>
<p>「no-fail保証」を満たす関数はエクセプションをthrowしない。
no-failを保証する関数は、 <a
href="core_lang_spec.html#SS_19_13_4">noexcept</a>を使用してエクセプションを発生させないことを明示できる。</p>
<p>標準テンプレートクラスのパラメータとして使用するクラスのメンバ関数には、
正確にnoexceptの宣言をしないと、
テンプレートクラスのメンバ関数によってはパフォーマンスを起こしてしまう可能性がある。</p>
<h3 id="強い安全性の保証">強い安全性の保証 <a id="SS_19_13_2"></a></h3>
<p>「強い保証」を満たす関数は、この関数がエクセプションによりスコープから外れた場合でも、
この関数が呼ばれなかった状態と同じ(プログラムカウンタ以外の状態は同じ)であることを保証する。
従って、この関数呼び出しは成功したか、完全な無効だったかのどちらかになる。</p>
<h3 id="基本的な安全性の保証">基本的な安全性の保証
<a id="SS_19_13_3"></a></h3>
<p>「基本的な安全性の保証」を満たす関数は、この関数がエクセプションによりスコープから外れた場合でも、
メモリ等のリソースリークは起こさず、
オブジェクトは(変更されたかもしれないが)引き続き使えることを保証する。</p>
<h3 id="noexcept">noexcept <a id="SS_19_13_4"></a></h3>
<p>C++11で導入されたnoexceptキーワードには、以下の2つの意味がある。</p>
<ul>
<li><p>C++03までのthrowキーワードによるエクセプション仕様の代替。
関数がどのエクセプションを送出する可能性があるかを列挙するのではなく、
エクセプションを送出する可能性があるかないかのみを指定する。</p></li>
<li><p>sizeofと同じような形式で使用されるのような演算子としてのnoexceptは、
noexcept(expression)の形式使用され、
expressionがエクセプションを送出しないと宣言されている場合(noexceptと宣言された関数の呼び出し)、
noexcept(expression)は静的にtrueとなる。</p></li>
</ul>
<p>以下に上記のコード例を示す。</p>
<div class="sourceCode" id="cb303"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/noexcept_ut.cpp 11</span></span>
<span id="cb303-2"><a href="#cb303-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-3"><a href="#cb303-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string f_noexcept<span class="op">()</span> <span class="kw">noexcept</span>  <span class="co">// エクセプションを発生させない</span></span>
<span id="cb303-4"><a href="#cb303-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb303-5"><a href="#cb303-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;No exceptions here!&quot;</span><span class="op">;</span></span>
<span id="cb303-6"><a href="#cb303-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb303-7"><a href="#cb303-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-8"><a href="#cb303-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string f_except<span class="op">()</span> <span class="kw">noexcept</span><span class="op">(</span><span class="kw">false</span><span class="op">)</span>  <span class="co">// エクセプションを発生させる</span></span>
<span id="cb303-9"><a href="#cb303-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb303-10"><a href="#cb303-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;always throw&quot;</span><span class="op">};</span></span>
<span id="cb303-11"><a href="#cb303-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-12"><a href="#cb303-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;No exceptions here!&quot;</span><span class="op">;</span></span>
<span id="cb303-13"><a href="#cb303-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb303-14"><a href="#cb303-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-15"><a href="#cb303-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// noexcept or noexcept(false)と宣言しない限りnoexceptでない</span></span>
<span id="cb303-16"><a href="#cb303-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string f_except2<span class="op">()</span>  <span class="co">// エクセプションを発生させる</span></span>
<span id="cb303-17"><a href="#cb303-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb303-18"><a href="#cb303-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>runtime_error<span class="op">{</span><span class="st">&quot;always throw&quot;</span><span class="op">};</span></span>
<span id="cb303-19"><a href="#cb303-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-20"><a href="#cb303-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;No exceptions here!&quot;</span><span class="op">;</span></span>
<span id="cb303-21"><a href="#cb303-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb304"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/noexcept_ut.cpp 37</span></span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-3"><a href="#cb304-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">noexcept</span><span class="op">(</span>f_noexcept<span class="op">()));</span>  <span class="co">// エクセプションを発生させる可能性の確認</span></span>
<span id="cb304-4"><a href="#cb304-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="kw">noexcept</span><span class="op">(</span>f_except<span class="op">()));</span>   <span class="co">// エクセプションを発生させない可能性の確認</span></span>
<span id="cb304-5"><a href="#cb304-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="kw">noexcept</span><span class="op">(</span>f_except2<span class="op">()));</span>  <span class="co">// エクセプションを発生させない可能性の確認</span></span>
<span id="cb304-6"><a href="#cb304-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-7"><a href="#cb304-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>f_noexcept<span class="op">(),</span> <span class="st">&quot;No exceptions here!&quot;</span><span class="op">);</span>  <span class="co">// 動作確認</span></span>
<span id="cb304-8"><a href="#cb304-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>f_except<span class="op">(),</span> <span class="bu">std::</span>runtime_error<span class="op">);</span>    <span class="co">// エクセプションの発生確認</span></span>
<span id="cb304-9"><a href="#cb304-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>f_except2<span class="op">(),</span> <span class="bu">std::</span>runtime_error<span class="op">);</span>   <span class="co">// エクセプションの発生確認</span></span></code></pre></div>
<p>演算子としてのnoexceptはテンプレートで頻繁に使用されるため、以下にそのような例を示す。</p>
<div class="sourceCode" id="cb305"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/noexcept_ut.cpp 50</span></span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> PossiblyThrow <span class="op">{</span>  <span class="co">// オブジェクト生成でエクセプションの発生可能性あり</span></span>
<span id="cb305-4"><a href="#cb305-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb305-5"><a href="#cb305-5" aria-hidden="true" tabindex="-1"></a>        PossiblyThrow<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb305-6"><a href="#cb305-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb305-7"><a href="#cb305-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb305-8"><a href="#cb305-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// テンプレート型Tがnoexceptで生成可能なら、関数もnoexceptにする</span></span>
<span id="cb305-9"><a href="#cb305-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb305-10"><a href="#cb305-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> t_f<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;)</span> <span class="kw">noexcept</span><span class="op">(</span><span class="bu">std::</span>is_nothrow_constructible_v<span class="op">&lt;</span>T<span class="op">&gt;)</span></span>
<span id="cb305-11"><a href="#cb305-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb305-12"><a href="#cb305-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Tを生成して、何らかの処理を行う</span></span>
<span id="cb305-13"><a href="#cb305-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb306"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/noexcept_ut.cpp 67</span></span>
<span id="cb306-2"><a href="#cb306-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb306-3"><a href="#cb306-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> i <span class="op">=</span> <span class="dt">int</span><span class="op">{};</span></span>
<span id="cb306-4"><a href="#cb306-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p <span class="op">=</span> PossiblyThrow<span class="op">{};</span></span>
<span id="cb306-5"><a href="#cb306-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb306-6"><a href="#cb306-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_nothrow_constructible_v<span class="op">&lt;</span>PossiblyThrow<span class="op">&gt;);</span></span>
<span id="cb306-7"><a href="#cb306-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_nothrow_constructible_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>i<span class="op">)&gt;);</span></span>
<span id="cb306-8"><a href="#cb306-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">noexcept</span><span class="op">(</span>t_f<span class="op">(</span>i<span class="op">)));</span></span>
<span id="cb306-9"><a href="#cb306-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="kw">noexcept</span><span class="op">(</span>t_f<span class="op">(</span>p<span class="op">)));</span></span></code></pre></div>
<h3 id="exception-unfriendly">exception-unfriendly
<a id="SS_19_13_5"></a></h3>
<p>以下のような関数</p>
<ul>
<li>初期化に関連する関数やコンストラクタ
<ul>
<li>静的または thread_local な変数を初期化する関数やコンストラクタ</li>
</ul></li>
<li>特殊メンバ関数
<ul>
<li>すべてのデストラクタ</li>
<li>すべてのエクセプションオブジェクトのコピーコンストラクタ</li>
<li>すべてのムーブコンストラクタ</li>
<li>すべてのムーブ代入演算子</li>
</ul></li>
<li>特定の名前を持つ関数
<ul>
<li>“swap” という名前のすべての関数</li>
</ul></li>
<li>C言語との互換性を持つ関数
<ul>
<li>Cとのリンケージを持つすべての関数</li>
</ul></li>
</ul>
<p>の呼び出しでエクセプションがthrowされると、<a
href="core_lang_spec.html#SS_19_14_3">未定義動作</a>や<a
href="core_lang_spec.html#SS_19_14_4">未規定動作</a>が発生するため、
exception-unfriendly(エクセプションに不向き)であるとされる。
従って上記の関数は暗黙的または明示的に<code>noexcept</code>であることが求められる。</p>
<h2 id="言語仕様の定義要素">言語仕様の定義要素
<a id="SS_19_14"></a></h2>
<h3 id="ill-formed">ill-formed <a id="SS_19_14_1"></a></h3>
<p><a
href="https://cpprefjp.github.io/implementation-compliance.html">標準規格と処理系</a>に詳しい解説があるが、</p>
<ul>
<li><a
href="core_lang_spec.html#SS_19_14_2">well-formed</a>(適格)とはプログラムが全ての構文規則・診断対象の意味規則・
単一定義規則を満たすことである。</li>
<li>ill-formed(不適格)とはプログラムが適格でないことである。</li>
</ul>
<p>プログラムがwell-formedになった場合、そのプログラムはコンパイルできる。
プログラムがill-formedになった場合、通常はコンパイルエラーになるが、
対象がテンプレートの場合、事情は少々異なり、<a
href="core_lang_spec.html#SS_19_11_1">SFINAE</a>によりコンパイルできることもある。</p>
<h3 id="well-formed">well-formed <a id="SS_19_14_2"></a></h3>
<p>「<a
href="core_lang_spec.html#SS_19_14_1">ill-formed</a>」を参照せよ。</p>
<h3 id="未定義動作">未定義動作 <a id="SS_19_14_3"></a></h3>
<p>未定義動作(Undefined Behavior)とは、
C++標準が特定の操作や状況に対して一切の制約を設けないケースである。
未定義動作が発生すると、プログラムの実行結果が予測できなくなり、
何が起こるかはコンパイラや環境によって異なる。
未定義動作を含むコードは、クラッシュやセキュリティの問題を引き起こす可能性がある。</p>
<div class="sourceCode" id="cb307"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/undefined_ut.cpp 14</span></span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-3"><a href="#cb307-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb307-4"><a href="#cb307-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb307-5"><a href="#cb307-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c <span class="op">=</span> a <span class="op">/</span> b<span class="op">;</span>  <span class="co">// 未定義動作 - ゼロ除算</span></span>
<span id="cb307-6"><a href="#cb307-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-7"><a href="#cb307-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[]{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb307-8"><a href="#cb307-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> arr<span class="op">[</span>index<span class="op">];</span>  <span class="co">// 未定義動作 - index&gt;2の場合、配列範囲外アクセス</span></span></code></pre></div>
<h3 id="未規定動作">未規定動作 <a id="SS_19_14_4"></a></h3>
<p>未規定動作(Unspecified
Behavior)とは、C++標準がある操作の動作を完全には決めておらず、
複数の許容可能な選択肢がある場合でのコードの動作を指す。
未規定動作は、実装ごとに異なる可能性があり、標準は少なくとも「何らかの合理的な結果」を保証する。
つまり、動作が特定の範囲で予測可能だが、正確な挙動が処理系の実装に依存することになる。</p>
<div class="sourceCode" id="cb308"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/undefined_ut.cpp 35</span></span>
<span id="cb308-2"><a href="#cb308-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb308-3"><a href="#cb308-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> MyEnum <span class="op">:</span> <span class="dt">int</span> <span class="op">{</span> Value1 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> Value2 <span class="op">=</span> <span class="dv">256</span> <span class="op">};</span></span>
<span id="cb308-4"><a href="#cb308-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int8_t</span><span class="op">&gt;(</span>MyEnum<span class="op">::</span>Value2<span class="op">);</span>  <span class="co">// 未規定 - 256はint8_tとして表現できない</span></span>
<span id="cb308-5"><a href="#cb308-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb308-6"><a href="#cb308-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a      <span class="op">=</span> <span class="dt">int</span><span class="op">{</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb308-7"><a href="#cb308-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> lambda <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span> a0<span class="op">,</span> <span class="kw">auto</span> a1<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a0 <span class="op">/</span> a1<span class="op">;</span> <span class="op">};</span></span>
<span id="cb308-8"><a href="#cb308-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> result <span class="op">=</span> lambda<span class="op">(</span>a<span class="op">++,</span> a<span class="op">++);</span>  <span class="co">// 未規定 - 引数評価の順序が決まっていない</span></span></code></pre></div>
<h3 id="未定義動作と未規定動作">未定義動作と未規定動作
<a id="SS_19_14_5"></a></h3>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 44%" />
<col style="width: 22%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th>種類</th>
<th>定義</th>
<th>例</th>
<th>結果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="core_lang_spec.html#SS_19_14_3">未定義動作</a></td>
<td>C++標準が全く保証しない動作</td>
<td>ゼロ除算、配列範囲外アクセス</td>
<td>予測不能(クラッシュなど)</td>
</tr>
<tr class="even">
<td><a href="core_lang_spec.html#SS_19_14_4">未規定動作</a></td>
<td>C++標準が動作を定めていないが、いくつかの選択肢が許容されている動作</td>
<td><code>int8_t</code> に収まらない値のキャスト</td>
<td>実装依存(異なるが合理的な動作)</td>
</tr>
</tbody>
</table>
<h3 id="被修飾型">被修飾型 <a id="SS_19_14_6"></a></h3>
<p>被修飾型(unqualified
type)とは、変数の宣言において付加される修飾子(const、 volatile
など)やポインタやリファレンスなどの間接指定子を除いた素の型を指す。</p>
<p>修飾子(const、volatile)に注視しい場合、cv-被修飾型(cv-unqualified
type)という場合もある。</p>
<p>例えば:</p>
<table>
<thead>
<tr class="header">
<th>定義</th>
<th style="text-align: center;">被修飾型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>const A&amp; a</td>
<td style="text-align: center;">A</td>
</tr>
<tr class="even">
<td>volatile B&amp; b</td>
<td style="text-align: center;">B</td>
</tr>
<tr class="odd">
<td>const T* C</td>
<td style="text-align: center;">C</td>
</tr>
<tr class="even">
<td>const D d</td>
<td style="text-align: center;">D</td>
</tr>
</tbody>
</table>
<p>見た目が類似する<a
href="core_lang_spec.html#SS_19_12_7">修飾付き関数呼び出し</a>とは無関係である。</p>
<h3 id="実引数仮引数">実引数/仮引数 <a id="SS_19_14_7"></a></h3>
<p>引数(もしくは実引数、argument)、仮引数(parameter)とは下記のように定義される。</p>
<div class="sourceCode" id="cb309"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/argument.cpp 2</span></span>
<span id="cb309-2"><a href="#cb309-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-3"><a href="#cb309-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> f0<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span><span class="op">&amp;</span> b<span class="op">)</span> <span class="kw">noexcept</span>  <span class="co">// a, bは仮引数</span></span>
<span id="cb309-4"><a href="#cb309-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb309-5"><a href="#cb309-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb309-6"><a href="#cb309-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb309-7"><a href="#cb309-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-8"><a href="#cb309-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f1<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb309-9"><a href="#cb309-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb309-10"><a href="#cb309-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb309-11"><a href="#cb309-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-12"><a href="#cb309-12" aria-hidden="true" tabindex="-1"></a>        f0<span class="op">(</span>x<span class="op">,</span> y<span class="op">);</span>  <span class="co">// x, yは実引数</span></span>
<span id="cb309-13"><a href="#cb309-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="単純代入">単純代入 <a id="SS_19_14_8"></a></h3>
<p>代入は下記のように分類される。</p>
<ul>
<li>単純代入(=)</li>
<li>複合代入(+=，++ 等)</li>
</ul>
<h3 id="one-definition-rule">one-definition rule
<a id="SS_19_14_9"></a></h3>
<p>「<a href="core_lang_spec.html#SS_19_14_10">ODR</a>」を参照せよ。</p>
<h3 id="odr">ODR <a id="SS_19_14_10"></a></h3>
<p>ODRとは、One Definition
Ruleの略語であり、下記のようなことを定めている。</p>
<ul>
<li>どの翻訳単位でも、テンプレート、型、関数、またはオブジェクトは、複数の定義を持つことができない。</li>
<li>プログラム全体で、オブジェクトまたは非インライン関数は複数の定義を持つことはできない。</li>
<li>型、テンプレート、外部インライン関数等、いくつかのものは複数の翻訳単位で定義することができる。</li>
</ul>
<p>より詳しい内容がが知りたい場合は、 <a
href="https://en.cppreference.com/w/cpp/language/definition">https://en.cppreference.com/w/cpp/language/definition</a>
が参考になる。</p>
<h3 id="型特性キーワード">型特性キーワード <a id="SS_19_14_11"></a></h3>
<p>アライメントとは、
データが効率的にアクセスされるために特定のメモリアドレス境界に配置される規則である。
C++03までの規約では、アライメントのコントロールは実装依存した#pragmaなどで行っていた。</p>
<p><a href="core_lang_spec.html#SS_19_14_11_2">alignas</a>、 <a
href="core_lang_spec.html#SS_19_14_11_1">alignof</a>によりコンパイラの標準的な方法でアライメントのコントロールできるようになった。</p>
<h4 id="alignof">alignof <a id="SS_19_14_11_1"></a></h4>
<p>C++11で導入されたキーワードで、型のアライメント要求を取得するために使用する。</p>
<div class="sourceCode" id="cb310"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/aliging_ut.cpp 12</span></span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-3"><a href="#cb310-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> <span class="kw">alignas</span><span class="op">(</span><span class="dv">16</span><span class="op">)</span> AlignedStruct <span class="op">{</span>  <span class="co">// メモリ上で16バイト境界にアライメントされる</span></span>
<span id="cb310-4"><a href="#cb310-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span>   a<span class="op">;</span></span>
<span id="cb310-5"><a href="#cb310-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> x<span class="op">;</span></span>
<span id="cb310-6"><a href="#cb310-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> y<span class="op">;</span></span>
<span id="cb310-7"><a href="#cb310-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb310-8"><a href="#cb310-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-9"><a href="#cb310-9" aria-hidden="true" tabindex="-1"></a>    AlignedStruct a<span class="op">;</span></span>
<span id="cb310-10"><a href="#cb310-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-11"><a href="#cb310-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uintptr_t</span> address <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="dt">uintptr_t</span><span class="op">&gt;(&amp;</span>a<span class="op">);</span>  <span class="co">// aのアドレスを取得</span></span>
<span id="cb310-12"><a href="#cb310-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-13"><a href="#cb310-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>address <span class="op">%</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span>             <span class="co">// アドレスが16の倍数であることを確認</span></span>
<span id="cb310-14"><a href="#cb310-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">alignof</span><span class="op">(</span>AlignedStruct<span class="op">),</span> <span class="dv">16</span><span class="op">);</span>  <span class="co">// アライメントが正しいか確認</span></span></code></pre></div>
<h4 id="alignas">alignas <a id="SS_19_14_11_2"></a></h4>
<p>C++11で導入されたキーワードで、メモリのアライメントを指定するために使用する。</p>
<div class="sourceCode" id="cb311"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/aliging_ut.cpp 27</span></span>
<span id="cb311-2"><a href="#cb311-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-3"><a href="#cb311-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">alignof</span><span class="op">(</span><span class="dt">long</span> <span class="dt">double</span><span class="op">),</span> <span class="dv">16</span><span class="op">);</span>  <span class="co">// アライメントが正しいか確認</span></span>
<span id="cb311-4"><a href="#cb311-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">alignof</span><span class="op">(</span><span class="dt">long</span> <span class="dt">long</span><span class="op">),</span> <span class="dv">8</span><span class="op">);</span>     <span class="co">// アライメントが正しいか確認</span></span>
<span id="cb311-5"><a href="#cb311-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">alignof</span><span class="op">(</span><span class="dt">void</span><span class="op">*),</span> <span class="dv">8</span><span class="op">);</span>         <span class="co">// アライメントが正しいか確認</span></span>
<span id="cb311-6"><a href="#cb311-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="kw">alignof</span><span class="op">(</span><span class="dt">int</span><span class="op">),</span> <span class="dv">4</span><span class="op">);</span>           <span class="co">// アライメントが正しいか確認</span></span></code></pre></div>
<h4 id="addressof">addressof <a id="SS_19_14_11_3"></a></h4>
<p>addressofは、オブジェクトの「実際の」
アドレスを取得するために使用されるC++標準ライブラリのユーティリティ関数である。
通常、オブジェクトのアドレスを取得するには&amp;演算子を使うが、
operator&amp; がオーバーロードされている場合には、
&amp;演算子ではオブジェクトのメモリ上の実際のアドレスを取得できない場合があり得る。
そのような場合にstd::addressofすることにより、
オーバーロードを無視して元のアドレスを確実に取得できる。</p>
<div class="sourceCode" id="cb312"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/aliging_ut.cpp 38</span></span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb312-3"><a href="#cb312-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> X <span class="op">{</span></span>
<span id="cb312-4"><a href="#cb312-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb312-5"><a href="#cb312-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> X<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">:</span> <span class="va">v_</span><span class="op">{</span>v<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb312-6"><a href="#cb312-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb312-7"><a href="#cb312-7" aria-hidden="true" tabindex="-1"></a>        X<span class="op">*</span> <span class="kw">operator</span><span class="op">&amp;()</span></span>
<span id="cb312-8"><a href="#cb312-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span>                    <span class="co">// `operator&amp;` をオーバーロードしてアドレス取得の挙動を変更</span></span>
<span id="cb312-9"><a href="#cb312-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span>  <span class="co">// 意図的に nullptr を返す</span></span>
<span id="cb312-10"><a href="#cb312-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb312-11"><a href="#cb312-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">operator</span> <span class="dt">int</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">v_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb312-12"><a href="#cb312-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb312-13"><a href="#cb312-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb312-14"><a href="#cb312-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="va">v_</span><span class="op">;</span></span>
<span id="cb312-15"><a href="#cb312-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb313"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/aliging_ut.cpp 54</span></span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-3"><a href="#cb313-3" aria-hidden="true" tabindex="-1"></a>    X obj<span class="op">{</span><span class="dv">42</span><span class="op">};</span></span>
<span id="cb313-4"><a href="#cb313-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-5"><a href="#cb313-5" aria-hidden="true" tabindex="-1"></a>    X<span class="op">*</span> p0 <span class="op">=</span> <span class="op">&amp;</span>obj<span class="op">;</span>  <span class="co">// &amp;演算子で取得するアドレス(オーバーロードされているためnullptr が返る)</span></span>
<span id="cb313-6"><a href="#cb313-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>p0<span class="op">,</span> <span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb313-7"><a href="#cb313-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-8"><a href="#cb313-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::addressofとほぼ同じ実装であるラムダ</span></span>
<span id="cb313-9"><a href="#cb313-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> addressof <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span><span class="op">&amp;</span> arg<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb313-10"><a href="#cb313-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="bu">std::</span>remove_reference_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>arg<span class="op">)&gt;*&gt;(</span></span>
<span id="cb313-11"><a href="#cb313-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;</span><span class="kw">const_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&amp;&gt;(</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="at">const</span> <span class="at">volatile</span> <span class="dt">char</span><span class="op">&amp;&gt;(</span>arg<span class="op">)));</span></span>
<span id="cb313-12"><a href="#cb313-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb313-13"><a href="#cb313-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-14"><a href="#cb313-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ラムダaddressofを使用して強引にobjのアドレスを取得</span></span>
<span id="cb313-15"><a href="#cb313-15" aria-hidden="true" tabindex="-1"></a>    X<span class="op">*</span> p1 <span class="op">=</span> addressof<span class="op">(</span>obj<span class="op">);</span></span>
<span id="cb313-16"><a href="#cb313-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_NE<span class="op">(</span>p1<span class="op">,</span> <span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb313-17"><a href="#cb313-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-18"><a href="#cb313-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> i_ptr <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;(</span>p1<span class="op">);</span>  <span class="co">// 処理系依存だが、通常の32/64bit環境なら通る</span></span>
<span id="cb313-19"><a href="#cb313-19" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">42</span><span class="op">,</span> <span class="op">*</span>i_ptr<span class="op">);</span></span>
<span id="cb313-20"><a href="#cb313-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-21"><a href="#cb313-21" aria-hidden="true" tabindex="-1"></a>    X<span class="op">*</span> p2 <span class="op">=</span> <span class="bu">std::</span>addressof<span class="op">(</span>obj<span class="op">);</span></span>
<span id="cb313-22"><a href="#cb313-22" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>p1<span class="op">,</span> p2<span class="op">);</span></span></code></pre></div>
<h3 id="演算子のオペランドの評価順位">演算子のオペランドの評価順位
<a id="SS_19_14_12"></a></h3>
<p>C++17で、演算子のオペランドに対する評価順序が明確に規定された。
それに対し、C++14までは、演算子のオペランド部分式の評価順序は<a
href="core_lang_spec.html#SS_19_14_4">未規定動作</a>であった。
以下の表で示す演算子に関しては、オペランドaがオペランドbよりも先に評価される。</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">演算子</th>
<th style="text-align: left;">説明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">a.b</td>
<td style="text-align: left;">メンバアクセス演算子</td>
</tr>
<tr class="even">
<td style="text-align: left;">a-&gt;b</td>
<td style="text-align: left;">ポインタメンバアクセス演算子</td>
</tr>
<tr class="odd">
<td style="text-align: left;">a-&gt;*b</td>
<td style="text-align: left;">メンバポインタアクセス演算子</td>
</tr>
<tr class="even">
<td style="text-align: left;">a(b1, b2, b3)</td>
<td
style="text-align: left;">関数呼び出し、引数リストの評価順序は規定外)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">b @= a</td>
<td style="text-align: left;">代入演算子 = や複合代入演算子。<span
class="citation" data-cites="は">@は</span>+,-,/,&amp;,|など</td>
</tr>
<tr class="even">
<td style="text-align: left;">a[b]</td>
<td style="text-align: left;">配列アクセス</td>
</tr>
<tr class="odd">
<td style="text-align: left;">a &lt;&lt; b</td>
<td style="text-align: left;">ビットシフト左演算子</td>
</tr>
<tr class="even">
<td style="text-align: left;">a &gt;&gt; b</td>
<td style="text-align: left;">ビットシフト右演算子</td>
</tr>
</tbody>
</table>
<p>C++11以前では、以下のコードの評価順序は未規定であったが、上記の通り定義された。</p>
<div class="sourceCode" id="cb314"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/etc_ut.cpp 74</span></span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-3"><a href="#cb314-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb314-4"><a href="#cb314-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y <span class="op">=</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> x <span class="op">+</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb314-5"><a href="#cb314-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-6"><a href="#cb314-6" aria-hidden="true" tabindex="-1"></a>    a<span class="op">(</span>b1<span class="op">,</span> b2<span class="op">,</span> b3<span class="op">);</span>  <span class="co">// b1, b2, b3の評価順序は規定外</span></span></code></pre></div>
<p>関数呼び出しにおける引数の式の評価順序は、上記の例a(b1, b2,
b3)での評価順序は、 不定順で序列化される。これは、b1, b2, b3
が特定の順序で評価される保証はなく、 例えば b3, b2, b1
の順に評価されたり、 b2, b3, b1 で評価される可能性があることを意味する。
一方で一度評価が開始された場合、部分式間でインターリーブ（交差実行されることはない。
つまり、b1 の評価が完全に終わる前に b2 や b3
の評価が開始されることはない。</p>
<p>条件演算子式<code>condition ? expr1 : expr2</code>については、
最初の部分であるconditionがまず評価される。
conditionの評価結果に基づき、expr1または expr2
のどちらかが選択され、選択された側だけが評価される。</p>
<div class="sourceCode" id="cb315"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/core_lang_spec/etc_ut.cpp 83</span></span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a      <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb315-4"><a href="#cb315-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b      <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb315-5"><a href="#cb315-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> <span class="op">(</span>a <span class="op">&lt;</span> b<span class="op">)</span> <span class="op">?</span> func1<span class="op">()</span> <span class="op">:</span> func2<span class="op">();</span></span></code></pre></div>
<p>なお、単項演算子のオペランドは1つであるため、優先順位の定義は不要である。</p>
<h2 id="その他">その他 <a id="SS_19_15"></a></h2>
<h3 id="rvoreturn-value-optimization">RVO(Return Value Optimization)
<a id="SS_19_15_1"></a></h3>
<p>関数の戻り値がオブジェクトである場合、
戻り値オブジェクトは、その関数の呼び出し元のオブジェクトにcopyされた後、すぐに破棄される。
この「オブジェクトをcopyして、その後すぐにそのオブジェクトを破棄する」動作は、
「関数の戻り値オブジェクトをそのままその関数の呼び出し元で使用する」ことで効率的になる。
RVOとはこのような最適化を指す。</p>
<p>なお、このような最適化は、 <a
href="https://cpprefjp.github.io/lang/cpp17/guaranteed_copy_elision.html">C++17から規格化</a>された。</p>
<h3 id="トライグラフ">トライグラフ <a id="SS_19_15_2"></a></h3>
<p>トライグラフとは、2つの疑問符とその後に続く1文字によって表される、下記の文字列である。</p>
<pre><code>    ??=  ??/  ??&#39;  ??(  ??)  ??!  ??&lt;  ??&gt;  ??-</code></pre>
</body>
</html>
