<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Comprehensive Knowledge of C++(V20.04)</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #cccccc; background-color: #303030; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ffcfaf; } /* Alert */
    code span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bn { color: #dca3a3; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #f0dfaf; } /* ControlFlow */
    code span.ch { color: #dca3a3; } /* Char */
    code span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
    code span.co { color: #7f9f7f; } /* Comment */
    code span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
    code span.do { color: #7f9f7f; } /* Documentation */
    code span.dt { color: #dfdfbf; } /* DataType */
    code span.dv { color: #dcdccc; } /* DecVal */
    code span.er { color: #c3bf9f; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #c0bed1; } /* Float */
    code span.fu { color: #efef8f; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #7f9f7f; font-weight: bold; } /* Information */
    code span.kw { color: #f0dfaf; } /* Keyword */
    code span.op { color: #f0efd0; } /* Operator */
    code span.ot { color: #efef8f; } /* Other */
    code span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
    code span.sc { color: #dca3a3; } /* SpecialChar */
    code span.ss { color: #cc9393; } /* SpecialString */
    code span.st { color: #cc9393; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #cc9393; } /* VerbatimString */
    code span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */

    body {
        margin: 0 auto;
        max-width: none;
        width: 1000px;
        padding-left: 50px;
        padding-right: 50px;
        padding-top: 50px;
        padding-bottom: 50px;
        hyphens: auto;
        overflow-wrap: break-word;
        text-rendering: optimizeLegibility;
        font-kerning: normal;
    }

    table {
        border-collapse: collapse;
    }

    table, th, td {
        border: 2px solid black;
    }

    header {
        margin-bottom: 4em;
        text-align: center;
        color: white;
        background-color: lightblue;
    }

    h1:not(:first-of-type) {
        page-break-before: always;
    }

  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Comprehensive Knowledge of C++(V20.04)</h1>
<p class="author">autor:ichiroprogrammer</p>
</header>
<!-- deep/md/template_meta_programming.md -->
<h1 id="テンプレートメタプログラミング">テンプレートメタプログラミング
<a id="SS_13"></a></h1>
<p>本章でのテンプレートメタプログラミングとは、下記の2つを指す。</p>
<ul>
<li>ジェネリックプログラミング</li>
<li>メタプログラミング</li>
</ul>
<p>C++においては、この2つはテンプレートを用いたプログラミングとなる。</p>
<p>ジェネリックプログラミングとは、具体的なデータ型に依存しない抽象的プログラミングであり、
その代表的な成果物はSTLのコンテナやそれらを扱うアルゴリズム関数テンプレートである。</p>
<p>この利点は、</p>
<ul>
<li>i種の型</li>
<li>j種のコンテナ</li>
<li>k種のアルゴリズム</li>
</ul>
<p>の開発を行うことを考えれば明らかである。</p>
<p>ジェネリックプログラミングが無ければ、コンテナの種類はi x
j個必要になり、 それらに適用するアルゴリズム関数は、i x j x
k個必要になる。
また、サポートする型の増加に伴いコンテナやアルゴリズム関数は指数関数的に増えて行く。
C言語のqsort()のように強引なキャストを使い、この増加をある程度食い止めることはできるが、
それによりコンパイラによる型チェックは無効化され、
静的な型付け言語を使うメリットの多くを失うことになる。</p>
<p>メタプログラミングとは、</p>
<ul>
<li>ジェネリックのサポート</li>
<li>実行時コードの最適化</li>
<li>関数やクラスを生成するコードのプログラミング</li>
</ul>
<p>のような目的で行われるテンプレートプログラミングの総称である。</p>
<p>ジェネリックプログラミングとメタプログラミングに明確な境界はない、
また明確にしたところで大きなメリットはと思われるため、
本章では、これらをまとめた概念であるテンプレートメタプログラミングとして扱い、
ログ取得ライブラリやSTLを応用したNstdライブラリの実装を通して、
これらのテクニックや、使用上の注意点について解説する。</p>
<p>c++20から導入された<a
href="term_explanation.html#SS_19_11_2">コンセプト</a>によりジェネリックプログラミングは、
開発容易性、可読性、保守性が大きく向上しため、この章のコード例には、 <a
href="term_explanation.html#SS_19_11_2">コンセプト</a>(<code>concept</code>,
<code>requires</code>)を多用した。</p>
<p>が、この副作用として、
c++17までしか使えない読者の参考にならないコードが増えてしまうことを避けるため、
以下のような<code>#ifdef</code>を使うことによりc++17でも使えるコード例となるようにした
(本来、<code>#ifdef</code>は使うべきではないが、<code>#ifdef</code>の数少ない使いどころだと判断した)。</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/cplusplus.cpp 4</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// c++20以上の機能を使い、c++17以下の機能ではill-formedとなるコード</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> same_as <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>T <span class="at">const</span><span class="op">*</span> t<span class="op">,</span> U <span class="at">const</span><span class="op">*</span> u<span class="op">)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span>t <span class="op">=</span> u<span class="op">,</span> u <span class="op">=</span> t<span class="op">};</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17以下の機能を使い上記のコードと同じ機能を持つ実装</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> same_as <span class="op">=</span> <span class="bu">std::</span>is_same_t<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span></code></pre></div>
<hr />
<p><strong>この章の構成</strong></p>
<p>   <a
href="template_meta_programming.html#SS_13_1">ログ取得ライブラリの開発</a><br />
    <a href="template_meta_programming.html#SS_13_1_1">要件</a><br />
    <a
href="template_meta_programming.html#SS_13_1_2">ログ取得ライブラリのインターフェース</a><br />
    <a
href="template_meta_programming.html#SS_13_1_3">パラメータパック</a><br />
    <a
href="template_meta_programming.html#SS_13_1_4">Loggerの実装</a><br />
    <a
href="template_meta_programming.html#SS_13_1_5">ユーザ定義型とそのoperator&lt;&lt;のname
lookup</a><br />
    <a
href="template_meta_programming.html#SS_13_1_6">Ints_tのログ登録</a></p>
<p>   <a
href="template_meta_programming.html#SS_13_2">Nstdライブラリの開発</a><br />
    <a
href="template_meta_programming.html#SS_13_2_1">Nstdライブラリを使用したリファクタリング</a><br />
    <a
href="template_meta_programming.html#SS_13_2_2">安全なvector</a><br />
    <a
href="template_meta_programming.html#SS_13_2_3">安全な配列型コンテナ</a><br />
    <a
href="template_meta_programming.html#SS_13_2_4">初期化子リストの副作用</a></p>
<p>   <a
href="template_meta_programming.html#SS_13_3">メタ関数のテクニック</a><br />
    <a
href="template_meta_programming.html#SS_13_3_1">STLのtype_traits</a><br />
    <a
href="template_meta_programming.html#SS_13_3_2">is_void_xxxの実装</a><br />
    <a
href="template_meta_programming.html#SS_13_3_3">is_same_xxxの実装</a><br />
    <a
href="template_meta_programming.html#SS_13_3_4">AreConvertibleXxxの実装</a><br />
    <a
href="template_meta_programming.html#SS_13_3_5">関数の存在の診断</a></p>
<p>   <a
href="template_meta_programming.html#SS_13_4">Nstdライブラリの開発2</a><br />
    <a
href="template_meta_programming.html#SS_13_4_1">SafeArray2の開発</a><br />
    <a
href="template_meta_programming.html#SS_13_4_2">Nstd::SafeIndexの開発</a><br />
    <a
href="template_meta_programming.html#SS_13_4_3">Nstd::SafeIndexのoperator&lt;&lt;の開発</a><br />
    <a
href="template_meta_programming.html#SS_13_4_4">コンテナ用Nstd::operator&lt;&lt;の開発</a></p>
<p>   <a
href="template_meta_programming.html#SS_13_5">Nstdライブラリの開発3(浮動小数点関連)</a><br />
    <a
href="template_meta_programming.html#SS_13_5_1">浮動小数点の比較</a><br />
    <a
href="template_meta_programming.html#SS_13_5_2">固定小数点クラス</a><br />
    <a
href="template_meta_programming.html#SS_13_5_3">固定小数点リテラル</a><br />
    <a
href="template_meta_programming.html#SS_13_5_4">有理数クラス</a><br />
    <a
href="template_meta_programming.html#SS_13_5_5">有理数リテラル</a></p>
<p>   <a
href="template_meta_programming.html#SS_13_6">ログ取得ライブラリの開発2</a><br />
   <a
href="template_meta_programming.html#SS_13_7">その他のテンプレートテクニック</a><br />
    <a
href="template_meta_programming.html#SS_13_7_1">ユニバーサルリファレンスとstd::forward</a><br />
    <a
href="template_meta_programming.html#SS_13_7_2">ジェネリックラムダによる関数内での関数テンプレートの定義</a><br />
    <a
href="template_meta_programming.html#SS_13_7_3">クラステンプレートと継承の再帰構造</a><br />
    <a href="template_meta_programming.html#SS_13_7_4">意図しないname
lookupの防止</a><br />
    <a
href="template_meta_programming.html#SS_13_7_5">Nstd::Type2Strの開発</a><br />
    <a
href="template_meta_programming.html#SS_13_7_6">静的な文字列オブジェクト</a><br />
    <a
href="template_meta_programming.html#SS_13_7_7">関数型をテンプレートパラメータで使う</a></p>
<p>   <a
href="template_meta_programming.html#SS_13_8">注意点まとめ</a></p>
<p><a
href="introduction.html#SS_1_7">このドキュメントの構成</a>に戻る。<br />
___</p>
<h2 id="ログ取得ライブラリの開発">ログ取得ライブラリの開発
<a id="SS_13_1"></a></h2>
<p>ここではログ取得ライブラリの開発を行う。</p>
<h3 id="要件">要件 <a id="SS_13_1_1"></a></h3>
<p>ログ取得ライブラリの要件は、</p>
<ul>
<li>ソースコードの場所とそこで指示されたオブジェクトの値を文字列で保持する</li>
<li>後からそれらを取り出せる</li>
</ul>
<p>ことのみとする。下記はその文字列を取り出した例である。</p>
<pre><code>    app/src/main.cpp: 96:Options
                         cmd       : GenPkg
                         in        : 
                         out       : 
                         recursive : true
                         src_as_pkg: false
        ...

    app/src/main.cpp: 51:start GenPkg

    file_utils/ut/path_utils.cpp: 38:1
    file_utils/ut/path_utils.cpp: 48:ut_data/app1
                         ut_data/app1/mod1
                         ut_data/app1/mod2

        ...

    app/src/main.cpp:100:Exit:0</code></pre>
<p>単純化のためログの番号やタイムスタンプのサポートはしない。
また、実行速度や仕様メモリ量の制限等も本章の趣旨とは離れるため考慮しない。</p>
<h3
id="ログ取得ライブラリのインターフェース">ログ取得ライブラリのインターフェース
<a id="SS_13_1_2"></a></h3>
<p>ログ取得コードにより、コードクローンが増えたり、主なロジックの可読性が下がったのでは、
本末転倒であるため、下記のようにワンライナーで記述できるべきだろう。</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    LOGGER<span class="op">(</span><span class="st">&quot;start GenPkg&quot;</span><span class="op">,</span> objA<span class="op">,</span> objB<span class="op">,</span> objC<span class="op">);</span></span></code></pre></div>
<p>また、要件で述べた通り、ソースコード位置を特定できなければならないため、
上記LOGGERは下記のような関数型マクロにならざるを得ない。</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define LOGGER</span><span class="op">(...)</span><span class="pp"> </span>CppLoggerFunc<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span><span class="pp"> </span><span class="ot">__LINE__</span><span class="op">,</span><span class="pp"> </span><span class="ot">__VA_ARGS__</span><span class="op">)</span></span></code></pre></div>
<p>CppLoggerFuncをクラス外の関数として実装した場合、ログ保持のための静的なオブジェクトが必要になる。
これは避けるべきなので、「<a
href="design_pattern.html#SS_9_12">Singleton</a>」で述べた構造を導入すると、</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define LOGGER</span><span class="op">(...)</span><span class="pp"> </span>Logger<span class="op">::</span>Inst<span class="op">().</span>Set<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span><span class="pp"> </span><span class="ot">__LINE__</span><span class="op">,</span><span class="pp"> </span><span class="ot">__VA_ARGS__</span><span class="op">)</span></span></code></pre></div>
<p>のような関数型マクロとなる。これがログ取得ライブラリの主なインターフェースとなる。</p>
<p>C言語プログラミングばかりをやりすぎて、
視神経と手の運動神経が直結してしまった大脳レス・プログラマーは、</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    __VA_ARGS__</span></code></pre></div>
<p>を見るとprintf(…)のような可変長引数を取る関数を思い浮かべる。
「人は一昨日も行ったことを昨日も行ったという理由で、今日もそれを行う」
という諺を思い出すと気持ちは分からなくもないが、
C++ではprintf(…)のような危険な可変長引数を取る関数を作ってはならない。
パラメータパックを使って実装するべきである。</p>
<h3 id="パラメータパック">パラメータパック <a id="SS_13_1_3"></a></h3>
<p>C++11で導入されたパラメータパックはやや複雑なシンタックスを持つため、
まずは単純な例から説明する。</p>
<p>次のような単体テストをパスする関数テンプレートsumをパラメータパックで実装することを考える。</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 26</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">));</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">6</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">));</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_FLOAT_EQ<span class="op">(</span><span class="fl">6.0</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">));</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">10</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">));</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">55</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">10</span><span class="op">));</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span></code></pre></div>
<p>sumの要件は、</p>
<ul>
<li>可変長引数を持つ</li>
<li><a
href="term_explanation.html#SS_19_1_3">算術型</a>の引数と戻り値を持つ</li>
<li>すべての引数の和を返す</li>
</ul>
<p>のようなものになるため、関数テンプレートsumは下記のように書ける。</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 9</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sum<span class="op">(</span>HEAD head<span class="op">)</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> head<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> TAIL<span class="op">&gt;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sum<span class="op">(</span>HEAD head<span class="op">,</span> TAIL<span class="op">...</span> tails<span class="op">)</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> head <span class="op">+</span> sum<span class="op">(</span>tails<span class="op">...);</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>1つ目の関数テンプレートsumは引数が一つの場合に対応する。
2つ目の関数テンプレートsumは引数が2つ以上の場合に対応する。</p>
<p>2つ目の関数テンプレートsumのテンプレートパラメータ</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span><span class="op">...</span> TAIL</span></code></pre></div>
<p>がパラメータパックであり、0個以上の型が指定されることを意味する。
これを関数の引数として表すシンタックスが</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    TAIL<span class="op">...</span> tails</span></code></pre></div>
<p>であり、同様に0個以上のインスタンスが指定されることを表している。</p>
<p>HEADとTAILより、2つ目のsumは1個以上の引数を取れることになるため、
引数が1つの場合、どちらのsumを呼び出すかが曖昧になるように思えるが、
ベストマッチの観点から1つ目のsumが呼び出される。</p>
<p>sum(1, 2,
3)の呼び出し時のsumの展開を見てみることでパラメータパックの振る舞いを解説する。</p>
<p>この呼び出しは、2つ目のsumにマッチする。従って下記のように展開される。</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> sum<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span></code></pre></div>
<p>sum(2, 3)も同様に展開されるため、上記コードは下記のようになる。</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">+</span> sum<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span></code></pre></div>
<p>sum(3)は1つ目のsumにマッチするため、最終的には下記のように展開される。</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span><span class="op">;</span></span></code></pre></div>
<p>これで基本的な要件は満たしたが、このsumでは下記のようなコードもコンパイルできてしまう。</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 43</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="kw">true</span><span class="op">,</span> <span class="kw">false</span><span class="op">));</span></span></code></pre></div>
<p>これを認めるかどうかはsumの仕様次第だが、ここではこれらを認めないようにしたい。
また、引数に浮動小数が与えられた場合でも、sumの戻り値の型がintなる仕様には問題がある。
合わせてそれも修正する。</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 53</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sum<span class="op">(</span>HEAD head<span class="op">)</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// std::is_sameの2パラメータが同一であれば、std::is_same&lt;&gt;::value == true</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_same<span class="op">&lt;</span>HEAD<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;arguemnt type must not be bool.&quot;</span><span class="op">);</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> head<span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> TAIL<span class="op">&gt;</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sum<span class="op">(</span>HEAD head<span class="op">,</span> TAIL<span class="op">...</span> tails<span class="op">)</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// std::is_sameの2パラメータが同一であれば、std::is_same&lt;&gt;::value == true</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_same<span class="op">&lt;</span>HEAD<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;::</span>value<span class="op">,</span> <span class="st">&quot;arguemnt type must not be bool.&quot;</span><span class="op">);</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> head <span class="op">+</span> sum<span class="op">(</span>tails<span class="op">...);</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 83</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// boolを除く算術型のみ認めるため、下記はコンパイルできない。</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_EQ(2, sum(1, true, false));</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> i1 <span class="op">=</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> i2 <span class="op">=</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>i1<span class="op">)&gt;::</span>value<span class="op">);</span>  <span class="co">// 1の型はint</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>i2<span class="op">)&gt;::</span>value<span class="op">);</span>  <span class="co">// 1 + 2の型はint</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> u1 <span class="op">=</span> sum<span class="op">(</span><span class="dv">1</span><span class="bu">U</span><span class="op">);</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> u2 <span class="op">=</span> sum<span class="op">(</span><span class="dv">1</span><span class="bu">U</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">unsigned</span> <span class="dt">int</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>u1<span class="op">)&gt;::</span>value<span class="op">);</span>  <span class="co">// 1Uの型はunsigned int</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">unsigned</span> <span class="dt">int</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>u2<span class="op">)&gt;::</span>value<span class="op">);</span>  <span class="co">// 1U + 2の型はunsigned int</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f0 <span class="op">=</span> sum<span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.2</span><span class="op">);</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>f0<span class="op">)&gt;::</span>value<span class="op">);</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ただし、戻り型をautoにしたため、下記も認められるようになった。</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// これに対しての対処は別の関数で行う。</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str <span class="op">=</span> sum<span class="op">(</span><span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;1&quot;</span><span class="op">},</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;2&quot;</span><span class="op">});</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>str<span class="op">,</span> <span class="st">&quot;12&quot;</span><span class="op">);</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>str<span class="op">)&gt;::</span>value<span class="op">);</span></span></code></pre></div>
<p>以上で示したようにパラメータパックにより、
C言語での可変長引数関数では不可能だった引数の型チェックができるようになったため、
C言語でのランタイムエラーがコンパイルエラーにできるようになった。</p>
<p>なお、上記コードで使用した<a
href="template_meta_programming.html#SS_13_3_1_3">std::is_same</a>は、
与えられた2つのテンプレートパラメータが同じ型であった場合、
valueをtrueで初期化するクラステンプレートであり、
type_traitsで定義されている
(後ほど使用するstd::is_same_vはstd::is_same&lt;&gt;::valueと等価な定数テンプレート)。
この実装については、後ほど説明する。</p>
<p><a href="exercise_q.html#SS_20_11_1">演習-パラメータパック</a></p>
<h4 id="パラメータパックの畳みこみ式">パラメータパックの畳みこみ式
<a id="SS_13_1_3_1"></a></h4>
<p>上記したsumは、パラメータパックの展開に汎用的な再帰構造を用いたが、
C++17で導入された畳みこみ式を用い、以下の様に簡潔に記述することもできる。</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 123</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sum<span class="op">(</span>ARGS<span class="op">...</span> args<span class="op">)</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>args <span class="op">+</span> <span class="op">...);</span>  <span class="co">// 畳みこみ式は()で囲まなければならない。</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 134</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">));</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">6</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">));</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="fl">6.0</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">));</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">10</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">));</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">55</span><span class="op">,</span> sum<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">10</span><span class="op">));</span></span></code></pre></div>
<p>畳みこみ式で使用できる演算子を以下に示す。</p>
<pre><code>    + - * / % ^ &amp; | = &lt; &gt; &lt;&lt; &gt;&gt; += -= *= /= %= ^= &amp;= |= &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || , .* -&gt;*</code></pre>
<p>これらの演算子がオーバーロードである場合でも、畳みこみ式は利用できる。</p>
<h4 id="前から演算するパラメータパック">前から演算するパラメータパック
<a id="SS_13_1_3_2"></a></h4>
<p>パラメータパックを使うプログラミングでは、
上記したHEADとTAILによるリカーシブコールがよく使われるパターンであるが、
これには後ろから処理されるという、微妙な問題点がある。</p>
<p>これまでのsumに代えて下記のようなproduct(掛け算)を考える。</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 149</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> product<span class="op">(</span>HEAD head<span class="op">)</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>HEAD<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;,</span> <span class="st">&quot;arguemnt type must not be bool.&quot;</span><span class="op">);</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_arithmetic_v<span class="op">&lt;</span>HEAD<span class="op">&gt;,</span> <span class="st">&quot;arguemnt type must be arithmetic.&quot;</span><span class="op">);</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> head<span class="op">;</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> TAIL<span class="op">&gt;</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> product<span class="op">(</span>HEAD head<span class="op">,</span> TAIL<span class="op">...</span> tails<span class="op">)</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>HEAD<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;,</span> <span class="st">&quot;arguemnt type must not be bool.&quot;</span><span class="op">);</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_arithmetic_v<span class="op">&lt;</span>HEAD<span class="op">&gt;,</span> <span class="st">&quot;arguemnt type must be arithmetic.&quot;</span><span class="op">);</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> head <span class="op">*</span> product<span class="op">(</span>tails<span class="op">...);</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>このコードの単体テストは、</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 173</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> product<span class="op">(</span><span class="dv">100</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">));</span></span></code></pre></div>
<p>のようになるだろうが、
std::numeric_limits&lt;&gt;::epsilonを使用していないため (「<a
href="term_explanation.html#SS_19_1_12">浮動小数点型</a>」参照)
、このテストはパスしない。一方で、以下のテストはパスする。</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 178</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> product<span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="dv">100</span><span class="op">));</span></span></code></pre></div>
<p>一般に0.01の2進数表現は無限小数になるため、これを含む演算にはepsilon以下の演算誤差が発生する。
前者単体テストでは、後ろから演算されるために処理の途中に0.01が現れるが、
後者では現れないため、この誤差の有無が結果の差になる。</p>
<p>このような演算順序による微妙な誤差が問題になるような関数を開発する場合、
演算は見た目の順序通りに行われた方が良いだろう。
ということで、productを前から演算するように修正する。</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 196</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> product<span class="op">(</span>HEAD head<span class="op">)</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>HEAD<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;,</span> <span class="st">&quot;arguemnt type must not be bool.&quot;</span><span class="op">);</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_arithmetic_v<span class="op">&lt;</span>HEAD<span class="op">&gt;,</span> <span class="st">&quot;arguemnt type must be arithmetic.&quot;</span><span class="op">);</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> head<span class="op">;</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">,</span> <span class="kw">typename</span> HEAD2<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> TAIL<span class="op">&gt;</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> product<span class="op">(</span>HEAD head<span class="op">,</span> HEAD2 head2<span class="op">,</span> TAIL<span class="op">...</span> tails<span class="op">)</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>HEAD<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;,</span> <span class="st">&quot;arguemnt type must not be bool.&quot;</span><span class="op">);</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_arithmetic_v<span class="op">&lt;</span>HEAD<span class="op">&gt;,</span> <span class="st">&quot;arguemnt type must be arithmetic.&quot;</span><span class="op">);</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> product<span class="op">(</span>head <span class="op">*</span> head2<span class="op">,</span> tails<span class="op">...);</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>HEAD、TAILに加えHEAD2を導入することで、前からの演算を実装できる
(引数が一つのproductに変更はない)。当然ながら、これにより、</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 220</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> product<span class="op">(</span><span class="dv">100</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">));</span></span></code></pre></div>
<p>はパスし、下記はパスしなくなる。</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/parameter_pack_ut.cpp 225</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> product<span class="op">(</span><span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span> <span class="dv">100</span><span class="op">));</span></span></code></pre></div>
<h3 id="loggerの実装">Loggerの実装 <a id="SS_13_1_4"></a></h3>
<p>パラメータパックを使用したログ取得コードは以下のようになる。</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0.h 48</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define LOGGER_P</span><span class="op">(...)</span><span class="pp"> </span>Logging<span class="op">::</span>Logger<span class="op">::</span>Inst<span class="op">().</span>Set<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span><span class="pp"> </span><span class="ot">__LINE__</span><span class="op">)</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define LOGGER</span><span class="op">(...)</span><span class="pp"> </span>Logging<span class="op">::</span>Logger<span class="op">::</span>Inst<span class="op">().</span>Set<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span><span class="pp"> </span><span class="ot">__LINE__</span><span class="op">,</span><span class="pp"> </span><span class="ot">__VA_ARGS__</span><span class="op">)</span></span></code></pre></div>
<p>予定していたものと若干違う理由は、__VA_ARGS__が1個以上の識別子を表しているからである。
従って、通過ポイントのみをロギングしたい場合、LOGGER_P()を使うことになる。
gcc拡張を使えば、LOGGER_PとLOGGERを統一できるが、そのようなことをすると別のコンパイラや、
静的解析ツールが使用できなくなることがあるため、残念だが上記のように実装するべきである。</p>
<p>Loggerクラスの実装は、下記のようになる。</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0.h 6</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Logging <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Logger <span class="op">{</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> Logger<span class="op">&amp;</span>       Inst<span class="op">();</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> Logger <span class="at">const</span><span class="op">&amp;</span> InstConst<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> Inst<span class="op">();</span> <span class="op">}</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string Get<span class="op">()</span> <span class="at">const</span><span class="op">;</span>  <span class="co">// ログデータの取得</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span>        Clear<span class="op">();</span>      <span class="co">// ログデータの消去</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span>  <span class="co">// ログの登録</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> Set<span class="op">(</span><span class="dt">char</span> <span class="at">const</span><span class="op">*</span> filename<span class="op">,</span> <span class="dt">uint32_t</span> line_no<span class="op">,</span> ARGS <span class="at">const</span><span class="op">&amp;...</span> args<span class="op">)</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">oss_</span><span class="op">.</span>width<span class="op">(</span><span class="dv">32</span><span class="op">);</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>            <span class="va">oss_</span> <span class="op">&lt;&lt;</span> filename <span class="op">&lt;&lt;</span> <span class="st">&quot;:&quot;</span><span class="op">;</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">oss_</span><span class="op">.</span>width<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>            <span class="va">oss_</span> <span class="op">&lt;&lt;</span> line_no<span class="op">;</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>            set_inner<span class="op">(</span>args<span class="op">...);</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>        Logger<span class="op">(</span>Logger <span class="at">const</span><span class="op">&amp;)</span>            <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>        Logger<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Logger <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> set_inner<span class="op">()</span> <span class="op">{</span> <span class="va">oss_</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="op">}</span></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span>Nstd<span class="op">::</span>Printable HEAD<span class="op">,</span> Nstd<span class="op">::</span>Printable<span class="op">...</span> TAIL<span class="op">&gt;</span></span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> set_inner<span class="op">(</span>HEAD <span class="at">const</span><span class="op">&amp;</span> head<span class="op">,</span> TAIL <span class="at">const</span><span class="op">&amp;...</span> tails<span class="op">)</span></span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>            <span class="va">oss_</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;:&quot;</span> <span class="op">&lt;&lt;</span> head<span class="op">;</span></span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a>            set_inner<span class="op">(</span>tails<span class="op">...);</span></span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a>        Logger<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ostringstream <span class="va">oss_</span><span class="op">{};</span></span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Logging</span></span></code></pre></div>
<p>すでに述べた通り、</p>
<ul>
<li>クラスはシングルトンにする</li>
<li>パラメータパックにより可変長引数を実現する</li>
</ul>
<p>ようにした。
また、識別子の衝突を避けるために、名前空間Loggingを導入し、Loggerはその中で宣言した。</p>
<p>次に、どのように動作するのかを単体テストで示す。</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_ut.cpp 16</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;b&quot;</span><span class="op">};</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    LOGGER_P<span class="op">();</span>               <span class="co">// (1)</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    LOGGER<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="st">&quot;hehe&quot;</span><span class="op">,</span> a<span class="op">,</span> b<span class="op">);</span>  <span class="co">// (2)</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> line_num <span class="op">=</span> <span class="ot">__LINE__</span><span class="op">;</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> s <span class="op">=</span> Logging<span class="op">::</span>Logger<span class="op">::</span>InstConst<span class="op">().</span>Get<span class="op">();</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> exp <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span>log_str_exp<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span> line_num <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)};</span>  <span class="co">// (1)のログ</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    exp <span class="op">+=</span> log_str_exp<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span> line_num <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;:5:hehe:1:b</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>        <span class="co">// (2)のログ</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>exp<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    Logging<span class="op">::</span>Logger<span class="op">::</span>Inst<span class="op">().</span>Clear<span class="op">();</span>  <span class="co">// クリアの確認</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">,</span> Logging<span class="op">::</span>Logger<span class="op">::</span>InstConst<span class="op">().</span>Get<span class="op">());</span></span></code></pre></div>
<p>行を含む出力の期待値をソースコードに直接書くと行増減のたびにそれらを修正する必要ある。
期待値の一部を自動計算する下記コード(上記コードで使用)を単体テストに導入することで、
そういった修正を避けている。</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_ut.h 4</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="bu">std::</span>string line_to_str<span class="op">(</span><span class="dt">uint32_t</span> line<span class="op">)</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>line <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;:  &quot;</span><span class="op">;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>line <span class="op">&lt;</span> <span class="dv">100</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;: &quot;</span><span class="op">;</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>line <span class="op">&lt;</span> <span class="dv">1000</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;:&quot;</span><span class="op">;</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>            <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span>  <span class="co">// 1000行を超える単体テストファイルを認めない</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="bu">std::</span>string log_str_exp<span class="op">(</span><span class="dt">char</span> <span class="at">const</span><span class="op">*</span> filename_cstr<span class="op">,</span> <span class="dt">uint32_t</span> line<span class="op">,</span> <span class="dt">char</span> <span class="at">const</span><span class="op">*</span> str<span class="op">)</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="at">const</span> filename <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span>filename_cstr<span class="op">};</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="at">const</span> len      <span class="op">=</span> <span class="dv">32</span> <span class="op">&gt;</span> filename<span class="op">.</span>size<span class="op">()</span> <span class="op">?</span> <span class="dv">32</span> <span class="op">-</span> filename<span class="op">.</span>size<span class="op">()</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span>       ret      <span class="op">=</span> <span class="bu">std::</span>string<span class="op">(</span>len<span class="op">,</span> <span class="ch">&#39; &#39;</span><span class="op">);</span></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">+=</span> filename<span class="op">;</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">+=</span> line_to_str<span class="op">(</span>line<span class="op">);</span></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">+=</span> <span class="bu">std::</span>to_string<span class="op">(</span>line<span class="op">);</span></span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>        ret <span class="op">+=</span> str<span class="op">;</span></span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>アプリケーションの開発では、
下記のようなユーザが定義した名前空間とクラスを用いることがほとんどである。</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/app_ints.h 12</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> X <span class="op">{</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        X<span class="op">(</span><span class="bu">std::</span>string str<span class="op">,</span> <span class="dt">int</span> num<span class="op">)</span> <span class="op">:</span> <span class="va">str_</span><span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>str<span class="op">)},</span> <span class="va">num_</span><span class="op">{</span>num<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string ToString<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">str_</span> <span class="op">+</span> <span class="st">&quot;/&quot;</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span><span class="va">num_</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>このApp::Xのインスタンスのログを取得できることも、当然Logging::Loggerの要件となる。
従って、下記の単体テストはコンパイルでき、且つパスすることが必要になる。</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_ut.cpp 42</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> x <span class="op">=</span> App<span class="op">::</span>X<span class="op">{</span><span class="st">&quot;name&quot;</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    LOGGER<span class="op">(</span><span class="dv">1</span><span class="op">,</span> x<span class="op">);</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> line_num <span class="op">=</span> <span class="ot">__LINE__</span><span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> s <span class="op">=</span> Logging<span class="op">::</span>Logger<span class="op">::</span>InstConst<span class="op">().</span>Get<span class="op">();</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> exp <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span>log_str_exp<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span> line_num <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;:1:name/3</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)};</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>exp<span class="op">,</span> s<span class="op">);</span></span></code></pre></div>
<p>Logging::Loggerのコードからオブジェクトのログを登録するためには、
Logging::Logger::set_innerがコンパイルできなければならない。
つまり、</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;,</span> ログ登録オブジェクトの型<span class="op">)</span></span></code></pre></div>
<p>の実装が必要条件となる。App::Xでは下記のようなコードになる。</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/app_ints.h 28</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> X <span class="at">const</span><span class="op">&amp;</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> os <span class="op">&lt;&lt;</span> x<span class="op">.</span>ToString<span class="op">();</span> <span class="op">}</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>他の任意のユーザ定義型に対しても、このようにすることでログ登録が可能になる。</p>
<p>なお、ヒューマンリーダブルな文字列でその状態を表示できる関数をユーザ定義型に与えることは、
デバッガを使用したデバッグ時にも有用である。</p>
<h3
id="ユーザ定義型とそのoperatorのname-lookup">ユーザ定義型とそのoperator&lt;&lt;のname
lookup <a id="SS_13_1_5"></a></h3>
<p>ここで、一旦Logging::Loggerの開発を止め、
Logging::Logger::set_innerでのApp::operator&lt;&lt;の<a
href="term_explanation.html#SS_19_10_2">name
lookup</a>について考えてみることにする。</p>
<p>ここまでで紹介したログ取得ライブラリやそれを使うユーザ定義型等の定義、宣言の順番は、</p>
<ol type="1">
<li>Logging::Logger</li>
<li>App::X</li>
<li>App::operator&lt;&lt;</li>
<li>単体テスト(Logger::set_innerのインスタンス化される場所)</li>
</ol>
<p>となっている。 name
lookupの原則に従い、App::Xの宣言は、App::operator&lt;&lt;より前に行われている。
これを逆にするとコンパイルできない。
しかし、Logging::Loggerは、後から宣言されたApp::operator&lt;&lt;を使うことができる。
多くのプログラマは、これについて気づいていないか、その理由を間違っての認識している。</p>
<p>その認識とは、「テンプレート内の識別子の<a
href="term_explanation.html#SS_19_10_2">name lookup</a>は、
それがインスタンス化される時に行われる」というものであり、これにより 「
Logging::Loggerのname lookupは単体テスト内で行われる。
それはApp::operator&lt;&lt;宣言後であるためコンパイルできる」と考えることができるが、
<a href="term_explanation.html#SS_19_10_3">two phase name
lookup</a>で行われるプロセスと反するため誤りである。</p>
<p>まずは、この認識の誤りを下記のコードで説明する。</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_ut.cpp 68</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App2 <span class="op">{</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> X <span class="op">{</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> X<span class="op">(</span><span class="bu">std::</span>string str<span class="op">,</span> <span class="dt">int</span> num<span class="op">)</span> <span class="op">:</span> <span class="va">str_</span><span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>str<span class="op">)},</span> <span class="va">num_</span><span class="op">{</span>num<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string ToString<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">str_</span> <span class="op">+</span> <span class="st">&quot;/&quot;</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span><span class="va">num_</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App2</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App3 <span class="op">{</span>  <span class="co">// App3をApp2にすればコンパイルできる</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> App2<span class="op">::</span>X <span class="at">const</span><span class="op">&amp;</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> os <span class="op">&lt;&lt;</span> x<span class="op">.</span>ToString<span class="op">();</span> <span class="op">}</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App3</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> <span class="op">{</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    TEST<span class="op">(</span>Template<span class="op">,</span> logger_0_X_in_AppX<span class="op">)</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>        Logging<span class="op">::</span>Logger<span class="op">::</span>Inst<span class="op">().</span>Clear<span class="op">();</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> x <span class="op">=</span> App2<span class="op">::</span>X<span class="op">{</span><span class="st">&quot;name&quot;</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="kw">namespace</span> App3<span class="op">;</span>  <span class="co">// この記述は下記のエラーに効果がない</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>        LOGGER<span class="op">(</span><span class="dv">1</span><span class="op">,</span> x<span class="op">);</span>  <span class="co">// ここがコンパイルエラーとなる</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> line_num <span class="op">=</span> <span class="ot">__LINE__</span><span class="op">;</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> s <span class="op">=</span> Logging<span class="op">::</span>Logger<span class="op">::</span>InstConst<span class="op">().</span>Get<span class="op">();</span></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> exp <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span>log_str_exp<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span> line_num <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;:1:name/3</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)};</span></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>exp<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace</span></span></code></pre></div>
<p>このコードは、もともとのコードの名前空間名をApp2とApp3にしただけのものである。
もし、前記した「認識」の内容が正しいのであれば、このコードもコンパイルできるはずであるが
(実際にApp3と書いた部分をApp2に書き換えればコンパイルできる)、
実際には下記のようなエラーが発生する。</p>
<pre><code>    logger_0.h:37:21: error: no match for ‘operator&lt;&lt;’ 
    (operand types are ‘std::basic_ostream&lt;char&gt;’ and ‘const App2::X’)
       37 |         oss_ &lt;&lt; &quot;:&quot; &lt;&lt; head;
          |         ~~~~~~~~~~~~^~~~~~~
</code></pre>
<p>エラー内容からoperator&lt;&lt;が発見できないことは明らかである。
単体テスト内でのusing namespace
App3はLogging::Logger::set_innerの宣言より後に書かれているため、
このエラーを防ぐ効果はない。</p>
<p>Logging::Logger::set_innerの中でusing namespace App3とした上で、 two
phase name lookupの原則に従い、
App2::XとApp3::operator&lt;&lt;をLogging::Loggerの宣言より前に宣言することで、
ようやくコンパイルすることができる。</p>
<p>名前空間Appの例と名前空間App2、App3の例での本質的な違いは、
「型Xとそのoperator&lt;&lt;が同じ名前空間で宣言されているかどうか」である。</p>
<p>名前空間Appの例の場合、型Xとそのoperator&lt;&lt;が同じ名前空間で宣言されているため、
<a href="term_explanation.html#SS_19_10_5">ADL</a>(実引数依存探索)が働く。
また、Logging::Logger::set_inner(x)はテンプレートであるため、<a
href="term_explanation.html#SS_19_10_3">two phase name lookup</a>
が使用される。 その結果、Logging::Logger::set_inner(x)でのname
lookupの対象には、
「Logging::Logger::set_inner(x)がインスタンス化される場所
(単体テスト内でのLOGGER_PやLOGGERが使われている場所)より前方で宣言された名前空間App」も含まれる。
こういったメカニズムにより、
Logging::Logger::set_inner定義位置の後方で宣言されたApp::operator&lt;&lt;も発見できることになる。</p>
<p>一方で、名前空間App2、App3の例では、型XがApp2で宣言されているため、
Logging::Logger::set_inner(x)でのname lookupの対象にApp3は含ず、
App3::operator&lt;&lt;は発見されない(繰り返すが、インスタン化の場所直前でのusing
nameには効果がない)。</p>
<p>型Xとそのoperator&lt;&lt;を同じ名前空間で宣言することは本質的に重要なことであるが、
名前空間を使用する場合、自然にそのような構造になるため、
その重要性の理由を知る必要はないように思われる。
しかし、次の例で示すようにこのメカニズムを知らずに解決することができないケースが存在する。</p>
<h3 id="ints_tのログ登録">Ints_tのログ登録 <a id="SS_13_1_6"></a></h3>
<p>話題はログ取得ライブラリの開発に戻る。
アプリケーションの開発では、下記のように宣言された型エイリアスを使うことは珍しくない。</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/app_ints.h 6</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">Ints_t</span> <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>そのoperator&lt;&lt;を下記のように定義したとする。</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_ut.cpp 109</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> <span class="dt">Ints_t</span> <span class="at">const</span><span class="op">&amp;</span> ints<span class="op">)</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sep <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span> i <span class="op">:</span> ints<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>            os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>exchange<span class="op">(</span>sep<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>単体テストは下記のように書けるが、残念ながらコンパイルエラーになり、</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_ut.cpp 131</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ints <span class="op">=</span> App<span class="op">::</span><span class="dt">Ints_t</span><span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    oss <span class="op">&lt;&lt;</span> ints<span class="op">;</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;1, 2, 3&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span></code></pre></div>
<p>下記のようなエラーメッセージが表示される。</p>
<pre><code>    logger_0_ut.cpp:140:9: error: no match for ‘operator&lt;&lt;’
        (operand types are ‘std::ostringstream’ {aka ‘std::basic_ostringstream&lt;char&gt;’}
         and ‘App::Ints_t’ {aka ‘std::vector&lt;int&gt;’})
      140 |     oss &lt;&lt; ints;
          |     ~~~ ^~ ~~~~
          |     |      |
          |     |      App::Ints_t {aka std::vector&lt;int&gt;}
          |     std::ostringstream {aka std::basic_ostringstream&lt;char&gt;}</code></pre>
<p>Ints_tはAppで定義されているが、実際の型はstdで定義されているため、
instsの<a
href="term_explanation.html#SS_19_10_6">関連名前空間</a>もstdであり、Appではない。
その結果App::operator&lt;&lt;は発見できず、このようなエラーになった。</p>
<p>LOGGERからApp::operator&lt;&lt;を使う場合の単体テストは下記のようになるが、
<a
href="term_explanation.html#SS_19_10_5">ADL</a>によってLogging::Logger::set_inner(ints)内に導入される名前空間はstdのみであり、
前記単体テスト同様にコンパイルできない。</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_ints_ut.h 8</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ints <span class="op">=</span> App<span class="op">::</span><span class="dt">Ints_t</span><span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    LOGGER<span class="op">(</span><span class="st">&quot;Ints&quot;</span><span class="op">,</span> ints<span class="op">);</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> line_num <span class="op">=</span> <span class="ot">__LINE__</span><span class="op">;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> s <span class="op">=</span> Logging<span class="op">::</span>Logger<span class="op">::</span>InstConst<span class="op">().</span>Get<span class="op">();</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> exp <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span>log_str_exp<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span> line_num <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;:Ints:1, 2, 3</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)};</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>exp<span class="op">,</span> s<span class="op">);</span></span></code></pre></div>
<p>この解決方法は、</p>
<ul>
<li><a
href="template_meta_programming.html#SS_13_1_6_1">operator&lt;&lt;をstd内で宣言する</a></li>
<li><a
href="template_meta_programming.html#SS_13_1_6_2">operator&lt;&lt;をグローバル名前空間内で宣言する</a></li>
<li><a
href="template_meta_programming.html#SS_13_1_6_3">operator&lt;&lt;をLogging内で宣言する</a></li>
<li><a
href="template_meta_programming.html#SS_13_1_6_4">Logging::Logger::set_inner(ints)内でusing
namespace Appを行う</a></li>
<li><a
href="template_meta_programming.html#SS_13_1_6_5">Ints_tを構造体としてApp内に宣言する</a></li>
<li><a
href="template_meta_programming.html#SS_13_1_6_6">operator&lt;&lt;を使わない</a></li>
</ul>
<p>のようにいくつか考えられる。以下では、順を追ってこれらの問題点について解説を行う。</p>
<h4 id="operatorをstd内で宣言する">operator&lt;&lt;をstd内で宣言する
<a id="SS_13_1_6_1"></a></h4>
<p>ここで解決したい問題は、すでに示した通り、 「<a
href="term_explanation.html#SS_19_10_5">ADL</a>によってLogging::Logger::set_inner(ints)内に導入される名前空間はstdである」
ことにって発生する。であれば、App内でのoperator&lt;&lt;の宣言をstdで行えばコンパイルできるはずである。
下記はその変更を行ったコードである。</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/app_ints.h 6</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">Ints_t</span> <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb42"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_std_ut.cpp 11</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> std <span class="op">{</span>  <span class="co">// operator&lt;&lt;の定義をstdで行う</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> App<span class="op">::</span><span class="dt">Ints_t</span> <span class="at">const</span><span class="op">&amp;</span> ints<span class="op">)</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sep <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> i <span class="op">:</span> ints<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>            os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>exchange<span class="op">(</span>sep<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace std</span></span></code></pre></div>
<p>上記コードは<a href="term_explanation.html#SS_19_10_3">two phase name
lookup</a>等の効果により、想定通りコンパイルできるが、
stdをユーザが拡張することは一部の例外を除き未定義動作を引き起こす可能性があり、
たとえこのコードがうまく動作したとしても
(実際、このコードはこのドキュメント作成時には正常動作している)、
未来においてその保証はなく、このようなプログラミングは厳に避けるべきである。</p>
<h4
id="operatorをグローバル名前空間内で宣言する">operator&lt;&lt;をグローバル名前空間内で宣言する
<a id="SS_13_1_6_2"></a></h4>
<p>すでに述べた通り、
「ADLによってLogging::Logger::set_inner(ints)内に導入される名前空間はstdのみである」ため、
この関数の中でのname
lookupに使用される名前空間は、std、グローバル名前空間、
Loggerを宣言しているLoggingの3つである。</p>
<p>ここでは、下記のコードのようにグローバル名前空間内でのoperator&lt;&lt;の宣言を試す。</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/app_ints.h 6</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">Ints_t</span> <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb44"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_global_ut.cpp 10</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// グローバル名前空間</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> App<span class="op">::</span><span class="dt">Ints_t</span> <span class="at">const</span><span class="op">&amp;</span> ints<span class="op">)</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sep <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> i <span class="op">:</span> ints<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>            os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>exchange<span class="op">(</span>sep<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>このドキュメントで使用している<a
href="term_explanation.html#SS_19_19_1">g++</a>ではこのコードはコンパイルでき、
動作も問題ないように思われるが、<a
href="term_explanation.html#SS_19_19_2">clang++</a>では以下のようなエラーが発生し、コンパイルできない。</p>
<pre><code>    ./logger_0.h:37:21: error: call to function &#39;operator&lt;&lt;&#39; that is neither 
    visible in the tem plate definition nor found by argument-dependent lookup
            oss_ &lt;&lt; &quot;:&quot; &lt;&lt; head;</code></pre>
<p>この理由は「<a href="term_explanation.html#SS_19_10_3">two phase name
lookup</a>」の後半で詳しく解説したので、ここでは繰り返さないが、
このようなコードを使うと、コード解析ツール等が使用できなくなることがあるため、
避けるべきである (「<a
href="code_analysis.html#SS_4_2">scan-buildによる静的解析</a>」参照)
。</p>
<p>多くのプログラマは、コードに問題があるとしても、
それが意図通りに動くように見えるのであればその問題を無視する。
今回のような難題に対しては、なおさらそのような邪悪な欲求に負けやすい。
そのような観点でclang++が吐き出したエラーメッセージを眺めると、上記したメッセージの後に、
下記のような出力を見つけるかもしれない。</p>
<pre><code>    logger_0_global_ut.cpp:13:15: note: &#39;operator&lt;&lt;&#39; should be declared prior to the call site
    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, App::Ints_t const&amp; ints)</code></pre>
<p>clang++は「LOGGERの前にoperator&lt;&lt;を宣言せよ」と言っている。
実際そうすれば、clang++でのコンパイルも通り、単体テストもパスする。
しかし、それには下記のような問題がある。</p>
<ul>
<li>operator&lt;&lt;(std::ostream&amp; os, App::Ints_t const&amp; ints)
という名前空間Appローカルな宣言をグローバル名前空間で行うことによって、
グローバル名前空間を汚染してしまう
(このコードは名前空間を正しく使うことに対しての割れ窓 (「<a
href="term_explanation.html#SS_19_21_1">割れ窓理論</a>」参照)になってしまうかもしれない)。</li>
<li>例示したコードでのoperator&lt;&lt;(std::ostream&amp; os, App::Ints_t
const&amp; ints)の定義は、
単体テストファイル内にあったが、実際には何らかのヘッダファイル内で定義されることになる。
その場合、ロガーのヘッダファイルよりも、
そのヘッダファイルを先にインクルードしなければならなくなる。
これは大した問題ではないように見えるが、
ヘッダファイル間の暗黙の依存関係を生み出し将来の保守作業を難しくさせる。</li>
</ul>
<p>以上述べた理由からこのアイデアを選択するべきではない。</p>
<h4
id="operatorをlogging内で宣言する">operator&lt;&lt;をLogging内で宣言する
<a id="SS_13_1_6_3"></a></h4>
<p>前節でのグローバル名前空間内でのoperator&lt;&lt;の宣言はうまく行かなかったので、
同様のことをLoggingで試す。</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/app_ints.h 6</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">Ints_t</span> <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb48"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_logging_ut.cpp 10</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Logging <span class="op">{</span>  <span class="co">// operator&lt;&lt;の定義をLoggingで行う</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> App<span class="op">::</span><span class="dt">Ints_t</span> <span class="at">const</span><span class="op">&amp;</span> ints<span class="op">)</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sep <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> i <span class="op">:</span> ints<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>            os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>exchange<span class="op">(</span>sep<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Logging</span></span></code></pre></div>
<p>動作はするものの、当然ながら結果は「<a
href="template_meta_programming.html#SS_13_1_6_2">operator&lt;&lt;をグローバル名前空間内で宣言する</a>」
で述べた状況とほぼ同様であるため、このアイデアを採用することはできない。</p>
<h4
id="loggingloggerset_innerints内でusing-namespace-appを行う">Logging::Logger::set_inner(ints)内でusing
namespace Appを行う <a id="SS_13_1_6_4"></a></h4>
<p>Logging::Logger::set_inner(ints)内でusing namespace Appを行えば、
意図通りに動作させることができるが、App内のロギングは名前空間Loggingに依存するため、
AppとLoggingが循環した依存関係を持ってしまう。
また、LoggingはAppに対して上位概念であるため、<a
href="solid.html#SS_8_5">依存関係逆転の原則(DIP)</a>にも反する。
よって、このアイデアを採用することはできない。</p>
<h4
id="ints_tを構造体としてapp内に宣言する">Ints_tを構造体としてApp内に宣言する
<a id="SS_13_1_6_5"></a></h4>
<p>App::Ints_t用のoperator&lt;&lt;がLogging::Logger::set_inner内でname
lookup出来ない理由は、 これまで述べてきたようにApp::Inst_tの<a
href="term_explanation.html#SS_19_10_6">関連名前空間</a>がAppではなく、stdになってしまうからである。</p>
<p>これを回避するためにはその原因を取り払えばよく、
つまり、App::Inst_tの<a
href="term_explanation.html#SS_19_10_6">関連名前空間</a>がAppになるようにすればよい。
これを実現するために、次のコードを試してみる。</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_struct_ut.cpp 10</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span>                     <span class="co">// Ints_tの宣言はApp</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> <span class="dt">Ints_t</span> <span class="op">:</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">{</span>  <span class="co">// エイリアスではなく、継承を使う</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> vector<span class="op">::</span>vector<span class="op">;</span>           <span class="co">// 継承コンストラクタ</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// App内</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> <span class="dt">Ints_t</span> <span class="at">const</span><span class="op">&amp;</span> ints<span class="op">)</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sep <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> i <span class="op">:</span> ints<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>            os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>exchange<span class="op">(</span>sep<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>上記のコードでは、</p>
<ul>
<li>App::Ints_tをstd::vectorからpublic継承</li>
<li>using宣言によりstd::vectorのすべてのコンストラクタをApp::Ints_tに導入
(「<a
href="term_explanation.html#SS_19_5_4">継承コンストラクタ</a>」参照)</li>
</ul>
<p>としているため、エイリアスで宣言されたInts_tと等価である。
C++03では、<a
href="term_explanation.html#SS_19_5_4">継承コンストラクタ</a>が使えなかったため、
上記のような構造体を定義するためには、
std::vectorのすべてのコンストラクタと等価なコンストラクタをApp::Ints_t内に定義することが必要で、
実践的にはこのようなアイデアは使い物にならなかったが、
C++11での改善により、実践的なアイデアとして使用できるようになった。</p>
<p>実際、名前空間の問題もなく、すでに示した単体テストもパスするので有力な候補となるが、
若干の「やりすぎ感」は否めない。</p>
<h4 id="operatorを使わない">operator&lt;&lt;を使わない
<a id="SS_13_1_6_6"></a></h4>
<p>色々なアイデアを試してみたが、これまでの議論ではこれといった解決方法を発見できなかった。
「<a
href="https://ja.wikipedia.org/wiki/%E3%83%8B%E3%83%BC%E3%83%90%E3%83%BC%E3%81%AE%E7%A5%88%E3%82%8A">バーニーの祈り</a>」
が言っている通り、時にはどうにもならないことを受け入れることも重要である。
LOGGERの中でname
lookupできる、エイリアスApp::Ints_tのoperator&lt;&lt;の開発をあきらめ、
ここでは一旦、下記のような受け入れがたいコードを受け入れることにする。</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/app_ints.h 6</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">Ints_t</span> <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb51"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_no_put_to_ut.cpp 10</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span>  <span class="co">// App::Ints_tのoperator&lt;&lt;とToStringをApp内で定義</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> <span class="op">{</span>      <span class="co">// operator&lt;&lt;は外部から使わない</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> <span class="dt">Ints_t</span> <span class="at">const</span><span class="op">&amp;</span> ints<span class="op">)</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sep <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> i <span class="op">:</span> ints<span class="op">)</span> <span class="op">{</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>            os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>exchange<span class="op">(</span>sep<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ints_tオブジェクトをstd::stringに変換する</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// この変換によりロガーに渡すことができる</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToString<span class="op">(</span><span class="dt">Ints_t</span> <span class="at">const</span><span class="op">&amp;</span> inst<span class="op">)</span></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> inst<span class="op">;</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> oss<span class="op">.</span>str<span class="op">();</span></span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>当然だが、恥を忍んで受け入れたコードにも単体テストは必要である。</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_no_put_to_ut.cpp 44</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ints <span class="op">=</span> App<span class="op">::</span><span class="dt">Ints_t</span><span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ToStringのテスト</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;1, 2, 3&quot;</span><span class="op">,</span> App<span class="op">::</span>ToString<span class="op">(</span>ints<span class="op">));</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// LOGGERのテスト</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>    LOGGER<span class="op">(</span><span class="st">&quot;Ints&quot;</span><span class="op">,</span> App<span class="op">::</span>ToString<span class="op">(</span>ints<span class="op">));</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> line_num <span class="op">=</span> <span class="ot">__LINE__</span><span class="op">;</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> s <span class="op">=</span> Logging<span class="op">::</span>Logger<span class="op">::</span>InstConst<span class="op">().</span>Get<span class="op">();</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> exp <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span>log_str_exp<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span> line_num <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;:Ints:1, 2, 3</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)};</span></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>exp<span class="op">,</span> s<span class="op">);</span></span></code></pre></div>
<p>上記コードから明らかな通り、App::Ints_tのインスタンスをログ登録する場合、
App::ToString()によりstd::stringへ変換する必要があり、残念なインターフェースとなっている。</p>
<h4 id="ints_tのログ登録のまとめ">Ints_tのログ登録のまとめ
<a id="SS_13_1_6_7"></a></h4>
<p>製品開発では、満足できる仕様の関数やクラスが作れず、妥協せざるを得ないことはよくあることである。
このような場合、将来、良いアイデアが見つかった時に備えて、
妥協コードを簡単に修正できるようなレベルにした後、捲土重来を期してさっさと退却するのがベストである。
ただし、漫然と過ごしても良いアイデアは浮かばない。
時間を作り、関連書籍やウェブドキュメント等を読み、学習を継続する必要があることは言うまでもない。</p>
<h2 id="nstdライブラリの開発">Nstdライブラリの開発
<a id="SS_13_2"></a></h2>
<p>「<a
href="template_meta_programming.html#SS_13_1_6_6">operator&lt;&lt;を使わない</a>」で導入したコードは、短いながらも汎用性が高い。
このようなコードをローカルなファイルに閉じ込めてしまうと、
コードクローンや、<a
href="term_explanation.html#SS_19_21_2">車輪の再発明</a>による開発効率の低下につながることがある。</p>
<p>通常、プロジェクトの全ファイルから参照可能で且つ、
プロジェクトの他のパッケージに非依存なパッケージを用意することで、このような問題を回避できる。</p>
<p>ここでは、そのようなパッケージをNstd(not standard
library)とし、名前空間も同様に宣言する。
そうした場合、この章の例題で使用している名前空間の依存関係は下記のようになる。</p>
<!-- pu:deep/plant_uml/template_dependency.pu-->
<p>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAagAAAB0CAIAAABfWzF3AAAAKnRFWHRjb3B5bGVmdABHZW5lcmF0ZWQgYnkgaHR0cHM6Ly9wbGFudHVtbC5jb212zsofAAABQWlUWHRwbGFudHVtbAABAAAAeJyFkUtvwjAQhO/+FStxgUNQCgWhqAfa0iKlIUW8enaSrXExduTYIP59HR4ltKW9zrczs6vtF4ZqY9eCEI2poZIJhMJkUBOcLc0OhVDbCorPLBEWKyRSjHHJjpBpRFmh93kOtZzLVUUbCpVQAbXtkhskpEy+83Tp9o49+4oL/avlsNmh5mLi3HQhn8oSQdMVIfH/qfGV2Piv3FPSL74f6Ju1nLzG+iiz/ZPGgkozH0WwQV1wJeGm2fJbnaZff8MMQirB74HfCtqdoN2FcDqDEjdIfTiOoFBWpwgZL4zmiTXO3yAh3VCYWGn4GgN4zVGGg5eTAE9yw7WSa5SGhIvReaB76z1wA1PUbhNYjMgA36kVxjlSlbk7A5jPnr0eidyzLWUu+4OSR+Vy9S6AcEw+AQHm0gWJO8yMAAAq1UlEQVR4Xu2dBVgU6RvAVUrpDuFERcVGRezAQsQOzLPOBOxTkTJIRUJF5fQsxAJUVE5UFEEJpbtFECmlRTrm/w7j7X9vllhld9n4fs/7+Mx+3zezMyv72/ed7IYhEAgEj9GN3IBAIBDcDhIfAoHgOZD4EAgEz4HEh0AgeA4kPgQCwXMg8SEQCJ4DiQ+BQPAcSHwIBILnQOJDIBA8BxIfAoHgOZD4EAgEz4HEh0AgeA4kPgQCwXMg8SEQCJ4DiQ+BQPAcSHwIuiguLs7KyoqIiAgICPDw8LjxL1ZWVsc7wtXVlTLe398flpCZmQlLa25uJr8NAsESkPgQOJWVlfHx8c+ePQM3gaoMDQ1XrFgxbdq0vn37SkhIdOvWTVpaGqbHjh2rra29cuXKTf9ibm5O9hwNO3fupIyfMWMGLKFfv36wtO7du8OSVVVVNTQ0Zs+eDb0mJiZOTk7u7u6BgYFgRvJaIhAMAomP5ygoKHj16tXFixcPHTqkr6+vpaUlKysrIiIybNiwuXPngn2OHj16/vx5T09Pwj7l5eXkRTCU7OzsmJgYPz8/cK6Njc2+ffvWrVs3derUPn36gBbBj9OnT9+wYYOFhYWbm9v79+9LSkrIi0AgfhIkPi7n48eP3t7eJ0+eBHeA4yB9k5eXh5wLsjBohKI1LCzs69ev5NnYA6iFwbxQGhN56Nq1a2ETJCUlwdQTJ07cvHnzqVOnnjx5Auokz4lAtAsSH1dRW1sbHR199erVvXv3QqEKmlNRUVm0aBEkd9AI6VJZWRl5Hg4ETB0SEnL58uWDBw/Onz9fWVlZXFx8woQJBgYGLi4ub9++/fbtG3keBIIKJD6OJyUl5ebNm7t379bU1BQWFtbQ0IDkzsnJCepZ3qkKQejgO7CeoaEhGBAq9yFDhqxZswY+ByjYkQcRJJD4OI/KysoXL15YWFjMnTsX6j41NbXVq1c7Ozu/e/eupqaGPJongRo5Pj7ezc1tz549UBQTHty0aZOrq2tsbCw6moxA4uMMiouLvb299+/fP3bsWFFRUW1tbXNz8ydPnvBOTtcZwHRxcXFQGv/xxx9Dhw4VExObNWuWqampj48Psw/dINgTJD72Bb6TDx8+NDIygu+quLi4np6enZ1dSEhIXV0deSiJ2jqspvZHVFZh1TU/phsaySN5EvhgfX19jx07pqOjA78iGhoau3fv9vT0LCwsJA9FcClIfOwF1Kr+/v6QjIwfPx4SE11dXQcHh+jo6B/VWU0dVl6JFZVi+V+x7DwsNQtLyMCik7H38dibSCww4ke8i8NbiIhMwsISfkwHR/8YAIOJlpgULOkDlvEJ+5SPFRZjZd+wqhqe8mNjY2N4eLijo+PixYulpKQGDRq0ZcsWd3f3vLw88lAEF4HExxakpqY6OTnNmTMHZDd58uSjR4++eR1Q97UEy/uCWykhHQtPwG0FRgNVJX7A0rJx8RUUYcVlWEUlns391H4rGEzkgKBReJfcL9jHz7hGY1PxNwqKxhUZlYy35BTgb1FdS14CG1BfX5+VlQXaCggIIE69pgay4+PHj588eZJ46ebmFvAv6enpbV03Eh8ff+HCBX19fRkZmcGDBxsaGt6/f7+0tJQ8DsHhIPF1GVVVVU+fPjUwMOjXr5+qqur2LVseu9+uTEjF4tOx0FjsbRSerCVlYll5uJugYm1qIi+CeUDS9+079qUEf3dYh4hE3IbE+nwqwErKWZYVfvr0KTAw8Nq1a/BjsGnTpgULFkyZMqVv374iIiL8/PwwoaWlpa2tDakx5eIQAhMTExCfsbEx8XLDhg3a/zJw4ECYsVu3bvLy8iNHjoTfm00tl6C4uLh4eXnFxcVVV1fDW8fExEC6raenB79GY8aMOXTokJ+fHzp8xB0g8bGa7Oxs+ILp6OiIi4vPnDbN3sQ8+dEzPMOCbC4xA8vOx4rL8VyM3YD86Hs1ruDMz3hiCCsMlTKUyZ8LsYrvP5dvtkFDQwNI586dO+Cs5cuXDx8+XFBQUFJScuzYsatXrwYxQeL25MmToKAgyNcqKyvJ8/88hYWF8I4vXryAJVtaWhoZGcH7jhgxQkhICMw4b968vXv3nj9//vnz5/C+MGDq1KkgQfi/AyEmJiaSF4fgHJD4WERkZCTkLKM0NORl5f5YsfLh6bOVfkG4QaDGhFqyvoE8A/tTVYOnhFCJQyYYFIXX4OBESAYb6c1MIbEKDQ09c+YMpGOjRo3q2bMnyG7lypXgOHd393fv3hUVFZHnYRUZGRmQjzs7O0NKDkmigoKChITEjBkzdu/eDanfmjVr1NTUlJWVN2/eDKZGtTDHgcTHROrq6qA4Mti5U6V370H9+htv3BJ04VpzfBq+4+wbY7IkdgFkV/YNT1dB5VAURye3SLCCtjwHoUB6tWPHDjCdsLCwpqYmqOTKlStRUVFsXkWWlZX5+/s7OTmtW7cOskIpKSkouqFMhlpbVFQUpq2traE6Js+GYEuQ+BgPfIEfP368Yc1aSXHxqWPGnjLYm+7j90N2vEBTM1b+DT/2QkgwLi32+Svnk6eWLVsGeVOfPn0gXTp37hykwB2fl8PGQK0dEBBgb2+/dOlSRUVFWVnZQYMGycnJycvLb9my5f79++hyEXYGiY9hVFVVed7zWLNsuYSY2EzNcReNzfNDI/HSjybr4QVSUlLOnz+/fNkyaSmpwf3VDJavunPC7lNACL6XsJFFB0ZYycePH2/evAmZ7MCBA6FmBwPCv+PHjwfFQxd5NKKrQeLrLOC7Ozfdl+nNlxAVmztu4pXjNkXxKex4dIL5lJaWenh4QL4DaV3fvn1h4tatW/n5+T+6a+qwvK/4MWtIAyEZhBSYLc+S6TxFRUVeXl7bt2//7bffBAUFwYBKSkoGBgbBwcGtnkODYD1IfL8I1LMP73msWrgIfKc3ccoNu9NlH7Lo36/PTURHR1tZWU2aNElMTGz+/PmQ6KWlpZEHUQMpMCTCadn4gezwBOxjLn4qIpdSWFh4+/Zt+FjExcUJCWpra0ML/F6ShyJYCBLfz1FfX+/r/WjD8hWSUM+OHXfFxr7k4yeuOkxBH9XV1Y8fP966dauysvKgQYMO7Nrj/+BRXUY2lkZ1MUmr14pEJOLpXmoWfvQj78uPM7ShMTQWV2FpBRd/mFD+Hz9+fOjQofwtDB48+NixY1++fCGPQzAfJD56CXz+YtvqdTISklNHjXE5ZlmYkUkewQNAEXf9+vXFixZJiIvPmjzljLH5By8f/FyWyCQsueVc6/yvLReTfCdfHUy5VuR7NX78t7AYL3XTP2Fxabjy8CUkYtEpWFg8FhKNaxFSQu41IJQL3t7eurq6kCN3795dUVFx06ZNCQkJ5HEIpoHE1wEJkVFHDHf1UVQaNVD9lLFxYrTfh9LnqcWPovIvkSKt+El2ecDXqqSaBm47qysnJ+eMo+O0iZMkxMRWzp7rbmFdHhKJl6hFZfgNETpPYyN+8dznQvzKkPdx+FUrITH4v5A8crUBsZY0cOfOnZA4gwFFRUX19PSePXtGHoRgNEh8rZOblX3a/NjIQep9FBR3b17u7r3jRuw0tzht75TfX308Eph9nFZ8gdnHXnzY/zBl3c24mTDycerm4By7lCLv4uq0Zowj9/1lfvhw8tiJ8aNGy0pK/TF/sa/rldqPn/GUjdnU1eOnRqd8bNFfJG7A2DQ8keRkA1ZUVERFRREPqIOCF4pcytV1Bw4cIFqWL1/et29fPj4+ISGhSZMmQXKNDoYwCSS+/1BZUXHF2Wm6lqa0uPiqRVOcLy9//dE0/ot73rfw2sYK8ui2qWkoy6+MSvx6NzD7qFey/rWYyU8zDKILrhRURjc1s/tFGh8zMmxNzUcPGaokI7tzxSr/O56NZT+x7Qympg6/c0x4AhYYie8ojEnBb07DCZSWlj5+/NjMzGzhwoVKSkqQzY0ePVpfX39Ty+OcwHSU+yk4OjrCS1NTU+iaM2eOmpoaPz+/iIgIGLBHjx4DBgxwcHCoreXOI+BdBRIfDvyuPr1/c+X8WZKiorrTNJ2dtybkeVXUfiaP+1XqGr9/Kn/7PtfZO2X99dgpzz/sS/rqycDlM4TsjA/25se0ho1QkJYxXL0u0PtJM2Re7ENTE5ZfhO9MfEPkgKlYCds9P6SkpMTT0xNK1yFDhoiLi+vq6kIe9+jRo0+fPpGHtkt1dXVERMRff/0FSwADEs/hlJOTMzQ0RHdOZQi8Lr7YyIC921apyMtrqKsdM9mYlPGS2RlZbUNFZumLN9knbsXP9UhaCjbM/xbZ1Nxl5/QWfs51sbGbPGqMnKTU9pVrXj983NTA3E+gs0D1l//1/waMz8BvXdN1NDU1hYSEQBI3btw4MTGxBQsWODs7x8bGksd1guLiYltb2379+kECCAaEd4GiODc3lzwOQTc8Kr4vhTn2lnu1hg9WlJHZuXHx27ce8H0iD2I+RVXJUfmXH6VucIvVDsiyyCx9Wd/Eou9wRWnp9bMucyZOlhQV27B42TOP+w317JTf0Unul5YqOALfG5iahdfFrOL79+9eXl4bN26UlZXV0NAwMTEJDAxsYP5vxj///KOpqSkgIAAG7NWr1+zZszMzefEEg07Cc+ILeOm5ehFe0i6eM/mum0N9PVtcGF9V/zWl6MGzjF03Yqe9zDycXR7Q1MwsDQX4PF23YDH4btnsuZ5XrtVwwZm0jU34WYHv4nADhiVghUx8DklVVdXdu3eXLFkiISGho6Nz8eLFnJwc8iCWEBUVNW3aNCEhITCgsLDw5s2bOfraZxbDK+Krqqo472iiOUxdVVHR/ODm/NwM8gj2oK6xMrXY2yd92824GcE5toXfGVYxFX7+fMrEfOBvqiMHDjpnZVP6tcvu+MREqmrwS+KgBA6Kwk+HbmDYwXT8Qp2HD1evXg2+mzdv3o0bNyoquu6Az3+Jj48fO3YsUQWrqKjcunWLPAJBA/eLr6Ag68DO1XJSkjMnjHG/dqqxienFCEOorCuIKbjmlbTibuLCqPxLVfXF5BF0E/rSH5I7KTHxbSvXhAUEkru5kqw8vPiFBDA6BbdhJwgNDYV6VlJScubMmX///Tc7P9bu7NmzCgoKoD9+fn4ogRlyr1ZuhZvFV1SUd9Borayk5Lqlc2Ki/MndHEJRVUpIjr1bnHZg9rGS6p9LVF888NYeO66/sspFO/vvFbx3l6TSb/gFIW8isJhU7CfLQLAGlLEaGhrq6upOTk4c9AC28vLyFStWCAgIdO/efcyYMRy05qyEO8VXWlp4ZO96yPJWLZyZEBdE7uZAahsrYguv34qf65th9LkilNz9X5qbmx9cdxszeOhwtYG3XS81Mn+PO1tT/h3f8QfZH1TBdHwUcXFxBgYG0tLSoI9Xr16RuzkHCwuLnj17QgI4ePDglJQUcjdvw4XiO2t/WEFaernutOhIDv6rbZWm5vr0Ep8HyavvJ69MK/Zpbm5lH5bfw0fguwkjNB7fukPu42VKyrF3sfjuv5TMtu6Q+Pr1a6gQVVRUrKys/n83LQ7n3LlzoqKixO4/dINoClwlvtCgJxM0hmoOUw/09yL3cRe5397/k77DM2lZZulLSmNydIzu5GmD+qgi5bVJYQl+w5igaPySOCp8fHwmTpwImdGNGzdYcEoK67l3756kpCTob9SoUegUaIxrxFdSXLD990VQ2zpY72s1D+JKcivee6f8/jBlXWL6851r1slLSZ+1tK7/yZ1ZvEhaNp76RSU11dR5enpqaGiADry8vJrayAS5hgsXLggKCnbv3l1fX5/cx2Nwg/iePLj8m4L82sWz2fYkFaZyzv6InJTUH2t10j8Fk/sQbVFT4+dyWWPAoImjNf/55x9yL1ezZcsWcB8/P7+trS25j2fgbPHV1lYZbV7WW07W89YZch8PkJ2WMXfSFM0hw2LfvU8tfnQnQe9l5uHKugLyOMR/iYuL09HRUVdX9756HU/9QuM6ecoLx1FdXT1hwgSofKH+jY+PJ3fzABwsvsiwF6PUB+hOG5f3ud0bnXMjzc3N523s5CSlTpqYUS41a2yui8r/+2bczJiCq8y78IOjyc3N3bx5s6KiIhR9P/blQXkblYzrL4fnfjDS09NlZGRAf4sWLSL3cTucKr4LTqaykpKnrfaSO3iA/E+fZo6bMHnUmLS4Vn6rv9Xl+WUe8Ehc0uFZLzxFfX29nZ0dfM/NzMxauejicyHuvsiktg74cjFHjhyByldISMjX15fcx71wnvga6usMNi7pr9L7fQhv7ZoheO71UElG1urPw+3vic+pCLmXuNgv82BlHZecltEZQkJChg8fPn/+/KysLHIfhZoavOZ9G4Wf+MJjlJeX9+3bF1I/LS2tRm58+CctHCa+goKsGeNHaY8bBRPkPm4HSloTg12/KSi+8aXr1uRQ7UYX4JVvwpfbHHoL6M5TWlq6bds2FRUVLy/6znBKycJPdU7LJrfzAK6urnx8fPz8/I8ePSL3cR2cJL7IsBeQ6O3csBiSPnIft5OX/QlqW72p04vyf25X1LfaXJ+0bY/TNpfX/ty9MLmAe/fuKSkp7d69u5Xath2KyvCyN4IXy966urohQ4ZA6jdv3jxyH3fBMeLze+quIC19zsGY3MEDRLx5C4me7WGTX30CQ3Pi13s342bFf3HnkdQPEr1Vq1YNHTo0PDyc3EcPNXVYaAx+qjOPHe0lsLGxIZ58xMUXunGG+O7ccJSTkrzn7kTu4AHuXvpbXkq68xdjfKvL/Sd9++PUTeU1XF7HPX/+HGrb/fv319R0TlsxqfiDPgq58f5dHZGTkyMtLQ36O3ToELmPK+AA8bk4GEOu99KX5+4yBvmdxe59fZV6x4dFkPt+keakr56Q+iV86axG2ZOqqipDQ0NVVdWAgABy36+RlYvv8svg8p+KtoCsGcre/v37c98RD3YRX1FRHrmpBSvTnaqKilHh/78ilcuoKG39mWG11TUrdedPHaP5NY/Bh2Uh9XuUuvHZh93VDex7a7l2aOtLGBsbO2jQoI0bN/7cHr0OKSnHd/nF8ty5ogQvX77k5+cXFBTkshscsIv4zjuakJswzNJ0Rz/l3inJYeQOLsL9vCu5qcWGM7TGg/jqmPNQwabmxoi8C7fjdTnuXL9v3761ms1dunRJXl7+7t275A6G8L0Kv69BWAIPHu7AWm5NqKioCGWvpaUluY9jYRfx6U4dR2o5fmQbWC8thVFVHpuyaMYsUktBTs5o9SG71m9s/0y9zpNfGXknQe/dZycOuszD3Nw8ISGBugW+lmvXrtXQ0EhLY2ZSVteAhcZiwTE/e0NTrmHx4sVQ9o4fP57cwZmwhfigzhUSEKBuOWa8tb9K7/S0SOpG7gMyOyEBQeqWjISk/soq1gdZdPC6trHCL/Pgg5Q1HHGyS3Z2tri4OPUjdeLi4tTV1bdv397Z4xj0AL9DEUn40zy+c/7jmX6J69evQ94H/wVccFdnthDfyeO74ceE8tLa3EBNRTkjPYpqCHdy4+x56g1PCI/sLSt3xZHVN1xILvJyj5udVfaa3MFmTJ06dfDgwZSXt27dgvL29u3bVEOYT0LLw4zKee8+/i3k5OSIiIjw8fG9fMnZu93ZQnzDB/SnfP/P2h/uo6jA3fv1KIwbNoKy4VFBIYoysh5/X/3vEBZRVJV8N2HB+9wzXfho8/aJioqCz2rFihVYy/GNAwcODBgwIDExkTyOBaRk4u4raf2oFC+gpqYG/xccvcuv68UHdS4/Hx/x/b/2l5WSrAz33TK+VaDOFeDjJzb8vX+AgrTMo5usTV7+S21DxbOM3T5p2zrzRDfmMWzYMH5+/qNHjxYXF8+ePVtXV7esrIw8iGVkfMLdx8wH+LI5y5Ytgz9dPT09cgeH0PXigzq3e/fu8CF63XGRl5IKCnxAHsGlnLOyJTY86LmfvJS0rwd9F5Myl+ao/L9vx+vmV7LXfgYfHx8hISE5ObnTp0/369fvyJEjzD7y0zHEKX55X8ntPIODgwP8AauqqrZ1ghE70/XiGz6gX7fW6Cko+PsynYj3z8kzcAtD+uIFPi2w4dtXrU2O7rLTpnIr3t+Kn5P0lR1EjAPfK2VlZfhkxMXFe/fufe/ePfKIruJzIe6+zxy/p/+XCQoK4uPjExER+fqVw34Aulh8lDqXgoyEhKSY2CGjddx9e9HykpIePXpQb7ggv4Bwz56G6zb87G0ImMG3ulyvZP23n6ybmrv+yTuurq7w1YKPiEiQqYE0UEdH58KFC9nZ2eTZWEMer7uvsLBQWFiYn5+fs85w7mLxnTy2i/hrFuDnlxITU1NRdj55sKqKoWfesyWmhviBbAD0JyYs0kdR6fJpx9pq5p+TQTf1TVV+mQd80rbWNHTlXvxv374RjwejfFwgQVFR0YULFz548OD79+/kGVgPz+d9kJIrKSnBF5nee3+xAV0sPqhzBQUERIWFp2tpeN1xIXdzLyryCr2EhMSEhWeNn+j3kG1vf9YcmX/xbsKC4uouy77NzMwEBQXBdL169VJVVT106FBISMiv3qWGafC8+wBNTU34ZTpx4gS5gy1pU3weHndsbY87ONgyL+ztj8E3f8W8qbbW+y5dulj/77MjWENtXd3pcxfMre26IE5YwYYvnaVjamxGaXQ6z+pPoKa+xvairfEp4/bD6sami8GTTRwO0nYxOwxNDYV6Can0VdFZomNwxIB2ACWOnDpy+z6rj4l7uN+yNbNwOG4J4f+3W1NA+AXbk8RL1sSlM2dZ/DcDb3fp0iWHNtDQ0AD3WVhYkDu6FFhh2k+pdfEFBb308bmGYdlMjdycN3mf3xLT+fnhpqYHqU/KZyrVNbUbdh24GhT7IDWf9XE7OO52SDypEVZmx37WfQJVtVXLDy63SrE6U3qm4yhxILewJE4knbDPtadtbzWM7hk9DHxI3k6mEfTkqc+ps3ii13WR//C56U4jlv3NwBuZmprm57d314ycnBxyU1cDKwyrTfqUulG/oGBvb9HcnEWrKqZGfn7k5cuXyavCHE6dO99V1msnYJVc/7pEXlfmYOlqSa/1OCScS5w3WW8ibyfTsN/7Z3NAOK2MWBz5D59fdjlPXjnmAF/P9q3HtsBqk9zSjfoFBQcHc1oxsSBOn7YnrwpzMLa0ofUOO4T1yVPkdWUO++z20bqD02Od9TrydjINh10HaDXUJXH6hBV55ZjD6dOnyU2cA2nlu1G/oNBV4nNwYNEna2xpSysddgjWie/kPlpxcHrwpvgcLK3JK8ccHBwcyE2cA2nlu1G/oIDE11WBxNeZQOJjKkh8zAokPiS+zgQSH1NB4mNWIPEh8XUmkPiYChIfswKJD4mvM4HEx1SQ+JgVSHxIfJ0JJD6mgsTHrEDiQ+LrTCDxMRUkPmYFEh8SX2cCiY+pIPExK5D4kPg6E0h8TAWJj1mBxIfE15lA4mMqSHw/HW5ujhERT2jbSdGO+IqKMEdHLCWF3P5r0CO+q8GxF/xC76fkUTe6vnp/JzaTdnCHsfvkWfv7z2jbSdGO+GoayuK/uJfVZJE7fgl6xGeZammTYUPbzrbRnvjqG/DbRlUx7I6HdIqvwf991GV32nYGRjviKyoqcnR0TGHQ14Z+8TU1NYWHhz98+DA0NLSh4f/3sr1161ZISAjVwFagZwwJemZhovjKyuJpG4mYPHmsi8sJ2nZStCq+5GRs/XpMRgYLDCR3/TL0iG+Czvxu3brtOHGKulFMUsr879u0gylxMzyVthFi8BitrRYdXyDcqvjKaj4GZp9wi9POr4wk9/0q9IhPY6HGlK1TaNsZEr+N+o3hC29dfCC7tGwsJAYrY+QzIekU333LU/BXFOZ6g7aLUdGq+JKTk3///XcZGZlAxn1t6BRfWFiYurq6nJzclClTlFt4/frHk0tnzZplZ2f33+Fk6BlDgp5ZmCU+OzvjXbs20rYT8Wvi8/PDJk/GunXDhIQYaT2MbvGN1Z7TS1TsUkAkpbF98f1+wHTeus207Q9+VXy5Fe//ydhxOWrMlejxDLQexgbi+8Ptjz2+e2jbOxNk8ZVWYHFpuB3eROLTDIVO8c3VmjhuyLBtC5bQdjEqSOLz8/ObNGkS2LZnz54MtB5G445WSU1NFRMTO3z4MHELPEj9bG1te/Xq9eHDB4w+Q9EzhgQ9szBMfGFhj58+vf7lSxRMV1Qkbtq0AuLz53cwTQyorEx688YzPPxxc3PWT4mvtha7ehVTVcVERLDu3TFhYQZbD6NbfKv3HJo0b9GoKdqURmrxnfR8anbJ/dq/d9a7FZk2Y+kqiMuBUTANLbejM6zcH57y8oV6+afE19hcl1b8+F7iYrfY6X9Ha15ltPWwzonPqcjpcNDhXT677LLsqNvtc+0P+B8wCTM5kXRiwdEFtpm27bRDEX0q5xQxwDrd2j7PHhb75+s/zSPN6Vlmq/FDfE3NWEERFpaABcfgamCC9TD6xJft8URMWBjSPfj3+/O3lPavj/yqngdVvwh+5XQx7uod6lna6WorCPHV1tZeuXKlT58+wsLCPXr0gH8Zaz2Mxh2tsnjx4nHjxpFukX316lUoujEaQzU2NsbFxcF6Uj8plBhTU1Pz6tWrmJgY0qKqq6uDg4OhnfrRbqwT35IlOpMmaa5cuUBOTvr27bNXrpzq3VsBYvr08TANA96981ZUlAPf6ehMnTFj4vDh6vSI78SJ8xYWmLg4rjxI9Pj48GlG//fh0Cm+FQb7rgbHiopLGNk6E40U8Y2bras+eixoUVxaZp/DBWgxtHaUlleAGKY1EabtPHwkZeXBdxqTpw8fP7nPwMH0iM/W0TIq/7Jb3HQobCHRg7gWPYnh1sM6IT7TcFPl4cp9xvQZuXCkiIyIvqM+0W70yEhcQRwafxv9G78Qv66xLuG1ttoHzxysZ6pHzNtvfD+dgzqK6orKI5QFhQXHrR3X/jLbip2ntmLZ+bjvQmJ/eIE51sPoE5/Fhq0rZ8yGCfXfVK8etqC0Tx6ucWTtpqF9+0E+qCgtA/9WPnvTYVdbceKIqZmZGeRZkFhBoicgICAhIcFw62E07qAFbCUoKHj9+nVyx79QGwpyQw0NDbDksmXLZGVlXV1dKWM2b948ZMiQuXPnQpk8Y8YMihb9/f0VFBTmzJkzcuRILS0tyhNXWCS+T59C4Selri4DptPTA4hde0ZGGyCIAfX1HwYO7GdqakS8DAi4x8/P36H4goMLhITqIcUD5RFB6I9JQSsdUoD4lm7f9aDluISIuPjfb2NgWlxKGsR3KSCie48eHgmfoOX8ixDKfj2oc4lS1zPxk5Jqv+U79hDtljfv8/Hxdyg+jyT/v8LGX47WJJRHVLiUaYYHrThIQSs+SMoUBipQGiFB4xPkM3psBNNyanJrXNacabkh6MBpAxdZLiLGtNVOEh849Mi7IzBtHGIM317zKDzva2veVsPz87Uq/2DcdDRqYEZ0KL7G12EqcvJPT56BabvtRhOGjqB0gd2UZGQ/3PGG6VIf/4Eqv+3XX9thV6sRfP4KuIbyMCZAVFSU+iVjIZviv2RkZMAYyMgoLZCXNbRAPAeZYihoHzx4sJGRETEsMjIStoLYFQhjwIOgRZiuqKgYOnTojh07iGGOjo7379+HCUgDJ0yY8NdffxHtLBIfKG/QoH76+vOpD9RSiy8+/jlsf2lpHKVXS0ujQ/FhLRnfvn14bQu5XrcW8UlJdWXGt3SbETE9ZvosrZk6MCEhIwviA+X17tt/ku5C0oFaivicnvjDJ+AWnkLpGjBiVIfie9CS8YXlnr8RO+VqzARCT9djprBPxgdVJ2yXdZo1pQXSsQnrJ8CEYC/BfX4/ljlp4yTKjG21k8Q399BcyjJ7ivc09DZsZ962As/4svKw4GjsbdQPNcAEQ49pUOhQfD52TtLi4oXeL4oev4y/dhdyhcQbHkQX2M3yjx2UkU5G+/sp9e6wq62AjG/37t1Ehdut5enD0tLSXZLxffz4EVaAcigDmD9/PqSfQkJCGzduxKgMFR4eDiO/fPlCGQl539atW4kxpqamlPZLly4pKipSXhYXF0MJfPPmTcgETUxMiEYWiQ+ipCTWzGyXsrLiuHEaWVkg+P+Iz9f3hqCgAPX4n93H5+KCwcYKCOAhKsp49/2s+C4HRvUSFTNxdZNVUiZKXbew5OU790orKA4cOdrVP4wYRhGf2eVb/AIC1Ev72X18qUXedxLmXYuZCO67GjOR4e77NfFt99gOKR51y9RtU4fpDoOJ6QbTof7d4bVj9bnVYK49T38cuGirnSS+pTZLKcsUkRaB8e3M21b8Zx/f+zgsqEV/byOZ4b4Oxbdo8jTRXsIy4hJE9BQU3LdiDdEFdnPZe4gy0vO4nRi+J7uDrraCso/v3LlzUAlCdQWigbyP4e7rUHyQ2UHF7eTkRGqHSpwkvqdPn0KKRz1m165dCxcupB5D4OvrC8U7MQ2mg+J3+/btNjY22traxsbGRDvrxEcElLRr1ixasUIP+6/4EhP9QOepqa+Jlw0NH1RVlekXHwVfX2zUKDz169WLwe77WfFB7LQ8rdinr1xvFeqjulDSTpm/ZOLcBcRLivjO/BMAn4DLs6Afw5JyYEb6xUcht+L9o7QNl9nmqK7JexPYLrMIM0qL2iS1aTumwcRKp5WQ/Wkbas/eP/tg4EHKgLba6RFfW/O2Fa0c1Y1Jwe3ABPe1L768+758PXrEXLlNaXE3swT91b0MxVrsZrb+D0qX1Zadw/r2J6bb6WorSEd1wSkjR46E/6ZevXox1n0dig+AslRFRYX0vGPI4EjiS05OhjVMS/v/Y0unTZu2Z88eYszBgwcp7aBRNTU1mMjMzIRZsrKyiPb169ezWnzZ2SG7dm0sLo6B6ePH9y1ePAcmDh/euXz5vMbGTEgG4eWkSZpz5kz99i0J6mJDw/Xi4qK/ID6C5GRIg7vmPD5q8UGMmDgFPnoQ31+vw0FwN94nQeOqXX+OmzWXGLBkqyHM5ZX0GfJB9dFjNSZNuxWVDnWx7tpNkDD+gvgIymo+vvp4pEvO4wPv7PHdQwmbDzaDpg8aOG0gcTxX30FfQEgAbHim5bw8rVVa2+5sg+KUuhZuq50e8bU1b1tBFh9BVQ2W8hE/4sFQ97UvPustBiPVBlK3VL8IFhcRuXfUFmuxm6So2Juzl2E61f2+rITkmV1/EsPa6Wor2jqPD4pH1p/HV1paqq6uPnHixNDQUEhCoTK9du0alN7EEQ9qQ82ePXvmzJnEgYuLFy/27NkT1pkYIykp6e/vD9MfPnyAOpeY5fPnz1DLR0REwPSLFy9gjKGhIbEoFomvsjJp+/a1oqIi8vIyI0YMTkmBVcyOifElDuy6uzvDy4KCiIULZ4uICCspydvaHgZREu3tR6viI2D9lRugtg2HLahboKRV7j/A+pb37eiMOSt/7yksIiEjqzpoyDnft8QAB++XxIHdvfYuV4Njx86YI9RLWEpOYd0BE1gaNNK+CylaFR8B66/cgDJWtp8sdYCPTmafnLB+goiMCESf0X0o++CgCpZTkxuhN2KozlBRWdHRS0Y7Fzu30z5+3fgVp1cQ845eOnrt+bWU94XFElVtW/O2Fa2Lj4C1V27MGTv+rwMmpMaDq37fOh8/oQ/sZrx2o47WBDlJKUgDT2zeQXlgWztdbUWr4iPokis3SkpKjIyMZGVliaxTT0+Pcrhjw4YNlCMS5eXlW7dulW1BS0vr3bt3RLu+vr6bm9ucOXPk5eXBmBYWFsSBEcDFxUVKSgrGL1iw4MmTJ6tWraJdbFswQHxENDV9rK1Np22nDihyf+oxle2Ij7HQI74O435y7r34bNp26oAil3TRW/vRjvgYCz3iaz8cvzhSpo/GHeUT5LNO/5GUQT7Yg6+HSZhJW+20S6ONX5i3PfExmvbF135QduTVvgyhv6utaEd8jIVO8VGorq4mN7UG7dO+CVp9XnBzc3Or7R3CMPExIzhLfMwIDhIfdYCehESEVtivOJ5w3DTcdNbeWTJ9ZU4XnG6rnXYJtPEL83Kc+Gijna62gm3Fx1Yg8eEg8TFWfGdajnvMMJoxfN5wjUUa883mU+5u0FY7PfGz83KK+I5t2vbitAtte/tdbQUSHz0g8eEg8TFcfOwQnCI+xgYSHz0g8eEg8SHxdRIkPs4CiQ8HiQ+Jr5Mg8XEWSHw4SHxIfJ0EiY+zQOLDQeJD4uskSHycBRIfDhIfEl8nQeLjLJD4cJD4kPg6CRIfZ4HEh4PEh8TXSZD4OAs6xWdBayUWBMvEd+joCVrpsEPYnrInrytz2GPVwS2eODHW26wnbyfTcNjdwb0DWBYOVjbklWMOHd4IgJ2hS3xnztiUlyfQiomp4eNzy9vbm7wqzOH67TsWl27Seqdrw/rq7Yes+gSu3L1icM+A1h2cGyezT+47vY+8nUzjjOnR8qcBtBpicficdvG+/4C8cszBw8PDx8eH3MoJwGqT3NKN+gWFiooyZ2cbR8djDg5HWRP29seDgt6Q14OZeL/wNzA7vtPsBJvEbvMTLwICyWvJTO4F3NtgtQHKQy6I9bbr99jvKSkvIW8k06goLnE2Peq4/7DDvkNdFfYHjINevCSvGTMJCgqyt7d34ChghWG1SRvSuvgQCASCi0HiQyAQPAcSHwKB4DmQ+BAIBM/xP181NSOoUIeuAAAAAElFTkSuQmCC" />
</p>
<p>このように整理された依存関係は、 「<a
href="programming_convention.html#SS_3_7">パッケージとその構成ファイル</a>」でも述べた通り、
大規模ソフトウェア開発においては特に重要であり、決して循環しないように維持しなければならない。</p>
<h3
id="nstdライブラリを使用したリファクタリング">Nstdライブラリを使用したリファクタリング
<a id="SS_13_2_1"></a></h3>
<p>すでに述べた通り、「<a
href="template_meta_programming.html#SS_13_1_6_6">operator&lt;&lt;を使わない</a>」で導入したコードは、Nstdで定義するべきである。
その場合、下記のようにさらに一般化するのが良いだろう。</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_0.h 4</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> vec<span class="op">)</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sep <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> i <span class="op">:</span> vec<span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>            os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>exchange<span class="op">(</span>sep<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToString<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> vec<span class="op">)</span></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> vec<span class="op">;</span></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> oss<span class="op">.</span>str<span class="op">();</span></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>その単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_0_ut.cpp 13</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> ints <span class="op">=</span> App<span class="op">::</span><span class="dt">Ints_t</span><span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="kw">namespace</span> Nstd<span class="op">;</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> ints <span class="op">&lt;&lt;</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1, 2, 34&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>        Nstd<span class="op">::</span><span class="kw">operator</span><span class="op">&lt;&lt;(</span>oss<span class="op">,</span> ints<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="dv">4</span><span class="op">;</span>  <span class="co">// 念のためこの形式でもテスト</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1, 2, 34&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;1, 2, 3&quot;</span><span class="op">,</span> Nstd<span class="op">::</span>ToString<span class="op">(</span>ints<span class="op">));</span></span></code></pre></div>
<p>勘のいい読者なら、このコードをLOGGERから利用することで、
App:Ints_tのログ登録問題を解消できると思うかもしれない。
実際その通りなのであるが、そうした場合、
std::list等の他のコンテナや配列には対応できないという問題が残るため、
以降もしばらくNstdの開発を続ける。</p>
<h3 id="安全なvector">安全なvector <a id="SS_13_2_2"></a></h3>
<p>std::vector、std::basic_string、std::array等の配列型コンテナは、</p>
<ul>
<li>operator[]経由でのメンバアクセスについて範囲の妥当性をチェックしない</li>
<li>範囲のチェックが必要ならばat()を使用する</li>
</ul>
<p>という仕様になっているが、
ここではoperator[]にも範囲のチェックを行う配列型コンテナが必要になった場合について考える。</p>
<p>手始めにoperator[]にも範囲のチェックを行うstd::vector相当のコンテナSafeVectorを作ると、
下記のコードのようになる。</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 10</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SafeVector <span class="op">:</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;::</span>vector<span class="op">;</span>  <span class="co">// 継承コンストラクタ</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">base_type</span> <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;;</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">size_type</span> <span class="op">=</span> <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span><span class="dt">size_type</span><span class="op">;</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>reference       <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>const_reference <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>このコードで行ったことは、</p>
<ul>
<li>std::vectorからSafeVectorをpublic継承する</li>
<li>継承コンストラクタの機能を使い、std::vectorのコンストラクタをSafeVectorで宣言する</li>
<li>std::vector::atを使い、SafeVector::operator[]を定義する</li>
</ul>
<p>である。単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 30</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> v <span class="op">=</span> Nstd<span class="op">::</span>SafeVector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">10</span><span class="op">);</span>  <span class="co">// ()での初期化</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">10</span><span class="op">,</span> v<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="at">const</span> v <span class="op">=</span> Nstd<span class="op">::</span>SafeVector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> v<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">10</span><span class="op">,</span> v<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>        ASSERT_THROW<span class="op">(</span>v<span class="op">[</span><span class="dv">1</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span>  <span class="co">// エクセプションの発生</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> v <span class="op">=</span> Nstd<span class="op">::</span>SafeVector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;1&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> <span class="st">&quot;3&quot;</span><span class="op">};</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> v<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">((</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;1&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> <span class="st">&quot;3&quot;</span><span class="op">}),</span> v<span class="op">);</span></span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>        ASSERT_THROW<span class="op">(</span>v<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span>  <span class="co">// エクセプションの発生</span></span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="at">const</span> v <span class="op">=</span> Nstd<span class="op">::</span>SafeVector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;1&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> <span class="st">&quot;3&quot;</span><span class="op">};</span></span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> v<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">((</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;1&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> <span class="st">&quot;3&quot;</span><span class="op">}),</span> v<span class="op">);</span></span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true" tabindex="-1"></a>        ASSERT_THROW<span class="op">(</span>v<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span>  <span class="co">// エクセプションの発生</span></span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><a href="exercise_q.html#SS_20_11_4">演習-std::arrayの継承</a></p>
<h3 id="安全な配列型コンテナ">安全な配列型コンテナ
<a id="SS_13_2_3"></a></h3>
<p>配列型コンテナはすでに述べたようにstd::vectorの他にすくなともstd::basic_string、
std::arrayがあるため、それらにも範囲チェックを導入する。</p>
<p>std::basic_stringはstd::vectorとほぼ同様に下記のようになる。</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 62</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> SafeString <span class="op">:</span> <span class="bu">std::</span>string <span class="op">{</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="bu">std::</span>string::string<span class="op">;</span>  <span class="co">// 継承コンストラクタ</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="dt">base_type</span> <span class="op">=</span> <span class="bu">std::</span>string<span class="op">;</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="dt">size_type</span> <span class="op">=</span> <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span><span class="dt">size_type</span><span class="op">;</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>reference       <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>const_reference <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>std::stringはstd::basic_string&lt;char&gt;のエイリアスであるため、
上記では、通常使われる形式であるstd::stringを継承したSafeStringを定義した。</p>
<p>この単体テストはSafeVectorの場合と同様に下記のようになる。</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 80</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> s <span class="op">=</span> Nstd<span class="op">::</span>SafeString<span class="op">{</span><span class="st">&quot;0123456789&quot;</span><span class="op">};</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">10</span><span class="op">,</span> s<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;0123456789&quot;</span><span class="op">,</span> s<span class="op">);</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>        ASSERT_THROW<span class="op">(</span>s<span class="op">[</span><span class="dv">10</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="at">const</span> s <span class="op">=</span> Nstd<span class="op">::</span>SafeString<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="ch">&#39;c&#39;</span><span class="op">);</span>  <span class="co">// ()での初期化が必要</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> s<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;ccc&quot;</span><span class="op">,</span> s<span class="op">);</span></span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>std::arrayでは少々事情が異なるが、
std::vectorのコードパターンをそのまま適用すると下記のようになる。</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 101</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> SafeArray <span class="op">:</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;::</span>array<span class="op">;</span>  <span class="co">// 継承コンストラクタ</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="dt">base_type</span> <span class="op">=</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;;</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="dt">size_type</span> <span class="op">=</span> <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span><span class="dt">size_type</span><span class="op">;</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>reference       <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>const_reference <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>ただし、この実装には問題がある。</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 122</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sa_not_init <span class="op">=</span> Nstd<span class="op">::</span>SafeArray<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;{};</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> sa_not_init<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>sa_not_init<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span></code></pre></div>
<p>上記コードでは、その問題が露見することはないが、以下のコードはコンパイルできない。</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 132</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::initializer_listを引数とするコンストラクタが未定義</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sa_init <span class="op">=</span> Nstd<span class="op">::</span>SafeArray<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// デフォルトコンストラクタがないため、未初期化</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    Nstd<span class="op">::</span>SafeArray<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;</span> <span class="at">const</span> sa_const<span class="op">;</span></span></code></pre></div>
<p>std::arrayにはコンストラクタが明示的に定義されていないため、
std::arrayにはデフォルトで自動生成される</p>
<ul>
<li>デフォルトコンストラクタ</li>
<li>copyコンストラクタ</li>
<li>moveコンストラクタ</li>
</ul>
<p>以外のコンストラクタがないことが原因である。
従って、SafeArray(std::initializer_list)が定義されず前述したようにコンパイルエラーとなる。</p>
<p>この問題に対処したのが以下のコードである。</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 146</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> SafeArray <span class="op">:</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;::</span>array<span class="op">;</span>  <span class="co">// 継承コンストラクタ</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="dt">base_type</span> <span class="op">=</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;;</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span>  <span class="co">// コンストラクタを定義</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>        SafeArray<span class="op">(</span>ARGS<span class="op">...</span> args<span class="op">)</span> <span class="op">:</span> <span class="dt">base_type</span><span class="op">{</span>args<span class="op">...}</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="dt">size_type</span> <span class="op">=</span> <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span><span class="dt">size_type</span><span class="op">;</span></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>reference       <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>const_reference <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>上記コードで注目すべきは、パラメータパックをテンプレートパラメータとしたコンストラクタである。
これにより、前例ではコンパイルすらできなかった下記のような初期化子リストを用いた単体テストが、
このコンストラクタによりパスするようになった。</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 181</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sa_init <span class="op">=</span> Nstd<span class="op">::</span>SafeArray<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> sa_init<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>        ASSERT_THROW<span class="op">(</span>sa_init<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="at">const</span> sa_string_const <span class="op">=</span> Nstd<span class="op">::</span>SafeArray<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dv">5</span><span class="op">&gt;{</span><span class="st">&quot;1&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> <span class="st">&quot;3&quot;</span><span class="op">};</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">5</span><span class="op">,</span> sa_string_const<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1&quot;</span><span class="op">,</span> sa_string_const<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;2&quot;</span><span class="op">,</span> sa_string_const<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;3&quot;</span><span class="op">,</span> sa_string_const<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">,</span> sa_string_const<span class="op">[</span><span class="dv">3</span><span class="op">]);</span></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">,</span> sa_string_const<span class="op">[</span><span class="dv">4</span><span class="op">]);</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>        ASSERT_THROW<span class="op">(</span>sa_string_const<span class="op">[</span><span class="dv">5</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>この効果を生み出した上記を抜粋した下記のコードには解説が必要だろう。</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 155</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span>  <span class="co">// コンストラクタを定義</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    SafeArray<span class="op">(</span>ARGS<span class="op">...</span> args<span class="op">)</span> <span class="op">:</span> <span class="dt">base_type</span><span class="op">{</span>args<span class="op">...}</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>一般にコンストラクタには「メンバ変数の初期化」と「基底クラスの初期化」が求められるが、
SafeArrayにはメンバ変数が存在しないため、
このコンストラクタの役割は「基底クラスの初期化」のみとなる。
基底クラスstd::array(上記例ではbase_typeにエイリアスしている)
には名前が非規定の配列メンバのみを持つため、
これを初期化するためには初期化子リスト (「<a
href="term_explanation.html#SS_19_5_3">初期化子リストコンストラクタ</a>」、
「<a
href="term_explanation.html#SS_19_5_2">一様初期化</a>」参照)を用いるのが良い。</p>
<p>ということは、SafeArrayの初期化子リストコンストラクタには、
「基底クラスstd::arrayに初期子リストを与えて初期化する」形式が必要になる。
値を持つパラメータパックは初期化子リストに展開できるため、
ここで必要な形式はパラメータパックとなる。
これを実現したのが上記に抜粋したわずか数行のコードである。</p>
<h3 id="初期化子リストの副作用">初期化子リストの副作用
<a id="SS_13_2_4"></a></h3>
<p>上記SafeArrayの初期化子リストコンストラクタは以下のようなコードを許可しない。</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 213</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sa_init <span class="op">=</span> Nstd<span class="op">::</span>SafeArray<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;{</span><span class="fl">1.0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> sa_init<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>        ASSERT_THROW<span class="op">(</span>sa_init<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>このコードをコンパイルすると、</p>
<pre><code>    safe_vector_ut.cpp:147:41: error: narrowing conversion of ‘
                                        args#0’ from ‘double’ to ‘int’ -Werror=narrowing]
      147 |     SafeArray(ARGS... args) : base_type{args...}
          |                                         ^~~~</code></pre>
<p>のようなエラーが出力されるが、</p>
<ul>
<li>double(上記例では1.0)をintに変換する際に縮小変換(narrowing
conversio)nが起こる</li>
<li>初期化子リストでの縮小変換は許可されない</li>
</ul>
<p>が原因である。これは意図しない縮小変換によるバグを防ぐ良い機能だと思うが、
ここではテンプレートメタプログラミングのテクニックを解説するため、
あえてこのコンパイルエラーを起こさないSafeArray2を開発する
(言うまでもないが、通常のソフトウェア開発では、
縮小変換によるコンパイルエラーを回避するようなコードを書いてはならない)。</p>
<p>SafeArray2のコードは、</p>
<ul>
<li>STLのtype_traitsの使用</li>
<li>テンプレートの特殊化</li>
<li>メンバ関数テンプレートとオーバーロードによる静的ディスパッチ(コンパイル時ディスパッチ)</li>
<li><a href="term_explanation.html#SS_19_11_1">SFINAE</a></li>
</ul>
<p>等のメタ関数系のテクニックが必要になるため、
まずはこれらを含めたテンプレートのテクニックについて解説し、
その後SafeArray2を見ていくことにする。</p>
<h2 id="メタ関数のテクニック">メタ関数のテクニック
<a id="SS_13_3"></a></h2>
<p>本章で扱うメタ関数とは、型、定数、クラステンプレート等からなるテンプレート引数から、
型、エイリアス、定数等を宣言、定義するようなクラステンプレート、関数テンプレート、
定数テンプレート、エイリアステンプレートを指す
(本章ではこれらをまとめて単にテンプレート呼ぶことがある)。</p>
<p><a
href="exercise_q.html#SS_20_11_2">演習-エイリアステンプレート</a></p>
<h3 id="stlのtype_traits">STLのtype_traits <a id="SS_13_3_1"></a></h3>
<p>メタ関数ライブラリの代表的実装例はSTLの <a
href="https://cpprefjp.github.io/reference/type_traits.html">type_traits</a>である。</p>
<p>ここでは、よく使ういくつかのtype_traitsテンプレートの使用例や解説を示す。</p>
<h4 id="stdtrue_typestdfalse_type">std::true_type/std::false_type
<a id="SS_13_3_1_1"></a></h4>
<p>std::true_type/std::false_typeは真/偽を返すSTLメタ関数群の戻り型となる型エイリアスであるため、
最も使われるテンプレートの一つである。</p>
<p>これらは、下記で確かめられる通り、後述する<a
href="template_meta_programming.html#SS_13_3_1_2">std::integral_constant</a>を使い定義されている。</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 13</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::is_same_vの2パラメータが同一であれば、std::is_same_v&lt;&gt; == true</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> <span class="kw">true</span><span class="op">&gt;,</span> <span class="bu">std::</span>true_type<span class="op">&gt;);</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> <span class="kw">false</span><span class="op">&gt;,</span> <span class="bu">std::</span>false_type<span class="op">&gt;);</span></span></code></pre></div>
<p>それぞれの型が持つvalue定数は、下記のように定義されている。</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 20</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>true_type::value<span class="op">,</span> <span class="st">&quot;must be true&quot;</span><span class="op">);</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>false_type::value<span class="op">,</span> <span class="st">&quot;must be false&quot;</span><span class="op">);</span></span></code></pre></div>
<p>これらが何の役に立つのか直ちに理解することは難しいが、
true/falseのメタ関数版と考えれば、追々理解できるだろう。</p>
<p>以下に簡単な使用例を示す。</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 29</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 引数の型がintに変換できるかどうかを判定する関数</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// decltypeの中でのみ使用されるため、定義は不要</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="bu">std::</span>true_type  IsCovertibleToInt<span class="op">(</span><span class="dt">int</span><span class="op">);</span>  <span class="co">// intに変換できる型はこちら</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="bu">std::</span>false_type IsCovertibleToInt<span class="op">(...);</span>  <span class="co">// それ以外はこちら</span></span></code></pre></div>
<p>上記の単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 40</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">decltype</span><span class="op">(</span>IsCovertibleToInt<span class="op">(</span><span class="dv">1</span><span class="op">))::</span>value<span class="op">);</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">decltype</span><span class="op">(</span>IsCovertibleToInt<span class="op">(</span><span class="dv">1</span><span class="bu">u</span><span class="op">))::</span>value<span class="op">);</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="kw">decltype</span><span class="op">(</span>IsCovertibleToInt<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">))::</span>value<span class="op">);</span>  <span class="co">// ポインタはintに変換不可</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ConvertibleToInt <span class="op">{</span></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">operator</span> <span class="dt">int</span><span class="op">();</span></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> NotConvertibleToInt <span class="op">{};</span></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">decltype</span><span class="op">(</span>IsCovertibleToInt<span class="op">(</span>ConvertibleToInt<span class="op">{}))::</span>value<span class="op">);</span></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="kw">decltype</span><span class="op">(</span>IsCovertibleToInt<span class="op">(</span>NotConvertibleToInt<span class="op">{}))::</span>value<span class="op">);</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// なお、IsCovertibleToInt()やConvertibleToInt::operator int()は実際に呼び出されるわけでは</span></span>
<span id="cb70-17"><a href="#cb70-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ないため、定義は必要なく宣言のみがあれば良い。</span></span></code></pre></div>
<p>IsCovertibleToIntの呼び出しをdecltypeのオペランドにすることで、
std::true_typeかstd::false_typeを受け取ることができる。</p>
<h4 id="stdintegral_constant">std::integral_constant
<a id="SS_13_3_1_2"></a></h4>
<p>std::integral_constantは
「テンプレートパラメータとして与えられた型とその定数から新たな型を定義する」
クラステンプレートである。</p>
<p>以下に簡単な使用例を示す。</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 62</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> int3 <span class="op">=</span> <span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;;</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::is_same_vの2パラメータが同一であれば、std::is_same_v&lt;&gt; == true</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> int3<span class="op">::</span><span class="dt">value_type</span><span class="op">&gt;);</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;,</span> int3<span class="op">::</span>type<span class="op">&gt;);</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>int3<span class="op">::</span>value <span class="op">==</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> bool_true <span class="op">=</span> <span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> <span class="kw">true</span><span class="op">&gt;;</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-12"><a href="#cb71-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> bool_true<span class="op">::</span><span class="dt">value_type</span><span class="op">&gt;);</span></span>
<span id="cb71-13"><a href="#cb71-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> <span class="kw">true</span><span class="op">&gt;,</span> bool_true<span class="op">::</span>type<span class="op">&gt;);</span></span>
<span id="cb71-14"><a href="#cb71-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>bool_true<span class="op">::</span>value <span class="op">==</span> <span class="kw">true</span><span class="op">);</span></span></code></pre></div>
<p>また、すでに示したようにstd::true_type/std::false_typeを実装するためのクラステンプレートでもある。</p>
<h4 id="stdis_same">std::is_same <a id="SS_13_3_1_3"></a></h4>
<p>すでに上記の例でも使用したが、std::is_sameは2つのテンプレートパラメータが</p>
<ul>
<li>同じ型である場合、std::true_type</li>
<li>違う型である場合、std::false_type</li>
</ul>
<p>から派生した型となる。</p>
<p>以下に簡単な使用例を示す。</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 99</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int32_t</span><span class="op">&gt;::</span>value<span class="op">);</span>   <span class="co">// 64ビットg++/clang++</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int64_t</span><span class="op">&gt;::</span>value<span class="op">);</span>  <span class="co">// 64ビットg++/clang++</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;::</span>value<span class="op">);</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="kw">typename</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>reference<span class="op">,</span> <span class="dt">int</span><span class="op">&amp;&gt;::</span>value<span class="op">);</span></span></code></pre></div>
<p>また、 C++17で導入されたstd::is_same_vは、定数テンプレートを使用し、
下記のように定義されている。</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 90</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_v<span class="op">{</span><span class="bu">std::</span>is_same<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb74"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 108</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int32_t</span><span class="op">&gt;);</span>   <span class="co">// 64ビットg++/clang++</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int64_t</span><span class="op">&gt;);</span>  <span class="co">// 64ビットg++/clang++</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;);</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="kw">typename</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>reference<span class="op">,</span> <span class="dt">int</span><span class="op">&amp;&gt;);</span></span></code></pre></div>
<p>このような簡潔な記述の一般形式は、</p>
<pre><code>   T::value  -&gt; T_v
   T::type   -&gt; T_t</code></pre>
<p>のように定義されている(このドキュメントのほとんど場所では、簡潔な形式を用いる)。</p>
<p>第1テンプレートパラメータが第2テンプレートパラメータの基底クラスかどうかを判断する
std::is_base_ofを使うことで下記のようにstd::is_sameの基底クラス確認することもできる。</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 117</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>true_type<span class="op">,</span> <span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>false_type<span class="op">,</span> <span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<h4 id="stdenable_if">std::enable_if <a id="SS_13_3_1_4"></a></h4>
<p>std::enable_ifは、bool値である第1テンプレートパラメータが</p>
<ul>
<li>trueである場合、型である第2テンプレートパラメータをメンバ型typeとして宣言する。</li>
<li>falseである場合、メンバ型typeを持たない。</li>
</ul>
<p>下記のコードはクラステンプレートの特殊化を用いたstd::enable_ifの実装例である。</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 124</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> T_F<span class="op">,</span> <span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> enable_if<span class="op">;</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> enable_if<span class="op">&lt;</span><span class="kw">true</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> enable_if<span class="op">&lt;</span><span class="kw">false</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span>  <span class="co">// メンバエイリアスtypeを持たない</span></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> COND<span class="op">,</span> <span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">enable_if_t</span> <span class="op">=</span> <span class="kw">typename</span> enable_if<span class="op">&lt;</span>COND<span class="op">,</span> T<span class="op">&gt;::</span>type<span class="op">;</span></span></code></pre></div>
<p>std::enable_ifの使用例を下記に示す。</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 148</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="kw">true</span><span class="op">&gt;&gt;);</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="kw">true</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<p>実装例から明らかなように</p>
<ul>
<li>std::enable_if&lt;true&gt;::typeは<a
href="term_explanation.html#SS_19_18_6">well-formed</a></li>
<li>std::enable_if&lt;false&gt;::typeは<a
href="term_explanation.html#SS_19_18_5">ill-formed</a></li>
</ul>
<p>となるため、下記のコードはコンパイルできない。</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 155</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記はill-formedとなるため、コンパイルできない。</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="kw">false</span><span class="op">&gt;&gt;);</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="kw">false</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<p>std::enable_ifのこの特性と後述する<a
href="term_explanation.html#SS_19_11_1">SFINAE</a>により、
様々な静的ディスパッチを行うことができる。</p>
<h4 id="stdconditional">std::conditional <a id="SS_13_3_1_5"></a></h4>
<p>std::conditionalは、bool値である第1テンプレートパラメータが</p>
<ul>
<li>trueである場合、第2テンプレートパラメータ</li>
<li>falseである場合、第3テンプレートパラメータ</li>
</ul>
<p>をメンバ型typeとして宣言する。</p>
<p>下記のコードはクラステンプレートの特殊化を用いたstd::conditionalの実装例である。</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 164</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> T_F<span class="op">,</span> <span class="kw">typename</span><span class="op">,</span> <span class="kw">typename</span><span class="op">&gt;</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> conditional<span class="op">;</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> conditional<span class="op">&lt;</span><span class="kw">true</span><span class="op">,</span> T<span class="op">,</span> U<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> conditional<span class="op">&lt;</span><span class="kw">false</span><span class="op">,</span> T<span class="op">,</span> U<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> U<span class="op">;</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> COND<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">conditional_t</span> <span class="op">=</span> <span class="kw">typename</span> conditional<span class="op">&lt;</span>COND<span class="op">,</span> T<span class="op">,</span> U<span class="op">&gt;::</span>type<span class="op">;</span></span></code></pre></div>
<p>std::conditionalの使用例を下記に示す。</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 189</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span><span class="kw">true</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;&gt;);</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span><span class="kw">false</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<h4 id="stdis_void">std::is_void <a id="SS_13_3_1_6"></a></h4>
<p>std::is_voidはテンプレートパラメータの型が</p>
<ul>
<li>voidである場合、std::true_type</li>
<li>voidでない場合、std::false_type</li>
</ul>
<p>から派生した型となる。</p>
<p>以下に簡単な使用例を示す。</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/type_traits_ut.cpp 82</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_void<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_void<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_void<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;::</span>value<span class="op">);</span></span></code></pre></div>
<h3 id="is_void_xxxの実装">is_void_xxxの実装 <a id="SS_13_3_2"></a></h3>
<p>ここではstd::is_voidに似た以下のような仕様を持ついくつかのテンプレートis_void_xxxの実装を考える。</p>
<table>
<thead>
<tr class="header">
<th>テンプレートパラメータ</th>
<th>戻り値</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>void</td>
<td>true</td>
</tr>
<tr class="even">
<td>非void</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>それぞれのis_void_xxxは下記テーブルで示した言語機能を使用して実装する。</p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>is_void_xxx</th>
<th>実装方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_2_1">is_void_f</a></td>
<td>関数テンプレートの特殊化</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_2_2">is_void_s</a></td>
<td>クラステンプレートの特殊化</td>
</tr>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_2_3">is_void_sfinae_f</a></td>
<td>FINAEと関数テンプレートのオーバーロード</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_2_4">is_void_sfinae_s</a></td>
<td>FINAEとクラステンプレートの特殊化</td>
</tr>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_2_5">is_void_concept_s</a></td>
<td>コンセプトとクラステンプレートの特殊化</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_2_6">is_void_ena_s</a></td>
<td>std::enable_ifによるSFINAEとクラステンプレートの特殊化</td>
</tr>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_2_7">is_void_cond_s</a></td>
<td>std::conditionalと関数テンプレートの特殊化</td>
</tr>
</tbody>
</table>
<p>なお、実装例をシンプルに保つため、
理解の妨げとなり得る下記のような正確性(例外条件の対応)等のためのコードを最低限に留めた。</p>
<ul>
<li>テンプレートパラメータの型のチェック</li>
<li>テンプレートパラメータの型からのポインタ/リファレンス/const/volatileの削除</li>
<li>戻り型からのconst/volatileの削除</li>
</ul>
<p>これは、「テンプレートプログラミングでの有用なテクニックの解説」
というここでの目的を見失わないための措置である。</p>
<h4 id="is_void_f">is_void_f <a id="SS_13_3_2_1"></a></h4>
<p>関数テンプレートの特殊化を使用したis_void_fの実装は以下のようになる。</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 8</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_f<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_f<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;()</span> <span class="kw">noexcept</span></span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_f_v<span class="op">{</span>is_void_f<span class="op">&lt;</span>T<span class="op">&gt;()};</span></span></code></pre></div>
<p>単純なので解説は不要だろう。これらの単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 28</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_f_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_f_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_void_f_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;);</span></span></code></pre></div>
<p>関数テンプレートの特殊化には、</p>
<ul>
<li>特殊化された関数テンプレートとそのプライマリテンプレートのシグネチャ、
戻り値は一致しなければならない</li>
<li>クラステンプレートのような部分特殊化は許可されない</li>
</ul>
<p>のような制限があるため用途は限られるが、関数テンプレートはオーバーロードすることが可能である。</p>
<p><a
href="exercise_q.html#SS_20_11_5">演習-SFINAEを利用しない関数テンプレートの特殊化によるis_void</a></p>
<h4 id="is_void_s">is_void_s <a id="SS_13_3_2_2"></a></h4>
<p>クラステンプレートの特殊化を使用したis_void_sの実装は以下のようになる。</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 36</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void_s <span class="op">{</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value<span class="op">{</span><span class="kw">false</span><span class="op">};</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;&gt;</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void_s<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value<span class="op">{</span><span class="kw">true</span><span class="op">};</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_s_v<span class="op">{</span>is_void_s<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>is_void_fと同様に単純なので解説は不要だろう。これらの単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 54</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_s_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_void_s_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;);</span></span></code></pre></div>
<p><a
href="exercise_q.html#SS_20_11_6">演習-SFINAEを利用しないクラステンプレートの特殊化によるis_void</a></p>
<h4 id="is_void_sfinae_f">is_void_sfinae_f <a id="SS_13_3_2_3"></a></h4>
<p><a
href="term_explanation.html#SS_19_11_1">SFINAE</a>を使用した関数テンプレートis_void_sfinae_fの実装は以下のようになる。</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 62</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// T == void</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> is_void_sfinae_f_detector<span class="op">(</span><span class="dt">void</span> <span class="at">const</span><span class="op">*</span> v<span class="op">,</span> T <span class="at">const</span><span class="op">*</span> t<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>t <span class="op">=</span> v<span class="op">,</span> <span class="dt">bool</span><span class="op">{})</span>  <span class="co">// T != voidの場合、t = vはill-formed</span></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">// T == voidの場合、well-formedでbool型生成</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// T != void</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> is_void_sfinae_f_detector<span class="op">(</span><span class="dt">void</span> <span class="at">const</span><span class="op">*,</span> T <span class="at">const</span><span class="op">*)</span> <span class="kw">noexcept</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>T<span class="op">),</span> <span class="dt">bool</span><span class="op">{})</span>  <span class="co">// T != voidの場合、well-formedでbool型生成</span></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">// T == voidの場合、sizeof(T)はill-formed</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb87-23"><a href="#cb87-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-24"><a href="#cb87-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb87-25"><a href="#cb87-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_sfinae_f<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb87-26"><a href="#cb87-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb87-27"><a href="#cb87-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Inner_<span class="op">::</span>is_void_sfinae_f_detector<span class="op">(</span><span class="kw">nullptr</span><span class="op">,</span> <span class="kw">static_cast</span><span class="op">&lt;</span>T<span class="op">*&gt;(</span><span class="kw">nullptr</span><span class="op">));</span></span>
<span id="cb87-28"><a href="#cb87-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb87-29"><a href="#cb87-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-30"><a href="#cb87-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb87-31"><a href="#cb87-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_sfinae_f_v<span class="op">{</span>is_void_sfinae_f<span class="op">&lt;</span>T<span class="op">&gt;()};</span></span></code></pre></div>
<p>関数テンプレートである2つのis_void_sfinae_f_detectorのオーバーロードにSFINAEを使用している。</p>
<p>1つ目のis_void_sfinae_f_detectorでは、</p>
<table>
<thead>
<tr class="header">
<th>T</th>
<th>t = v の診断(コンパイル)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>== void</td>
<td>well-formed</td>
</tr>
<tr class="even">
<td>!= void</td>
<td>ill-formed</td>
</tr>
</tbody>
</table>
<p>であるため、Tがvoidの時のみ<a
href="term_explanation.html#SS_19_10_2">name lookup</a>の対象になる。</p>
<p>2つ目のis_void_sfinae_f_detectorでは、</p>
<table>
<thead>
<tr class="header">
<th>T</th>
<th>sizeof(T)の診断(コンパイル)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>== void</td>
<td>ill-formed</td>
</tr>
<tr class="even">
<td>!= void</td>
<td>well-formed</td>
</tr>
</tbody>
</table>
<p>であるため、Tが非voidの時のみ<a
href="term_explanation.html#SS_19_10_2">name lookup</a>の対象になる。</p>
<p>is_void_sfinae_fはこの性質を利用し、</p>
<ul>
<li>T ==
voidの場合、1つ目のis_void_sfinae_f_detectorが選択され、戻り値はtrue</li>
<li>T !=
voidの場合、2つ目のis_void_sfinae_f_detectorが選択され、戻り値はfalse</li>
</ul>
<p>となる。念のため単体テストを示すと下記のようになる。</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 97</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_sfinae_f_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_sfinae_f_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_void_sfinae_f_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;);</span></span></code></pre></div>
<p>一般にファイル外部に公開するテンプレートは、
コンパイルの都合上ヘッダファイルにその全実装を記述することになる。
これは、本来外部公開すべきでない実装の詳細である
is_void_sfinae_f_detectorのようなテンプレートに関しては大変都合が悪い。
というのは、外部から使用されたくない実装の詳細が使われてしまうことがあり得るからである。
上記の例では、こういうことに備え
「これは外部非公開である」ということを示す名前空間Inner_ (「<a
href="programming_convention.html#SS_3_8_2">名前空間</a>」参照)
を導入した。</p>
<p>関数テンプレートはクラステンプレート内にも定義することができるため、
is_void_sfinae_fは下記のように実装することも可能である。この場合、名前空間Inner_は不要になる。</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 106</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> is_void_sfinae_f <span class="op">{</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// U == void</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="kw">auto</span> detector<span class="op">(</span><span class="dt">void</span> <span class="at">const</span><span class="op">*</span> v<span class="op">,</span> U <span class="at">const</span><span class="op">*</span> u<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>u <span class="op">=</span> v<span class="op">,</span> <span class="dt">bool</span><span class="op">{})</span>  <span class="co">// U != voidの場合、t = vはill-formed</span></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">// U == voidの場合、well-formedでbool型生成</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// U != void</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="kw">auto</span> detector<span class="op">(</span><span class="dt">void</span> <span class="at">const</span><span class="op">*,</span> U <span class="at">const</span><span class="op">*)</span> <span class="kw">noexcept</span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>U<span class="op">),</span> <span class="dt">bool</span><span class="op">{})</span>  <span class="co">// U != voidの場合、well-formedでbool型生成</span></span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>                                            <span class="co">// U == voidの場合、ill-formed</span></span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value<span class="op">{</span>is_void_sfinae_f<span class="op">::</span>detector<span class="op">(</span><span class="kw">nullptr</span><span class="op">,</span> <span class="kw">static_cast</span><span class="op">&lt;</span>T<span class="op">*&gt;(</span><span class="kw">nullptr</span><span class="op">))};</span></span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_sfinae_f_v<span class="op">{</span>is_void_sfinae_f<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb90"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 138</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_sfinae_f_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_sfinae_f_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_void_sfinae_f_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;);</span></span></code></pre></div>
<p><a
href="exercise_q.html#SS_20_11_7">演習-SFINAEを利用した関数テンプレートの特殊化によるis_void</a></p>
<h4 id="is_void_sfinae_s">is_void_sfinae_s <a id="SS_13_3_2_4"></a></h4>
<p><a
href="term_explanation.html#SS_19_11_1">SFINAE</a>を使用したクラステンプレートis_void_sfinae_sの実装は以下のようになる。</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 147</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>    T<span class="op">*&amp;</span> t2ptr<span class="op">();</span>  <span class="co">// 定義は不要</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">*&amp;&gt;</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void_sfinae_s <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void_sfinae_s<span class="op">&lt;</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>        T<span class="op">,</span></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// T != voidの場合、ill-formed</span></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// T == voidの場合、well-formedでvoid*&amp;生成</span></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">decltype</span><span class="op">(</span>Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">=</span> Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;())</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_sfinae_s_v<span class="op">{</span>is_void_sfinae_s<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>1つ目のis_void_sfinae_sはプライマリテンプレートである。
is_void_sfinae_sの特殊化が<a href="term_explanation.html#SS_19_10_2">name
lookup</a>の対象の中に見つからなかった場合、 これが使われる。</p>
<p>2つ目のis_void_sfinae_sは、上記を抜粋した下記のコード</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 163</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// T != voidの場合、ill-formed</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// T == voidの場合、well-formedでvoid*&amp;生成</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decltype</span><span class="op">(</span>Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">=</span> Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;())</span></span></code></pre></div>
<p>がT ==
voidの時のみ、well-formedになり、このテンプレートは下記のようにインスタンス化される。</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void_sfinae_s<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="dt">void</span><span class="op">*&amp;&gt;</span></span></code></pre></div>
<p>この形状はプライマリテンプレートの</p>
<ul>
<li>第1パラメータにvoidを与える</li>
<li>第2パラメータには何も与えない(デフォルトのまま)</li>
</ul>
<p>とした場合の、つまりプライマリテンプレートを</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void_sfinae_s<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span>   <span class="co">// プライマリテンプレート</span></span></code></pre></div>
<p>としてインスタンス化した場合と一致する。
プライマリと特殊化が一致した場合、特殊化されたものがname
lookupで選択される。</p>
<p>T != voidの場合、 2つ目のis_void_sfinae_sはill-formedになり、name
lookupの対象から外れるため、 プライマリが選択される。</p>
<p>以上をまとめると、</p>
<table>
<thead>
<tr class="header">
<th>T</th>
<th>is_void_sfinae_sの基底クラス</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>== void</td>
<td>std::true_type</td>
</tr>
<tr class="even">
<td>!= void</td>
<td>std::false_type</td>
</tr>
</tbody>
</table>
<p>となる。以下の単体テストによって、このことを確かめることができる。</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 180</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_sfinae_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>false_type<span class="op">,</span> is_void_sfinae_s<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_sfinae_s_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>false_type<span class="op">,</span> is_void_sfinae_s<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;&gt;);</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_void_sfinae_s_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;);</span></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>true_type<span class="op">,</span> is_void_sfinae_s<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<p>上記コードのように「プライマリテンプレートのデフォルトパラメータ」と、</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 163</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// T != voidの場合、ill-formed</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// T == voidの場合、well-formedでvoid*&amp;生成</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decltype</span><span class="op">(</span>Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">=</span> Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;())</span></span></code></pre></div>
<p>が「well-formedであった場合に生成される型」が一致することを利用した静的ディスパッチは、
SFINAEとクラステンプレートの特殊化を組み合わせたメタ関数の典型的な実装パターンである。
ただし、一般にはill-formedを起こすためにst::enable_ifを使うことが多いため、
「<a
href="template_meta_programming.html#SS_13_3_2_6">is_void_ena_s</a>の実装」でその例を示す。</p>
<p><a
href="exercise_q.html#SS_20_11_8">演習-SFINAEを利用したクラステンプレートの特殊化によるis_void</a></p>
<h4 id="is_void_concept_s">is_void_concept_s
<a id="SS_13_3_2_5"></a></h4>
<p><a
href="template_meta_programming.html#SS_13_3_2_4">is_void_sfinae_s</a>の実装で使用したSFINAEを回避し、
コンセプトを使用することで可読性の向上が見込める。
以下の実装で使用した<a
href="template_meta_programming.html#SS_13_3_3_6">same_as</a>は&lt;concepts&gt;で定義されているコンセプトと同様のものである。</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 193</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void_concept_s <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>T<span class="op">,</span> <span class="dt">void</span><span class="op">&gt;</span>  <span class="co">// コンセプトによるTの制約</span></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void_concept_s<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb98"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 207</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_concept_s<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>false_type<span class="op">,</span> is_void_concept_s<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_concept_s<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>false_type<span class="op">,</span> is_void_concept_s<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;&gt;);</span></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_void_concept_s<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>true_type<span class="op">,</span> is_void_concept_s<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<p>下記に示した通り、テンプレート特殊化はクラスのみなく定数に対しても使用することができる。</p>
<div class="sourceCode" id="cb99"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 220</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_concept_s_v <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>T<span class="op">,</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_concept_s_v<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span></code></pre></div>
<p>以下に示した通り、<a
href="template_meta_programming.html#SS_13_3_2_4">is_void_sfinae_s</a>の実装で示した定数テンプレートのテストと同様になっている。</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 232</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_concept_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_concept_s_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_void_concept_s_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;);</span></span></code></pre></div>
<h4 id="is_void_ena_s">is_void_ena_s <a id="SS_13_3_2_6"></a></h4>
<p><a
href="template_meta_programming.html#SS_13_3_1_4">std::enable_if</a>による<a
href="term_explanation.html#SS_19_11_1">SFINAE</a>とクラステンプレートの特殊化を使用した
is_void_ena_sの実装は以下のようになる。</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 240</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void_ena_s <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void_ena_s<span class="op">&lt;</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>        T<span class="op">,</span></span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span>is_void_f<span class="op">&lt;</span>T<span class="op">&gt;()&gt;</span></span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_ena_s_v<span class="op">{</span>is_void_ena_s<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>この例では、「<a
href="template_meta_programming.html#SS_13_3_2_4">is_void_sfinae_s</a>の実装」の</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 163</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// T != voidの場合、ill-formed</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// T == voidの場合、well-formedでvoid*&amp;生成</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">decltype</span><span class="op">(</span>Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">=</span> Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;())</span></span></code></pre></div>
<p>で示したSFINAEの処理を上記を抜粋した下記のコード</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 250</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span>is_void_f<span class="op">&lt;</span>T<span class="op">&gt;()&gt;</span></span></code></pre></div>
<p>で行っている。
std::enable_ifの値パラメータis_void_f&lt;T&gt;()は、「<a
href="template_meta_programming.html#SS_13_3_2_1">is_void_f</a>の実装」で示したものである。</p>
<p>単体テストは、「<a
href="template_meta_programming.html#SS_13_3_2_4">is_void_sfinae_s</a>の実装」で示したものとほぼ同様で、以下のようになる。</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 264</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_ena_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>false_type<span class="op">,</span> is_void_ena_s<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_ena_s_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>false_type<span class="op">,</span> is_void_ena_s<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;&gt;);</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_void_ena_s_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;);</span></span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>true_type<span class="op">,</span> is_void_ena_s<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<h4 id="is_void_cond_s">is_void_cond_s <a id="SS_13_3_2_7"></a></h4>
<p><a
href="template_meta_programming.html#SS_13_3_1_5">std::conditional</a>と関数テンプレートの特殊化を使用したis_void_cond_sの実装は以下のようになる。</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 277</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_void_cond_s <span class="op">:</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>is_void_f<span class="op">&lt;</span>T<span class="op">&gt;(),</span> <span class="bu">std::</span>true_type<span class="op">,</span> <span class="bu">std::</span>false_type<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_void_cond_s_v<span class="op">{</span>is_void_cond_s<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>std::conditionalの値パラメータis_void_f&lt;T&gt;()は、「<a
href="template_meta_programming.html#SS_13_3_2_1">is_void_f</a>の実装」で示したものである。
この例では、SFINAEもクラステンプレートの特殊化も使用していないが、
下記単体テストからわかる通り、「<a
href="template_meta_programming.html#SS_13_3_2_4">is_void_sfinae_s</a>の実装」と同じ機能を備えている。</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/is_void_ut.cpp 288</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_cond_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>false_type<span class="op">,</span> is_void_cond_s<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_void_cond_s_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>false_type<span class="op">,</span> is_void_cond_s<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;&gt;);</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_void_cond_s_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;);</span></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>true_type<span class="op">,</span> is_void_cond_s<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<h3 id="is_same_xxxの実装">is_same_xxxの実装 <a id="SS_13_3_3"></a></h3>
<p>ここではstd::is_same&lt;T, U&gt;に似た、
以下のような仕様を持ついくつかのテンプレートis_same_xxxの実装を考える。</p>
<table>
<thead>
<tr class="header">
<th>テンプレートパラメータ</th>
<th>戻り値</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>T == U</td>
<td>true</td>
</tr>
<tr class="even">
<td>T != U</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>それぞれのis_same_xxxは下記テーブルで示された言語機能を使用して実装する。</p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>is_same_xxx</th>
<th>実装方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_3_1">is_same_f</a></td>
<td>関数テンプレートのオーバーロード</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_3_2">is_same_v</a></td>
<td>定数テンプレートの特殊化</td>
</tr>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_3_3">is_same_s</a></td>
<td>クラステンプレートの特殊化</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_3_4">is_same_sfinae_f</a></td>
<td>SFINAEと関数テンプレート/関数のオーバーロード</td>
</tr>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_3_5">is_same_sfinae_s</a></td>
<td>SFINAEとクラステンプレートの特殊化</td>
</tr>
<tr class="even">
<td><a href="template_meta_programming.html#SS_13_3_3_6">same_as</a></td>
<td><a
href="term_explanation.html#SS_19_11_2">コンセプト</a>よるis_same_sfinae_sと同一の機能</td>
</tr>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_3_7">is_same_templ</a></td>
<td>テンプレートテンプレートパラメータ</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_3_8">IsSameSomeOf</a></td>
<td>パラメータパックと再帰</td>
</tr>
<tr class="odd">
<td><a href="template_meta_programming.html#SS_13_3_3_9">OneOf</a></td>
<td>IsSameSomeOfをコンセプトに</td>
</tr>
</tbody>
</table>
<h4 id="is_same_f">is_same_f <a id="SS_13_3_3_1"></a></h4>
<p>関数テンプレートのオーバーロードを用いたis_same_fの実装は以下のようになる。</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 9</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_f_helper<span class="op">(</span>T <span class="at">const</span><span class="op">*,</span> U <span class="at">const</span><span class="op">*)</span> <span class="kw">noexcept</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_f_helper<span class="op">(</span>T <span class="at">const</span><span class="op">*,</span> T <span class="at">const</span><span class="op">*)</span> <span class="kw">noexcept</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb107-16"><a href="#cb107-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_f<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb107-17"><a href="#cb107-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb107-18"><a href="#cb107-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> is_same_f_helper<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span>T<span class="op">*&gt;(</span><span class="kw">nullptr</span><span class="op">),</span> <span class="kw">static_cast</span><span class="op">&lt;</span>U<span class="op">*&gt;(</span><span class="kw">nullptr</span><span class="op">));</span></span>
<span id="cb107-19"><a href="#cb107-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb107-20"><a href="#cb107-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-21"><a href="#cb107-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb107-22"><a href="#cb107-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_f_v<span class="op">{</span>is_same_f<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;()};</span></span></code></pre></div>
<p>すでに述べたように関数テンプレートの部分特殊化は言語仕様として認められておらず、</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 34</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_f<span class="op">()</span></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_f<span class="op">&lt;</span>T<span class="op">,</span> T<span class="op">&gt;()</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>上記のようなのようなコードは、以下のようなコンパイルエラーになる
(g++/clang++のような優れたコンパイラを使えば、
以下のメッセージのように簡単に問題点が理解できることもある)。</p>
<pre><code>    is_same_ut.cpp:35:32: error: non-class, non-variable partial specialization ‘
                                          is_same_f&lt;T, T&gt;’ is not allowed
        35 | constexpr bool is_same_f&lt;T, T&gt;()</code></pre>
<p>関数テンプレートは部分特殊化が出来ない代わりに、
同じ識別子を持つ関数や関数テンプレートとのオーバーロードができる。関数とのオーバーロードの場合、
is_same_f_helper&lt;T&gt;()のようなテンプレートパラメータを直接使用した静的ディスパッチが出来ないため、
常に型推測によるディスパッチが必要になる。</p>
<p>単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 52</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_f_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;);</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_f_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_f_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">&gt;);</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_f_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<h4 id="is_same_v">is_same_v <a id="SS_13_3_3_2"></a></h4>
<p>定数テンプレートの特殊化を用いたis_same_vの実装は以下のようになる。</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 61</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_v<span class="op">{</span><span class="kw">false</span><span class="op">};</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_v<span class="op">&lt;</span>T<span class="op">,</span> T<span class="op">&gt;{</span><span class="kw">true</span><span class="op">};</span></span></code></pre></div>
<p>単純であるため、解説は不要だろう。 単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 72</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;);</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">&gt;);</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<h4 id="is_same_s">is_same_s <a id="SS_13_3_3_3"></a></h4>
<p>クラステンプレートの特殊化を用いたis_same_sの実装は以下のようになる。</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 81</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">,</span> <span class="kw">class</span> U<span class="op">&gt;</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_s <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_s<span class="op">&lt;</span>T<span class="op">,</span> T<span class="op">&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_s_v<span class="op">{</span>is_same_s<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>「<a
href="template_meta_programming.html#SS_13_3_3_2">is_same_v</a>の実装」と同様に単純であるため、解説は不要だろう。
単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 97</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;);</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">&gt;);</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_s_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<h4 id="is_same_sfinae_f">is_same_sfinae_f <a id="SS_13_3_3_4"></a></h4>
<p>SFINAEと関数テンプレート/関数のオーバーロードを用いたis_same_sfinae_f実装は以下のようになる。</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 106</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> is_same_sfinae_f_detector<span class="op">(</span>T <span class="at">const</span><span class="op">*</span> t<span class="op">,</span> U <span class="at">const</span><span class="op">*</span> u<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>t <span class="op">=</span> u<span class="op">,</span> u <span class="op">=</span> t<span class="op">,</span> <span class="dt">bool</span><span class="op">{})</span>  <span class="co">// T != Uの場合、t = u, u = tはill-formed</span></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>                                           <span class="co">// T == Uの場合、well-formedでbool型生成</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_sfinae_f_detector<span class="op">(...)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb115-14"><a href="#cb115-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-15"><a href="#cb115-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb115-16"><a href="#cb115-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_sfinae_f<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb115-17"><a href="#cb115-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb115-18"><a href="#cb115-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Inner_<span class="op">::</span>is_same_sfinae_f_detector<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span>T<span class="op">*&gt;(</span><span class="kw">nullptr</span><span class="op">),</span> <span class="kw">static_cast</span><span class="op">&lt;</span>U<span class="op">*&gt;(</span><span class="kw">nullptr</span><span class="op">));</span></span>
<span id="cb115-19"><a href="#cb115-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb115-20"><a href="#cb115-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-21"><a href="#cb115-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb115-22"><a href="#cb115-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_sfinae_f_v<span class="op">{</span>is_same_sfinae_f<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;()};</span></span></code></pre></div>
<p>上記の抜粋である下記コードのコメントで示したように、</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 112</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>t <span class="op">=</span> u<span class="op">,</span> u <span class="op">=</span> t<span class="op">,</span> <span class="dt">bool</span><span class="op">{})</span>  <span class="co">// T != Uの場合、t = u, u = tはill-formed</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>                                       <span class="co">// T == Uの場合、well-formedでbool型生成</span></span></code></pre></div>
<p>T != Uの場合、この関数テンプレートはill-formedとなりname
lookupの対象ではなくなる。
その結果、関数is_same_sfinae_f_detectorが選択される。
省略記号”…“(ellipsis)を引数とする関数は、そのオーバーロード群の中での最後の選択となるため、
T ==
Uの場合は、関数テンプレートis_same_sfinae_f_detectorが選択される。</p>
<p>単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 136</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_sfinae_f_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;);</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_sfinae_f_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_sfinae_f_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">&gt;);</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_sfinae_f_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<h4 id="is_same_sfinae_s">is_same_sfinae_s <a id="SS_13_3_3_5"></a></h4>
<p>SFINAEとクラステンプレートの特殊化を用いたis_same_sfinae_sの実装は以下のようになる。</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 144</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>    T<span class="op">*&amp;</span> t2ptr<span class="op">();</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> T<span class="op">*&amp;&gt;</span></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_sfinae_s <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb118-11"><a href="#cb118-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-12"><a href="#cb118-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb118-13"><a href="#cb118-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_sfinae_s<span class="op">&lt;</span></span>
<span id="cb118-14"><a href="#cb118-14" aria-hidden="true" tabindex="-1"></a>        T<span class="op">,</span> U<span class="op">,</span></span>
<span id="cb118-15"><a href="#cb118-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-16"><a href="#cb118-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// T != Uの場合、ill-formed</span></span>
<span id="cb118-17"><a href="#cb118-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// T == Uの場合、well-formedでT*&amp;生成</span></span>
<span id="cb118-18"><a href="#cb118-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">decltype</span><span class="op">(</span>Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">=</span> Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span>U<span class="op">&gt;(),</span> Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span>U<span class="op">&gt;()</span> <span class="op">=</span> Inner_<span class="op">::</span>t2ptr<span class="op">&lt;</span>T<span class="op">&gt;())</span></span>
<span id="cb118-19"><a href="#cb118-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb118-20"><a href="#cb118-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb118-21"><a href="#cb118-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-22"><a href="#cb118-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb118-23"><a href="#cb118-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_sfinae_s_v<span class="op">{</span>is_same_sfinae_s<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>「<a
href="template_meta_programming.html#SS_13_3_2_4">is_void_sfinae_s</a>の実装」とほぼ同様であるため、解説は不要だろう。
単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 172</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_sfinae_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;);</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_sfinae_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_sfinae_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">&gt;);</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_sfinae_s_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<h4 id="same_as">same_as <a id="SS_13_3_3_6"></a></h4>
<p><a href="term_explanation.html#SS_19_11_1">SFINAE</a>による<a
href="template_meta_programming.html#SS_13_3_3_5">is_same_sfinae_s</a>の難解なコードを<a
href="term_explanation.html#SS_19_11_2">コンセプト</a>
よりリファクタリングしたコードを以下に示す。</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 181</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> same_as <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>T <span class="at">const</span><span class="op">*</span> t<span class="op">,</span> U <span class="at">const</span><span class="op">*</span> u<span class="op">)</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span>t <span class="op">=</span> u<span class="op">,</span> u <span class="op">=</span> t<span class="op">};</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> same_as <span class="op">=</span> is_same_sfinae_s_v<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;;</span></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span></code></pre></div>
<p>is_same_sfinae_sは定数テンプレートであり、same_asはコンセプトであるが、
下記のテストから明らかな通り、ほぼ同様に同様に使用することができる。</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 196</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>same_as<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;);</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>same_as<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>same_as<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">&gt;);</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>same_as<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<p>「<a
href="template_meta_programming.html#SS_13_3_3_3">is_same_s</a>」で紹介した特殊化のテクニックを下記のように使用することができる。</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 203</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_concept_s <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> same_as<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;</span></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_concept_s<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_concept_s <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-18"><a href="#cb122-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb122-19"><a href="#cb122-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_concept_s<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span>same_as<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;,</span> <span class="dt">void</span><span class="op">&gt;&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb122-20"><a href="#cb122-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb122-21"><a href="#cb122-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-22"><a href="#cb122-22" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb122-23"><a href="#cb122-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-24"><a href="#cb122-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_concept_s<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">void</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb122-25"><a href="#cb122-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_concept_s<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb122-26"><a href="#cb122-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_concept_s<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb122-27"><a href="#cb122-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_concept_s<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;::</span>value<span class="op">);</span></span></code></pre></div>
<h4 id="is_same_templ">is_same_templ <a id="SS_13_3_3_7"></a></h4>
<p>例えば、std::stringとstd::basic_string&lt;T&gt;が同じもしくは違う型であることを確認するためには、
すでに示したis_same_sを使用し、</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 246</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_s_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;);</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_s_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">&lt;</span><span class="dt">signed</span> <span class="dt">char</span><span class="op">&gt;&gt;);</span></span></code></pre></div>
<p>のようにすればよいが、
以下に示したコードのようにテンプレートテンプレートパラメータを使うことでも実装できる。</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 234</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...&gt;</span> <span class="kw">class</span> TEMPL<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_templ <span class="op">:</span> is_same_sfinae_s<span class="op">&lt;</span>T<span class="op">,</span> TEMPL<span class="op">&lt;</span>ARGS<span class="op">...&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...&gt;</span> <span class="kw">class</span> TEMPL<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_same_templ_v<span class="op">{</span>is_same_templ<span class="op">&lt;</span>T<span class="op">,</span> TEMPL<span class="op">,</span> ARGS<span class="op">...&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>上記のis_same_templは、第2引数にクラステンプレート、
第3引数以降にそのクラステンプレートの1個以上の引数を取ることができる。
使用例を兼ねた単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 251</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>is_same_templ_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">,</span> <span class="dt">char</span><span class="op">&gt;);</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>is_same_templ_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">,</span> <span class="dt">signed</span> <span class="dt">char</span><span class="op">&gt;);</span></span></code></pre></div>
<p>これを応用したエイリアステンプレート</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 258</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> gen_std_string <span class="op">=</span> is_same_templ<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>basic_string<span class="op">,</span> T<span class="op">&gt;;</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> gen_std_string_v<span class="op">{</span>gen_std_string<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>は与えられたテンプレートパラメータがstd::stringを生成するかどうかを判定することができる。</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/is_same_ut.cpp 269</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>gen_std_string_v<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;);</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>gen_std_string_v<span class="op">&lt;</span><span class="dt">signed</span> <span class="dt">char</span><span class="op">&gt;);</span></span></code></pre></div>
<p><a
href="exercise_q.html#SS_20_11_9">演習-テンプレートテンプレートパラメータ</a></p>
<h4 id="issamesomeof">IsSameSomeOf <a id="SS_13_3_3_8"></a></h4>
<p>IsSameSomeOfはこれまでの例とは少々異なり、</p>
<ul>
<li>第1パラメータが第2パラメータ以降で指定された型のどれかと一致する
SameAsSomeOfという名前の<a
href="term_explanation.html#SS_19_11_2">コンセプト</a>を<a
href="term_explanation.html#SS_19_11_3">畳み込み式</a>を使用し定義する</li>
<li>SameAsSomeOfで制約したテンプレートパラメータをstd::bool_constantからIsSameSomeOfを派生させる</li>
</ul>
<p>のような特徴のを持つ。
このようなIsSameSomeOfの実装はは以下のようになる。</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_type_traits.h 13</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_as_some_of_impl <span class="op">{</span>  <span class="co">// 型特性の補助クラス: 複数の型と比較する再帰的な実装</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value</span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">=</span> <span class="bu">std::</span>is_same<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;::</span>value <span class="op">||</span> is_same_as_some_of_impl<span class="op">&lt;</span>T<span class="op">,</span> Us<span class="op">...&gt;::</span>value<span class="op">;</span></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 再帰の終端条件: 比較する型が1つの場合</span></span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> is_same_as_some_of_impl<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value <span class="op">=</span> <span class="bu">std::</span>is_same<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;::</span>value<span class="op">;</span></span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb128-17"><a href="#cb128-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-18"><a href="#cb128-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb128-19"><a href="#cb128-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// コンセプト: 複数の型のいずれかがTと同じかどうかをチェック</span></span>
<span id="cb128-20"><a href="#cb128-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb128-21"><a href="#cb128-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> SameAsSomeOf <span class="op">=</span> <span class="op">(</span><span class="bu">std::</span>same_as<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;</span> <span class="op">||</span> <span class="op">(</span><span class="bu">std::</span>same_as<span class="op">&lt;</span>T<span class="op">,</span> Us<span class="op">&gt;</span> <span class="op">||</span> <span class="op">...));</span></span>
<span id="cb128-22"><a href="#cb128-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-23"><a href="#cb128-23" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb128-24"><a href="#cb128-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// コンセプトが使えない場合、上と同じ機能を持つ変数テンプレート</span></span>
<span id="cb128-25"><a href="#cb128-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb128-26"><a href="#cb128-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> SameAsSomeOf <span class="op">=</span> Inner_<span class="op">::</span>is_same_as_some_of_impl<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">,</span> Us<span class="op">...&gt;::</span>value<span class="op">;</span></span>
<span id="cb128-27"><a href="#cb128-27" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb128-28"><a href="#cb128-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-29"><a href="#cb128-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 型特性: TがUsのいずれかと同じ場合true_type、そうでない場合false_typeを継承</span></span>
<span id="cb128-30"><a href="#cb128-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb128-31"><a href="#cb128-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> IsSameSomeOf <span class="op">:</span> <span class="bu">std::</span>bool_constant<span class="op">&lt;</span>SameAsSomeOf<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">,</span> Us<span class="op">...&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb128-32"><a href="#cb128-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb128-33"><a href="#cb128-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-34"><a href="#cb128-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 便利な定数テンプレート</span></span>
<span id="cb128-35"><a href="#cb128-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb128-36"><a href="#cb128-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> IsSameSomeOfV <span class="op">=</span> IsSameSomeOf<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">,</span> Us<span class="op">...&gt;::</span>value<span class="op">;</span></span>
<span id="cb128-37"><a href="#cb128-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>IsSameSomeOfは、TがUsのいずれかと一致するかどうかのほとんどの処理をSameAsSomeOfに移譲する。</p>
<p>Usが1つだった場合、SameAsSomeOfは処理をstd::same_as(「<a
href="template_meta_programming.html#SS_13_3_3_6">same_as</a>」参照)に委譲する。
Usが複数だった場合、<a
href="--">畳み込み式</a>を使用し上記の処理をその数分、繰り返す。</p>
<p>単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_type_traits_ut.cpp 14</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>IsSameSomeOfV<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int8_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">uint16_t</span><span class="op">&gt;);</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>IsSameSomeOfV<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int8_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">uint16_t</span><span class="op">,</span> <span class="dt">int32_t</span><span class="op">&gt;);</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>IsSameSomeOfV<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="dt">int8_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">int32_t</span><span class="op">&amp;,</span> <span class="dt">int32_t</span><span class="op">&gt;);</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>IsSameSomeOfV<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="dt">int8_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">&amp;,</span> <span class="dt">int32_t</span><span class="op">&gt;);</span></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>IsSameSomeOfV<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">*,</span> <span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>IsSameSomeOfV<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">*&gt;);</span></span></code></pre></div>
<p><a
href="exercise_q.html#SS_20_11_10">演習-テンプレートパラメータを可変長にしたstd::is_same</a></p>
<h4 id="oneof">OneOf <a id="SS_13_3_3_9"></a></h4>
<p>OneOfは、<a
href="template_meta_programming.html#SS_13_3_3_8">IsSameSomeOf</a>同様の機能を持つコンセプトである。
OneOfの実装にはシンプルに記述するための<a
href="term_explanation.html#SS_19_11_3">畳み込み式</a>を使用した。</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/nstd_concepts.h 52</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> OneOf <span class="op">=</span> <span class="op">(</span><span class="bu">std::</span>same_as<span class="op">&lt;</span>T<span class="op">,</span> Us<span class="op">&gt;</span> <span class="op">||</span> <span class="op">...);</span></span></code></pre></div>
<p>単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_type_traits_ut.cpp 29</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>OneOf<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int8_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">uint16_t</span><span class="op">&gt;);</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>OneOf<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int8_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">uint16_t</span><span class="op">,</span> <span class="dt">int32_t</span><span class="op">&gt;);</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>OneOf<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="dt">int8_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">int32_t</span><span class="op">&amp;,</span> <span class="dt">int32_t</span><span class="op">&gt;);</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>OneOf<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="dt">int8_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">&amp;,</span> <span class="dt">int32_t</span><span class="op">&gt;);</span></span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>OneOf<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">*,</span> <span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>OneOf<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">*&gt;);</span></span></code></pre></div>
<h3 id="areconvertiblexxxの実装">AreConvertibleXxxの実装
<a id="SS_13_3_4"></a></h3>
<p>std::is_convertible&lt;FROM, TO&gt;は、</p>
<ul>
<li>型FROMが型TOに変換できる場合、std::true_typeから派生する</li>
<li>型FROMが型TOに変換できない場合、std::false_typeから派生する</li>
</ul>
<p>のような仕様を持つテンプレートである。</p>
<p>ここでは、</p>
<ul>
<li>std::is_convertibleを複数のFROMが指定できるように拡張したNstd::AreConvertible</li>
<li>縮小無しでの型変換ができるかどうかを判定するAreConvertibleWithoutNarrowConv</li>
</ul>
<p>の実装を考える。</p>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th>AreConvertibleXxx</th>
<th>実装方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_4_1">AreConvertible</a></td>
<td>クラステンプレートの特殊化</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_4_3">ConvertibleToAll</a></td>
<td>AreConvertibleをコンセプトへ</td>
</tr>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_4_2">AreConvertibleWithoutNarrowConv</a></td>
<td>SFINAEとクラステンプレートの特殊化</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_4_4">ConvertibleWithoutNarrowing</a></td>
<td>AreConvertibleWithoutNarrowConvをコンセプトへ</td>
</tr>
</tbody>
</table>
<h4 id="areconvertible">AreConvertible <a id="SS_13_3_4_1"></a></h4>
<p>AreConvertibleの実装は以下のようになる。</p>
<div class="sourceCode" id="cb132"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_type_traits.h 54</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span> FROM<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> are_convertible <span class="op">{</span></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value<span class="op">{</span></span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>is_convertible_v<span class="op">&lt;</span>FROM<span class="op">,</span> TO<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> are_convertible<span class="op">&lt;</span>TO<span class="op">,</span> FROMs<span class="op">...&gt;::</span>value<span class="op">};</span></span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span> FROM<span class="op">&gt;</span></span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> are_convertible<span class="op">&lt;</span>TO<span class="op">,</span> FROM<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value<span class="op">{</span><span class="bu">std::</span>is_convertible_v<span class="op">&lt;</span>FROM<span class="op">,</span> TO<span class="op">&gt;};</span></span>
<span id="cb132-15"><a href="#cb132-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb132-16"><a href="#cb132-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-17"><a href="#cb132-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb132-18"><a href="#cb132-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> are_convertible_v<span class="op">{</span>are_convertible<span class="op">&lt;</span>TO<span class="op">,</span> FROMs<span class="op">...&gt;::</span>value<span class="op">};</span></span>
<span id="cb132-19"><a href="#cb132-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb132-20"><a href="#cb132-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-21"><a href="#cb132-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb132-22"><a href="#cb132-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> AreConvertible</span>
<span id="cb132-23"><a href="#cb132-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>Inner_<span class="op">::</span>are_convertible_v<span class="op">&lt;</span>TO<span class="op">,</span> FROMs<span class="op">...&gt;,</span> <span class="bu">std::</span>true_type<span class="op">,</span> <span class="bu">std::</span>false_type<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb132-24"><a href="#cb132-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb132-25"><a href="#cb132-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-26"><a href="#cb132-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb132-27"><a href="#cb132-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> AreConvertibleV<span class="op">{</span>AreConvertible<span class="op">&lt;</span>TO<span class="op">,</span> FROMs<span class="op">...&gt;::</span>value<span class="op">};</span></span>
<span id="cb132-28"><a href="#cb132-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>「<a
href="template_meta_programming.html#SS_13_3_3_8">IsSameSomeOf</a>の実装」のコードパターンとほぼ同様であるため、解説は不要だろうが、</p>
<ul>
<li>パラメータパックの都合上、TOとFROMのパラメータの位置がstd::is_convertibleとは逆になる</li>
<li>IsSameSomeOfでは条件の一つがtrueであればIsSameSomeOf::valueがtrueとなるが、
AreConvertibleでは全条件がtrueとならない限り、AreConvertible::valueがtrueとならない</li>
</ul>
<p>ので注意が必要である。</p>
<p>単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_type_traits_ut.cpp 43</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>AreConvertibleV<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int8_t</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>AreConvertibleV<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>AreConvertibleV<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">*,</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>AreConvertibleV<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="dt">char</span><span class="op">*,</span> <span class="dt">char</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>AreConvertibleV<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="dt">char</span><span class="op">*,</span> <span class="dt">int</span><span class="op">&gt;);</span></span></code></pre></div>
<h4 id="areconvertiblewithoutnarrowconv">AreConvertibleWithoutNarrowConv
<a id="SS_13_3_4_2"></a></h4>
<p>縮小無しの型変換ができるかどうかを判定するAreConvertibleWithoutNarrowConvは、
AreConvertibleと同じように実装できるが、
その場合、AreConvertibleに対してstd::is_convertibleが必要になったように、
AreConvertibleWithoutNarrowConvに対しis_convertible_without_narrow_convが必要になる。</p>
<p>縮小無しでFROMからTOへの型変換ができるかどうかを判定するis_convertible_without_narrow_convは、
SFINAEと関数テンプレート/関数のオーバーライドを使用し以下のように実装できる。</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_type_traits.h 88</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span> FROM<span class="op">&gt;</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> is_convertible_without_narrow_conv <span class="op">{</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> TO<span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> FROM<span class="op">&gt;</span></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="kw">auto</span> detector<span class="op">(</span>T<span class="op">*</span> t<span class="op">,</span> U<span class="op">*</span> u<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 縮小無しでFROMからTOへ変換可能な場合、*t = T{*u}はwell-formed</span></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 上記ではない場合、*t = T{*u}はill-formed</span></span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(*</span>t <span class="op">=</span> T<span class="op">{*</span>u<span class="op">},</span> <span class="dt">bool</span><span class="op">{})</span></span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> detector<span class="op">(...)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value<span class="op">{</span>is_convertible_without_narrow_conv<span class="op">::</span>detector<span class="op">(</span></span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">static_cast</span><span class="op">&lt;</span>TO<span class="op">*&gt;(</span><span class="kw">nullptr</span><span class="op">),</span> <span class="kw">static_cast</span><span class="op">&lt;</span>FROM<span class="op">*&gt;(</span><span class="kw">nullptr</span><span class="op">))};</span></span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span> FROM<span class="op">&gt;</span></span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_convertible_without_narrow_conv_v<span class="op">{</span></span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true" tabindex="-1"></a>        is_convertible_without_narrow_conv<span class="op">&lt;</span>TO<span class="op">,</span> FROM<span class="op">&gt;::</span>value<span class="op">};</span></span>
<span id="cb134-27"><a href="#cb134-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb134-28"><a href="#cb134-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>AreConvertibleWithoutNarrowConvはNstdで定義するため、その内部のみで用いる
is_convertible_without_narrow_convはNstd::Inner_で定義している。</p>
<p>上記を抜粋した下記のコードは「縮小型変換を発生さる{}による初期化は<a
href="term_explanation.html#SS_19_18_5">ill-formed</a>になる」
ことをSFINAEに利用している。</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_type_traits.h 98</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 縮小無しでFROMからTOへ変換可能な場合、*t = T{*u}はwell-formed</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 上記ではない場合、*t = T{*u}はill-formed</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(*</span>t <span class="op">=</span> T<span class="op">{*</span>u<span class="op">},</span> <span class="dt">bool</span><span class="op">{})</span></span></code></pre></div>
<p>単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_type_traits_ut.cpp 55</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>Inner_<span class="op">::</span>is_convertible_without_narrow_conv_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>Inner_<span class="op">::</span>is_convertible_without_narrow_conv_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">&gt;);</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>Inner_<span class="op">::</span>is_convertible_without_narrow_conv_v<span class="op">&lt;</span><span class="dt">int16_t</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>Inner_<span class="op">::</span>is_convertible_without_narrow_conv_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">char</span><span class="op">*&gt;);</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>Inner_<span class="op">::</span>is_convertible_without_narrow_conv_v<span class="op">&lt;</span><span class="dt">char</span><span class="op">*,</span> <span class="bu">std::</span>string<span class="op">&gt;);</span></span></code></pre></div>
<p>is_convertible_without_narrow_convを利用したAreConvertibleWithoutNarrowConv
の実装は以下のようになる。</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_type_traits.h 121</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span> FROM<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> are_convertible_without_narrow_conv <span class="op">{</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value<span class="op">{</span></span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>            is_convertible_without_narrow_conv_v<span class="op">&lt;</span>TO<span class="op">,</span> FROM<span class="op">&gt;</span> </span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>                  <span class="op">&amp;&amp;</span> are_convertible_without_narrow_conv<span class="op">&lt;</span>TO<span class="op">,</span> FROMs<span class="op">...&gt;::</span>value<span class="op">};</span></span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-13"><a href="#cb137-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span> FROM<span class="op">&gt;</span></span>
<span id="cb137-14"><a href="#cb137-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> are_convertible_without_narrow_conv<span class="op">&lt;</span>TO<span class="op">,</span> FROM<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb137-15"><a href="#cb137-15" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value<span class="op">{</span>is_convertible_without_narrow_conv_v<span class="op">&lt;</span>TO<span class="op">,</span> FROM<span class="op">&gt;};</span></span>
<span id="cb137-16"><a href="#cb137-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb137-17"><a href="#cb137-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-18"><a href="#cb137-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span> FROM<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb137-19"><a href="#cb137-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> are_convertible_without_narrow_conv_v<span class="op">{</span></span>
<span id="cb137-20"><a href="#cb137-20" aria-hidden="true" tabindex="-1"></a>        are_convertible_without_narrow_conv<span class="op">&lt;</span>TO<span class="op">,</span> FROM<span class="op">,</span> FROMs<span class="op">...&gt;::</span>value<span class="op">};</span></span>
<span id="cb137-21"><a href="#cb137-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb137-22"><a href="#cb137-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-23"><a href="#cb137-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span> FROM<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb137-24"><a href="#cb137-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> AreConvertibleWithoutNarrowConv</span>
<span id="cb137-25"><a href="#cb137-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>Inner_<span class="op">::</span>are_convertible_without_narrow_conv_v<span class="op">&lt;</span>TO<span class="op">,</span> FROM<span class="op">,</span> FROMs<span class="op">...&gt;,</span></span>
<span id="cb137-26"><a href="#cb137-26" aria-hidden="true" tabindex="-1"></a>                             <span class="bu">std::</span>true_type<span class="op">,</span> <span class="bu">std::</span>false_type<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb137-27"><a href="#cb137-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb137-28"><a href="#cb137-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-29"><a href="#cb137-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span> FROM<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb137-30"><a href="#cb137-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> AreConvertibleWithoutNarrowConvV<span class="op">{</span></span>
<span id="cb137-31"><a href="#cb137-31" aria-hidden="true" tabindex="-1"></a>        AreConvertibleWithoutNarrowConv<span class="op">&lt;</span>TO<span class="op">,</span> FROM<span class="op">,</span> FROMs<span class="op">...&gt;::</span>value<span class="op">};</span></span>
<span id="cb137-32"><a href="#cb137-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_type_traits_ut.cpp 63</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>AreConvertibleWithoutNarrowConvV<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">uint16_t</span><span class="op">&gt;);</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>AreConvertibleWithoutNarrowConvV<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">,</span> <span class="dt">int16_t</span><span class="op">,</span> <span class="dt">uint32_t</span><span class="op">&gt;);</span></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>AreConvertibleWithoutNarrowConvV<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">char</span><span class="op">[</span><span class="dv">5</span><span class="op">],</span> <span class="dt">char</span><span class="op">*&gt;);</span></span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>AreConvertibleWithoutNarrowConvV<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dt">float</span><span class="op">&gt;);</span></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// int8_t -&gt; doubleは縮小型変換</span></span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>AreConvertibleWithoutNarrowConvV<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dt">float</span><span class="op">,</span> <span class="dt">int8_t</span><span class="op">&gt;);</span></span></code></pre></div>
<h4 id="convertibletoall">ConvertibleToAll <a id="SS_13_3_4_3"></a></h4>
<p>ConvertibleToAllの実装は下記のようになる。</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/nstd_concepts.h 57</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 複数の型 FROMs がすべて TO に変換可能かどうかを制約するコンセプト</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> ConvertibleToAll <span class="op">=</span> <span class="op">(</span><span class="bu">std::</span>convertible_to<span class="op">&lt;</span>FROMs<span class="op">,</span> TO<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="op">...);</span></span></code></pre></div>
<p>使用方法を含めて、単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_concepts_ut.cpp 137</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ConvertibleToAll_Test テンプレートの定義</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ConvertibleToAll_Test <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// すべての FROMs が TO に変換可能な場合の部分特殊化</span></span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Us<span class="op">&gt;</span></span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> ConvertibleToAll<span class="op">&lt;</span>TO<span class="op">,</span> Us<span class="op">...&gt;</span></span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ConvertibleToAll_Test<span class="op">&lt;</span>TO<span class="op">,</span> Us<span class="op">...&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> convert_bool <span class="op">{</span></span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb140-17"><a href="#cb140-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-18"><a href="#cb140-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>ConvertibleToAll_Test<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;::</span>value<span class="op">);</span></span>
<span id="cb140-19"><a href="#cb140-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>ConvertibleToAll_Test<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> convert_bool<span class="op">&gt;::</span>value<span class="op">);</span></span></code></pre></div>
<h4 id="convertiblewithoutnarrowing">ConvertibleWithoutNarrowing
<a id="SS_13_3_4_4"></a></h4>
<p>ConvertibleWithoutNarrowingは以下のようなコンセプトである。</p>
<ul>
<li><a
href="template_meta_programming.html#SS_13_3_4_2">AreConvertibleWithoutNarrowConv</a>と同様の機能を持つ</li>
<li><a
href="template_meta_programming.html#SS_13_3_4_3">ConvertibleToAll</a>と同様構造を持つ</li>
</ul>
<p>実装は以下のようになる。</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/nstd_concepts.h 63</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span> FROM<span class="op">&gt;</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> convertible_without_narrowing <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>FROM from<span class="op">)</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> TO <span class="op">{</span>from<span class="op">}</span> <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>TO<span class="op">&gt;;</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a><span class="co">// 複数の型が変換可能かどうかを確認するバージョン</span></span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> all_convertible_without_narrowing <span class="op">=</span> <span class="op">(</span>convertible_without_narrowing<span class="op">&lt;</span>TO<span class="op">,</span> FROMs<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="op">...);</span></span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a><span class="co">// コンセプトを使用</span></span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> TO<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> FROMs<span class="op">&gt;</span></span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> ConvertibleWithoutNarrowing <span class="op">=</span> Inner_<span class="op">::</span>all_convertible_without_narrowing<span class="op">&lt;</span>TO<span class="op">,</span> FROMs<span class="op">...&gt;;</span></span></code></pre></div>
<p>単体テストは他の似たコンセプトとほぼ同様になるため省略する。</p>
<h3 id="関数の存在の診断">関数の存在の診断 <a id="SS_13_3_5"></a></h3>
<p>Nstdライブラリの開発には関数の存在の診断が欠かせない。 例えば、</p>
<ul>
<li>テンプレートパラメータに特定のメンバ関数がある場合、特殊化を作る</li>
<li>テンプレートパラメータに範囲for文が適用できる場合にのみoperator&lt;&lt;を適用する</li>
<li>テンプレートパラメータに適用できるoperator&lt;&lt;がすでにあった場合、
自作operator&lt;&lt;を不活性化する</li>
</ul>
<p>等、応用範囲は多岐にわたる。
ここでは、上記の場合分けを可能とするようなメタ関数に必要なテクニックや、
それらを使用したNstdのメタ関数の実装を下記のように示す。</p>
<ul>
<li>テンプレートパラメータである型が、メンバ関数void
func()を持つかどうかの診断について、 次の表のように実装を示す。</li>
</ul>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>メタ関数名</th>
<th>メタ関数の目的</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_5_1">exists_void_func_sfinae_f</a></td>
<td>メンバ関数void func()を持つかどうかの判断</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_5_2">exists_void_func_sfinae_s</a></td>
<td>同上</td>
</tr>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_5_3">exists_void_func_sfinae_s2</a></td>
<td>同上</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_5_4">exists_void_func_concept</a></td>
<td>同上。コンセプトによるSFINAEの回避</td>
</tr>
</tbody>
</table>
<ul>
<li>テンプレートパラメータに範囲for文ができるかどうかの診断について、
次の表のように実装を示す。</li>
</ul>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th>メタ関数名</th>
<th>メタ関数の目的</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_5_5">exists_begin/exsits_end</a></td>
<td>SFINAEを使用したstd::begin(T)/std::end(T)が存在するか否かの診断</td>
</tr>
<tr class="even">
<td><a href="template_meta_programming.html#SS_13_3_5_7">Array</a></td>
<td>型が配列である制約を行うためのコンセプト</td>
</tr>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_5_8">Beginable/Endable</a></td>
<td><a
href="term_explanation.html#SS_19_11_2">コンセプト</a>を使用したexists_begin/exsits_endを単純化した例</td>
</tr>
<tr class="even">
<td><a href="template_meta_programming.html#SS_13_3_5_6">IsRange</a></td>
<td>exists_begin/exsits_endを使し、範囲forのオペランドになれるか?の判断</td>
</tr>
<tr class="odd">
<td><a href="template_meta_programming.html#SS_13_3_5_9">Ranged</a></td>
<td>機能はIsRangeと同一だが、<a
href="term_explanation.html#SS_19_11_2">コンセプト</a>を使用しSFINAEの回避</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_5_10">Container</a></td>
<td>Ranged且つ!Arrayをコンテナと便宜的に決めつける</td>
</tr>
</tbody>
</table>
<ul>
<li>テンプレートパラメータにoperator&lt;&lt;(put
toと発音する)ができるかどうかの診断について、
次の表のように実装を示す。</li>
</ul>
<table>
<colgroup>
<col style="width: 40%" />
<col style="width: 59%" />
</colgroup>
<thead>
<tr class="header">
<th>メタ関数名</th>
<th>メタ関数の目的</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_5_11">exists_put_to_as_member</a></td>
<td>std::ostream::operator&lt;&lt;(T)が存在するか否かの診断</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_5_12">exists_put_to_as_non_member</a></td>
<td>operator&lt;&lt;(std::ostream&amp;, T)が存在するか否かの診断</td>
</tr>
<tr class="odd">
<td><a
href="template_meta_programming.html#SS_13_3_5_13">ExistsPutTo</a></td>
<td>std::ostream&amp; &lt;&lt; Tができるかどうかの診断</td>
</tr>
<tr class="even">
<td><a
href="template_meta_programming.html#SS_13_3_5_14">Printable</a></td>
<td>std::ostream&amp; &lt;&lt; Tができるかどうか制約コンセプト</td>
</tr>
</tbody>
</table>
<ul>
<li>テンプレートパラメータがT[N]やC&lt;T&gt;の形式である時のTに、
operator&lt;&lt;が適用できるかの診断については、Tの型を取り出す必要がある。
そのようなメタ関数ValueTypeの実装を示す。</li>
</ul>
<h4 id="exists_void_func_sfinae_f">exists_void_func_sfinae_f
<a id="SS_13_3_5_1"></a></h4>
<p>「テンプレートパラメータである型が、メンバ関数void
func()を持つかどうかを診断する」 exists_void_func_sfinae_f
のSFINAEと関数テンプレート/関数のオーバーロードを用いた実装は以下のようになる。</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 13</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> exists_void_func_void <span class="op">=</span></span>
<span id="cb142-7"><a href="#cb142-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// メンバvoid func(void)があれば、voidを生成</span></span>
<span id="cb142-8"><a href="#cb142-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// メンバvoid func(void)がなければ、ill-formed</span></span>
<span id="cb142-9"><a href="#cb142-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&gt;().</span>func<span class="op">()),</span> <span class="dt">void</span><span class="op">&gt;&gt;;</span></span>
<span id="cb142-10"><a href="#cb142-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb142-11"><a href="#cb142-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-12"><a href="#cb142-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> Inner_<span class="op">::</span>exists_void_func_void<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span></span>
<span id="cb142-13"><a href="#cb142-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> exists_void_func_sfinae_f<span class="op">(</span>T<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb142-14"><a href="#cb142-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb142-15"><a href="#cb142-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb142-16"><a href="#cb142-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb142-17"><a href="#cb142-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-18"><a href="#cb142-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> exists_void_func_sfinae_f<span class="op">(...)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>decltypeの中での関数呼び出しは、実際には呼び出されず関数の戻り値の型になる。
上記の抜粋である下記のコードはこの性質を利用してSFINAEによる静的ディスパッチを行っている。</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 20</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// メンバvoid func(void)があれば、voidを生成</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// メンバvoid func(void)がなければ、ill-formed</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&gt;().</span>func<span class="op">()),</span> <span class="dt">void</span><span class="op">&gt;&gt;;</span></span></code></pre></div>
<p>単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 40</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// テスト用クラス</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> X <span class="op">{</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> func<span class="op">();</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Y <span class="op">{</span></span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> func<span class="op">();</span></span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Z <span class="op">{</span></span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> func<span class="op">();</span>  <span class="co">// privateなvoid func()は外部からは呼び出せない</span></span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb145"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 60</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_sfinae_f<span class="op">(</span><span class="dt">int</span><span class="op">{}));</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_void_func_sfinae_f<span class="op">(</span>X<span class="op">{}));</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_sfinae_f<span class="op">(</span>Y<span class="op">{}));</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_sfinae_f<span class="op">(</span>Z<span class="op">{}));</span></span></code></pre></div>
<h4 id="exists_void_func_sfinae_s">exists_void_func_sfinae_s
<a id="SS_13_3_5_2"></a></h4>
<p>「テンプレートパラメータである型が、メンバ関数void
func()を持つかどうかを診断」する exists_void_func_sfinae_s
のSFINAEとクラステンプレートの特殊化を用いた実装は以下のようになる。</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 69</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_void_func_sfinae_s <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_void_func_sfinae_s<span class="op">&lt;</span>T<span class="op">,</span></span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// メンバvoid func()が呼び出せれば、voidを生成</span></span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// メンバvoid func()が呼び出せなければ、ill-formed</span></span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&gt;().</span>func<span class="op">())</span></span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-15"><a href="#cb146-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb146-16"><a href="#cb146-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> exists_void_func_sfinae_s_v<span class="op">{</span>exists_void_func_sfinae_s<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>exists_void_func_sfinae_fとほぼ等しいSFINAEを利用したクラステンプレートの特殊化により、
静的ディスパッチを行っている。</p>
<p>単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 91</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_sfinae_s_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_void_func_sfinae_s_v<span class="op">&lt;</span>X<span class="op">&gt;);</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_sfinae_s_v<span class="op">&lt;</span>Y<span class="op">&gt;);</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_sfinae_s_v<span class="op">&lt;</span>Z<span class="op">&gt;);</span></span></code></pre></div>
<h4 id="exists_void_func_sfinae_s2">exists_void_func_sfinae_s2
<a id="SS_13_3_5_3"></a></h4>
<p>exists_void_func_sfinae_sとほぼ同様の仕様を持つexists_void_func_sfinae_s2の</p>
<ul>
<li>SFINAE</li>
<li>メンバ関数テンプレート/メンバ関数のオーバーロード</li>
<li>メンバ関数へのポインタ</li>
</ul>
<p>を用いた実装は以下のようになる。</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 100</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> exists_void_func_sfinae_s2 <span class="op">{</span></span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-6"><a href="#cb148-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// メンバvoid func()が呼び出せれば、メンバ関数テンプレートはtrueを返す</span></span>
<span id="cb148-7"><a href="#cb148-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// メンバvoid func()が呼び出せなければ、ill-formed</span></span>
<span id="cb148-8"><a href="#cb148-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">,</span> <span class="dt">void</span> <span class="op">(</span>U<span class="op">::*)()</span> <span class="op">=</span> <span class="op">&amp;</span>U<span class="op">::</span>func<span class="op">&gt;</span></span>
<span id="cb148-9"><a href="#cb148-9" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> detector<span class="op">(</span>U<span class="op">*)</span> <span class="kw">noexcept</span></span>
<span id="cb148-10"><a href="#cb148-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb148-11"><a href="#cb148-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb148-12"><a href="#cb148-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb148-13"><a href="#cb148-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-14"><a href="#cb148-14" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> detector<span class="op">(...)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb148-15"><a href="#cb148-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-16"><a href="#cb148-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb148-17"><a href="#cb148-17" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value<span class="op">{</span>exists_void_func_sfinae_s2<span class="op">::</span>detector<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span>T<span class="op">*&gt;(</span><span class="kw">nullptr</span><span class="op">))};</span></span>
<span id="cb148-18"><a href="#cb148-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb148-19"><a href="#cb148-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-20"><a href="#cb148-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb148-21"><a href="#cb148-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> exists_void_func_sfinae_s2_v<span class="op">{</span>exists_void_func_sfinae_s2<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>前2例とは異なり、上記の抜粋である下記コードのように、
メンバ関数へのポインタを使用しSFINAEを実装している。</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 105</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// メンバvoid func()が呼び出せれば、メンバ関数テンプレートはtrueを返す</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// メンバvoid func()が呼び出せなければ、ill-formed</span></span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">,</span> <span class="dt">void</span> <span class="op">(</span>U<span class="op">::*)()</span> <span class="op">=</span> <span class="op">&amp;</span>U<span class="op">::</span>func<span class="op">&gt;</span></span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> detector<span class="op">(</span>U<span class="op">*)</span> <span class="kw">noexcept</span></span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>あまり応用範囲が広くない方法ではあるが、
decltypeを使っていないのでC++03コンパイラにも受け入れられるメリットがある。</p>
<p>exists_void_func_sfinae_fと同じテスト用クラスを用いた単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 129</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_sfinae_s2_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_void_func_sfinae_s2_v<span class="op">&lt;</span>X<span class="op">&gt;);</span></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_sfinae_s2_v<span class="op">&lt;</span>Y<span class="op">&gt;);</span></span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_sfinae_s2_v<span class="op">&lt;</span>Z<span class="op">&gt;);</span></span></code></pre></div>
<p><a
href="exercise_q.html#SS_20_11_11">演習-メンバ関数の存在の診断</a></p>
<h4 id="exists_void_func_concept">exists_void_func_concept
<a id="SS_13_3_5_4"></a></h4>
<p><a
href="template_meta_programming.html#SS_13_3_5_2">exists_void_func_sfinae_s</a>や<a
href="template_meta_programming.html#SS_13_3_5_3">exists_void_func_sfinae_s2</a>
の実装で見たようなSFINAEによるテンプレートの特殊化は難解なコードを生み出す。
また、シンタックスエラー時、ほぼ理解できない大量のコンパイラのメッセージを生成する。
このため、このようなテクニックはきわめて有用である一方で、開発に多くの時間を消費する、
保守員を選んでしまう、といった問題があった。
以下に示すように、C++20から導入された<a
href="term_explanation.html#SS_19_11_2">コンセプト</a>はこのような問題の軽減につながる。</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 138</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">// C++20スタイル。concept/requiresによるSFINAEの回避</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> exists_void_func_concept <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>T<span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> t<span class="op">.</span>func<span class="op">()</span> <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;;</span></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-10"><a href="#cb151-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb151-11"><a href="#cb151-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb151-12"><a href="#cb151-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb151-13"><a href="#cb151-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_void_func_impl <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb151-14"><a href="#cb151-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb151-15"><a href="#cb151-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-16"><a href="#cb151-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">// C++17スタイル。SFINAEでの実装</span></span>
<span id="cb151-17"><a href="#cb151-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_void_func_impl<span class="op">&lt;</span></span>
<span id="cb151-18"><a href="#cb151-18" aria-hidden="true" tabindex="-1"></a>        T<span class="op">,</span></span>
<span id="cb151-19"><a href="#cb151-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>void_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&amp;&gt;().</span>func<span class="op">())&gt;&gt;</span>  <span class="co">// func()が呼び出し可能か確認</span></span>
<span id="cb151-20"><a href="#cb151-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="bu">std::</span>is_same<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&amp;&gt;().</span>func<span class="op">())&gt;</span>  <span class="co">// 戻り値がvoidか確認</span></span>
<span id="cb151-21"><a href="#cb151-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb151-22"><a href="#cb151-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb151-23"><a href="#cb151-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb151-24"><a href="#cb151-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-25"><a href="#cb151-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb151-26"><a href="#cb151-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> exists_void_func_concept <span class="op">=</span> Inner_<span class="op">::</span>exists_void_func_impl<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">;</span></span>
<span id="cb151-27"><a href="#cb151-27" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span></code></pre></div>
<div class="sourceCode" id="cb152"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 171</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_concept<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="dt">int</span><span class="op">{})&gt;);</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_void_func_concept<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>X<span class="op">{})&gt;);</span></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_concept<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>Y<span class="op">{})&gt;);</span>  <span class="co">// Y::funcの戻りはint</span></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_void_func_concept<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>Z<span class="op">{})&gt;);</span>  <span class="co">// Z::funcは呼び出せない</span></span></code></pre></div>
<h4 id="exists_beginexsits_end">exists_begin/exsits_end
<a id="SS_13_3_5_5"></a></h4>
<p>「テンプレートパラメータTに対して、
std::begin(T)が存在するか否かの診断」をするexists_beginの実装は、 「<a
href="template_meta_programming.html#SS_13_3_5_2">exists_void_func_sfinae_s</a>」
で用いたパターンのメンバ関数を非メンバ関数に置き換えて使えば以下のようになる。</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 181</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_begin <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_begin<span class="op">&lt;</span>T<span class="op">,</span> <span class="bu">std::</span>void_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&gt;()))&gt;&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> exists_begin_v<span class="op">{</span>exists_begin<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>上記で使用したstd::void_tは、テンプレートパラメータが</p>
<ul>
<li><a
href="term_explanation.html#SS_19_18_5">ill-formed</a>ならばill-formedになる</li>
<li><a
href="term_explanation.html#SS_19_18_6">well-formed</a>ならvoidを生成する</li>
</ul>
<p>テンプレートである。</p>
<p>下記単体テストでは問題ないように見えるが、</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 197</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_begin_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_begin_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_begin_v<span class="op">&lt;</span><span class="dt">int</span> <span class="at">const</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span></code></pre></div>
<p>下記の単体テストはstatic_assertがフェールするためコンパイルできない。</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 207</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 以下が問題</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_begin_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span></code></pre></div>
<p>理由は、</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>declval<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;())</span></span></code></pre></div>
<p>の戻り型が配列型の<a
href="term_explanation.html#SS_19_14_3">rvalue</a>である”int (&amp;&amp;)
[3]“となり、 これに対応するstd::beginが定義されていないためである。</p>
<p>これに対処する方法方はいくつかあるが、
すべての配列は常にstd::beginの引数になれることに気づけば、
テンプレートパラメータが配列か否かで場合分けしたクラステンプレートの特殊化を使い、
下記のように実装できることにも気付けるだろう。</p>
<div class="sourceCode" id="cb157"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 224</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_begin <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Tが非配列の場合の特殊化</span></span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_begin<span class="op">&lt;</span>T<span class="op">,</span></span>
<span id="cb157-10"><a href="#cb157-10" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">typename</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;!</span><span class="bu">std::</span>is_array_v<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb157-11"><a href="#cb157-11" aria-hidden="true" tabindex="-1"></a>                                                  <span class="bu">std::</span>void_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&gt;()))&gt;&gt;&gt;</span></span>
<span id="cb157-12"><a href="#cb157-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb157-13"><a href="#cb157-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb157-14"><a href="#cb157-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-15"><a href="#cb157-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Tが配列の場合の特殊化</span></span>
<span id="cb157-16"><a href="#cb157-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb157-17"><a href="#cb157-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_begin<span class="op">&lt;</span>T<span class="op">,</span> <span class="kw">typename</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_array_v<span class="op">&lt;</span>T<span class="op">&gt;&gt;&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb157-18"><a href="#cb157-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb157-19"><a href="#cb157-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-20"><a href="#cb157-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb157-21"><a href="#cb157-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> exists_begin_v<span class="op">{</span>exists_begin<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>2個目のexists_beginはTが配列でない場合、
3個目のexists_beginはTが配列ある場合にそれぞれが対応しているが、複雑すぎて何とも醜い。
ということで、このコードは却下して、別のアイデアを試そう。</p>
<p>テンプレートパラメータが配列である場合でも、 そのオブジェクトが<a
href="term_explanation.html#SS_19_14_2">lvalue</a>(この例ではint
(&amp;)[3])であれば、 std::beginはそのオブジェクトを使用できるので、
decltype内で使用できるlvalueのT型オブジェクトを生成できれば、
と考えれば下記のような実装を思いつくだろう。</p>
<div class="sourceCode" id="cb158"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_type_traits.h 164</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_begin <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_begin<span class="op">&lt;</span>T<span class="op">,</span> <span class="bu">std::</span>void_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&amp;&gt;()))&gt;&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-11"><a href="#cb158-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb158-12"><a href="#cb158-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> exists_begin_v<span class="op">{</span>exists_begin<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>十分にシンプルなのでこれを採用し、exists_endも同様に実装する。</p>
<div class="sourceCode" id="cb159"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_type_traits.h 177</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_end <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_end<span class="op">&lt;</span>T<span class="op">,</span> <span class="bu">std::</span>void_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>end<span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&amp;&gt;()))&gt;&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb159-11"><a href="#cb159-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> exists_end_v<span class="op">{</span>exists_end<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_type_traits_ut.cpp 97</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_begin_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_begin_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_begin_v<span class="op">&lt;</span><span class="dt">int</span> <span class="at">const</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_begin_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span>  <span class="co">// 問題が解決</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_end_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_end_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_end_v<span class="op">&lt;</span><span class="dt">int</span> <span class="at">const</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_end_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span></code></pre></div>
<h4 id="isrange">IsRange <a id="SS_13_3_5_6"></a></h4>
<p><a
href="https://cpprefjp.github.io/lang/cpp11/range_based_for.html">範囲for文</a>
文の”:“の後ろにT型オブジェクトが指定できる要件は、</p>
<ul>
<li>std::begin(T)、std::end(T)がTのイテレータであるITOR型のオブジェクトを返す</li>
<li>std::begin(T)が返すITORオブジェクトはTが保持する先頭の要素を指す</li>
<li>std::end(T)が返すITORオブジェクトはTが保持する最後の要素の次を指す</li>
<li>++ITORによりTが保持する全要素にアクセスできる</li>
</ul>
<p>ようなことである。多くの要件はセマンティクス的なものであり、
メタ関数で診断できることは前項で見たようなstd::begin(T)、std::end(T)の可否のみであると考えれば、
IsRangeの実装は以下のようになる。</p>
<div class="sourceCode" id="cb161"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_type_traits.h 191</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> IsRange <span class="op">:</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>Inner_<span class="op">::</span>exists_begin_v<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> Inner_<span class="op">::</span>exists_end_v<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>                                        <span class="bu">std::</span>true_type<span class="op">,</span> <span class="bu">std::</span>false_type<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> IsRangeV<span class="op">{</span>IsRange<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>なお、上記のコードでは、exists_begin/exsits_endは、IsRangeの実装の詳細であるため、
名前空間Inner_で宣言している。</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_type_traits_ut.cpp 116</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>IsRangeV<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>IsRangeV<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>IsRangeV<span class="op">&lt;</span><span class="dt">int</span> <span class="at">const</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>IsRangeV<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span></code></pre></div>
<p><a
href="exercise_q.html#SS_20_11_12">演習-範囲for文のオペランドになれるかどうかの診断</a></p>
<h4 id="array">Array <a id="SS_13_3_5_7"></a></h4>
<p>以降の節で使用するため、テンプレートパラメータが配列である制約を下記のように宣言する。</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/nstd_concepts.h 9</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> Array <span class="op">=</span> <span class="bu">std::</span>is_array_v<span class="op">&lt;</span>T<span class="op">&gt;;</span></span></code></pre></div>
<div class="sourceCode" id="cb164"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_concepts_ut.cpp 18</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>  a<span class="op">[</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> ptr <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v   <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Array<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">)&gt;);</span></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Array<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">)&gt;);</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Array<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ptr<span class="op">)&gt;);</span></span></code></pre></div>
<h4 id="beginableendable">Beginable/Endable
<a id="SS_13_3_5_8"></a></h4>
<p>コンセプトを使用し、<a
href="template_meta_programming.html#SS_13_3_5_5">exists_begin/exsits_end</a>をリファクタリングした例を以下に示す。</p>
<div class="sourceCode" id="cb165"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/nstd_concepts.h 15</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> Beginable <span class="op">=</span> Array<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">||</span> <span class="kw">requires</span><span class="op">(</span>T<span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> <span class="bu">std::</span>begin<span class="op">(</span>t<span class="op">)</span> <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">::</span>iterator<span class="op">&gt;;</span></span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb165-10"><a href="#cb165-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> Endable <span class="op">=</span> Array<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">||</span> <span class="kw">requires</span><span class="op">(</span>T<span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb165-11"><a href="#cb165-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb165-12"><a href="#cb165-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> <span class="bu">std::</span>end<span class="op">(</span>t<span class="op">)</span> <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">::</span>iterator<span class="op">&gt;;</span></span>
<span id="cb165-13"><a href="#cb165-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb166"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_concepts_ut.cpp 34</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>  a<span class="op">[</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> ptr <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v   <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Array<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">)&gt;);</span></span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Beginable<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">)&gt;);</span></span>
<span id="cb166-10"><a href="#cb166-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Beginable<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>ptr<span class="op">)&gt;);</span></span>
<span id="cb166-11"><a href="#cb166-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Beginable<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>v<span class="op">)&gt;);</span></span></code></pre></div>
<h4 id="ranged">Ranged <a id="SS_13_3_5_9"></a></h4>
<p>IsRangeと同一の機能を持つコンセプトRangedを以下のように定義する。</p>
<div class="sourceCode" id="cb167"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/nstd_concepts.h 33</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> Ranged <span class="op">=</span> Beginable<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> Endable<span class="op">&lt;</span>T<span class="op">&gt;;</span></span></code></pre></div>
<p>単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb168"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_concepts_ut.cpp 53</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Ranged<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Ranged<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Ranged<span class="op">&lt;</span><span class="dt">int</span> <span class="at">const</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Ranged<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span></code></pre></div>
<p>すでにみたようにRangedは<a
href="template_meta_programming.html#SS_13_3_5_5">exists_begin/exsits_end</a>の醜いコードを使用しないことで、
Rangedの可読性はIsRangedに比べ格段に改善している。</p>
<h4 id="container">Container <a id="SS_13_3_5_10"></a></h4>
<p>与えられた型をコンテナに制約するためのコンセプトを下記のように便宜的に宣言する。</p>
<div class="sourceCode" id="cb169"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/nstd_concepts.h 33</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> Ranged <span class="op">=</span> Beginable<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> Endable<span class="op">&lt;</span>T<span class="op">&gt;;</span></span></code></pre></div>
<p>単体テストには少々の工夫が必要になる。</p>
<div class="sourceCode" id="cb170"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_concepts_ut.cpp 62</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> X <span class="op">{</span></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> data<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> begin<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> data<span class="op">.</span>begin<span class="op">();</span> <span class="op">}</span>  <span class="co">// std::begin</span></span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> end<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> data<span class="op">.</span>end<span class="op">();</span> <span class="op">}</span>      <span class="co">// std::end</span></span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_concepts_ut.cpp 74</span></span>
<span id="cb170-11"><a href="#cb170-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-12"><a href="#cb170-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Container<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb170-13"><a href="#cb170-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Container<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb170-14"><a href="#cb170-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Container<span class="op">&lt;</span><span class="dt">int</span> <span class="at">const</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span>
<span id="cb170-15"><a href="#cb170-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-16"><a href="#cb170-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Ranged<span class="op">&lt;</span>X<span class="op">&gt;);</span>  <span class="co">// begin/endがあるが、value_typeをもっていない</span></span></code></pre></div>
<h4 id="exists_put_to_as_member">exists_put_to_as_member
<a id="SS_13_3_5_11"></a></h4>
<p>std::ostreamのメンバ関数operator&lt;&lt;の戻り型はstd::ostream&amp;であるため、
exists_put_to_as_memberの実装は以下のようになる(“&lt;&lt;”は英語で”put
to”と発音する)。</p>
<div class="sourceCode" id="cb171"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 260</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="bu">std::</span>ostream<span class="op">&amp;&gt;</span></span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_put_to_as_member <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb171-8"><a href="#cb171-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_put_to_as_member<span class="op">&lt;</span>T<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span><span class="bu">std::</span>ostream<span class="op">&amp;&gt;().</span><span class="kw">operator</span><span class="op">&lt;&lt;(</span></span>
<span id="cb171-9"><a href="#cb171-9" aria-hidden="true" tabindex="-1"></a>                                          <span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&gt;()))&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb171-10"><a href="#cb171-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb171-11"><a href="#cb171-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-12"><a href="#cb171-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb171-13"><a href="#cb171-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> exists_put_to_as_member_v<span class="op">{</span>exists_put_to_as_member<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>「<a
href="template_meta_programming.html#SS_13_3_5_1">exists_void_func_sfinae_f</a>の実装」と同様のパターンを使用したので解説は不要だろう。</p>
<p>単体テストは以下のようになる。</p>
<div class="sourceCode" id="cb172"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/test_class.h 3</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> test_class_exits_put_to <span class="op">{</span></span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>        test_class_exits_put_to<span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">i_</span><span class="op">{</span>i<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">i_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb172-7"><a href="#cb172-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-8"><a href="#cb172-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb172-9"><a href="#cb172-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="va">i_</span><span class="op">;</span></span>
<span id="cb172-10"><a href="#cb172-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb172-11"><a href="#cb172-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-12"><a href="#cb172-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> test_class_exits_put_to <span class="at">const</span><span class="op">&amp;</span> p<span class="op">)</span></span>
<span id="cb172-13"><a href="#cb172-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb172-14"><a href="#cb172-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os <span class="op">&lt;&lt;</span> p<span class="op">.</span>get<span class="op">();</span></span>
<span id="cb172-15"><a href="#cb172-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb172-16"><a href="#cb172-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-17"><a href="#cb172-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> test_class_not_exits_put_to <span class="op">{};</span></span></code></pre></div>
<div class="sourceCode" id="cb173"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 277</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_put_to_as_member_v<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;);</span></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_put_to_as_member_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_put_to_as_member_v<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_put_to_as_member_v<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;*&gt;);</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_put_to_as_member_v<span class="op">&lt;</span>test_class_exits_put_to<span class="op">&gt;);</span></span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>exists_put_to_as_member_v<span class="op">&lt;</span>test_class_not_exits_put_to<span class="op">&gt;);</span></span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_put_to_as_member_v<span class="op">&lt;</span>test_class_not_exits_put_to<span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span>  <span class="co">// 驚き!</span></span></code></pre></div>
<p>やや驚きなのは、上記の抜粋である下記コードがコンパイルできることである。</p>
<div class="sourceCode" id="cb174"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 286</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>exists_put_to_as_member_v<span class="op">&lt;</span>test_class_not_exits_put_to<span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span>  <span class="co">// 驚き!</span></span></code></pre></div>
<p>これは、</p>
<div class="sourceCode" id="cb175"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="bu">std::</span>ostream::operator<span class="op">&lt;&lt;(</span><span class="dt">void</span> <span class="at">const</span><span class="op">*)</span></span></code></pre></div>
<p>が定義されているため、配列がポインタに変換されてこのメンバ関数にバインドした結果である。</p>
<h4 id="exists_put_to_as_non_member">exists_put_to_as_non_member
<a id="SS_13_3_5_12"></a></h4>
<p>exists_put_to_as_non_memberの実装は以下のようになる。</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 295</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="bu">std::</span>ostream<span class="op">&amp;&gt;</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_put_to_as_non_member <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> exists_put_to_as_non_member<span class="op">&lt;</span>T<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span><span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>declval<span class="op">&lt;</span><span class="bu">std::</span>ostream<span class="op">&amp;&gt;(),</span></span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a>                                                              <span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&gt;()))&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-12"><a href="#cb176-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb176-13"><a href="#cb176-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> exists_put_to_as_non_member_v<span class="op">{</span>exists_put_to_as_non_member<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>「<a
href="template_meta_programming.html#SS_13_3_5_5">exists_begin/exsits_end</a>や<a
href="template_meta_programming.html#SS_13_3_5_11">exists_put_to_as_member</a>の実装」
で使用したパターンを混合しただけなので解説や単体テストは省略する。</p>
<h4 id="existsputto">ExistsPutTo <a id="SS_13_3_5_13"></a></h4>
<p>テンプレートパラメータT、T型オブジェクトtに対して、 std::ostream
&lt;&lt;
tができるかどうかを判断するExistsPutToの実装は以下のようになる。</p>
<div class="sourceCode" id="cb177"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/exists_func_ut.cpp 324</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ExistsPutTo</span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span></span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a>              Inner_<span class="op">::</span>exists_put_to_as_member_v<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">||</span> Inner_<span class="op">::</span>exists_put_to_as_non_member_v<span class="op">&lt;</span>T<span class="op">&gt;,</span></span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a>              <span class="bu">std::</span>true_type<span class="op">,</span> <span class="bu">std::</span>false_type<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb177-9"><a href="#cb177-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-10"><a href="#cb177-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb177-11"><a href="#cb177-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> ExistsPutToV<span class="op">{</span>ExistsPutTo<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span></code></pre></div>
<p>「<a
href="template_meta_programming.html#SS_13_3_5_6">IsRange</a>の実装」に影響されて、一旦このように実装したが、先に書いた通り、
そもそものExistsPutToの役割はstd::ostream &lt;&lt;
tができるかどうかの診断であることを思い出せば、
下記のように、もっとシンプルに実装できることに気づくだろう。</p>
<div class="sourceCode" id="cb178"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_type_traits.h 206</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="bu">std::</span>ostream<span class="op">&amp;&gt;</span></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ExistsPutTo <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb178-7"><a href="#cb178-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb178-8"><a href="#cb178-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-9"><a href="#cb178-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb178-10"><a href="#cb178-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ExistsPutTo<span class="op">&lt;</span>T<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span><span class="bu">std::</span>ostream<span class="op">&amp;&gt;()</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>declval<span class="op">&lt;</span>T<span class="op">&gt;())&gt;</span></span>
<span id="cb178-11"><a href="#cb178-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb178-12"><a href="#cb178-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb178-13"><a href="#cb178-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-14"><a href="#cb178-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb178-15"><a href="#cb178-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> ExistsPutToV<span class="op">{</span>ExistsPutTo<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span>
<span id="cb178-16"><a href="#cb178-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb179"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_type_traits_ut.cpp 127</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>ExistsPutToV<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;);</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>ExistsPutToV<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>ExistsPutToV<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>ExistsPutToV<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;*&gt;);</span></span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>ExistsPutToV<span class="op">&lt;</span>test_class_exits_put_to<span class="op">&gt;);</span></span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>ExistsPutToV<span class="op">&lt;</span>test_class_not_exits_put_to<span class="op">&gt;);</span></span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>ExistsPutToV<span class="op">&lt;</span>test_class_not_exits_put_to<span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span></code></pre></div>
<h4 id="printable">Printable <a id="SS_13_3_5_14"></a></h4>
<p>これまでのパターンに従ってPrintableを以下のように作る。</p>
<ul>
<li><a href="term_explanation.html#SS_19_11_1">SFINAE</a>を利用した<a
href="template_meta_programming.html#SS_13_3_5_13">ExistsPutTo</a>は複雑で醜いため、リファクタリングする。</li>
<li>リファクタリングに合わせてコンセプト化し、それらしい名称にする。</li>
</ul>
<div class="sourceCode" id="cb180"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/nstd_concepts.h 42</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> Printable <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>T t<span class="op">,</span> <span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">)</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> os <span class="op">&lt;&lt;</span> t <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span><span class="bu">std::</span>ostream<span class="op">&amp;&gt;;</span></span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb181"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_concepts_ut.cpp 86</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> X <span class="op">{};</span>  <span class="co">// Non-pritable</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Y <span class="op">{};</span>  <span class="co">// Printable</span></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Y<span class="op">)</span></span>
<span id="cb181-7"><a href="#cb181-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb181-8"><a href="#cb181-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span>  <span class="co">// 何もしない</span></span>
<span id="cb181-9"><a href="#cb181-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb181-10"><a href="#cb181-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-11"><a href="#cb181-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_concepts_ut.cpp 99</span></span>
<span id="cb181-12"><a href="#cb181-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb181-13"><a href="#cb181-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Printable<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;);</span></span>
<span id="cb181-14"><a href="#cb181-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Printable<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span></span>
<span id="cb181-15"><a href="#cb181-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Printable<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb181-16"><a href="#cb181-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Printable<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;*&gt;);</span></span>
<span id="cb181-17"><a href="#cb181-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Printable<span class="op">&lt;</span>X<span class="op">&gt;);</span></span>
<span id="cb181-18"><a href="#cb181-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Printable<span class="op">&lt;</span>Y<span class="op">&gt;);</span></span></code></pre></div>
<p>これ以降は、<a
href="template_meta_programming.html#SS_13_3_5_13">ExistsPutTo</a>ではなくPrintableを使用する。</p>
<h4 id="valuetypeの実装">ValueTypeの実装 <a id="SS_13_3_5_15"></a></h4>
<p>下記で示す通り、</p>
<div class="sourceCode" id="cb182"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_type_traits_ut.cpp 145</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> T <span class="op">{};</span></span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> x<span class="op">)</span></span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os <span class="op">&lt;&lt;</span> <span class="st">&quot;T:&quot;</span> <span class="op">&lt;&lt;</span> x<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb182-8"><a href="#cb182-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb182-9"><a href="#cb182-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-10"><a href="#cb182-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;,</span> T <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb182-11"><a href="#cb182-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-12"><a href="#cb182-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>Nstd<span class="op">::</span>ExistsPutToV<span class="op">&lt;</span>T<span class="op">&gt;);</span>              <span class="co">// std::cout &lt;&lt; T{} はできない</span></span>
<span id="cb182-13"><a href="#cb182-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>ExistsPutToV<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;&gt;);</span>  <span class="co">// std::cout &lt;&lt; std::vector&lt;T&gt;{} はできる</span></span>
<span id="cb182-14"><a href="#cb182-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>Nstd<span class="op">::</span>ExistsPutToV<span class="op">&lt;</span>T<span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span>            <span class="co">// std::cout &lt;&lt; T[3]{} はできる</span></span></code></pre></div>
<p>型Xが与えれ、その形式が、</p>
<ul>
<li>クラステンプレートCとその型パラメータTにより、C&lt;T&gt;</li>
<li>型Tと定数整数Nにより、T[N]</li>
</ul>
<p>のような場合、Printable&lt;X&gt;がtrueであっても、Printable&lt;T&gt;の真偽はわからない。
従って上記のようなTに対して、Printable&lt;T&gt;がtrueかどうかを診断するためには、
XからTを導出することが必要になる。ここでは、そのようなメタ関数ValueTypeの実装を考える。
このValueTypeは上記のX、Tに対して、</p>
<div class="sourceCode" id="cb183"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span>ValueType<span class="op">&lt;</span>X<span class="op">&gt;::</span>type<span class="op">,</span> T<span class="op">&gt;);</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// もしくは、</span></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same<span class="op">&lt;</span>ValueType<span class="op">&lt;</span>X<span class="op">,</span> T<span class="op">&gt;);</span></span></code></pre></div>
<p>となるような機能を持たなければならないことは明らかだろう。
その他の機能については実装しながら決定していく。</p>
<p>一見、難しそうなテンプレートを作るコツは、条件を絞って少しずつ作っていくことである。
いきなり大量のテンプレートを書いてしまうと、
その何十倍ものコンパイルエラーに打ちのめされること必至である。</p>
<p>ということで、まずは、1次元の配列に対してのみ動作するValueTypeの実装を示す
(下記で使用するstd::remove_extent_t&lt;T&gt;は、テンプレートパラメータが配列だった場合に、
その次元を一つだけ除去するメタ関数である)。</p>
<div class="sourceCode" id="cb184"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 18</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType <span class="op">{</span></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> <span class="dt">void</span><span class="op">;</span></span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType<span class="op">&lt;</span>T<span class="op">[</span>N<span class="op">]&gt;</span> <span class="op">{</span>  <span class="co">// 配列型の特殊化</span></span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb184-12"><a href="#cb184-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-13"><a href="#cb184-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb184-14"><a href="#cb184-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> ValueTypeT <span class="op">=</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type<span class="op">;</span></span></code></pre></div>
<p>このコードは問題なく動作するが、下記の通り、2次元配列に対するValueType::typeは1次元配列となる。</p>
<div class="sourceCode" id="cb185"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 36</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> ValueTypeT<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">]&gt;&gt;);</span></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> ValueTypeT<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span></span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">2</span><span class="op">],</span> ValueTypeT<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">]&gt;&gt;);</span></span></code></pre></div>
<p>これを多次元配列に拡張する前に、配列の次元をで返すValueType::Nestや、extent、type_directを追加することにすると、
コードは下記のようになるだろう。</p>
<div class="sourceCode" id="cb186"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 49</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType <span class="op">{</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type        <span class="op">=</span> <span class="dt">void</span><span class="op">;</span></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_direct <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> Nest<span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType<span class="op">&lt;</span>T<span class="op">[</span>N<span class="op">]&gt;</span> <span class="op">{</span>  <span class="co">// 配列型の特殊化</span></span>
<span id="cb186-12"><a href="#cb186-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type                     <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb186-13"><a href="#cb186-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_direct              <span class="op">=</span> T<span class="op">;</span>  <span class="co">// T = S[N]の場合、Tを保存</span></span>
<span id="cb186-14"><a href="#cb186-14" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> extent <span class="op">=</span> N<span class="op">;</span>  <span class="co">// T = S[N]の場合、Nを保存</span></span>
<span id="cb186-15"><a href="#cb186-15" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> Nest<span class="op">{</span>ValueType<span class="op">&lt;</span>type<span class="op">&gt;::</span>Nest <span class="op">+</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb186-16"><a href="#cb186-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb186-17"><a href="#cb186-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-18"><a href="#cb186-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb186-19"><a href="#cb186-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> ValueTypeT <span class="op">=</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type<span class="op">;</span></span></code></pre></div>
<p>動作は下記のようになる。</p>
<div class="sourceCode" id="cb187"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 76</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">0</span> <span class="op">==</span> ValueType<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>Nest<span class="op">);</span></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">1</span> <span class="op">==</span> ValueType<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">]&gt;::</span>Nest<span class="op">);</span></span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">2</span> <span class="op">==</span> ValueType<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">]&gt;::</span>Nest<span class="op">);</span></span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">1</span> <span class="op">==</span> ValueType<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">]&gt;::</span>extent<span class="op">);</span></span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">1</span> <span class="op">==</span> ValueType<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">]&gt;::</span>extent<span class="op">);</span>  <span class="co">// int[1][2] == (int[1])[2]</span></span></code></pre></div>
<p>ここで、下記のような仕様をもつValueType::type_n&lt;N&gt;を考える。</p>
<pre><code>    ValueType&lt;int[1][2][3]&gt;::type_n&lt;0&gt;が表す型は、int[1][2][3]
    ValueType&lt;int[1][2][3]&gt;::type_n&lt;1&gt;が表す型は、int[2][3]
    ValueType&lt;int[1][2][3]&gt;::type_n&lt;2&gt;が表す型は、int[3]
    ValueType&lt;int[1][2][3]&gt;::type_n&lt;3&gt;が表す型は、int</code></pre>
<p>ValueType::type_n&lt;N&gt;は玉ねぎの皮を一枚ずつむくようなメンバテンプレートになる。
プライマリの実装は以下のようになる。</p>
<div class="sourceCode" id="cb189"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 91</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType <span class="op">{</span></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type                     <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_direct              <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> extent <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> Nest   <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_n <span class="op">=</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>N <span class="op">==</span> <span class="dv">0</span><span class="op">,</span> T<span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span>  <span class="co">// Nが0のときはT、それ以外はvoidを返す</span></span>
<span id="cb189-12"><a href="#cb189-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>Nが非0の場合、Value::type_n&lt;N&gt;はvoidになる仕様にした。</p>
<p>配列に対する特殊化は以下のようになる。</p>
<div class="sourceCode" id="cb190"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 104</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span>  <span class="co">// Array Tを使わずに配列の一般的な表現を使用してNを取り出す</span></span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType<span class="op">&lt;</span>T<span class="op">[</span>N<span class="op">]&gt;</span> <span class="op">{</span>  <span class="co">// 配列型の特殊化</span></span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type                     <span class="op">=</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_direct              <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> extent <span class="op">=</span> N<span class="op">;</span></span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> Nest   <span class="op">=</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>Nest <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb190-9"><a href="#cb190-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-10"><a href="#cb190-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> M<span class="op">&gt;</span></span>
<span id="cb190-11"><a href="#cb190-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_n <span class="op">=</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>M <span class="op">==</span> <span class="dv">0</span><span class="op">,</span> T<span class="op">[</span>N<span class="op">],</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span><span class="kw">template</span> type_n<span class="op">&lt;</span>M <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;&gt;;</span></span>
<span id="cb190-12"><a href="#cb190-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>Value::type_n&lt;&gt;のリカーシブ展開を頭の中で行うことは難しいので、
読者の理解を確かめるため、以下のように順を追って一枚づつ配列の階層を剝ぎ取る様子を見ていく。</p>
<div class="sourceCode" id="cb191"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 126</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ValueType&lt;int[1][2][3]&gt;の展開について、考えよう。</span></span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// int[1][2][3]は == (int[2][3])[1]であるため、下記の式が成立する</span></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>ValueType<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">]&gt;::</span>type_direct<span class="op">,</span> <span class="dt">int</span><span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">]&gt;);</span></span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>ValueType<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">]&gt;::</span>extent <span class="op">==</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// type_n&lt;M&gt;の仕様は、Mが1の時、配列から1階層を1枚剥ぎ取ることである</span></span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> T1 <span class="op">=</span> ValueType<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">]&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;;</span>  <span class="co">// 長い式は可読性が劣化するからT1を宣言</span></span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-12"><a href="#cb191-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// int[2][3] == (int[3])[2]であるため、下記の式が成立する</span></span>
<span id="cb191-13"><a href="#cb191-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T1<span class="op">,</span> <span class="dt">int</span><span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">]&gt;);</span></span>
<span id="cb191-14"><a href="#cb191-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>ValueType<span class="op">&lt;</span>T1<span class="op">&gt;::</span>extent <span class="op">==</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb191-15"><a href="#cb191-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-16"><a href="#cb191-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 上記T1と同様にT2を宣言する</span></span>
<span id="cb191-17"><a href="#cb191-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> T2 <span class="op">=</span> ValueType<span class="op">&lt;</span>T1<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;;</span></span>
<span id="cb191-18"><a href="#cb191-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-19"><a href="#cb191-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// int[2][3] == (int[3])[2]であるため、下記の式が成立する</span></span>
<span id="cb191-20"><a href="#cb191-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T2<span class="op">,</span> <span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span></span>
<span id="cb191-21"><a href="#cb191-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>ValueType<span class="op">&lt;</span>T2<span class="op">&gt;::</span>extent <span class="op">==</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb191-22"><a href="#cb191-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-23"><a href="#cb191-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 上記T1、T2と同様にT3を宣言する</span></span>
<span id="cb191-24"><a href="#cb191-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> T3 <span class="op">=</span> ValueType<span class="op">&lt;</span>T2<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;;</span></span>
<span id="cb191-25"><a href="#cb191-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-26"><a href="#cb191-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T3<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;);</span></span>
<span id="cb191-27"><a href="#cb191-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>ValueType<span class="op">&lt;</span>T3<span class="op">&gt;::</span>extent <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<p>単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb192"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 155</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> T <span class="op">=</span> <span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">],</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;&gt;);</span>  <span class="co">// 0枚剝く</span></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">],</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;&gt;);</span>     <span class="co">// 1枚剝く</span></span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">],</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;&gt;);</span>        <span class="co">// 2枚剝く</span></span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">3</span><span class="op">&gt;&gt;);</span>           <span class="co">// 3枚剝く</span></span>
<span id="cb192-9"><a href="#cb192-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">void</span><span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">4</span><span class="op">&gt;&gt;);</span>          <span class="co">// 全部剝く</span></span></code></pre></div>
<p>また、ValueType::NestとValueType::type_n&lt;&gt;の関係に注目すれば、
上記エイリアスTに対して下記が成立する。</p>
<div class="sourceCode" id="cb193"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 178</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> T <span class="op">=</span> ValueTypeT_n<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">],</span> <span class="dv">3</span><span class="op">&gt;;</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> T<span class="op">&gt;);</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> ValueTypeT_n<span class="op">&lt;</span>T<span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>Nest<span class="op">&gt;&gt;);</span></span></code></pre></div>
<p>このテンプレートにコンテナが渡された時の特殊化を与えることができればValueTypeは完成するが、
こういったタイミングで、リファクタリングを行い名前の整理や不要になったコードを削除することは良い習慣である。</p>
<p>これによりValueTypeは下記のようになる。</p>
<div class="sourceCode" id="cb194"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 240</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType <span class="op">{</span>  <span class="co">// プライマリ</span></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type                   <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> Nest <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_n <span class="op">=</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>N <span class="op">==</span> <span class="dv">0</span><span class="op">,</span> T<span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb194-11"><a href="#cb194-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-12"><a href="#cb194-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb194-13"><a href="#cb194-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType<span class="op">&lt;</span>T<span class="op">[</span>N<span class="op">]&gt;</span> <span class="op">{</span>  <span class="co">// 配列型の特殊化</span></span>
<span id="cb194-14"><a href="#cb194-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type                   <span class="op">=</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb194-15"><a href="#cb194-15" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> Nest <span class="op">=</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>Nest <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb194-16"><a href="#cb194-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-17"><a href="#cb194-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> M<span class="op">&gt;</span></span>
<span id="cb194-18"><a href="#cb194-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_n <span class="op">=</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>M <span class="op">==</span> <span class="dv">0</span><span class="op">,</span> T<span class="op">[</span>N<span class="op">],</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span><span class="kw">template</span> type_n<span class="op">&lt;</span>M <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;&gt;;</span></span>
<span id="cb194-19"><a href="#cb194-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>準備は整ったので上記のValueTypeに下記のようなコンテナ用特殊化を追加する。
この特殊化のテンプレートパラメータの制約にはすでに開発したコンセプト<a
href="template_meta_programming.html#SS_13_3_5_10">Container</a>を使用する。</p>
<div class="sourceCode" id="cb195"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 261</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span>Container T<span class="op">&gt;</span></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span>  <span class="co">// コンテナ型の特殊化</span></span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type                   <span class="op">=</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">::</span><span class="dt">value_type</span><span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> Nest <span class="op">=</span> ValueType<span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">::</span><span class="dt">value_type</span><span class="op">&gt;::</span>Nest <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_n <span class="op">=</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>N <span class="op">==</span> <span class="dv">0</span><span class="op">,</span> T<span class="op">,</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">::</span><span class="dt">value_type</span><span class="op">&gt;::</span><span class="kw">template</span> type_n<span class="op">&lt;</span>N <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;&gt;;</span></span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>まずは、追加した特殊化の機能を下記のように単体テストを行う。</p>
<div class="sourceCode" id="cb196"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 278</span></span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> T <span class="op">=</span> <span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// コンテナ特殊化以外の機能チェック</span></span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;&gt;);</span></span>
<span id="cb196-7"><a href="#cb196-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">],</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;&gt;);</span></span>
<span id="cb196-8"><a href="#cb196-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">],</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;&gt;);</span></span>
<span id="cb196-9"><a href="#cb196-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">3</span><span class="op">&gt;&gt;);</span></span>
<span id="cb196-10"><a href="#cb196-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type<span class="op">&gt;);</span></span></code></pre></div>
<p>次に特殊化がデグレードを起こしていないことを下記のように証明する。</p>
<div class="sourceCode" id="cb197"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 291</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// コンテナ特殊化の機能の機能チェック</span></span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> T <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&gt;;</span></span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;&gt;);</span></span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">3</span><span class="op">&gt;&gt;);</span></span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>Nest <span class="op">==</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb197-9"><a href="#cb197-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type<span class="op">&gt;);</span></span></code></pre></div>
<p>ValueTypeの最終的な単体テストのために上記を統合したテストを行う。</p>
<div class="sourceCode" id="cb198"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/value_type_ut.cpp 303</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 統合した機能チェック</span></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> T <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">]&gt;;</span></span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;&gt;);</span></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">],</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;&gt;);</span></span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">],</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;&gt;);</span></span>
<span id="cb198-9"><a href="#cb198-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">],</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">3</span><span class="op">&gt;&gt;);</span></span>
<span id="cb198-10"><a href="#cb198-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">4</span><span class="op">&gt;&gt;);</span></span>
<span id="cb198-11"><a href="#cb198-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type<span class="op">&gt;);</span></span>
<span id="cb198-12"><a href="#cb198-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>Nest <span class="op">==</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb198-13"><a href="#cb198-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-14"><a href="#cb198-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> L <span class="op">=</span> <span class="bu">std::</span>list<span class="op">&lt;</span>T<span class="op">&gt;;</span></span>
<span id="cb198-15"><a href="#cb198-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-16"><a href="#cb198-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> ValueType<span class="op">&lt;</span>L<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;&gt;);</span></span>
<span id="cb198-17"><a href="#cb198-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">],</span> ValueType<span class="op">&lt;</span>L<span class="op">&gt;::</span>type_n<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;&gt;);</span></span>
<span id="cb198-18"><a href="#cb198-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type<span class="op">&gt;);</span></span>
<span id="cb198-19"><a href="#cb198-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>ValueType<span class="op">&lt;</span>L<span class="op">&gt;::</span>Nest <span class="op">==</span> <span class="dv">5</span><span class="op">);</span></span></code></pre></div>
<p>以上でValueTypeは完成したが、これ以降のこのドキュメントの前準備として、
多少のメンバの追加や調整をした最終のコードを以下に示す。</p>
<div class="sourceCode" id="cb199"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_type_traits.h 227</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span>  <span class="co">// ValueTypeのプライマリ</span></span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType <span class="op">{</span></span>
<span id="cb199-6"><a href="#cb199-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_direct <span class="op">=</span> <span class="dt">void</span><span class="op">;</span></span>
<span id="cb199-7"><a href="#cb199-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-8"><a href="#cb199-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span>   IsBuiltinArray<span class="op">{</span><span class="kw">false</span><span class="op">};</span></span>
<span id="cb199-9"><a href="#cb199-9" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> Nest<span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb199-10"><a href="#cb199-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-11"><a href="#cb199-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb199-12"><a href="#cb199-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_n <span class="op">=</span> <span class="kw">typename</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>N <span class="op">==</span> <span class="dv">0</span><span class="op">,</span> T<span class="op">,</span> <span class="dt">void</span><span class="op">&gt;;</span></span>
<span id="cb199-13"><a href="#cb199-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-14"><a href="#cb199-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> type_n<span class="op">&lt;</span>Nest<span class="op">&gt;;</span></span>
<span id="cb199-15"><a href="#cb199-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb199-16"><a href="#cb199-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-17"><a href="#cb199-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &lt;= 201703L  </span><span class="co">// c++17</span></span>
<span id="cb199-18"><a href="#cb199-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb199-19"><a href="#cb199-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-20"><a href="#cb199-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb199-21"><a href="#cb199-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> conditional_value_type_n <span class="op">{</span></span>
<span id="cb199-22"><a href="#cb199-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> <span class="kw">typename</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span></span>
<span id="cb199-23"><a href="#cb199-23" aria-hidden="true" tabindex="-1"></a>            ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>Nest <span class="op">!=</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb199-24"><a href="#cb199-24" aria-hidden="true" tabindex="-1"></a>            <span class="kw">typename</span> ValueType<span class="op">&lt;</span><span class="kw">typename</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_direct<span class="op">&gt;::</span><span class="kw">template</span> type_n<span class="op">&lt;</span>N <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;,</span> T<span class="op">&gt;;</span></span>
<span id="cb199-25"><a href="#cb199-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb199-26"><a href="#cb199-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-27"><a href="#cb199-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb199-28"><a href="#cb199-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> conditional_value_type_n<span class="op">&lt;</span>T<span class="op">,</span> <span class="dv">0</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb199-29"><a href="#cb199-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb199-30"><a href="#cb199-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb199-31"><a href="#cb199-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-32"><a href="#cb199-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb199-33"><a href="#cb199-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> array_or_container <span class="op">:</span> <span class="bu">std::</span>false_type <span class="op">{</span></span>
<span id="cb199-34"><a href="#cb199-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb199-35"><a href="#cb199-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-36"><a href="#cb199-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb199-37"><a href="#cb199-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> array_or_container<span class="op">&lt;</span>T<span class="op">,</span> <span class="kw">typename</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_array_v<span class="op">&lt;</span>T<span class="op">&gt;&gt;&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb199-38"><a href="#cb199-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> <span class="kw">typename</span> <span class="bu">std::</span>remove_extent_t<span class="op">&lt;</span>T<span class="op">&gt;;</span></span>
<span id="cb199-39"><a href="#cb199-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb199-40"><a href="#cb199-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-41"><a href="#cb199-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Tが配列でなく、且つT型インスタンスに範囲for文が適用できるならばstdコンテナと診断する</span></span>
<span id="cb199-42"><a href="#cb199-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb199-43"><a href="#cb199-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> is_container_v<span class="op">{</span>Nstd<span class="op">::</span>IsRange<span class="op">&lt;</span>T<span class="op">&gt;::</span>value <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="bu">std::</span>is_array_v<span class="op">&lt;</span>T<span class="op">&gt;};</span></span>
<span id="cb199-44"><a href="#cb199-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-45"><a href="#cb199-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb199-46"><a href="#cb199-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> array_or_container<span class="op">&lt;</span>T<span class="op">,</span> <span class="kw">typename</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span>is_container_v<span class="op">&lt;</span>T<span class="op">&gt;&gt;&gt;</span> <span class="op">:</span> <span class="bu">std::</span>true_type <span class="op">{</span></span>
<span id="cb199-47"><a href="#cb199-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> <span class="kw">typename</span> T<span class="op">::</span><span class="dt">value_type</span><span class="op">;</span></span>
<span id="cb199-48"><a href="#cb199-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb199-49"><a href="#cb199-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-50"><a href="#cb199-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb199-51"><a href="#cb199-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> array_or_container_v<span class="op">{</span>array_or_container<span class="op">&lt;</span>T<span class="op">&gt;::</span>value<span class="op">};</span></span>
<span id="cb199-52"><a href="#cb199-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb199-53"><a href="#cb199-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-54"><a href="#cb199-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">// ValueTypeの特殊化</span></span>
<span id="cb199-55"><a href="#cb199-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType<span class="op">&lt;</span>T<span class="op">,</span> <span class="kw">typename</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span>Inner_<span class="op">::</span>array_or_container_v<span class="op">&lt;</span>T<span class="op">&gt;&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb199-56"><a href="#cb199-56" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_direct <span class="op">=</span> <span class="kw">typename</span> Inner_<span class="op">::</span>array_or_container<span class="op">&lt;</span>T<span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb199-57"><a href="#cb199-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-58"><a href="#cb199-58" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span>   IsBuiltinArray<span class="op">{</span><span class="bu">std::</span>is_array_v<span class="op">&lt;</span>T<span class="op">&gt;};</span></span>
<span id="cb199-59"><a href="#cb199-59" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> Nest<span class="op">{</span>ValueType<span class="op">&lt;</span>type_direct<span class="op">&gt;::</span>Nest <span class="op">+</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb199-60"><a href="#cb199-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-61"><a href="#cb199-61" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb199-62"><a href="#cb199-62" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_n <span class="op">=</span> <span class="kw">typename</span> Inner_<span class="op">::</span>conditional_value_type_n<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb199-63"><a href="#cb199-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-64"><a href="#cb199-64" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> type_n<span class="op">&lt;</span>Nest<span class="op">&gt;;</span></span>
<span id="cb199-65"><a href="#cb199-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb199-66"><a href="#cb199-66" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb199-67"><a href="#cb199-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-68"><a href="#cb199-68" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb199-69"><a href="#cb199-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType<span class="op">&lt;</span>T<span class="op">[</span>N<span class="op">]&gt;</span> <span class="op">{</span>  <span class="co">// 配列型の特殊化</span></span>
<span id="cb199-70"><a href="#cb199-70" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_direct <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb199-71"><a href="#cb199-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-72"><a href="#cb199-72" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span>   IsBuiltinArray<span class="op">{</span><span class="kw">true</span><span class="op">};</span></span>
<span id="cb199-73"><a href="#cb199-73" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> Nest<span class="op">{</span>ValueType<span class="op">&lt;</span>type_direct<span class="op">&gt;::</span>Nest <span class="op">+</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb199-74"><a href="#cb199-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-75"><a href="#cb199-75" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> M<span class="op">&gt;</span></span>
<span id="cb199-76"><a href="#cb199-76" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_n <span class="op">=</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>M <span class="op">==</span> <span class="dv">0</span><span class="op">,</span> T<span class="op">[</span>N<span class="op">],</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span><span class="kw">template</span> type_n<span class="op">&lt;</span>M <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;&gt;;</span></span>
<span id="cb199-77"><a href="#cb199-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-78"><a href="#cb199-78" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> type_n<span class="op">&lt;</span>Nest<span class="op">&gt;;</span></span>
<span id="cb199-79"><a href="#cb199-79" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb199-80"><a href="#cb199-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-81"><a href="#cb199-81" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span>Container T<span class="op">&gt;</span>  <span class="co">// ValueTypeの特殊化</span></span>
<span id="cb199-82"><a href="#cb199-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span>   <span class="co">// コンセプトによるSFINAEの回避</span></span>
<span id="cb199-83"><a href="#cb199-83" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_direct <span class="op">=</span> <span class="kw">typename</span> T<span class="op">::</span><span class="dt">value_type</span><span class="op">;</span></span>
<span id="cb199-84"><a href="#cb199-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-85"><a href="#cb199-85" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span>   IsBuiltinArray<span class="op">{</span><span class="kw">false</span><span class="op">};</span></span>
<span id="cb199-86"><a href="#cb199-86" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> Nest<span class="op">{</span>ValueType<span class="op">&lt;</span>type_direct<span class="op">&gt;::</span>Nest <span class="op">+</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb199-87"><a href="#cb199-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-88"><a href="#cb199-88" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb199-89"><a href="#cb199-89" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type_n <span class="op">=</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>N <span class="op">==</span> <span class="dv">0</span><span class="op">,</span> T<span class="op">,</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">::</span><span class="dt">value_type</span><span class="op">&gt;::</span><span class="kw">template</span> type_n<span class="op">&lt;</span>N <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;&gt;;</span></span>
<span id="cb199-90"><a href="#cb199-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-91"><a href="#cb199-91" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> type <span class="op">=</span> type_n<span class="op">&lt;</span>Nest<span class="op">&gt;;</span></span>
<span id="cb199-92"><a href="#cb199-92" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb199-93"><a href="#cb199-93" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb199-94"><a href="#cb199-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-95"><a href="#cb199-95" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb199-96"><a href="#cb199-96" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> ValueTypeT <span class="op">=</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb199-97"><a href="#cb199-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-98"><a href="#cb199-98" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb199-99"><a href="#cb199-99" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> ValueTypeT_n <span class="op">=</span> <span class="kw">typename</span> ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span><span class="kw">template</span> type_n<span class="op">&lt;</span>N<span class="op">&gt;;</span></span>
<span id="cb199-100"><a href="#cb199-100" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p><a href="exercise_q.html#SS_20_11_13">演習-配列の長さの取り出し</a> <a
href="exercise_q.html#SS_20_11_14">演習-配列の次元の取り出し</a></p>
<h2 id="nstdライブラリの開発2">Nstdライブラリの開発2
<a id="SS_13_4"></a></h2>
<p>ここでは予定していた通りSafeArray2を開発し、その後Nstdに必要なライブラリの開発を続ける。</p>
<h3 id="safearray2の開発">SafeArray2の開発 <a id="SS_13_4_1"></a></h3>
<p>「<a
href="template_meta_programming.html#SS_13_2_3">安全な配列型コンテナ</a>」で断念したSafeArray2の開発を再開する前に、
SafeArray2の要件をまとめると、</p>
<ul>
<li>std::arrayを基底クラスとする</li>
<li>operator[]に範囲チェックを行う</li>
<li>SafeArrayでのパラメータパックによる初期化機能はそのまま残す</li>
<li>SafeArrayではできなかった縮小型変換が起こる初期化にも対応する</li>
<li>新規要件として、
縮小型変換により初期化されたかどうかを示すメンバ関数InitWithNarrowing()を持つ。</li>
</ul>
<p>となる。この要件を満たすためには、SafeArrayが</p>
<div class="sourceCode" id="cb200"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 155</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span>  <span class="co">// コンストラクタを定義</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a>    SafeArray<span class="op">(</span>ARGS<span class="op">...</span> args<span class="op">)</span> <span class="op">:</span> <span class="dt">base_type</span><span class="op">{</span>args<span class="op">...}</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>で行っていた初期化を、SafeArray2では、
「縮小型変換が起こるか否かによる場合分けを行い、
それぞれの場合に対応するコンストラクタテンプレートによって初期化」
するようにすれば良いことがわかる。</p>
<p>パラメータパックによるコンストラクタのシグネチャは上記した一種類しかないため、
関数のシグネチャの差異よるオーバーロードは使えない。
とすれば、テンプレートパラメータの型の差異によるオーバーロードを使うしか方法がない。
縮小型変換が起こるか否かの場合分けは、 コンセプト<a
href="template_meta_programming.html#SS_13_3_4_4">ConvertibleWithoutNarrowing</a>を使用したSFINAEで実現させることができる。
という風な思考の変遷により以下のコードにたどり着く。</p>
<div class="sourceCode" id="cb201"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 228</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SafeArray2 <span class="op">:</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;::</span>array<span class="op">;</span>  <span class="co">// 継承コンストラクタ</span></span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">base_type</span> <span class="op">=</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;;</span></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-9"><a href="#cb201-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 縮小型変換した場合には、ill-formedになるコンストラクタ</span></span>
<span id="cb201-10"><a href="#cb201-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* c++17スタイルのSFINAE</span></span>
<span id="cb201-11"><a href="#cb201-11" aria-hidden="true" tabindex="-1"></a><span class="co">    template &lt;typename... ARGS,</span></span>
<span id="cb201-12"><a href="#cb201-12" aria-hidden="true" tabindex="-1"></a><span class="co">              typename = </span></span>
<span id="cb201-13"><a href="#cb201-13" aria-hidden="true" tabindex="-1"></a><span class="co">                  typename std::enable_if_t&lt;</span></span>
<span id="cb201-14"><a href="#cb201-14" aria-hidden="true" tabindex="-1"></a><span class="co">                       AreConvertibleWithoutNarrowConvV&lt;T, ARGS...&gt;&gt;&gt;</span></span>
<span id="cb201-15"><a href="#cb201-15" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span> </span>
<span id="cb201-16"><a href="#cb201-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span> <span class="co">// C++20のコンセプトを使用したSFINAE</span></span>
<span id="cb201-17"><a href="#cb201-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> ConvertibleWithoutNarrowing<span class="op">&lt;</span>T<span class="op">,</span> ARGS<span class="op">...&gt;</span></span>
<span id="cb201-18"><a href="#cb201-18" aria-hidden="true" tabindex="-1"></a>    SafeArray2<span class="op">(</span>ARGS<span class="op">...</span> args<span class="op">)</span> <span class="op">:</span> <span class="dt">base_type</span><span class="op">{</span>args<span class="op">...}</span> <span class="co">// 初期化子リストによるarrayの初期化</span></span>
<span id="cb201-19"><a href="#cb201-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb201-20"><a href="#cb201-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb201-21"><a href="#cb201-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-22"><a href="#cb201-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 縮小型変換しない場合には、ill-formedになるコンストラクタ</span></span>
<span id="cb201-23"><a href="#cb201-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* C++17までのSFINAE</span></span>
<span id="cb201-24"><a href="#cb201-24" aria-hidden="true" tabindex="-1"></a><span class="co">    template &lt;typename... ARGS, </span></span>
<span id="cb201-25"><a href="#cb201-25" aria-hidden="true" tabindex="-1"></a><span class="co">              typename std::enable_if_t&lt;</span></span>
<span id="cb201-26"><a href="#cb201-26" aria-hidden="true" tabindex="-1"></a><span class="co">                  !AreConvertibleWithoutNarrowConvV&lt;T, ARGS...&gt;&gt;* = nullptr&gt;</span></span>
<span id="cb201-27"><a href="#cb201-27" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span>
<span id="cb201-28"><a href="#cb201-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span> <span class="co">// C++20のコンセプトを使用したSFINAE</span></span>
<span id="cb201-29"><a href="#cb201-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="op">(!</span>ConvertibleWithoutNarrowing<span class="op">&lt;</span>T<span class="op">,</span> ARGS<span class="op">...&gt;)</span>  <span class="co">// この行には()が必要</span></span>
<span id="cb201-30"><a href="#cb201-30" aria-hidden="true" tabindex="-1"></a>    SafeArray2<span class="op">(</span>ARGS<span class="op">...</span> args<span class="op">)</span> <span class="op">:</span></span>
<span id="cb201-31"><a href="#cb201-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">base_type</span><span class="op">{</span>T<span class="op">(</span>args<span class="op">)...},</span>  <span class="co">// 縮小型変換を抑止するため、T(args)が必要</span></span>
<span id="cb201-32"><a href="#cb201-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">is_with_narrow_conv_</span><span class="op">{</span><span class="kw">true</span><span class="op">}</span></span>
<span id="cb201-33"><a href="#cb201-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb201-34"><a href="#cb201-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb201-35"><a href="#cb201-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-36"><a href="#cb201-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">size_type</span> <span class="op">=</span> <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span><span class="dt">size_type</span><span class="op">;</span></span>
<span id="cb201-37"><a href="#cb201-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-38"><a href="#cb201-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>reference       <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb201-39"><a href="#cb201-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>const_reference <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb201-40"><a href="#cb201-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-41"><a href="#cb201-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> InitWithNarrowing<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">is_with_narrow_conv_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb201-42"><a href="#cb201-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-43"><a href="#cb201-43" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb201-44"><a href="#cb201-44" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="at">const</span> <span class="va">is_with_narrow_conv_</span><span class="op">{</span><span class="kw">false</span><span class="op">};</span></span>
<span id="cb201-45"><a href="#cb201-45" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb201-46"><a href="#cb201-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>下記のようなコードでのコンストラクタ呼び出しには、</p>
<div class="sourceCode" id="cb202"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 299</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sa_init <span class="op">=</span> Nstd<span class="op">::</span>SafeArray2<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span></code></pre></div>
<p>上記の抜粋である下記のコンストラクタが置換失敗により排除される(SFINAE)。</p>
<div class="sourceCode" id="cb203"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 252</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 縮小型変換しない場合には、ill-formedになるコンストラクタ</span></span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* C++17までのSFINAE</span></span>
<span id="cb203-5"><a href="#cb203-5" aria-hidden="true" tabindex="-1"></a><span class="co">    template &lt;typename... ARGS, </span></span>
<span id="cb203-6"><a href="#cb203-6" aria-hidden="true" tabindex="-1"></a><span class="co">              typename std::enable_if_t&lt;</span></span>
<span id="cb203-7"><a href="#cb203-7" aria-hidden="true" tabindex="-1"></a><span class="co">                  !AreConvertibleWithoutNarrowConvV&lt;T, ARGS...&gt;&gt;* = nullptr&gt;</span></span>
<span id="cb203-8"><a href="#cb203-8" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span>
<span id="cb203-9"><a href="#cb203-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span> <span class="co">// C++20のコンセプトを使用したSFINAE</span></span>
<span id="cb203-10"><a href="#cb203-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="op">(!</span>ConvertibleWithoutNarrowing<span class="op">&lt;</span>T<span class="op">,</span> ARGS<span class="op">...&gt;)</span>  <span class="co">// この行には()が必要</span></span>
<span id="cb203-11"><a href="#cb203-11" aria-hidden="true" tabindex="-1"></a>    SafeArray2<span class="op">(</span>ARGS<span class="op">...</span> args<span class="op">)</span> <span class="op">:</span></span>
<span id="cb203-12"><a href="#cb203-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">base_type</span><span class="op">{</span>T<span class="op">(</span>args<span class="op">)...},</span>  <span class="co">// 縮小型変換を抑止するため、T(args)が必要</span></span>
<span id="cb203-13"><a href="#cb203-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">is_with_narrow_conv_</span><span class="op">{</span><span class="kw">true</span><span class="op">}</span></span>
<span id="cb203-14"><a href="#cb203-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb203-15"><a href="#cb203-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>従って、マッチするコンストラクタは</p>
<div class="sourceCode" id="cb204"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 237</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 縮小型変換した場合には、ill-formedになるコンストラクタ</span></span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* c++17スタイルのSFINAE</span></span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a><span class="co">    template &lt;typename... ARGS,</span></span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true" tabindex="-1"></a><span class="co">              typename = </span></span>
<span id="cb204-7"><a href="#cb204-7" aria-hidden="true" tabindex="-1"></a><span class="co">                  typename std::enable_if_t&lt;</span></span>
<span id="cb204-8"><a href="#cb204-8" aria-hidden="true" tabindex="-1"></a><span class="co">                       AreConvertibleWithoutNarrowConvV&lt;T, ARGS...&gt;&gt;&gt;</span></span>
<span id="cb204-9"><a href="#cb204-9" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span> </span>
<span id="cb204-10"><a href="#cb204-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span> <span class="co">// C++20のコンセプトを使用したSFINAE</span></span>
<span id="cb204-11"><a href="#cb204-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> ConvertibleWithoutNarrowing<span class="op">&lt;</span>T<span class="op">,</span> ARGS<span class="op">...&gt;</span></span>
<span id="cb204-12"><a href="#cb204-12" aria-hidden="true" tabindex="-1"></a>    SafeArray2<span class="op">(</span>ARGS<span class="op">...</span> args<span class="op">)</span> <span class="op">:</span> <span class="dt">base_type</span><span class="op">{</span>args<span class="op">...}</span> <span class="co">// 初期化子リストによるarrayの初期化</span></span>
<span id="cb204-13"><a href="#cb204-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb204-14"><a href="#cb204-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>のみとなり、無事にコンパイルが成功し、下記の単体テストもパスする。</p>
<div class="sourceCode" id="cb205"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 299</span></span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sa_init <span class="op">=</span> Nstd<span class="op">::</span>SafeArray2<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>sa_init<span class="op">.</span>InitWithNarrowing<span class="op">());</span>  <span class="co">// 縮小型変換なし</span></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> sa_init<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb205-10"><a href="#cb205-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>sa_init<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span></code></pre></div>
<p>下記の単体テストの場合、SFINAEにより、先述の例とは逆のコンストラクタが選択され、
コンパイルも単体テストもパスする。</p>
<div class="sourceCode" id="cb206"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 314</span></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> sa_init <span class="op">=</span> Nstd<span class="op">::</span>SafeArray2<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="fl">30.0</span><span class="op">};</span>  <span class="co">// 30.0はintに縮小型変換される</span></span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>sa_init<span class="op">.</span>InitWithNarrowing<span class="op">());</span>  <span class="co">// 縮小型変換あり</span></span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> sa_init<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">10</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">20</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">30</span><span class="op">,</span> sa_init<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb206-9"><a href="#cb206-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>sa_init<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span></code></pre></div>
<p>ここで紹介したC++17スタイルの2つのコンストラクタテンプレートの最後のパラメータには、
かなりの違和感があるだろうが、
引数や戻り値に制限の多いコンストラクタテンプレートでSFINAEを起こすためには、
このような記述が必要になる。 一方で<a
href="term_explanation.html#SS_19_11_2">コンセプト</a>を使用したC++20スタイルのSFINAEの可読性の高さを実感できただろう。</p>
<p>なお、2つ目のコンストラクタテンプレートの中で使用した下記のコードは、
パラメータパックで与えられた全引数をそれぞれにT型オブジェクトに変換するための記法である。</p>
<div class="sourceCode" id="cb207"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/safe_vector_ut.cpp 264</span></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">base_type</span><span class="op">{</span>T<span class="op">(</span>args<span class="op">)...},</span>  <span class="co">// 縮小型変換を抑止するため、T(args)が必要</span></span></code></pre></div>
<p>これにより、std::array&lt;T,
N&gt;のstd::initializer_listによる初期化が縮小変換を検出しなくなる。</p>
<h3 id="nstdsafeindexの開発">Nstd::SafeIndexの開発
<a id="SS_13_4_2"></a></h3>
<p>「<a
href="template_meta_programming.html#SS_13_2_2">安全なvector</a>」、「<a
href="template_meta_programming.html#SS_13_2_3">安全な配列型コンテナ</a>」等の中で、</p>
<ul>
<li>Nstd::SafeVector</li>
<li>Nstd::SafeString</li>
<li>Nstd::SafeArray</li>
</ul>
<p>を定義した。これらは少しだけランタイム速度を犠牲にすることで、
安全な(未定義動作を起こさない)インデックスアクセスを保障するため、
一般のソフトウェア開発にも有用であると思われるが、コードクローンして作ったため、
リファクタリングを行う必要がある。</p>
<p>まずは、Nstd::SafeVectorとNstd::SafeStringの統一を考える。</p>
<p>std::stringは、実際にはstd::basic_string&lt;char&gt;のエイリアスであることに注目すれば、
Nstd::SafeStringの基底クラスはstd::basic_string&lt;char&gt;であることがわかる。
この形式は、std::vector&lt;T&gt;と同形であるため、
Nstd::SafeVectorとNstd::SafeStringの共通コードはテンプレートテンプレートパラメータ
(「<a
href="template_meta_programming.html#SS_13_3_3_7">is_same_templ</a>」参照)を使用し下記のように書ける。</p>
<div class="sourceCode" id="cb208"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_safe_index.h 8</span></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-5"><a href="#cb208-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...&gt;</span> <span class="kw">class</span> C<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb208-6"><a href="#cb208-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> SafeIndex <span class="op">:</span> C<span class="op">&lt;</span>Ts<span class="op">...&gt;</span> <span class="op">{</span></span>
<span id="cb208-7"><a href="#cb208-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> C<span class="op">&lt;</span>Ts<span class="op">...&gt;::</span>C<span class="op">;</span></span>
<span id="cb208-8"><a href="#cb208-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-9"><a href="#cb208-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="dt">base_type</span> <span class="op">=</span> C<span class="op">&lt;</span>Ts<span class="op">...&gt;;</span></span>
<span id="cb208-10"><a href="#cb208-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="dt">size_type</span> <span class="op">=</span> <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span><span class="dt">size_type</span><span class="op">;</span></span>
<span id="cb208-11"><a href="#cb208-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-12"><a href="#cb208-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>reference       <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb208-13"><a href="#cb208-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">::</span>const_reference <span class="kw">operator</span><span class="op">[](</span><span class="dt">size_type</span> i<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>at<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb208-14"><a href="#cb208-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb208-15"><a href="#cb208-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>このコードの使用例を兼ねた単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb209"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_safe_index_ut.cpp 8</span></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v_i <span class="op">=</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb209-5"><a href="#cb209-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>v_i<span class="op">[</span><span class="dv">0</span><span class="op">])&gt;);</span></span>
<span id="cb209-6"><a href="#cb209-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;,</span> <span class="kw">decltype</span><span class="op">(</span>v_i<span class="op">)&gt;);</span></span>
<span id="cb209-7"><a href="#cb209-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> v_i<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb209-8"><a href="#cb209-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> v_i<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb209-9"><a href="#cb209-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>v_i<span class="op">[</span><span class="dv">2</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span>
<span id="cb209-10"><a href="#cb209-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb209-11"><a href="#cb209-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str <span class="op">=</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span><span class="bu">std::</span>basic_string<span class="op">,</span> <span class="dt">char</span><span class="op">&gt;{</span><span class="st">&quot;123&quot;</span><span class="op">};</span></span>
<span id="cb209-12"><a href="#cb209-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb209-13"><a href="#cb209-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">char</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>str<span class="op">[</span><span class="dv">0</span><span class="op">])&gt;);</span></span>
<span id="cb209-14"><a href="#cb209-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>str<span class="op">)&gt;);</span></span>
<span id="cb209-15"><a href="#cb209-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> str<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb209-16"><a href="#cb209-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;123&quot;</span><span class="op">,</span> str<span class="op">);</span></span>
<span id="cb209-17"><a href="#cb209-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>str<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span></code></pre></div>
<p>このままでは使いづらいので下記のようにエイリアスを使い、元のテンプレートと同じ名前を与える。</p>
<div class="sourceCode" id="cb210"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_safe_index.h 24</span></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> SafeVector <span class="op">=</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">,</span> T<span class="op">&gt;;</span></span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-8"><a href="#cb210-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> SafeString <span class="op">=</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span><span class="bu">std::</span>basic_string<span class="op">,</span> <span class="dt">char</span><span class="op">&gt;;</span></span>
<span id="cb210-9"><a href="#cb210-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>このコードの単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb211"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_safe_index_ut.cpp 54</span></span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v_i <span class="op">=</span> Nstd<span class="op">::</span>SafeVector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb211-4"><a href="#cb211-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb211-5"><a href="#cb211-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>v_i<span class="op">[</span><span class="dv">0</span><span class="op">])&gt;);</span></span>
<span id="cb211-6"><a href="#cb211-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;,</span> <span class="kw">decltype</span><span class="op">(</span>v_i<span class="op">)&gt;);</span></span>
<span id="cb211-7"><a href="#cb211-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> v_i<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb211-8"><a href="#cb211-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> v_i<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb211-9"><a href="#cb211-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>v_i<span class="op">[</span><span class="dv">2</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span>
<span id="cb211-10"><a href="#cb211-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb211-11"><a href="#cb211-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str <span class="op">=</span> Nstd<span class="op">::</span>SafeString<span class="op">{</span><span class="st">&quot;123&quot;</span><span class="op">};</span></span>
<span id="cb211-12"><a href="#cb211-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb211-13"><a href="#cb211-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">char</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>str<span class="op">[</span><span class="dv">0</span><span class="op">])&gt;);</span></span>
<span id="cb211-14"><a href="#cb211-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>str<span class="op">)&gt;);</span></span>
<span id="cb211-15"><a href="#cb211-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> str<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb211-16"><a href="#cb211-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;123&quot;</span><span class="op">,</span> str<span class="op">);</span></span>
<span id="cb211-17"><a href="#cb211-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>str<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span></code></pre></div>
<p>これで、Nstd::SafeVectorとNstd::SafeStringは統一できたので、
Nstd::SafeIndexにNstd::SafeArrayの実装が取り込めれば、リファクタリングは終了となるが、
残念ながら、下記のコードはコンパイルできない。</p>
<div class="sourceCode" id="cb212"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_safe_index_ut.cpp 44</span></span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記のように書きたいが、パラメータパックは型と値を混在できないのでコンパイルエラー</span></span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a_i <span class="op">=</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span><span class="bu">std::</span>array<span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="dv">5</span><span class="op">&gt;{};</span></span></code></pre></div>
<p>理由は、パラメータパックにはそのすべてに型を指定するか、そのすべてに値を指定しなければならず、
上記のコードのような型と値の混在が許されていないからである。</p>
<p>値を型に変換する<a
href="template_meta_programming.html#SS_13_3_1_2">std::integral_constant</a>を使用し、この問題を解決できる。
std::arrayから派生した下記のStdArrayLikeは、std::integral_constant::valueから値を取り出し、
基底クラスstd::arrayの第2テンプレートパラメータとする。
この仕組みにより、StdArrayLikeは、
Nstd::SafeIndexのテンプレートテンプレートパラメータとして使用できるようになる。</p>
<div class="sourceCode" id="cb213"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_safe_index.h 34</span></span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-6"><a href="#cb213-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb213-7"><a href="#cb213-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> std_array_like <span class="op">:</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">::</span>value<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb213-8"><a href="#cb213-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">::</span>value<span class="op">&gt;::</span>array<span class="op">;</span></span>
<span id="cb213-9"><a href="#cb213-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-10"><a href="#cb213-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span></span>
<span id="cb213-11"><a href="#cb213-11" aria-hidden="true" tabindex="-1"></a>        std_array_like<span class="op">(</span>ARGS<span class="op">...</span> args<span class="op">)</span> <span class="kw">noexcept</span><span class="op">(</span><span class="bu">std::</span>is_nothrow_constructible_v<span class="op">&lt;</span>T<span class="op">,</span> ARGS<span class="op">...&gt;)</span></span>
<span id="cb213-12"><a href="#cb213-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">::</span>value<span class="op">&gt;{</span>args<span class="op">...}</span></span>
<span id="cb213-13"><a href="#cb213-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb213-14"><a href="#cb213-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">static_assert</span><span class="op">(</span>ConvertibleToAll<span class="op">&lt;</span>T<span class="op">,</span> ARGS<span class="op">...&gt;,</span> <span class="st">&quot;arguemnt error&quot;</span><span class="op">);</span></span>
<span id="cb213-15"><a href="#cb213-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb213-16"><a href="#cb213-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb213-17"><a href="#cb213-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb213-18"><a href="#cb213-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>まずは、このコードの使用例を兼ねた単体テストを下記に示す。</p>
<div class="sourceCode" id="cb214"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_safe_index_ut.cpp 134</span></span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sal <span class="op">=</span> Nstd<span class="op">::</span>Inner_<span class="op">::</span>std_array_like<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_nothrow_constructible_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>sal<span class="op">),</span> <span class="dt">int</span><span class="op">&gt;);</span>  <span class="co">// エクセプション無し生成</span></span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>sal<span class="op">[</span><span class="dv">0</span><span class="op">])&gt;);</span></span>
<span id="cb214-7"><a href="#cb214-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;,</span> <span class="kw">decltype</span><span class="op">(</span>sal<span class="op">)&gt;);</span></span>
<span id="cb214-8"><a href="#cb214-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> sal<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb214-9"><a href="#cb214-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> sal<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb214-10"><a href="#cb214-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> sal<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb214-11"><a href="#cb214-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-12"><a href="#cb214-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> T   <span class="op">=</span> Nstd<span class="op">::</span>Inner_<span class="op">::</span>std_array_like<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;&gt;;</span></span>
<span id="cb214-13"><a href="#cb214-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sal2 <span class="op">=</span> T<span class="op">{</span><span class="st">&quot;1&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> <span class="st">&quot;3&quot;</span><span class="op">};</span></span>
<span id="cb214-14"><a href="#cb214-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-15"><a href="#cb214-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_nothrow_constructible_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">char</span> <span class="at">const</span><span class="op">*&gt;);</span></span>
<span id="cb214-16"><a href="#cb214-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_nothrow_constructible_v<span class="op">&lt;</span>T<span class="op">,</span> <span class="dt">char</span> <span class="at">const</span><span class="op">*&gt;);</span>  <span class="co">// エクセプション有り生成</span></span>
<span id="cb214-17"><a href="#cb214-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>sal2<span class="op">[</span><span class="dv">0</span><span class="op">])&gt;);</span></span>
<span id="cb214-18"><a href="#cb214-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>array<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dv">3</span><span class="op">&gt;,</span> <span class="kw">decltype</span><span class="op">(</span>sal2<span class="op">)&gt;);</span></span>
<span id="cb214-19"><a href="#cb214-19" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;1&quot;</span><span class="op">,</span> sal2<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb214-20"><a href="#cb214-20" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;2&quot;</span><span class="op">,</span> sal2<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb214-21"><a href="#cb214-21" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;3&quot;</span><span class="op">,</span> sal2<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span></code></pre></div>
<p>これを使えば、下記のような記述が可能となる。</p>
<div class="sourceCode" id="cb215"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_safe_index_ut.cpp 157</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> T2   <span class="op">=</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span>Nstd<span class="op">::</span>Inner_<span class="op">::</span>std_array_like<span class="op">,</span> <span class="bu">std::</span>string<span class="op">,</span></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a>                               <span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">,</span> <span class="dv">4</span><span class="op">&gt;&gt;;</span></span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sal_s <span class="op">=</span> T2<span class="op">{</span><span class="st">&quot;1&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> <span class="st">&quot;3&quot;</span><span class="op">};</span></span>
<span id="cb215-6"><a href="#cb215-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-7"><a href="#cb215-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_nothrow_constructible_v<span class="op">&lt;</span>T2<span class="op">,</span> <span class="dt">char</span> <span class="at">const</span><span class="op">*&gt;);</span>  <span class="co">// エクセプション有り生成</span></span>
<span id="cb215-8"><a href="#cb215-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>sal_s<span class="op">[</span><span class="dv">0</span><span class="op">])&gt;);</span></span>
<span id="cb215-9"><a href="#cb215-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>array<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dv">4</span><span class="op">&gt;,</span> <span class="kw">decltype</span><span class="op">(</span>sal_s<span class="op">)&gt;);</span></span>
<span id="cb215-10"><a href="#cb215-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;1&quot;</span><span class="op">,</span> sal_s<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb215-11"><a href="#cb215-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;2&quot;</span><span class="op">,</span> sal_s<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb215-12"><a href="#cb215-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;3&quot;</span><span class="op">,</span> sal_s<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb215-13"><a href="#cb215-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">,</span> sal_s<span class="op">[</span><span class="dv">3</span><span class="op">]);</span></span>
<span id="cb215-14"><a href="#cb215-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>sal_s<span class="op">[</span><span class="dv">4</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span></code></pre></div>
<p>このままでは使いづらいのでNstd::SafeVector、Nstd::Stringと同様にエイリアスを使えば、
下記のようになる。</p>
<div class="sourceCode" id="cb216"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_safe_index.h 53</span></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb216-6"><a href="#cb216-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> SafeArray</span>
<span id="cb216-7"><a href="#cb216-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span>Nstd<span class="op">::</span>Inner_<span class="op">::</span>std_array_like<span class="op">,</span> T<span class="op">,</span> <span class="bu">std::</span>integral_constant<span class="op">&lt;</span><span class="dt">size_t</span><span class="op">,</span> N<span class="op">&gt;&gt;;</span></span>
<span id="cb216-8"><a href="#cb216-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>このコードの単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb217"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_safe_index_ut.cpp 89</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> sal_s <span class="op">=</span> Nstd<span class="op">::</span>SafeArray<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dv">4</span><span class="op">&gt;{</span><span class="st">&quot;1&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> <span class="st">&quot;3&quot;</span><span class="op">};</span></span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>sal_s<span class="op">[</span><span class="dv">0</span><span class="op">])&gt;);</span></span>
<span id="cb217-6"><a href="#cb217-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>array<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dv">4</span><span class="op">&gt;,</span> <span class="kw">decltype</span><span class="op">(</span>sal_s<span class="op">)&gt;);</span></span>
<span id="cb217-7"><a href="#cb217-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;1&quot;</span><span class="op">,</span> sal_s<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb217-8"><a href="#cb217-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;2&quot;</span><span class="op">,</span> sal_s<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb217-9"><a href="#cb217-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;3&quot;</span><span class="op">,</span> sal_s<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb217-10"><a href="#cb217-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">,</span> sal_s<span class="op">[</span><span class="dv">3</span><span class="op">]);</span></span>
<span id="cb217-11"><a href="#cb217-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>sal_s<span class="op">[</span><span class="dv">4</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span></code></pre></div>
<p>これにより、当初の目的であったコードクローンの除去が完了した。
この効果により、下記に示したような拡張もコードクローンせずに簡単に行えるようになった。</p>
<div class="sourceCode" id="cb218"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_safe_index.h 62</span></span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> SafeStringU16 <span class="op">=</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span><span class="bu">std::</span>basic_string<span class="op">,</span> <span class="dt">char16_t</span><span class="op">&gt;;</span></span>
<span id="cb218-6"><a href="#cb218-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> SafeStringU32 <span class="op">=</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span><span class="bu">std::</span>basic_string<span class="op">,</span> <span class="dt">char32_t</span><span class="op">&gt;;</span></span>
<span id="cb218-7"><a href="#cb218-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<div class="sourceCode" id="cb219"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_safe_index_ut.cpp 112</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> u16str <span class="op">=</span> Nstd<span class="op">::</span>SafeStringU16<span class="op">{</span><span class="st">u&quot;あいうえお&quot;</span><span class="op">};</span></span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">char16_t</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>u16str<span class="op">[</span><span class="dv">0</span><span class="op">])&gt;);</span></span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>u16string<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>u16str<span class="op">)&gt;);</span></span>
<span id="cb219-7"><a href="#cb219-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">5</span><span class="op">,</span> u16str<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb219-8"><a href="#cb219-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">u&quot;あいうえお&quot;</span><span class="op">,</span> u16str<span class="op">);</span></span>
<span id="cb219-9"><a href="#cb219-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>u16str<span class="op">[</span><span class="dv">5</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span>
<span id="cb219-10"><a href="#cb219-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-11"><a href="#cb219-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> u32str <span class="op">=</span> Nstd<span class="op">::</span>SafeStringU32<span class="op">{</span><span class="st">U&quot;かきくけこ&quot;</span><span class="op">};</span></span>
<span id="cb219-12"><a href="#cb219-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-13"><a href="#cb219-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">char32_t</span><span class="op">&amp;,</span> <span class="kw">decltype</span><span class="op">(</span>u32str<span class="op">[</span><span class="dv">0</span><span class="op">])&gt;);</span></span>
<span id="cb219-14"><a href="#cb219-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>u32string<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>u32str<span class="op">)&gt;);</span></span>
<span id="cb219-15"><a href="#cb219-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">5</span><span class="op">,</span> u32str<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb219-16"><a href="#cb219-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">U&quot;かきくけこ&quot;</span><span class="op">,</span> u32str<span class="op">);</span></span>
<span id="cb219-17"><a href="#cb219-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span>u32str<span class="op">[</span><span class="dv">5</span><span class="op">],</span> <span class="bu">std::</span>out_of_range<span class="op">);</span></span></code></pre></div>
<h3
id="nstdsafeindexのoperatorの開発">Nstd::SafeIndexのoperator&lt;&lt;の開発
<a id="SS_13_4_3"></a></h3>
<p>ここでは、Nstd::SafeIndexのoperator&lt;&lt;の開発を行う。</p>
<p>他のoperator&lt;&lt;との間で定義が曖昧にならないようにするためには、
テンプレートテンプレートパラメータを使って以下のようにすることが考えられる。</p>
<div class="sourceCode" id="cb220"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/safe_index_put_to_ut.cpp 8</span></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...&gt;</span> <span class="kw">class</span> C<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span>C<span class="op">,</span> Ts<span class="op">...&gt;</span> <span class="at">const</span><span class="op">&amp;</span> safe_index<span class="op">)</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb220-6"><a href="#cb220-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sep <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb220-7"><a href="#cb220-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-8"><a href="#cb220-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> i <span class="op">:</span> safe_index<span class="op">)</span> <span class="op">{</span></span>
<span id="cb220-9"><a href="#cb220-9" aria-hidden="true" tabindex="-1"></a>            os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>exchange<span class="op">(</span>sep<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb220-10"><a href="#cb220-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb220-11"><a href="#cb220-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-12"><a href="#cb220-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb220-13"><a href="#cb220-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>以下の単体テストで動作確認する。</p>
<div class="sourceCode" id="cb221"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/safe_index_put_to_ut.cpp 25</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> v_i <span class="op">=</span> Nstd<span class="op">::</span>SafeVector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> v_i<span class="op">;</span></span>
<span id="cb221-7"><a href="#cb221-7" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1, 2&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb221-8"><a href="#cb221-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb221-9"><a href="#cb221-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb221-10"><a href="#cb221-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sal_s <span class="op">=</span> Nstd<span class="op">::</span>SafeArray<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dv">4</span><span class="op">&gt;{</span><span class="st">&quot;1&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> <span class="st">&quot;3&quot;</span><span class="op">};</span></span>
<span id="cb221-11"><a href="#cb221-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss   <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb221-12"><a href="#cb221-12" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> sal_s<span class="op">;</span></span>
<span id="cb221-13"><a href="#cb221-13" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1, 2, 3, &quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span>  <span class="co">// 4番目には何も入っていない</span></span>
<span id="cb221-14"><a href="#cb221-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>ここまではうまく行っているが、以下の単体テストによりバグが発覚する。</p>
<div class="sourceCode" id="cb222"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/safe_index_put_to_ut.cpp 40</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="va">s_str</span> <span class="op">=</span> Nstd<span class="op">::</span>SafeString<span class="op">{</span><span class="st">&quot;hello&quot;</span><span class="op">};</span></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss   <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> <span class="va">s_str</span><span class="op">;</span></span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-8"><a href="#cb222-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ASSERT_EQ(&quot;hello&quot;, oss.s_str());     // これがパス出来たらよいが、</span></span>
<span id="cb222-9"><a href="#cb222-9" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;h, e, l, l, o&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span>  <span class="co">// 実際にはこのようになる。</span></span>
<span id="cb222-10"><a href="#cb222-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb222-11"><a href="#cb222-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb222-12"><a href="#cb222-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> str <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;hello&quot;</span><span class="op">};</span>  <span class="co">// 上記と比較のためのstd::stringでのoperator&lt;&lt;</span></span>
<span id="cb222-13"><a href="#cb222-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-14"><a href="#cb222-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb222-15"><a href="#cb222-15" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> str<span class="op">;</span></span>
<span id="cb222-16"><a href="#cb222-16" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb222-17"><a href="#cb222-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>この原因は、Nstd::SafeStringオブジェクトに対して、std::operator&lt;&lt;が使用されなかったからである。</p>
<p>「<a
href="template_meta_programming.html#SS_13_3">メタ関数のテクニック</a>」で紹介したSFINAEによりこの問題を回避できるが、
ここでも、すでにみてきた<a
href="term_explanation.html#SS_19_11_2">コンセプト</a>による制約によりこの問題に対処する。</p>
<div class="sourceCode" id="cb223"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/safe_index_put_to_ut.cpp 99</span></span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb223-6"><a href="#cb223-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb223-7"><a href="#cb223-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> not_safe_string <span class="op">=</span> <span class="op">!</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> Nstd<span class="op">::</span>SafeString<span class="op">&gt;;</span></span>
<span id="cb223-8"><a href="#cb223-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb223-9"><a href="#cb223-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb223-10"><a href="#cb223-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-11"><a href="#cb223-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span><span class="op">...&gt;</span> <span class="kw">class</span> C<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb223-12"><a href="#cb223-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb223-13"><a href="#cb223-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span>C<span class="op">,</span> Ts<span class="op">...&gt;</span> <span class="at">const</span><span class="op">&amp;</span> safe_index<span class="op">)</span> <span class="op">-&gt;</span> <span class="bu">std::</span>ostream<span class="op">&amp;</span> </span>
<span id="cb223-14"><a href="#cb223-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">requires</span> Inner_<span class="op">::</span>not_safe_string<span class="op">&lt;</span>Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span>C<span class="op">,</span> Ts<span class="op">...&gt;&gt;</span> <span class="co">// enable_ifによるSFINAEを避け、</span></span>
<span id="cb223-15"><a href="#cb223-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-16"><a href="#cb223-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb223-17"><a href="#cb223-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span>C<span class="op">,</span> Ts<span class="op">...&gt;</span> <span class="at">const</span><span class="op">&amp;</span> safe_index<span class="op">)</span> <span class="op">-&gt;</span></span>
<span id="cb223-18"><a href="#cb223-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span>    <span class="co">// safe_indexがSafeString型ならば、SFINAEにより非活性化</span></span>
<span id="cb223-19"><a href="#cb223-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">!</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>Nstd<span class="op">::</span>SafeIndex<span class="op">&lt;</span>C<span class="op">,</span> Ts<span class="op">...&gt;,</span> Nstd<span class="op">::</span>SafeString<span class="op">&gt;,</span> <span class="bu">std::</span>ostream<span class="op">&amp;&gt;</span></span>
<span id="cb223-20"><a href="#cb223-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb223-21"><a href="#cb223-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// コンセプトによる制約</span></span>
<span id="cb223-22"><a href="#cb223-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sep <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb223-23"><a href="#cb223-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-24"><a href="#cb223-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> i <span class="op">:</span> safe_index<span class="op">)</span> <span class="op">{</span></span>
<span id="cb223-25"><a href="#cb223-25" aria-hidden="true" tabindex="-1"></a>            os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>exchange<span class="op">(</span>sep<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb223-26"><a href="#cb223-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb223-27"><a href="#cb223-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-28"><a href="#cb223-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb223-29"><a href="#cb223-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>これにより先ほど問題が発生した単体テストも下記のようにパスする。</p>
<div class="sourceCode" id="cb224"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/safe_index_put_to_ut.cpp 146</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> str <span class="op">=</span> Nstd<span class="op">::</span>SafeString<span class="op">{</span><span class="st">&quot;hello&quot;</span><span class="op">};</span></span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a>    oss <span class="op">&lt;&lt;</span> str<span class="op">;</span></span>
<span id="cb224-6"><a href="#cb224-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span>  <span class="co">// std::operator&lt;&lt;が使われる</span></span>
<span id="cb224-7"><a href="#cb224-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_EQ(&quot;h, e, l, l, o&quot;, oss.str());</span></span></code></pre></div>
<h3
id="コンテナ用nstdoperatorの開発">コンテナ用Nstd::operator&lt;&lt;の開発
<a id="SS_13_4_4"></a></h3>
<p>「<a
href="template_meta_programming.html#SS_13_4_3">Nstd::SafeIndexのoperator&lt;&lt;の開発</a>」で定義したNstd::operator&lt;&lt;の構造は、
範囲for文に適用できる配列やstdコンテナにも使えるため、ここではその拡張を考える。</p>
<p>すでに述べたように注意すべきは、</p>
<ul>
<li>使い勝手の良いstd::operator&lt;&lt;(例えばchar[N]やstd::stringのoperator&lt;&lt;)はそのまま使う</li>
<li>ほとんど使い物にならないstd::operator&lt;&lt;(例えば、int[N]のような配列に対するoperator&lt;&lt;(void*))
の代わりに、ここで拡張するNstd::operator&lt;&lt;を使う</li>
</ul>
<p>であるため、型Tが新しいNstd::operator&lt;&lt;を使用できる条件は、</p>
<ul>
<li>Tの型が、以下の条件を満たす
<ul>
<li>T == U[N]であった場合、Uはcharではない</li>
<li>std::stringおよびその派生型ではない</li>
</ul></li>
<li>Nstd::ValueType&lt;T&gt;::typeがoperator&lt;&lt;を持つ</li>
</ul>
<p>となるだろう。この条件を診断するためのメタ関数は以下のようになる。</p>
<div class="sourceCode" id="cb225"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_put_to.h 17</span></span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-6"><a href="#cb225-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">// Nstd::Printableを使用するとg++のバグで、問題が発生するため、</span></span>
<span id="cb225-7"><a href="#cb225-7" aria-hidden="true" tabindex="-1"></a>                           <span class="co">// バグ回避のため敢えてここでNstd::Inner_::Printableを宣言する</span></span>
<span id="cb225-8"><a href="#cb225-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> Printable <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>T t<span class="op">,</span> <span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">)</span></span>
<span id="cb225-9"><a href="#cb225-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb225-10"><a href="#cb225-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> os <span class="op">&lt;&lt;</span> t <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span><span class="bu">std::</span>ostream<span class="op">&amp;&gt;;</span></span>
<span id="cb225-11"><a href="#cb225-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb225-12"><a href="#cb225-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-13"><a href="#cb225-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb225-14"><a href="#cb225-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> enable_range_put_to<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb225-15"><a href="#cb225-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb225-16"><a href="#cb225-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>Nstd<span class="op">::</span>ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>IsBuiltinArray<span class="op">)</span> <span class="op">{</span>  <span class="co">// Tは配列</span></span>
<span id="cb225-17"><a href="#cb225-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span></span>
<span id="cb225-18"><a href="#cb225-18" aria-hidden="true" tabindex="-1"></a>                                         <span class="kw">typename</span> Nstd<span class="op">::</span>ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>type_direct<span class="op">&gt;)</span> <span class="op">{</span>  <span class="co">// Tはchar配列</span></span>
<span id="cb225-19"><a href="#cb225-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb225-20"><a href="#cb225-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb225-21"><a href="#cb225-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb225-22"><a href="#cb225-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> Nstd<span class="op">::</span>Printable<span class="op">&lt;</span><span class="kw">typename</span> Nstd<span class="op">::</span>ValueTypeT<span class="op">&lt;</span>T<span class="op">&gt;&gt;;</span></span>
<span id="cb225-23"><a href="#cb225-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb225-24"><a href="#cb225-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb225-25"><a href="#cb225-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span>  <span class="co">// Tは配列ではない</span></span>
<span id="cb225-26"><a href="#cb225-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>Printable<span class="op">&lt;</span>T<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb225-27"><a href="#cb225-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb225-28"><a href="#cb225-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb225-29"><a href="#cb225-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb225-30"><a href="#cb225-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>Nstd<span class="op">::</span>IsRangeV<span class="op">&lt;</span>T<span class="op">&gt;)</span> <span class="op">{</span>  <span class="co">// 範囲for文に適用できる</span></span>
<span id="cb225-31"><a href="#cb225-31" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> Nstd<span class="op">::</span>Printable<span class="op">&lt;</span><span class="kw">typename</span> Nstd<span class="op">::</span>ValueTypeT<span class="op">&lt;</span>T<span class="op">&gt;&gt;;</span></span>
<span id="cb225-32"><a href="#cb225-32" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb225-33"><a href="#cb225-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb225-34"><a href="#cb225-34" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb225-35"><a href="#cb225-35" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb225-36"><a href="#cb225-36" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb225-37"><a href="#cb225-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb225-38"><a href="#cb225-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb225-39"><a href="#cb225-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-40"><a href="#cb225-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb225-41"><a href="#cb225-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> enable_range_put_to_v<span class="op">{</span>enable_range_put_to<span class="op">&lt;</span>T<span class="op">&gt;()};</span></span>
<span id="cb225-42"><a href="#cb225-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb225-43"><a href="#cb225-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>ただし、このようなコードはコンパイラのバグによりコンパイルできないことがある。
実際、現在使用中の<a
href="term_explanation.html#SS_19_19_1">g++</a>ではこのコードはコンパイルできず、
上記コードでコメントにも書いた通り、Inner_の中でPrintableを再定義することで、
そのワークアラウンドを行っている。</p>
<p>このような場合、条件分岐に三項演算子や中間式にconstexprを使うことで回避できることが多い。
このような複雑なメタ関数には単体テストは必須である。</p>
<div class="sourceCode" id="cb226"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/test_class.h 3</span></span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> test_class_exits_put_to <span class="op">{</span></span>
<span id="cb226-4"><a href="#cb226-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb226-5"><a href="#cb226-5" aria-hidden="true" tabindex="-1"></a>        test_class_exits_put_to<span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">i_</span><span class="op">{</span>i<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb226-6"><a href="#cb226-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> get<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">i_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb226-7"><a href="#cb226-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb226-8"><a href="#cb226-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb226-9"><a href="#cb226-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="va">i_</span><span class="op">;</span></span>
<span id="cb226-10"><a href="#cb226-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb226-11"><a href="#cb226-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb226-12"><a href="#cb226-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> test_class_exits_put_to <span class="at">const</span><span class="op">&amp;</span> p<span class="op">)</span></span>
<span id="cb226-13"><a href="#cb226-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb226-14"><a href="#cb226-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os <span class="op">&lt;&lt;</span> p<span class="op">.</span>get<span class="op">();</span></span>
<span id="cb226-15"><a href="#cb226-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb226-16"><a href="#cb226-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb226-17"><a href="#cb226-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> test_class_not_exits_put_to <span class="op">{};</span></span></code></pre></div>
<div class="sourceCode" id="cb227"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_put_to_ut.cpp 31</span></span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-3"><a href="#cb227-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>enable_range_put_to_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span>                         <span class="co">// Nstd::operator&lt;&lt;</span></span>
<span id="cb227-4"><a href="#cb227-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>enable_range_put_to_v<span class="op">&lt;</span><span class="dt">char</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;);</span>                       <span class="co">// std::operator&lt;&lt;</span></span>
<span id="cb227-5"><a href="#cb227-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>enable_range_put_to_v<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;);</span>                           <span class="co">// std::operator&lt;&lt;</span></span>
<span id="cb227-6"><a href="#cb227-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>enable_range_put_to_v<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;);</span>               <span class="co">// Nstd::operator&lt;&lt;</span></span>
<span id="cb227-7"><a href="#cb227-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>enable_range_put_to_v<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&gt;);</span>  <span class="co">// Nstd::operator&lt;&lt;</span></span>
<span id="cb227-8"><a href="#cb227-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>enable_range_put_to_v<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;);</span>                   <span class="co">// std::operator&lt;&lt;</span></span>
<span id="cb227-9"><a href="#cb227-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>enable_range_put_to_v<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;&gt;);</span>       <span class="co">// Nstd::operator&lt;&lt;</span></span>
<span id="cb227-10"><a href="#cb227-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-11"><a href="#cb227-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>enable_range_put_to_v<span class="op">&lt;</span>test_class_not_exits_put_to<span class="op">&gt;);</span>  <span class="co">// operator&lt;&lt;無し</span></span>
<span id="cb227-12"><a href="#cb227-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(!</span>enable_range_put_to_v<span class="op">&lt;</span>test_class_exits_put_to<span class="op">&gt;);</span>  <span class="co">// ユーザ定義operator&lt;&lt;</span></span>
<span id="cb227-13"><a href="#cb227-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span></span>
<span id="cb227-14"><a href="#cb227-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">!</span>enable_range_put_to_v<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span>test_class_not_exits_put_to<span class="op">&gt;&gt;);</span>       <span class="co">// operator&lt;&lt;無し</span></span>
<span id="cb227-15"><a href="#cb227-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>enable_range_put_to_v<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span>test_class_exits_put_to<span class="op">&gt;&gt;);</span>  <span class="co">// Nstd::operator&lt;&lt;</span></span>
<span id="cb227-16"><a href="#cb227-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span></span>
<span id="cb227-17"><a href="#cb227-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">!</span>enable_range_put_to_v<span class="op">&lt;</span><span class="bu">std::</span>list<span class="op">&lt;</span>test_class_not_exits_put_to<span class="op">&gt;&gt;);</span>       <span class="co">// operator&lt;&lt;無し</span></span>
<span id="cb227-18"><a href="#cb227-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>enable_range_put_to_v<span class="op">&lt;</span><span class="bu">std::</span>list<span class="op">&lt;</span>test_class_exits_put_to<span class="op">&gt;&gt;);</span>  <span class="co">// Nstd::operator&lt;&lt;</span></span></code></pre></div>
<p>以上によりstd::enable_ifの第1引数に渡す値(enable_range_put_to_vはconstexpr)が用意できたので、
Nstd::operator&lt;&lt;は下記のように定義できる。</p>
<div class="sourceCode" id="cb228"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_put_to.h 64</span></span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-6"><a href="#cb228-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb228-7"><a href="#cb228-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="bu">std::</span>string_view range_put_to_sep<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb228-8"><a href="#cb228-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb228-9"><a href="#cb228-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span>N <span class="op">!=</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb228-10"><a href="#cb228-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">switch</span> <span class="op">(</span>N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb228-11"><a href="#cb228-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">1</span><span class="op">:</span></span>
<span id="cb228-12"><a href="#cb228-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;, &quot;</span><span class="op">;</span></span>
<span id="cb228-13"><a href="#cb228-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb228-14"><a href="#cb228-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot; | &quot;</span><span class="op">;</span></span>
<span id="cb228-15"><a href="#cb228-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">3</span><span class="op">:</span></span>
<span id="cb228-16"><a href="#cb228-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb228-17"><a href="#cb228-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot; # &quot;</span><span class="op">;</span></span>
<span id="cb228-18"><a href="#cb228-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb228-19"><a href="#cb228-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb228-20"><a href="#cb228-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-21"><a href="#cb228-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb228-22"><a href="#cb228-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">concept</span> range_put_to <span class="op">=</span> Inner_<span class="op">::</span>enable_range_put_to_v<span class="op">&lt;</span>T<span class="op">&gt;;</span></span>
<span id="cb228-23"><a href="#cb228-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb228-24"><a href="#cb228-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-25"><a href="#cb228-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb228-26"><a href="#cb228-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> T <span class="at">const</span><span class="op">&amp;</span> t<span class="op">)</span> <span class="op">-&gt;</span></span>
<span id="cb228-27"><a href="#cb228-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">typename</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span>Inner_<span class="op">::</span>enable_range_put_to_v<span class="op">&lt;</span>T<span class="op">&gt;,</span> <span class="bu">std::</span>ostream<span class="op">&amp;&gt;</span></span>
<span id="cb228-28"><a href="#cb228-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::enable_if_t&lt;Inner_::enable_range_put_to_v&lt;T&gt;を使わずに上のrange_put_toを使いたいが、</span></span>
<span id="cb228-29"><a href="#cb228-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// コンパイラのバグによりコンパイルできない</span></span>
<span id="cb228-30"><a href="#cb228-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb228-31"><a href="#cb228-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sep <span class="op">=</span> <span class="bu">std::</span>string_view<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb228-32"><a href="#cb228-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> s   <span class="op">=</span> Inner_<span class="op">::</span>range_put_to_sep<span class="op">&lt;</span>ValueType<span class="op">&lt;</span>T<span class="op">&gt;::</span>Nest<span class="op">&gt;();</span></span>
<span id="cb228-33"><a href="#cb228-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-34"><a href="#cb228-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> i <span class="op">:</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb228-35"><a href="#cb228-35" aria-hidden="true" tabindex="-1"></a>            os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>exchange<span class="op">(</span>sep<span class="op">,</span> s<span class="op">)</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span></span>
<span id="cb228-36"><a href="#cb228-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb228-37"><a href="#cb228-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-38"><a href="#cb228-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb228-39"><a href="#cb228-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb228-40"><a href="#cb228-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>値表示用のセパレータに”,“のみを用いるとコンテナや配列が多次元(ValueType::Nest
&gt; 2)の場合、
各次元でのデータの判別が難しくなるため、ValueType::Nestの値によってセパレータの種類を変える
range_put_to_sep&lt;&gt;()を用意した。
下記単体テストでわかる通り、この効果により値の構造が見やすくなっている。</p>
<p>まずは、配列の単体テストを示す。</p>
<div class="sourceCode" id="cb229"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_put_to_ut.cpp 113</span></span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">namespace</span> Nstd<span class="op">;</span></span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb229-5"><a href="#cb229-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> str<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;abcdef&quot;</span><span class="op">;</span></span>
<span id="cb229-6"><a href="#cb229-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss   <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb229-7"><a href="#cb229-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-8"><a href="#cb229-8" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> str<span class="op">;</span>  <span class="co">// std::operator&lt;&lt;</span></span>
<span id="cb229-9"><a href="#cb229-9" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>str<span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb229-10"><a href="#cb229-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb229-11"><a href="#cb229-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb229-12"><a href="#cb229-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> str<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="st">&quot;abc&quot;</span><span class="op">,</span> <span class="st">&quot;def&quot;</span><span class="op">};</span></span>
<span id="cb229-13"><a href="#cb229-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss       <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb229-14"><a href="#cb229-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-15"><a href="#cb229-15" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> str<span class="op">;</span>  <span class="co">// Nstd::operator&lt;&lt;</span></span>
<span id="cb229-16"><a href="#cb229-16" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;abc | def&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb229-17"><a href="#cb229-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb229-18"><a href="#cb229-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb229-19"><a href="#cb229-19" aria-hidden="true" tabindex="-1"></a>        test_class_exits_put_to p1<span class="op">[</span><span class="dv">3</span><span class="op">]{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb229-20"><a href="#cb229-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span>                    oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb229-21"><a href="#cb229-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-22"><a href="#cb229-22" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> p1<span class="op">;</span>  <span class="co">// Nstd::operator&lt;&lt;</span></span>
<span id="cb229-23"><a href="#cb229-23" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1, 2, 3&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb229-24"><a href="#cb229-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb229-25"><a href="#cb229-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb229-26"><a href="#cb229-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="at">const</span><span class="op">*</span> str<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="st">&quot;abc&quot;</span><span class="op">,</span> <span class="st">&quot;def&quot;</span><span class="op">,</span> <span class="st">&quot;ghi&quot;</span><span class="op">};</span></span>
<span id="cb229-27"><a href="#cb229-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span>        oss   <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb229-28"><a href="#cb229-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-29"><a href="#cb229-29" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> str<span class="op">;</span>  <span class="co">// Nstd::operator&lt;&lt;</span></span>
<span id="cb229-30"><a href="#cb229-30" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;abc, def, ghi&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb229-31"><a href="#cb229-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb229-32"><a href="#cb229-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb229-33"><a href="#cb229-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span>  v<span class="op">[</span><span class="dv">2</span><span class="op">][</span><span class="dv">3</span><span class="op">][</span><span class="dv">2</span><span class="op">]{{{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">}},</span> <span class="op">{{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">},</span> <span class="op">{</span><span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">},</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">11</span><span class="op">}}};</span></span>
<span id="cb229-34"><a href="#cb229-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb229-35"><a href="#cb229-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-36"><a href="#cb229-36" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> v<span class="op">;</span></span>
<span id="cb229-37"><a href="#cb229-37" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;0, 1 | 2, 3 | 4, 5 # 6, 7 | 8, 9 | 10, 11&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb229-38"><a href="#cb229-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>次に、コンテナの単体テストを示す。</p>
<div class="sourceCode" id="cb230"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_put_to_ut.cpp 170</span></span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">namespace</span> Nstd<span class="op">;</span></span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb230-5"><a href="#cb230-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> v   <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb230-6"><a href="#cb230-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb230-7"><a href="#cb230-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-8"><a href="#cb230-8" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> v<span class="op">;</span></span>
<span id="cb230-9"><a href="#cb230-9" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1, 2, 3&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb230-10"><a href="#cb230-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb230-11"><a href="#cb230-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb230-12"><a href="#cb230-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> p1  <span class="op">=</span> <span class="bu">std::</span>list<span class="op">&lt;</span>test_class_exits_put_to<span class="op">&gt;{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb230-13"><a href="#cb230-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb230-14"><a href="#cb230-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-15"><a href="#cb230-15" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> p1<span class="op">;</span></span>
<span id="cb230-16"><a href="#cb230-16" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1, 2, 3, 4&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb230-17"><a href="#cb230-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb230-18"><a href="#cb230-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb230-19"><a href="#cb230-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">[</span><span class="dv">2</span><span class="op">]{{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">}};</span>  <span class="co">// std::vectorの配列</span></span>
<span id="cb230-20"><a href="#cb230-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span>             oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb230-21"><a href="#cb230-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-22"><a href="#cb230-22" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> v<span class="op">;</span></span>
<span id="cb230-23"><a href="#cb230-23" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1, 2 | 3, 4, 5&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb230-24"><a href="#cb230-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>最後に、Nstd::SafeIndexの単体テストを示す。</p>
<div class="sourceCode" id="cb231"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_put_to_ut.cpp 220</span></span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sal_s <span class="op">=</span> Nstd<span class="op">::</span>SafeArray<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dv">4</span><span class="op">&gt;{</span><span class="st">&quot;1&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> <span class="st">&quot;3&quot;</span><span class="op">};</span></span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss   <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb231-6"><a href="#cb231-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-7"><a href="#cb231-7" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> sal_s<span class="op">;</span></span>
<span id="cb231-8"><a href="#cb231-8" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1 | 2 | 3 | &quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb231-9"><a href="#cb231-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb231-10"><a href="#cb231-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb231-11"><a href="#cb231-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> sv</span>
<span id="cb231-12"><a href="#cb231-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">=</span> Nstd<span class="op">::</span>SafeVector<span class="op">&lt;</span>Nstd<span class="op">::</span>SafeArray<span class="op">&lt;</span>Nstd<span class="op">::</span>SafeString<span class="op">,</span> <span class="dv">2</span><span class="op">&gt;&gt;{{</span><span class="st">&quot;ab&quot;</span><span class="op">,</span> <span class="st">&quot;cd&quot;</span><span class="op">},</span> <span class="op">{</span><span class="st">&quot;ef&quot;</span><span class="op">,</span> <span class="st">&quot;gh&quot;</span><span class="op">}};</span></span>
<span id="cb231-13"><a href="#cb231-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb231-14"><a href="#cb231-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-15"><a href="#cb231-15" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> sv<span class="op">;</span></span>
<span id="cb231-16"><a href="#cb231-16" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;ab | cd # ef | gh&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb231-17"><a href="#cb231-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h2
id="nstdライブラリの開発3浮動小数点関連">Nstdライブラリの開発3(浮動小数点関連)
<a id="SS_13_5"></a></h2>
<p><a
href="term_explanation.html#SS_19_1_12">浮動小数点型</a>を頻繁に使用するソフトウェアの開発を行うに場合、
ソースコードの中で、場当たり的に浮動小数点型を使用すると、 <a
href="term_explanation.html#SS_19_1_12_2">浮動小数点の誤差</a>や<a
href="term_explanation.html#SS_19_1_12_4">浮動小数点の演算エラー</a>
にまつわるバグの修正に多くの工数をロスしてしまうことになる。</p>
<p>これらの課題に対処するため、この節は浮動小数点演算によるバグを未然に防ぎ、
精度を確保するための機能を提供することを目的としている。 <a
href="template_meta_programming.html#SS_13_5_1">浮動小数点の比較</a>方法や、
浮動小数点を避けて高精度な演算を実現する<a
href="template_meta_programming.html#SS_13_5_2">固定小数点クラス</a>および<a
href="template_meta_programming.html#SS_13_5_4">有理数クラス</a>を導入し、
さらにそれらを簡単に使用できるリテラル表記もサポートしている。</p>
<h3 id="浮動小数点の比較">浮動小数点の比較 <a id="SS_13_5_1"></a></h3>
<p>浮動小数点の演算には下記に示したような問題が起こり得るため、単純な==の比較はできない。</p>
<div class="sourceCode" id="cb232"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_float_ut.cpp 9</span></span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記の0.01は2進数では循環小数となるため、実数の0.01とは異なる。</span></span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> a <span class="op">=</span> <span class="fl">0.01</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000001010001111...</span></span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> b <span class="op">=</span> <span class="fl">0.04</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000101000111101...</span></span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span><span class="fl">0.05</span><span class="bu">F</span> <span class="op">==</span> a <span class="op">+</span> b<span class="op">);</span>  <span class="co">// a + b == 0.05Fは一般には成立しない。</span></span></code></pre></div>
<p>この問題に対処するのが以下のコードである。</p>
<div class="sourceCode" id="cb233"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_float_ut.cpp 17</span></span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> epsilon  <span class="op">=</span> <span class="bu">std::</span>abs<span class="op">(</span><span class="fl">0.05</span><span class="bu">F</span> <span class="op">-</span> <span class="op">(</span>a <span class="op">+</span> b<span class="op">));</span></span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span>  is_equal <span class="op">=</span> epsilon <span class="op">&lt;=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;::</span>epsilon<span class="op">();</span></span>
<span id="cb233-5"><a href="#cb233-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>is_equal<span class="op">);</span></span></code></pre></div>
<p>単なる浮動小数変数の比較にこのようなコードを書くのは間違えやすいし、非効率であるため、
下記のような関数(float用とdouble用)で対処することが一般的である。</p>
<div class="sourceCode" id="cb234"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_float_ut.cpp 25</span></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> float比較用関数</span></span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_equal_f<span class="op">(</span><span class="dt">float</span> lhs<span class="op">,</span> <span class="dt">float</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb234-7"><a href="#cb234-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb234-8"><a href="#cb234-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>lhs <span class="op">-</span> rhs<span class="op">)</span> <span class="op">&lt;=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;::</span>epsilon<span class="op">();</span></span>
<span id="cb234-9"><a href="#cb234-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb234-10"><a href="#cb234-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-11"><a href="#cb234-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> double比較用関数</span></span>
<span id="cb234-12"><a href="#cb234-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_equal_d<span class="op">(</span><span class="dt">double</span> lhs<span class="op">,</span> <span class="dt">double</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb234-13"><a href="#cb234-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb234-14"><a href="#cb234-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>lhs <span class="op">-</span> rhs<span class="op">)</span> <span class="op">&lt;=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;::</span>epsilon<span class="op">();</span></span>
<span id="cb234-15"><a href="#cb234-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>実際に使う場面を以下に示す。</p>
<div class="sourceCode" id="cb235"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_float_ut.cpp 44</span></span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記の0.01は2進数では循環小数となるため、実数の0.01とは異なる。</span></span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> a <span class="op">=</span> <span class="fl">0.01</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000001010001111...</span></span>
<span id="cb235-5"><a href="#cb235-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> b <span class="op">=</span> <span class="fl">0.04</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000101000111101...</span></span>
<span id="cb235-6"><a href="#cb235-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-7"><a href="#cb235-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// floatの比較はis_equal_fのような関数を使う。</span></span>
<span id="cb235-8"><a href="#cb235-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_equal <span class="op">=</span> Nstd<span class="op">::</span>is_equal_f<span class="op">(</span><span class="fl">0.05</span><span class="bu">F</span><span class="op">,</span> a <span class="op">+</span> b<span class="op">);</span></span>
<span id="cb235-9"><a href="#cb235-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>is_equal<span class="op">);</span></span></code></pre></div>
<p>一見これで万事うまくいくように見えるが、そうは行かないことを以下の例で示す。</p>
<div class="sourceCode" id="cb236"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_float_ut.cpp 59</span></span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記の0.01は2進数では循環小数となるため、実数の0.01とは異なる。</span></span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> a <span class="op">=</span> <span class="fl">0.01</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000001010001111...</span></span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> b <span class="op">=</span> <span class="fl">0.04</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000101000111101...</span></span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-7"><a href="#cb236-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a + bはfloatの精度のまま、is_equal_dの引数の型であるdoubleに昇格される。</span></span>
<span id="cb236-8"><a href="#cb236-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 一方、0.05はdoubleであるため(循環小数をdoubleの精度で切り捨てた値であるため)、</span></span>
<span id="cb236-9"><a href="#cb236-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a + b(floatの精度の値)と0.05の差はdoubleのepsilonを超える。</span></span>
<span id="cb236-10"><a href="#cb236-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  ASSERT_TRUE(is_equal_d(0.05, a + b));  // NG</span></span>
<span id="cb236-11"><a href="#cb236-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>Nstd<span class="op">::</span>is_equal_d<span class="op">(</span><span class="fl">0.05</span><span class="op">,</span> a <span class="op">+</span> b<span class="op">));</span></span></code></pre></div>
<p>dobuleとfloatを1つの式に混載するとfloatがdoubleに昇格されるため、このような問題が起こり得る。
これに対処する方法を以下に示す。</p>
<div class="sourceCode" id="cb237"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_float_ut.cpp 74</span></span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// is_equal_dを改良して、引数の型が統一されていない呼び出しをコンパイルエラーにできるようにした。</span></span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> 浮動小数点比較用関数</span></span>
<span id="cb237-6"><a href="#cb237-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> FLOAT_0<span class="op">,</span> <span class="kw">typename</span> FLOAT_1<span class="op">&gt;</span></span>
<span id="cb237-7"><a href="#cb237-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_equal<span class="op">(</span>FLOAT_0 lhs<span class="op">,</span> FLOAT_1 rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb237-8"><a href="#cb237-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb237-9"><a href="#cb237-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_floating_point_v<span class="op">&lt;</span>FLOAT_0<span class="op">&gt;);</span></span>
<span id="cb237-10"><a href="#cb237-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>FLOAT_0<span class="op">,</span> FLOAT_1<span class="op">&gt;);</span></span>
<span id="cb237-11"><a href="#cb237-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-12"><a href="#cb237-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>lhs <span class="op">-</span> rhs<span class="op">)</span> <span class="op">&lt;=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>FLOAT_0<span class="op">&gt;::</span>epsilon<span class="op">();</span></span>
<span id="cb237-13"><a href="#cb237-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb237-14"><a href="#cb237-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>この関数のテストは以下の通りである。</p>
<div class="sourceCode" id="cb238"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_float_ut.cpp 91</span></span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記の0.01は2進数では循環小数となるため、実数の0.01とは異なる。</span></span>
<span id="cb238-4"><a href="#cb238-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> a <span class="op">=</span> <span class="fl">0.01</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000001010001111...</span></span>
<span id="cb238-5"><a href="#cb238-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> b <span class="op">=</span> <span class="fl">0.04</span><span class="bu">F</span><span class="op">;</span>  <span class="co">// 0.0000101000111101...</span></span>
<span id="cb238-6"><a href="#cb238-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb238-7"><a href="#cb238-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a + bはfloatであり、0.05はdoubleであるため、下記コードはコンパイルできない。</span></span>
<span id="cb238-8"><a href="#cb238-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_TRUE(Nstd::is_equal(0.05, a + b));</span></span>
<span id="cb238-9"><a href="#cb238-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>Nstd<span class="op">::</span>is_equal<span class="op">(</span><span class="fl">0.05</span><span class="bu">F</span><span class="op">,</span> a <span class="op">+</span> b<span class="op">));</span>  <span class="co">// OK リテラルに型を指定して、引数の型を統一</span></span></code></pre></div>
<p>通常の浮動小数の比較は相対誤差を指定できる必要性がある場合が多いため、
さらに下記のように拡張変更した。</p>
<div class="sourceCode" id="cb239"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_float_ut.cpp 106</span></span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> 浮動小数点比較用関数</span></span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// 相対誤差を考慮して、lhs と rhs の絶対値に基づくトレランスの範囲内での比較を行う。</span></span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// これにより、数値の大小に関わらず、適切な誤差で比較できる。</span></span>
<span id="cb239-6"><a href="#cb239-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> FLOAT_0<span class="op">,</span> <span class="kw">typename</span> FLOAT_1<span class="op">&gt;</span></span>
<span id="cb239-7"><a href="#cb239-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_equal<span class="op">(</span>FLOAT_0 lhs<span class="op">,</span> FLOAT_1 rhs<span class="op">,</span></span>
<span id="cb239-8"><a href="#cb239-8" aria-hidden="true" tabindex="-1"></a>                  FLOAT_0 tolerance <span class="op">=</span> <span class="bu">std::</span>numeric_limits<span class="op">&lt;</span>FLOAT_0<span class="op">&gt;::</span>epsilon<span class="op">())</span> <span class="kw">noexcept</span></span>
<span id="cb239-9"><a href="#cb239-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb239-10"><a href="#cb239-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_floating_point_v<span class="op">&lt;</span>FLOAT_0<span class="op">&gt;);</span></span>
<span id="cb239-11"><a href="#cb239-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>FLOAT_0<span class="op">,</span> FLOAT_1<span class="op">&gt;);</span></span>
<span id="cb239-12"><a href="#cb239-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-13"><a href="#cb239-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>lhs <span class="op">-</span> rhs<span class="op">)</span> <span class="op">&lt;=</span> tolerance <span class="op">*</span> <span class="bu">std::</span>max<span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>lhs<span class="op">),</span> <span class="bu">std::</span>abs<span class="op">(</span>rhs<span class="op">));</span></span>
<span id="cb239-14"><a href="#cb239-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>この関数のテストは以下の通りである。</p>
<div class="sourceCode" id="cb240"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_float_ut.cpp 125</span></span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> a <span class="op">=</span> <span class="fl">1000000.0</span><span class="bu">F</span><span class="op">;</span></span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> b <span class="op">=</span> <span class="fl">1000000.1</span><span class="bu">F</span><span class="op">;</span></span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-6"><a href="#cb240-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>Nstd<span class="op">::</span>is_equal<span class="op">(</span>a<span class="op">,</span> b<span class="op">));</span>       <span class="co">// a, bはほぼ同じだが。</span></span>
<span id="cb240-7"><a href="#cb240-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>Nstd<span class="op">::</span>is_equal<span class="op">(</span>a<span class="op">,</span> b<span class="op">,</span> <span class="fl">0.1</span><span class="bu">F</span><span class="op">));</span>  <span class="co">// 相対誤差を指定できる。</span></span></code></pre></div>
<h3 id="固定小数点クラス">固定小数点クラス <a id="SS_13_5_2"></a></h3>
<p>以上で見てきたように浮動小数点の扱いはやや面倒であるため、
浮動小数点のダイナミックレンジが必要な場合以外では安易に浮動小数点を使うべきでない。</p>
<p>従って、intやlong等のダイナミックレンジで表現できる1未満の値が必要な場合、
intやlongの値を100倍などのスケーリングして使うのが、浮動小数点の微妙な問題を避ける手段となる。
スケーリングとは、 整数型変数変数のスケーリングとは、intやlongの値を、
特定の倍率で拡大することで小数点以下の値を扱う方法を指す。
例えば、100倍にスケーリングして「1.23」を「123」として整数で表現するようする。
この方法は浮動小数点の代わりに使えるが、
スケーリング値を常に意識する必要があり、コードの可読性や保守性に影響を与える問題がある。</p>
<p>以下に示す固定小数点クラス(FixedPoint)はこれらの問題を解決できる。</p>
<div class="sourceCode" id="cb241"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/fixed_point.h 7</span></span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb241-4"><a href="#cb241-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> BASIC_TYPEで指定する基本型のビット長を持つ固定小数点を扱うためのクラス</span></span>
<span id="cb241-5"><a href="#cb241-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@tparam</span><span class="co"> </span><span class="cv">BASIC_TYPE</span><span class="co">       全体のビット長や、符号を指定するための整数型</span></span>
<span id="cb241-6"><a href="#cb241-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@tparam</span><span class="co"> </span><span class="cv">FRACTION_BIT_NUM</span><span class="co"> 小数点保持のためのビット長</span></span>
<span id="cb241-7"><a href="#cb241-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> BASIC_TYPE<span class="op">,</span> <span class="dt">uint32_t</span> FRACTION_BIT_NUM<span class="op">&gt;</span></span>
<span id="cb241-8"><a href="#cb241-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> FixedPoint <span class="op">{</span></span>
<span id="cb241-9"><a href="#cb241-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb241-10"><a href="#cb241-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> FixedPoint<span class="op">(</span>BASIC_TYPE                                integer  <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb241-11"><a href="#cb241-11" aria-hidden="true" tabindex="-1"></a>                             <span class="kw">typename</span> <span class="bu">std::</span>make_unsigned_t<span class="op">&lt;</span>BASIC_TYPE<span class="op">&gt;</span> fraction <span class="op">=</span> <span class="dv">0</span><span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-12"><a href="#cb241-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> <span class="va">value_</span><span class="op">{</span>get_init_value<span class="op">(</span>integer<span class="op">,</span> fraction<span class="op">)}</span></span>
<span id="cb241-13"><a href="#cb241-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-14"><a href="#cb241-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// signedに対する右ビットシフトの仕様が、算術右ビットシフトでないと</span></span>
<span id="cb241-15"><a href="#cb241-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">// このクラスは成立しない。下記のstatic_assertはその確認。</span></span>
<span id="cb241-16"><a href="#cb241-16" aria-hidden="true" tabindex="-1"></a>            <span class="kw">static_assert</span><span class="op">(</span>IsSigned<span class="op">()</span> <span class="op">?</span> <span class="op">(-</span><span class="dv">1</span> <span class="op">&gt;&gt;</span> <span class="dv">1</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">:</span> <span class="kw">true</span><span class="op">,</span> <span class="st">&quot;need logical right bit sift&quot;</span><span class="op">);</span></span>
<span id="cb241-17"><a href="#cb241-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-18"><a href="#cb241-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">// BASIC_TYPEをcharにすることは認めない。</span></span>
<span id="cb241-19"><a href="#cb241-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">static_assert</span><span class="op">(!</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>BASIC_TYPE<span class="op">,</span> <span class="dt">char</span><span class="op">&gt;,</span> <span class="st">&quot;BASIC_TYPE should not be char&quot;</span><span class="op">);</span></span>
<span id="cb241-20"><a href="#cb241-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-21"><a href="#cb241-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-22"><a href="#cb241-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 以下、特殊メンバ定義</span></span>
<span id="cb241-23"><a href="#cb241-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>FixedPoint<span class="op">()</span>                                <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb241-24"><a href="#cb241-24" aria-hidden="true" tabindex="-1"></a>        FixedPoint<span class="op">(</span>FixedPoint <span class="at">const</span><span class="op">&amp;)</span>                <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb241-25"><a href="#cb241-25" aria-hidden="true" tabindex="-1"></a>        FixedPoint<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>FixedPoint <span class="at">const</span><span class="op">&amp;)</span>     <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb241-26"><a href="#cb241-26" aria-hidden="true" tabindex="-1"></a>        FixedPoint<span class="op">(</span>FixedPoint<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span>            <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb241-27"><a href="#cb241-27" aria-hidden="true" tabindex="-1"></a>        FixedPoint<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>FixedPoint<span class="op">&amp;&amp;)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb241-28"><a href="#cb241-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-29"><a href="#cb241-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 以下、インターフェース定義</span></span>
<span id="cb241-30"><a href="#cb241-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> BASIC_TYPE GetValue<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">value_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb241-31"><a href="#cb241-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> BASIC_TYPE GetInteger<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">value_</span> <span class="op">&gt;&gt;</span> <span class="va">fraction_bit_num_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb241-32"><a href="#cb241-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> BASIC_TYPE GetFraction<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">value_</span> <span class="op">&amp;</span> <span class="va">fraction_bit_mask_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb241-33"><a href="#cb241-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-34"><a href="#cb241-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> doubleに変換する</span></span>
<span id="cb241-35"><a href="#cb241-35" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="dt">double</span> ToFloatPoint<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb241-36"><a href="#cb241-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-37"><a href="#cb241-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> GetInteger<span class="op">()</span> <span class="op">+</span> <span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>GetFraction<span class="op">())</span> <span class="op">/</span> <span class="op">(</span><span class="va">fraction_bit_mask_</span> <span class="op">+</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb241-38"><a href="#cb241-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-39"><a href="#cb241-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-40"><a href="#cb241-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> 小数部のビット長を返す</span></span>
<span id="cb241-41"><a href="#cb241-41" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>make_unsigned_t<span class="op">&lt;</span>BASIC_TYPE<span class="op">&gt;</span> GetFractionMask<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb241-42"><a href="#cb241-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-43"><a href="#cb241-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">fraction_bit_mask_</span><span class="op">;</span></span>
<span id="cb241-44"><a href="#cb241-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-45"><a href="#cb241-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-46"><a href="#cb241-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> 整数部のビット長を返す</span></span>
<span id="cb241-47"><a href="#cb241-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>make_unsigned_t<span class="op">&lt;</span>BASIC_TYPE<span class="op">&gt;</span> GetIntegerMask<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb241-48"><a href="#cb241-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-49"><a href="#cb241-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">integer_bit_mask_</span><span class="op">;</span></span>
<span id="cb241-50"><a href="#cb241-50" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-51"><a href="#cb241-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-52"><a href="#cb241-52" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> IsSigned<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>is_signed_v<span class="op">&lt;</span>BASIC_TYPE<span class="op">&gt;;</span> <span class="op">}</span></span>
<span id="cb241-53"><a href="#cb241-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-54"><a href="#cb241-54" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> IsUnsigned<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>is_unsigned_v<span class="op">&lt;</span>BASIC_TYPE<span class="op">&gt;;</span> <span class="op">}</span></span>
<span id="cb241-55"><a href="#cb241-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-56"><a href="#cb241-56" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co">    以下operator </span><span class="sc">@=</span><span class="co">の定義</span></span>
<span id="cb241-57"><a href="#cb241-57" aria-hidden="true" tabindex="-1"></a>        FixedPoint<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">+=(</span>FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-58"><a href="#cb241-58" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-59"><a href="#cb241-59" aria-hidden="true" tabindex="-1"></a>            <span class="va">value_</span> <span class="op">+=</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">;</span></span>
<span id="cb241-60"><a href="#cb241-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb241-61"><a href="#cb241-61" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-62"><a href="#cb241-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-63"><a href="#cb241-63" aria-hidden="true" tabindex="-1"></a>        FixedPoint<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">-=(</span>FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-64"><a href="#cb241-64" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-65"><a href="#cb241-65" aria-hidden="true" tabindex="-1"></a>            <span class="va">value_</span> <span class="op">-=</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">;</span></span>
<span id="cb241-66"><a href="#cb241-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb241-67"><a href="#cb241-67" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-68"><a href="#cb241-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-69"><a href="#cb241-69" aria-hidden="true" tabindex="-1"></a>        FixedPoint<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">*=(</span>FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-70"><a href="#cb241-70" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-71"><a href="#cb241-71" aria-hidden="true" tabindex="-1"></a>            <span class="va">value_</span> <span class="op">*=</span> rhs<span class="op">.</span><span class="va">value_</span> <span class="op">&gt;&gt;</span> <span class="va">fraction_bit_num_</span><span class="op">;</span></span>
<span id="cb241-72"><a href="#cb241-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb241-73"><a href="#cb241-73" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-74"><a href="#cb241-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-75"><a href="#cb241-75" aria-hidden="true" tabindex="-1"></a>        FixedPoint<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">/=(</span>FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-76"><a href="#cb241-76" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-77"><a href="#cb241-77" aria-hidden="true" tabindex="-1"></a>            <span class="kw">using</span> T <span class="op">=</span> <span class="bu">std::</span>conditional_t<span class="op">&lt;</span>IsSigned<span class="op">(),</span> <span class="dt">int64_t</span><span class="op">,</span> <span class="dt">uint64_t</span><span class="op">&gt;;</span></span>
<span id="cb241-78"><a href="#cb241-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-79"><a href="#cb241-79" aria-hidden="true" tabindex="-1"></a>            <span class="va">value_</span> <span class="op">=</span> <span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span>T<span class="op">&gt;(</span><span class="va">value_</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="va">fraction_bit_num_</span><span class="op">)</span> <span class="op">/</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">;</span></span>
<span id="cb241-80"><a href="#cb241-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-81"><a href="#cb241-81" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb241-82"><a href="#cb241-82" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-83"><a href="#cb241-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-84"><a href="#cb241-84" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb241-85"><a href="#cb241-85" aria-hidden="true" tabindex="-1"></a>        BASIC_TYPE <span class="va">value_</span><span class="op">;</span>  <span class="co">// FixedPointの実際の値</span></span>
<span id="cb241-86"><a href="#cb241-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-87"><a href="#cb241-87" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">uint32_t</span> bit_mask<span class="op">(</span><span class="dt">uint32_t</span> bit_len<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-88"><a href="#cb241-88" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-89"><a href="#cb241-89" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>bit_len <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb241-90"><a href="#cb241-90" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="bn">0x0</span><span class="op">;</span></span>
<span id="cb241-91"><a href="#cb241-91" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb241-92"><a href="#cb241-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-93"><a href="#cb241-93" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> bit_mask<span class="op">(</span>bit_len <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">|</span> <span class="op">(</span><span class="bn">0x01</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>bit_len <span class="op">-</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb241-94"><a href="#cb241-94" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-95"><a href="#cb241-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-96"><a href="#cb241-96" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">uint32_t</span> <span class="va">fraction_bit_num_</span><span class="op">{</span>FRACTION_BIT_NUM<span class="op">};</span></span>
<span id="cb241-97"><a href="#cb241-97" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">uint32_t</span> <span class="va">fraction_bit_mask_</span><span class="op">{</span>bit_mask<span class="op">(</span><span class="va">fraction_bit_num_</span><span class="op">)};</span></span>
<span id="cb241-98"><a href="#cb241-98" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">uint32_t</span> <span class="va">integer_bit_num_</span><span class="op">{</span><span class="kw">sizeof</span><span class="op">(</span>BASIC_TYPE<span class="op">)</span> <span class="op">*</span> <span class="dv">8</span> <span class="op">-</span> FRACTION_BIT_NUM<span class="op">};</span></span>
<span id="cb241-99"><a href="#cb241-99" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">uint32_t</span> <span class="va">integer_bit_mask_</span><span class="op">{</span>bit_mask<span class="op">(</span><span class="va">integer_bit_num_</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="va">fraction_bit_num_</span><span class="op">};</span></span>
<span id="cb241-100"><a href="#cb241-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-101"><a href="#cb241-101" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="kw">constexpr</span> BASIC_TYPE get_init_value<span class="op">(</span>BASIC_TYPE integer<span class="op">,</span> BASIC_TYPE fraction<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-102"><a href="#cb241-102" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-103"><a href="#cb241-103" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 本来は左シフト&lt;&lt;を使いたいが、signedに対しての&lt;&lt;ランタイム実装依存であるので、</span></span>
<span id="cb241-104"><a href="#cb241-104" aria-hidden="true" tabindex="-1"></a>            <span class="co">// return (integer &lt;&lt; fraction_bit_num_) | fraction;</span></span>
<span id="cb241-105"><a href="#cb241-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-106"><a href="#cb241-106" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">(</span>integer <span class="op">*</span> <span class="op">(</span><span class="va">fraction_bit_mask_</span> <span class="op">+</span> <span class="dv">1</span><span class="op">))</span> <span class="op">|</span> fraction<span class="op">;</span></span>
<span id="cb241-107"><a href="#cb241-107" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-108"><a href="#cb241-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-109"><a href="#cb241-109" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// 以下比較演算子の定義</span></span>
<span id="cb241-110"><a href="#cb241-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-111"><a href="#cb241-111" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb241-112"><a href="#cb241-112" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>FixedPoint lhs<span class="op">,</span> FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb241-113"><a href="#cb241-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-114"><a href="#cb241-114" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb241-115"><a href="#cb241-115" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>FixedPoint lhs<span class="op">,</span> FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-116"><a href="#cb241-116" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-117"><a href="#cb241-117" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> lhs<span class="op">.</span><span class="va">value_</span> <span class="op">==</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">;</span></span>
<span id="cb241-118"><a href="#cb241-118" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-119"><a href="#cb241-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-120"><a href="#cb241-120" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>FixedPoint lhs<span class="op">,</span> FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span> <span class="op">}</span></span>
<span id="cb241-121"><a href="#cb241-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-122"><a href="#cb241-122" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span>FixedPoint lhs<span class="op">,</span> FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-123"><a href="#cb241-123" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-124"><a href="#cb241-124" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> lhs<span class="op">.</span><span class="va">value_</span> <span class="op">&gt;</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">;</span></span>
<span id="cb241-125"><a href="#cb241-125" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-126"><a href="#cb241-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-127"><a href="#cb241-127" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>FixedPoint lhs<span class="op">,</span> FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-128"><a href="#cb241-128" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-129"><a href="#cb241-129" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">(</span>lhs <span class="op">&gt;</span> rhs<span class="op">)</span> <span class="op">||</span> <span class="op">(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb241-130"><a href="#cb241-130" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-131"><a href="#cb241-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-132"><a href="#cb241-132" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span>FixedPoint lhs<span class="op">,</span> FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>rhs <span class="op">&gt;</span> lhs<span class="op">);</span> <span class="op">}</span></span>
<span id="cb241-133"><a href="#cb241-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-134"><a href="#cb241-134" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span>FixedPoint lhs<span class="op">,</span> FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-135"><a href="#cb241-135" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-136"><a href="#cb241-136" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">(</span>lhs <span class="op">&lt;</span> rhs<span class="op">)</span> <span class="op">||</span> <span class="op">(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb241-137"><a href="#cb241-137" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-138"><a href="#cb241-138" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb241-139"><a href="#cb241-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-140"><a href="#cb241-140" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> FixedPoint() + intのようなオーバーロードを作るためにあえてfriend</span></span>
<span id="cb241-141"><a href="#cb241-141" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> FixedPoint <span class="kw">operator</span><span class="op">+(</span>FixedPoint lhs<span class="op">,</span> FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-142"><a href="#cb241-142" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-143"><a href="#cb241-143" aria-hidden="true" tabindex="-1"></a>            lhs <span class="op">+=</span> rhs<span class="op">;</span></span>
<span id="cb241-144"><a href="#cb241-144" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> lhs<span class="op">;</span></span>
<span id="cb241-145"><a href="#cb241-145" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-146"><a href="#cb241-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-147"><a href="#cb241-147" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> FixedPoint <span class="kw">operator</span><span class="op">-(</span>FixedPoint lhs<span class="op">,</span> FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-148"><a href="#cb241-148" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-149"><a href="#cb241-149" aria-hidden="true" tabindex="-1"></a>            lhs <span class="op">-=</span> rhs<span class="op">;</span></span>
<span id="cb241-150"><a href="#cb241-150" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> lhs<span class="op">;</span></span>
<span id="cb241-151"><a href="#cb241-151" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-152"><a href="#cb241-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-153"><a href="#cb241-153" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> FixedPoint <span class="kw">operator</span><span class="op">*(</span>FixedPoint lhs<span class="op">,</span> FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-154"><a href="#cb241-154" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-155"><a href="#cb241-155" aria-hidden="true" tabindex="-1"></a>            lhs <span class="op">*=</span> rhs<span class="op">;</span></span>
<span id="cb241-156"><a href="#cb241-156" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> lhs<span class="op">;</span></span>
<span id="cb241-157"><a href="#cb241-157" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-158"><a href="#cb241-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-159"><a href="#cb241-159" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> FixedPoint <span class="kw">operator</span><span class="op">/(</span>FixedPoint lhs<span class="op">,</span> FixedPoint rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb241-160"><a href="#cb241-160" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb241-161"><a href="#cb241-161" aria-hidden="true" tabindex="-1"></a>            lhs <span class="op">/=</span> rhs<span class="op">;</span></span>
<span id="cb241-162"><a href="#cb241-162" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> lhs<span class="op">;</span></span>
<span id="cb241-163"><a href="#cb241-163" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb241-164"><a href="#cb241-164" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>FixedPointの単体テストコードを以下に示す。</p>
<div class="sourceCode" id="cb242"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/fixed_point_ut.cpp 21</span></span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 以下は、FixedPoint&lt;&gt;の使用例である。</span></span>
<span id="cb242-4"><a href="#cb242-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> FP4 <span class="op">=</span> Nstd<span class="op">::</span>FixedPoint<span class="op">&lt;</span><span class="dt">uint8_t</span><span class="op">,</span> <span class="dv">4</span><span class="op">&gt;;</span>  <span class="co">// 基本型uint8_t、小数点4ビット</span></span>
<span id="cb242-5"><a href="#cb242-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> fp0  <span class="op">=</span> FP4<span class="op">{};</span></span>
<span id="cb242-6"><a href="#cb242-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-7"><a href="#cb242-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>fp0<span class="op">.</span>IsSigned<span class="op">());</span></span>
<span id="cb242-8"><a href="#cb242-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>fp0<span class="op">.</span>IsUnsigned<span class="op">());</span></span>
<span id="cb242-9"><a href="#cb242-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-10"><a href="#cb242-10" aria-hidden="true" tabindex="-1"></a>    fp0 <span class="op">=</span> <span class="dv">7</span><span class="op">;</span>    ASSERT_EQ<span class="op">(</span><span class="dv">7</span><span class="op">,</span> fp0<span class="op">);</span></span>
<span id="cb242-11"><a href="#cb242-11" aria-hidden="true" tabindex="-1"></a>    fp0 <span class="op">=</span> <span class="dv">7</span><span class="op">;</span>    ASSERT_NE<span class="op">(</span><span class="dv">6</span><span class="op">,</span> fp0<span class="op">);</span></span>
<span id="cb242-12"><a href="#cb242-12" aria-hidden="true" tabindex="-1"></a>    fp0 <span class="op">+=</span> <span class="dv">2</span><span class="op">;</span>   ASSERT_EQ<span class="op">(</span>FP4<span class="op">{</span><span class="dv">9</span><span class="op">},</span> fp0<span class="op">);</span>         </span>
<span id="cb242-13"><a href="#cb242-13" aria-hidden="true" tabindex="-1"></a>                ASSERT_DOUBLE_EQ<span class="op">(</span><span class="fl">9.0</span><span class="op">,</span> fp0<span class="op">.</span>ToFloatPoint<span class="op">());</span></span>
<span id="cb242-14"><a href="#cb242-14" aria-hidden="true" tabindex="-1"></a>    fp0 <span class="op">/=</span> <span class="dv">2</span><span class="op">;</span>   ASSERT_EQ<span class="op">((</span>FP4<span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">8</span><span class="op">}),</span> fp0<span class="op">);</span>    </span>
<span id="cb242-15"><a href="#cb242-15" aria-hidden="true" tabindex="-1"></a>                ASSERT_DOUBLE_EQ<span class="op">(</span><span class="fl">4.5</span><span class="op">,</span> fp0<span class="op">.</span>ToFloatPoint<span class="op">());</span></span>
<span id="cb242-16"><a href="#cb242-16" aria-hidden="true" tabindex="-1"></a>    fp0 <span class="op">/=</span> <span class="dv">2</span><span class="op">;</span>   ASSERT_EQ<span class="op">((</span>FP4<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">}),</span> fp0<span class="op">);</span>    </span>
<span id="cb242-17"><a href="#cb242-17" aria-hidden="true" tabindex="-1"></a>                ASSERT_DOUBLE_EQ<span class="op">(</span><span class="fl">2.25</span><span class="op">,</span> fp0<span class="op">.</span>ToFloatPoint<span class="op">());</span></span>
<span id="cb242-18"><a href="#cb242-18" aria-hidden="true" tabindex="-1"></a>    fp0 <span class="op">*=</span> <span class="dv">4</span><span class="op">;</span>   ASSERT_EQ<span class="op">(</span>FP4<span class="op">{</span><span class="dv">9</span><span class="op">},</span> fp0<span class="op">);</span></span>
<span id="cb242-19"><a href="#cb242-19" aria-hidden="true" tabindex="-1"></a>    fp0 <span class="op">+=</span> <span class="dv">7</span><span class="op">;</span>   ASSERT_EQ<span class="op">(</span>FP4<span class="op">{</span><span class="dv">0</span><span class="op">},</span> fp0<span class="op">);</span></span></code></pre></div>
<h3 id="固定小数点リテラル">固定小数点リテラル
<a id="SS_13_5_3"></a></h3>
<p><a
href="template_meta_programming.html#SS_13_5_2">固定小数点クラス</a>のようなクラス定義には、以下に示すようにユーザ定義リテラルを定義し、
使い勝手のよい環境をユーザに提供するべきである。</p>
<div class="sourceCode" id="cb243"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/fixed_point.h 175</span></span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> fixed_point_literals <span class="op">{</span></span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// FixedPoint&lt;int32_t, 8&gt; 用のユーザ定義リテラル</span></span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true" tabindex="-1"></a>    FixedPoint<span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">,</span> <span class="dv">8</span><span class="op">&gt;</span> <span class="kw">operator</span><span class="st">&quot;&quot;</span> _fxp<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> <span class="dt">int</span> val<span class="op">)</span></span>
<span id="cb243-7"><a href="#cb243-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb243-8"><a href="#cb243-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 整数部分を取り、FixedPoint&lt;int32_t, 8&gt;のインスタンスを作成</span></span>
<span id="cb243-9"><a href="#cb243-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FixedPoint<span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">,</span> <span class="dv">8</span><span class="op">&gt;(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">&gt;(</span>val<span class="op">));</span></span>
<span id="cb243-10"><a href="#cb243-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb243-11"><a href="#cb243-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-12"><a href="#cb243-12" aria-hidden="true" tabindex="-1"></a>    FixedPoint<span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">,</span> <span class="dv">8</span><span class="op">&gt;</span> <span class="kw">operator</span><span class="st">&quot;&quot;</span> _fxp<span class="op">(</span><span class="dt">long</span> <span class="dt">double</span> val<span class="op">)</span></span>
<span id="cb243-13"><a href="#cb243-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb243-14"><a href="#cb243-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 浮動小数点数からFixedPoint&lt;int32_t, 8&gt;のインスタンスを作成</span></span>
<span id="cb243-15"><a href="#cb243-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> integer_part  <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">&gt;(</span>val<span class="op">);</span></span>
<span id="cb243-16"><a href="#cb243-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> fraction_part <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">&gt;((</span>val <span class="op">-</span> integer_part<span class="op">)</span> <span class="op">*</span> <span class="dv">256</span><span class="op">);</span>  <span class="co">// 2^8 = 256</span></span>
<span id="cb243-17"><a href="#cb243-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> FixedPoint<span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">,</span> <span class="dv">8</span><span class="op">&gt;(</span>integer_part<span class="op">,</span> fraction_part<span class="op">);</span></span>
<span id="cb243-18"><a href="#cb243-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb243-19"><a href="#cb243-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace fixed_point_literals</span></span>
<span id="cb243-20"><a href="#cb243-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>以上のコードの単体テストを以下に示す。これにより使用方も明らかになるだろう。</p>
<div class="sourceCode" id="cb244"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/fixed_point_ut.cpp 171</span></span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">namespace</span> Nstd<span class="op">::</span>fixed_point_literals<span class="op">;</span></span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="dv">123</span><span class="op">_fxp;</span>  <span class="co">// 整数リテラル</span></span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-7"><a href="#cb244-7" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>a<span class="op">.</span>GetInteger<span class="op">(),</span> <span class="dv">123</span><span class="op">);</span></span>
<span id="cb244-8"><a href="#cb244-8" aria-hidden="true" tabindex="-1"></a>    EXPECT_EQ<span class="op">(</span>a<span class="op">.</span>GetFraction<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// 小数部は0のはず</span></span>
<span id="cb244-9"><a href="#cb244-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-10"><a href="#cb244-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b      <span class="op">=</span> <span class="fl">50.25</span><span class="op">_fxp;</span></span>
<span id="cb244-11"><a href="#cb244-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> result <span class="op">=</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb244-12"><a href="#cb244-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-13"><a href="#cb244-13" aria-hidden="true" tabindex="-1"></a>    EXPECT_NEAR<span class="op">(</span>result<span class="op">.</span>ToFloatPoint<span class="op">(),</span> <span class="fl">173.25</span><span class="op">,</span> <span class="fl">0.01</span><span class="op">);</span></span></code></pre></div>
<h3 id="有理数クラス">有理数クラス <a id="SS_13_5_4"></a></h3>
<p><a
href="template_meta_programming.html#SS_13_5_2">固定小数点クラス</a>では精度が足りず、浮動小数点を使用したくない場合、
以下のコードで示す有理数クラスがちょうどよい選択となることがある。</p>
<div class="sourceCode" id="cb245"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/rational.h 10</span></span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> ユーザー指定の型で分数を扱うためのクラス</span></span>
<span id="cb245-5"><a href="#cb245-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@tparam</span><span class="co"> </span><span class="cv">T</span><span class="co"> 基本の整数型（デフォルトはint32_t）</span></span>
<span id="cb245-6"><a href="#cb245-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb245-7"><a href="#cb245-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>signed_integral T <span class="op">=</span> <span class="dt">int32_t</span><span class="op">&gt;</span></span>
<span id="cb245-8"><a href="#cb245-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb245-9"><a href="#cb245-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">int32_t</span><span class="op">&gt;</span></span>
<span id="cb245-10"><a href="#cb245-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb245-11"><a href="#cb245-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Rational <span class="op">{</span></span>
<span id="cb245-12"><a href="#cb245-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb245-13"><a href="#cb245-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> <span class="dt">underlying_type_t</span> <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb245-14"><a href="#cb245-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> コンストラクタ</span></span>
<span id="cb245-15"><a href="#cb245-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">num</span><span class="co"> 分子</span></span>
<span id="cb245-16"><a href="#cb245-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@param</span><span class="co"> </span><span class="cv">deno</span><span class="co"> 分母</span></span>
<span id="cb245-17"><a href="#cb245-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> Rational<span class="op">(</span>T num<span class="op">,</span> T deno <span class="op">=</span> <span class="dv">1</span><span class="op">)</span> <span class="op">:</span> <span class="va">value_</span><span class="op">{</span>reduce<span class="op">(</span>num<span class="op">,</span> deno<span class="op">)}</span> <span class="op">{}</span></span>
<span id="cb245-18"><a href="#cb245-18" aria-hidden="true" tabindex="-1"></a>        T getNumerator<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">value_</span><span class="op">.</span>num<span class="op">;</span> <span class="op">}</span></span>
<span id="cb245-19"><a href="#cb245-19" aria-hidden="true" tabindex="-1"></a>        T getDenominator<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">value_</span><span class="op">.</span>deno<span class="op">;</span> <span class="op">}</span></span>
<span id="cb245-20"><a href="#cb245-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> 2項演算子(四則演算)の定義</span></span>
<span id="cb245-21"><a href="#cb245-21" aria-hidden="true" tabindex="-1"></a>        Rational <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Rational<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb245-22"><a href="#cb245-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-23"><a href="#cb245-23" aria-hidden="true" tabindex="-1"></a>            T num  <span class="op">=</span> <span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno <span class="op">+</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> <span class="va">value_</span><span class="op">.</span>deno<span class="op">;</span></span>
<span id="cb245-24"><a href="#cb245-24" aria-hidden="true" tabindex="-1"></a>            T deno <span class="op">=</span> <span class="va">value_</span><span class="op">.</span>deno <span class="op">*</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">;</span></span>
<span id="cb245-25"><a href="#cb245-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Rational<span class="op">{</span>num<span class="op">,</span> deno<span class="op">};</span></span>
<span id="cb245-26"><a href="#cb245-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-27"><a href="#cb245-27" aria-hidden="true" tabindex="-1"></a>        Rational <span class="kw">operator</span><span class="op">-(</span><span class="at">const</span> Rational<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb245-28"><a href="#cb245-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-29"><a href="#cb245-29" aria-hidden="true" tabindex="-1"></a>            T num  <span class="op">=</span> <span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno <span class="op">-</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> <span class="va">value_</span><span class="op">.</span>deno<span class="op">;</span></span>
<span id="cb245-30"><a href="#cb245-30" aria-hidden="true" tabindex="-1"></a>            T deno <span class="op">=</span> <span class="va">value_</span><span class="op">.</span>deno <span class="op">*</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">;</span></span>
<span id="cb245-31"><a href="#cb245-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Rational<span class="op">{</span>num<span class="op">,</span> deno<span class="op">};</span></span>
<span id="cb245-32"><a href="#cb245-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-33"><a href="#cb245-33" aria-hidden="true" tabindex="-1"></a>        Rational <span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> Rational<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb245-34"><a href="#cb245-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-35"><a href="#cb245-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Rational<span class="op">{</span><span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num<span class="op">,</span> <span class="va">value_</span><span class="op">.</span>deno <span class="op">*</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">};</span></span>
<span id="cb245-36"><a href="#cb245-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-37"><a href="#cb245-37" aria-hidden="true" tabindex="-1"></a>        Rational <span class="kw">operator</span><span class="op">/(</span><span class="at">const</span> Rational<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb245-38"><a href="#cb245-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-39"><a href="#cb245-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Rational<span class="op">(</span><span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">,</span> <span class="va">value_</span><span class="op">.</span>deno <span class="op">*</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num<span class="op">);</span></span>
<span id="cb245-40"><a href="#cb245-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-41"><a href="#cb245-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> 複合代入演算子(四則演算)の定義</span></span>
<span id="cb245-42"><a href="#cb245-42" aria-hidden="true" tabindex="-1"></a>        Rational<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">+=(</span>Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span></span>
<span id="cb245-43"><a href="#cb245-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-44"><a href="#cb245-44" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span><span class="kw">this</span> <span class="op">=</span> <span class="op">*</span><span class="kw">this</span> <span class="op">+</span> rhs<span class="op">;</span></span>
<span id="cb245-45"><a href="#cb245-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb245-46"><a href="#cb245-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-47"><a href="#cb245-47" aria-hidden="true" tabindex="-1"></a>        Rational<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">-=(</span>Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span></span>
<span id="cb245-48"><a href="#cb245-48" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-49"><a href="#cb245-49" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span><span class="kw">this</span> <span class="op">=</span> <span class="op">*</span><span class="kw">this</span> <span class="op">-</span> rhs<span class="op">;</span></span>
<span id="cb245-50"><a href="#cb245-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb245-51"><a href="#cb245-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-52"><a href="#cb245-52" aria-hidden="true" tabindex="-1"></a>        Rational<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">*=(</span>Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span></span>
<span id="cb245-53"><a href="#cb245-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-54"><a href="#cb245-54" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span><span class="kw">this</span> <span class="op">=</span> <span class="op">*</span><span class="kw">this</span> <span class="op">*</span> rhs<span class="op">;</span></span>
<span id="cb245-55"><a href="#cb245-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb245-56"><a href="#cb245-56" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-57"><a href="#cb245-57" aria-hidden="true" tabindex="-1"></a>        Rational<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">/=(</span>Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span></span>
<span id="cb245-58"><a href="#cb245-58" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-59"><a href="#cb245-59" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span><span class="kw">this</span> <span class="op">=</span> <span class="op">*</span><span class="kw">this</span> <span class="op">/</span> rhs<span class="op">;</span></span>
<span id="cb245-60"><a href="#cb245-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb245-61"><a href="#cb245-61" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-62"><a href="#cb245-62" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> 単項演算子の定義</span></span>
<span id="cb245-63"><a href="#cb245-63" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> Rational <span class="kw">operator</span><span class="op">+()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb245-64"><a href="#cb245-64" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> Rational <span class="kw">operator</span><span class="op">-()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> Rational<span class="op">{-</span><span class="va">value_</span><span class="op">.</span>num<span class="op">,</span> <span class="va">value_</span><span class="op">.</span>deno<span class="op">};</span> <span class="op">}</span></span>
<span id="cb245-65"><a href="#cb245-65" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> 比較演算子の定義</span></span>
<span id="cb245-66"><a href="#cb245-66" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb245-67"><a href="#cb245-67" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Rational <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb245-68"><a href="#cb245-68" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>Rational <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb245-69"><a href="#cb245-69" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-70"><a href="#cb245-70" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">(</span>lhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="op">(</span>rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> lhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">);</span></span>
<span id="cb245-71"><a href="#cb245-71" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-72"><a href="#cb245-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-73"><a href="#cb245-73" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb245-74"><a href="#cb245-74" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>Rational <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb245-75"><a href="#cb245-75" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-76"><a href="#cb245-76" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">(</span>lhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">)</span> <span class="op">==</span> <span class="op">(</span>rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> lhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">);</span></span>
<span id="cb245-77"><a href="#cb245-77" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-78"><a href="#cb245-78" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>Rational <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb245-79"><a href="#cb245-79" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-80"><a href="#cb245-80" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb245-81"><a href="#cb245-81" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-82"><a href="#cb245-82" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span>Rational <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb245-83"><a href="#cb245-83" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-84"><a href="#cb245-84" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">(</span>lhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">)</span> <span class="op">&lt;</span> <span class="op">(</span>rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num <span class="op">*</span> lhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">);</span></span>
<span id="cb245-85"><a href="#cb245-85" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-86"><a href="#cb245-86" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span>Rational <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb245-87"><a href="#cb245-87" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-88"><a href="#cb245-88" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">!(</span>rhs <span class="op">&lt;</span> lhs<span class="op">);</span></span>
<span id="cb245-89"><a href="#cb245-89" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-90"><a href="#cb245-90" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span>Rational <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> rhs <span class="op">&lt;</span> lhs<span class="op">;</span> <span class="op">}</span></span>
<span id="cb245-91"><a href="#cb245-91" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>Rational <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> Rational <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb245-92"><a href="#cb245-92" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-93"><a href="#cb245-93" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">&lt;</span> rhs<span class="op">);</span></span>
<span id="cb245-94"><a href="#cb245-94" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-95"><a href="#cb245-95" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb245-96"><a href="#cb245-96" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> put-to演算子の定義</span></span>
<span id="cb245-97"><a href="#cb245-97" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> <span class="at">const</span> Rational<span class="op">&amp;</span> rhs<span class="op">)</span></span>
<span id="cb245-98"><a href="#cb245-98" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-99"><a href="#cb245-99" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">(</span>rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">?</span> os <span class="op">&lt;&lt;</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num</span>
<span id="cb245-100"><a href="#cb245-100" aria-hidden="true" tabindex="-1"></a>                                          <span class="op">:</span> os <span class="op">&lt;&lt;</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>num <span class="op">&lt;&lt;</span> <span class="st">&quot;/&quot;</span> <span class="op">&lt;&lt;</span> rhs<span class="op">.</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">;</span></span>
<span id="cb245-101"><a href="#cb245-101" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-102"><a href="#cb245-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-103"><a href="#cb245-103" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> doubleへの変換演算子</span></span>
<span id="cb245-104"><a href="#cb245-104" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> doubleで表現可能な場合のみ利用可能</span></span>
<span id="cb245-105"><a href="#cb245-105" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> U <span class="op">=</span> T<span class="op">&gt;</span></span>
<span id="cb245-106"><a href="#cb245-106" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> <span class="kw">operator</span> <span class="dt">double</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span></span>
<span id="cb245-107"><a href="#cb245-107" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb245-108"><a href="#cb245-108" aria-hidden="true" tabindex="-1"></a>            <span class="kw">requires</span> <span class="bu">std::</span>is_convertible_v<span class="op">&lt;</span>U<span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span></span>
<span id="cb245-109"><a href="#cb245-109" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb245-110"><a href="#cb245-110" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-111"><a href="#cb245-111" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span><span class="va">value_</span><span class="op">.</span>num<span class="op">)</span> <span class="op">/</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span><span class="va">value_</span><span class="op">.</span>deno<span class="op">);</span></span>
<span id="cb245-112"><a href="#cb245-112" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-113"><a href="#cb245-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-114"><a href="#cb245-114" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb245-115"><a href="#cb245-115" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> <span class="dt">rational_t</span> <span class="op">{</span></span>
<span id="cb245-116"><a href="#cb245-116" aria-hidden="true" tabindex="-1"></a>            T num<span class="op">;</span></span>
<span id="cb245-117"><a href="#cb245-117" aria-hidden="true" tabindex="-1"></a>            T deno<span class="op">;</span></span>
<span id="cb245-118"><a href="#cb245-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-119"><a href="#cb245-119" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002  </span><span class="co">// c++20</span></span>
<span id="cb245-120"><a href="#cb245-120" aria-hidden="true" tabindex="-1"></a>            <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="dt">rational_t</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> <span class="dt">rational_t</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb245-121"><a href="#cb245-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-122"><a href="#cb245-122" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb245-123"><a href="#cb245-123" aria-hidden="true" tabindex="-1"></a>            <span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="dt">rational_t</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> <span class="dt">rational_t</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb245-124"><a href="#cb245-124" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb245-125"><a href="#cb245-125" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> lhs<span class="op">.</span>num <span class="op">==</span> rhs<span class="op">.</span>num <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>deno <span class="op">==</span> rhs<span class="op">.</span>deno<span class="op">;</span></span>
<span id="cb245-126"><a href="#cb245-126" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb245-127"><a href="#cb245-127" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb245-128"><a href="#cb245-128" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb245-129"><a href="#cb245-129" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// </span><span class="an">@brief</span><span class="co"> num/denoを約分して、rational_tで返す</span></span>
<span id="cb245-130"><a href="#cb245-130" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> <span class="dt">rational_t</span> reduce<span class="op">(</span>T num<span class="op">,</span> T deno<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb245-131"><a href="#cb245-131" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb245-132"><a href="#cb245-132" aria-hidden="true" tabindex="-1"></a>            T <span class="at">const</span> gcd <span class="op">=</span> <span class="bu">std::</span>gcd<span class="op">(</span>num<span class="op">,</span> deno<span class="op">);</span></span>
<span id="cb245-133"><a href="#cb245-133" aria-hidden="true" tabindex="-1"></a>            num <span class="op">/=</span> gcd<span class="op">;</span></span>
<span id="cb245-134"><a href="#cb245-134" aria-hidden="true" tabindex="-1"></a>            deno <span class="op">/=</span> gcd<span class="op">;</span></span>
<span id="cb245-135"><a href="#cb245-135" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>deno <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span>  <span class="co">// 分母を正に保つ</span></span>
<span id="cb245-136"><a href="#cb245-136" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="op">{-</span>num<span class="op">,</span> <span class="op">-</span>deno<span class="op">};</span></span>
<span id="cb245-137"><a href="#cb245-137" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb245-138"><a href="#cb245-138" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb245-139"><a href="#cb245-139" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="op">{</span>num<span class="op">,</span> deno<span class="op">};</span></span>
<span id="cb245-140"><a href="#cb245-140" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb245-141"><a href="#cb245-141" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-142"><a href="#cb245-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-143"><a href="#cb245-143" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb245-144"><a href="#cb245-144" aria-hidden="true" tabindex="-1"></a>        <span class="dt">rational_t</span> <span class="va">value_</span><span class="op">;</span></span>
<span id="cb245-145"><a href="#cb245-145" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb245-146"><a href="#cb245-146" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<div class="sourceCode" id="cb246"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/rational_ut.cpp 12</span></span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>       r1    <span class="op">=</span> Rational<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> r1_sv <span class="op">=</span> r1<span class="op">;</span></span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>       r2    <span class="op">=</span> Rational<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_GE<span class="op">(</span>r1<span class="op">,</span> r2<span class="op">);</span></span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a>    r1 <span class="op">+=</span> r2<span class="op">;</span>  <span class="co">// operator+</span></span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">((</span>Rational<span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">}),</span> r1<span class="op">);</span></span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true" tabindex="-1"></a>    r1 <span class="op">=</span> r1_sv<span class="op">;</span></span>
<span id="cb246-12"><a href="#cb246-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-13"><a href="#cb246-13" aria-hidden="true" tabindex="-1"></a>    r1 <span class="op">-=</span> r2<span class="op">;</span></span>
<span id="cb246-14"><a href="#cb246-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">((</span>Rational<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">6</span><span class="op">}),</span> r1<span class="op">);</span></span>
<span id="cb246-15"><a href="#cb246-15" aria-hidden="true" tabindex="-1"></a>    r1 <span class="op">=</span> r1_sv<span class="op">;</span></span>
<span id="cb246-16"><a href="#cb246-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-17"><a href="#cb246-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb246-18"><a href="#cb246-18" aria-hidden="true" tabindex="-1"></a>    oss <span class="op">&lt;&lt;</span> r1<span class="op">;</span></span>
<span id="cb246-19"><a href="#cb246-19" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;1/2&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span>  <span class="co">// operator&lt;&lt;</span></span></code></pre></div>
<h3 id="有理数リテラル">有理数リテラル <a id="SS_13_5_5"></a></h3>
<p><a
href="template_meta_programming.html#SS_13_5_2">固定小数点クラス</a>に対して、<a
href="template_meta_programming.html#SS_13_5_3">固定小数点リテラル</a>を定義したように、
使い勝手のよい環境をユーザに提供するために、 <a
href="template_meta_programming.html#SS_13_5_4">有理数クラス</a>に対して、有理数リテラルを定義するべきである。</p>
<div class="sourceCode" id="cb247"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/rational.h 157</span></span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-3"><a href="#cb247-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb247-4"><a href="#cb247-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> Rational</span><span class="kw">&lt;int32_t&gt;</span><span class="co">をユーザ定義リテラルとして扱うためのオペレータ</span></span>
<span id="cb247-5"><a href="#cb247-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">///        _rn: rational number</span></span>
<span id="cb247-6"><a href="#cb247-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">///  </span><span class="an">@param</span><span class="co"> </span><span class="cv">N/Mの形式の文字列リテラル</span></span>
<span id="cb247-7"><a href="#cb247-7" aria-hidden="true" tabindex="-1"></a>    Rational<span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">&gt;</span> <span class="kw">operator</span><span class="st">&quot;&quot;</span> _rn<span class="op">(</span><span class="dt">char</span> <span class="at">const</span><span class="op">*</span> str<span class="op">,</span> <span class="dt">size_t</span><span class="op">)</span></span>
<span id="cb247-8"><a href="#cb247-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb247-9"><a href="#cb247-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string_view input<span class="op">{</span>str<span class="op">};</span></span>
<span id="cb247-10"><a href="#cb247-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">size_t</span>           sep <span class="op">=</span> input<span class="op">.</span>find<span class="op">(</span><span class="ch">&#39;/&#39;</span><span class="op">);</span></span>
<span id="cb247-11"><a href="#cb247-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-12"><a href="#cb247-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>sep <span class="op">==</span> <span class="bu">std::</span>string::npos<span class="op">)</span> <span class="op">{</span></span>
<span id="cb247-13"><a href="#cb247-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">&quot;invalid formt for user-defined rational number&quot;</span><span class="op">);</span></span>
<span id="cb247-14"><a href="#cb247-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb247-15"><a href="#cb247-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-16"><a href="#cb247-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> num  <span class="op">=</span> <span class="bu">std::</span>stoi<span class="op">(</span>str<span class="op">);</span></span>
<span id="cb247-17"><a href="#cb247-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int32_t</span> deno <span class="op">=</span> <span class="bu">std::</span>stoi<span class="op">(</span>input<span class="op">.</span>substr<span class="op">(</span>sep <span class="op">+</span> <span class="dv">1</span><span class="op">).</span>data<span class="op">());</span></span>
<span id="cb247-18"><a href="#cb247-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-19"><a href="#cb247-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>num<span class="op">,</span> deno<span class="op">};</span></span>
<span id="cb247-20"><a href="#cb247-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb247-21"><a href="#cb247-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<div class="sourceCode" id="cb248"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/rational_ut.cpp 55</span></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> r1 <span class="op">=</span> <span class="st">&quot;1/2&quot;</span><span class="op">_rn;</span></span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> r2 <span class="op">=</span> <span class="st">&quot;1/3&quot;</span><span class="op">_rn;</span></span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-6"><a href="#cb248-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_GE<span class="op">(</span>r1<span class="op">,</span> r2<span class="op">);</span></span>
<span id="cb248-7"><a href="#cb248-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_DOUBLE_EQ<span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>r1<span class="op">),</span> <span class="fl">0.5</span><span class="op">);</span></span></code></pre></div>
<h2 id="ログ取得ライブラリの開発2">ログ取得ライブラリの開発2
<a id="SS_13_6"></a></h2>
<p>ログ取得ライブラリでの問題は「Logging名前空間が依存してよい名前空間」に</p>
<div class="sourceCode" id="cb249"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/app_ints.h 6</span></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">Ints_t</span> <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>のようなコンテナに共通したoperator&lt;&lt;を定義することで解決する。
それは 「<a
href="template_meta_programming.html#SS_13_4_4">コンテナ用Nstd::operator&lt;&lt;の開発</a>」で示したコードそのものであるため、
これを使い、問題を解決したログ取得ライブラリを以下に示す。</p>
<div class="sourceCode" id="cb250"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger.h 7</span></span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Logging <span class="op">{</span></span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Logger <span class="op">{</span></span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> Logger<span class="op">&amp;</span>       Inst<span class="op">();</span></span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">static</span> Logger <span class="at">const</span><span class="op">&amp;</span> InstConst<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> Inst<span class="op">();</span> <span class="op">}</span></span>
<span id="cb250-8"><a href="#cb250-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-9"><a href="#cb250-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string Get<span class="op">()</span> <span class="at">const</span><span class="op">;</span>  <span class="co">// ログデータの取得</span></span>
<span id="cb250-10"><a href="#cb250-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span>        Clear<span class="op">();</span>      <span class="co">// ログデータの消去</span></span>
<span id="cb250-11"><a href="#cb250-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-12"><a href="#cb250-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> ARGS<span class="op">&gt;</span>  <span class="co">// ログの登録</span></span>
<span id="cb250-13"><a href="#cb250-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> Set<span class="op">(</span><span class="dt">char</span> <span class="at">const</span><span class="op">*</span> filename<span class="op">,</span> <span class="dt">uint32_t</span> line_no<span class="op">,</span> ARGS <span class="at">const</span><span class="op">&amp;...</span> args<span class="op">)</span></span>
<span id="cb250-14"><a href="#cb250-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb250-15"><a href="#cb250-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">oss_</span><span class="op">.</span>width<span class="op">(</span><span class="dv">32</span><span class="op">);</span></span>
<span id="cb250-16"><a href="#cb250-16" aria-hidden="true" tabindex="-1"></a>            <span class="va">oss_</span> <span class="op">&lt;&lt;</span> filename <span class="op">&lt;&lt;</span> <span class="st">&quot;:&quot;</span><span class="op">;</span></span>
<span id="cb250-17"><a href="#cb250-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-18"><a href="#cb250-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">oss_</span><span class="op">.</span>width<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb250-19"><a href="#cb250-19" aria-hidden="true" tabindex="-1"></a>            <span class="va">oss_</span> <span class="op">&lt;&lt;</span> line_no<span class="op">;</span></span>
<span id="cb250-20"><a href="#cb250-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-21"><a href="#cb250-21" aria-hidden="true" tabindex="-1"></a>            set_inner<span class="op">(</span>args<span class="op">...);</span></span>
<span id="cb250-22"><a href="#cb250-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb250-23"><a href="#cb250-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-24"><a href="#cb250-24" aria-hidden="true" tabindex="-1"></a>        Logger<span class="op">(</span>Logger <span class="at">const</span><span class="op">&amp;)</span>            <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb250-25"><a href="#cb250-25" aria-hidden="true" tabindex="-1"></a>        Logger<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Logger <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb250-26"><a href="#cb250-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-27"><a href="#cb250-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb250-28"><a href="#cb250-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> set_inner<span class="op">()</span> <span class="op">{</span> <span class="va">oss_</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="op">}</span></span>
<span id="cb250-29"><a href="#cb250-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-30"><a href="#cb250-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> TAIL<span class="op">&gt;</span></span>
<span id="cb250-31"><a href="#cb250-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> set_inner<span class="op">(</span>HEAD <span class="at">const</span><span class="op">&amp;</span> head<span class="op">,</span> TAIL <span class="at">const</span><span class="op">&amp;...</span> tails<span class="op">)</span></span>
<span id="cb250-32"><a href="#cb250-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb250-33"><a href="#cb250-33" aria-hidden="true" tabindex="-1"></a>            <span class="kw">using</span> Nstd<span class="op">::</span><span class="kw">operator</span><span class="op">&lt;&lt;;</span>  <span class="co">// Nstd::operator&lt;&lt;もname lookupの対象にする</span></span>
<span id="cb250-34"><a href="#cb250-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-35"><a href="#cb250-35" aria-hidden="true" tabindex="-1"></a>            <span class="va">oss_</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;:&quot;</span> <span class="op">&lt;&lt;</span> head<span class="op">;</span></span>
<span id="cb250-36"><a href="#cb250-36" aria-hidden="true" tabindex="-1"></a>            set_inner<span class="op">(</span>tails<span class="op">...);</span></span>
<span id="cb250-37"><a href="#cb250-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb250-38"><a href="#cb250-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-39"><a href="#cb250-39" aria-hidden="true" tabindex="-1"></a>        Logger<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb250-40"><a href="#cb250-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ostringstream <span class="va">oss_</span><span class="op">{};</span></span>
<span id="cb250-41"><a href="#cb250-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb250-42"><a href="#cb250-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Logging</span></span>
<span id="cb250-43"><a href="#cb250-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-44"><a href="#cb250-44" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define LOGGER_P</span><span class="op">(...)</span><span class="pp"> </span>Logging<span class="op">::</span>Logger<span class="op">::</span>Inst<span class="op">().</span>Set<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span><span class="pp"> </span><span class="ot">__LINE__</span><span class="op">)</span></span>
<span id="cb250-45"><a href="#cb250-45" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define LOGGER</span><span class="op">(...)</span><span class="pp"> </span>Logging<span class="op">::</span>Logger<span class="op">::</span>Inst<span class="op">().</span>Set<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span><span class="pp"> </span><span class="ot">__LINE__</span><span class="op">,</span><span class="pp"> </span><span class="ot">__VA_ARGS__</span><span class="op">)</span></span></code></pre></div>
<p>問題のあったコードとの差分は、メンバ関数テンプレートset_innerの</p>
<div class="sourceCode" id="cb251"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger.h 40</span></span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> Nstd<span class="op">::</span><span class="kw">operator</span><span class="op">&lt;&lt;;</span>  <span class="co">// Nstd::operator&lt;&lt;もname lookupの対象にする</span></span></code></pre></div>
<p>のみである。実際に解決できたことを以下の単体テストで示す。</p>
<div class="sourceCode" id="cb252"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_0_ints_ut.h 8</span></span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ints <span class="op">=</span> App<span class="op">::</span><span class="dt">Ints_t</span><span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb252-4"><a href="#cb252-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-5"><a href="#cb252-5" aria-hidden="true" tabindex="-1"></a>    LOGGER<span class="op">(</span><span class="st">&quot;Ints&quot;</span><span class="op">,</span> ints<span class="op">);</span></span>
<span id="cb252-6"><a href="#cb252-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> line_num <span class="op">=</span> <span class="ot">__LINE__</span><span class="op">;</span></span>
<span id="cb252-7"><a href="#cb252-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-8"><a href="#cb252-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> s <span class="op">=</span> Logging<span class="op">::</span>Logger<span class="op">::</span>InstConst<span class="op">().</span>Get<span class="op">();</span></span>
<span id="cb252-9"><a href="#cb252-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb252-10"><a href="#cb252-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> exp <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span>log_str_exp<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span> line_num <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;:Ints:1, 2, 3</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)};</span></span>
<span id="cb252-11"><a href="#cb252-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>exp<span class="op">,</span> s<span class="op">);</span></span></code></pre></div>
<p>また、</p>
<div class="sourceCode" id="cb253"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/app_ints.h 12</span></span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb253-4"><a href="#cb253-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb253-5"><a href="#cb253-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> X <span class="op">{</span></span>
<span id="cb253-6"><a href="#cb253-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb253-7"><a href="#cb253-7" aria-hidden="true" tabindex="-1"></a>        X<span class="op">(</span><span class="bu">std::</span>string str<span class="op">,</span> <span class="dt">int</span> num<span class="op">)</span> <span class="op">:</span> <span class="va">str_</span><span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>str<span class="op">)},</span> <span class="va">num_</span><span class="op">{</span>num<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb253-8"><a href="#cb253-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string ToString<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">str_</span> <span class="op">+</span> <span class="st">&quot;/&quot;</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span><span class="va">num_</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb253-9"><a href="#cb253-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb253-10"><a href="#cb253-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb253-11"><a href="#cb253-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>のように定義されたクラスも、</p>
<div class="sourceCode" id="cb254"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/app_ints.h 28</span></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> X <span class="at">const</span><span class="op">&amp;</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> os <span class="op">&lt;&lt;</span> x<span class="op">.</span>ToString<span class="op">();</span> <span class="op">}</span></span>
<span id="cb254-6"><a href="#cb254-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>のような型専用のoperator&lt;&lt;があれば、そのオブジェクトのみではなく、
コンテナや配列に対しても下記のようにログ取得が可能となる。</p>
<div class="sourceCode" id="cb255"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/logger_ut.cpp 37</span></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="kw">namespace</span> Nstd<span class="op">;</span></span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-5"><a href="#cb255-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>         x  <span class="op">=</span> App<span class="op">::</span>X<span class="op">{</span><span class="st">&quot;name&quot;</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb255-6"><a href="#cb255-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>         lx <span class="op">=</span> <span class="bu">std::</span>list<span class="op">&lt;</span>App<span class="op">::</span>X<span class="op">&gt;{{</span><span class="st">&quot;lx3&quot;</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="st">&quot;lx4&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">}};</span></span>
<span id="cb255-7"><a href="#cb255-7" aria-hidden="true" tabindex="-1"></a>    App<span class="op">::</span>X <span class="at">const</span> x3<span class="op">[</span><span class="dv">3</span><span class="op">]{{</span><span class="st">&quot;x0&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span> <span class="op">{</span><span class="st">&quot;x1&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="st">&quot;x2&quot;</span><span class="op">,</span> <span class="dv">2</span><span class="op">}};</span></span>
<span id="cb255-8"><a href="#cb255-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-9"><a href="#cb255-9" aria-hidden="true" tabindex="-1"></a>    LOGGER<span class="op">(</span><span class="dv">1</span><span class="op">,</span> x<span class="op">,</span> x3<span class="op">,</span> lx<span class="op">);</span></span>
<span id="cb255-10"><a href="#cb255-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> line_num <span class="op">=</span> <span class="ot">__LINE__</span><span class="op">;</span></span>
<span id="cb255-11"><a href="#cb255-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-12"><a href="#cb255-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> s <span class="op">=</span> Logging<span class="op">::</span>Logger<span class="op">::</span>InstConst<span class="op">().</span>Get<span class="op">();</span></span>
<span id="cb255-13"><a href="#cb255-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-14"><a href="#cb255-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> exp</span>
<span id="cb255-15"><a href="#cb255-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> log_str_exp<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span> line_num <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;:1:name/3:x0/0, x1/1, x2/2:lx3/3, lx4/1</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb255-16"><a href="#cb255-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>exp<span class="op">,</span> s<span class="op">);</span></span></code></pre></div>
<p>「<a
href="template_meta_programming.html#SS_13_2">Nstdライブラリの開発</a>」で示した依存関係も維持されており、
これでログ取得ライブラリは完成したと言って良いだろう。</p>
<h2 id="その他のテンプレートテクニック">その他のテンプレートテクニック
<a id="SS_13_7"></a></h2>
<p>ここでは、これまでの議論の対象にならなかったテンプレートのテクニックや注意点について記述する。</p>
<h3
id="ユニバーサルリファレンスとstdforward">ユニバーサルリファレンスとstd::forward
<a id="SS_13_7_1"></a></h3>
<p>2個の文字列からstd::vector&lt;std::string&gt;を生成する下記のような関数について考える。</p>
<div class="sourceCode" id="cb256"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 9</span></span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> gen_vector<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> s0<span class="op">,</span> <span class="bu">std::</span>string <span class="at">const</span><span class="op">&amp;</span> s1<span class="op">)</span></span>
<span id="cb256-4"><a href="#cb256-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb256-5"><a href="#cb256-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> ret <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{};</span></span>
<span id="cb256-6"><a href="#cb256-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-7"><a href="#cb256-7" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">.</span>push_back<span class="op">(</span>s0<span class="op">);</span></span>
<span id="cb256-8"><a href="#cb256-8" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">.</span>push_back<span class="op">(</span>s1<span class="op">);</span></span>
<span id="cb256-9"><a href="#cb256-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-10"><a href="#cb256-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb256-11"><a href="#cb256-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>これは下記のように動作する。</p>
<div class="sourceCode" id="cb257"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 25</span></span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;a&quot;</span><span class="op">};</span></span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;b&quot;</span><span class="op">};</span></span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-6"><a href="#cb257-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> gen_vector<span class="op">(</span>a<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(</span>b<span class="op">));</span></span>
<span id="cb257-7"><a href="#cb257-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-8"><a href="#cb257-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">((</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">}),</span> v<span class="op">);</span></span>
<span id="cb257-9"><a href="#cb257-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;a&quot;</span><span class="op">,</span> a<span class="op">);</span></span>
<span id="cb257-10"><a href="#cb257-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;b&quot;</span><span class="op">,</span> b<span class="op">);</span>  <span class="co">// bはmoveされない</span></span></code></pre></div>
<p>このコードは正しく動作するものの、move代入できず、パフォーマンス問題を引き起こす可能性があるため、
<a
href="term_explanation.html#SS_19_15_1">ユニバーサルリファレンス</a>を使って下記のように書き直した。</p>
<div class="sourceCode" id="cb258"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 41</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> STR0<span class="op">,</span> <span class="kw">typename</span> STR1<span class="op">&gt;</span></span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> gen_vector<span class="op">(</span>STR0<span class="op">&amp;&amp;</span> s0<span class="op">,</span> STR1<span class="op">&amp;&amp;</span> s1<span class="op">)</span></span>
<span id="cb258-5"><a href="#cb258-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb258-6"><a href="#cb258-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> ret <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{};</span></span>
<span id="cb258-7"><a href="#cb258-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-8"><a href="#cb258-8" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">.</span>push_back<span class="op">(</span>s0<span class="op">);</span></span>
<span id="cb258-9"><a href="#cb258-9" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">.</span>push_back<span class="op">(</span>s1<span class="op">);</span></span>
<span id="cb258-10"><a href="#cb258-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-11"><a href="#cb258-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb258-12"><a href="#cb258-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>残念ながら、このコードは意図したようには動作せず、下記に示した通り相変わらずmove代入ができない。</p>
<div class="sourceCode" id="cb259"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 58</span></span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-3"><a href="#cb259-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;a&quot;</span><span class="op">};</span></span>
<span id="cb259-4"><a href="#cb259-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;b&quot;</span><span class="op">};</span></span>
<span id="cb259-5"><a href="#cb259-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-6"><a href="#cb259-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> gen_vector<span class="op">(</span>a<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(</span>b<span class="op">));</span></span>
<span id="cb259-7"><a href="#cb259-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-8"><a href="#cb259-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">((</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">}),</span> v<span class="op">);</span></span>
<span id="cb259-9"><a href="#cb259-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;a&quot;</span><span class="op">,</span> a<span class="op">);</span></span>
<span id="cb259-10"><a href="#cb259-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;b&quot;</span><span class="op">,</span> b<span class="op">);</span>  <span class="co">// bはmoveされない</span></span></code></pre></div>
<p>この原因は、 「関数が受け取った<a
href="term_explanation.html#SS_19_14_3">rvalue</a>リファレンスは、
その関数から別の関数に受け渡される時に<a
href="term_explanation.html#SS_19_14_2">lvalue</a>リファレンスとして扱われる」からである。</p>
<p>この現象について下記の関数テンプレートを用いて解説を行う。</p>
<div class="sourceCode" id="cb260"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 71</span></span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="kw">class</span> ExpressionType <span class="op">{</span> Lvalue<span class="op">,</span> Rvalue <span class="op">};</span></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-5"><a href="#cb260-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb260-6"><a href="#cb260-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> ExpressionType universal_ref2<span class="op">(</span>T<span class="op">&amp;&amp;</span> t<span class="op">)</span></span>
<span id="cb260-7"><a href="#cb260-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb260-8"><a href="#cb260-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>is_lvalue_reference_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>t<span class="op">)&gt;</span> <span class="op">?</span> ExpressionType<span class="op">::</span>Lvalue</span>
<span id="cb260-9"><a href="#cb260-9" aria-hidden="true" tabindex="-1"></a>                                                       <span class="op">:</span> ExpressionType<span class="op">::</span>Rvalue<span class="op">;</span></span>
<span id="cb260-10"><a href="#cb260-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb260-11"><a href="#cb260-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-12"><a href="#cb260-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::pair&lt;&gt;::first  : universal_refの中のtのExpressionType</span></span>
<span id="cb260-13"><a href="#cb260-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::pair&lt;&gt;::second : universal_ref2の中でtのExpressionType</span></span>
<span id="cb260-14"><a href="#cb260-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb260-15"><a href="#cb260-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="bu">std::</span>pair<span class="op">&lt;</span>ExpressionType<span class="op">,</span> ExpressionType<span class="op">&gt;</span> universal_ref<span class="op">(</span>T<span class="op">&amp;&amp;</span> t<span class="op">)</span></span>
<span id="cb260-16"><a href="#cb260-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb260-17"><a href="#cb260-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>make_pair<span class="op">(</span></span>
<span id="cb260-18"><a href="#cb260-18" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>is_lvalue_reference_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>t<span class="op">)&gt;</span> <span class="op">?</span> ExpressionType<span class="op">::</span>Lvalue <span class="op">:</span> ExpressionType<span class="op">::</span>Rvalue<span class="op">,</span></span>
<span id="cb260-19"><a href="#cb260-19" aria-hidden="true" tabindex="-1"></a>            universal_ref2<span class="op">(</span>t<span class="op">));</span></span>
<span id="cb260-20"><a href="#cb260-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>下記に示した通り、universal_refとuniversal_ref2のパラメータが同じ型であるとは限らない。</p>
<div class="sourceCode" id="cb261"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 96</span></span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-5"><a href="#cb261-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> p <span class="op">=</span> universal_ref<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb261-6"><a href="#cb261-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>universal_ref2<span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> ExpressionType<span class="op">::</span>Lvalue<span class="op">);</span>            <span class="co">// iはlvalue</span></span>
<span id="cb261-7"><a href="#cb261-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>p<span class="op">.</span>first <span class="op">==</span> ExpressionType<span class="op">::</span>Lvalue<span class="op">);</span>                      <span class="co">// universal_refの引数はlvalue</span></span>
<span id="cb261-8"><a href="#cb261-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>p<span class="op">.</span>second <span class="op">==</span> ExpressionType<span class="op">::</span>Lvalue<span class="op">);</span>                     <span class="co">// universal_ref中のuniversal_ref2の引数はlvalue</span></span>
<span id="cb261-9"><a href="#cb261-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-10"><a href="#cb261-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> pm <span class="op">=</span> universal_ref<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>i<span class="op">));</span>                       <span class="co">// universal_refの引数はrvalue</span></span>
<span id="cb261-11"><a href="#cb261-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>universal_ref2<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>i<span class="op">))</span> <span class="op">==</span> ExpressionType<span class="op">::</span>Rvalue<span class="op">);</span> <span class="co">// universal_ref2の引数はrvalue</span></span>
<span id="cb261-12"><a href="#cb261-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>pm<span class="op">.</span>first <span class="op">==</span> ExpressionType<span class="op">::</span>Rvalue<span class="op">);</span>                     <span class="co">// universal_refの引数はrvalue</span></span>
<span id="cb261-13"><a href="#cb261-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>pm<span class="op">.</span>second <span class="op">==</span> ExpressionType<span class="op">::</span>Lvalue<span class="op">);</span>                    <span class="co">// universal_ref中のuniversal_ref2の引数はrvalue</span></span>
<span id="cb261-14"><a href="#cb261-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-15"><a href="#cb261-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> pm2 <span class="op">=</span> universal_ref<span class="op">(</span><span class="dt">int</span><span class="op">{});</span></span>
<span id="cb261-16"><a href="#cb261-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>universal_ref2<span class="op">(</span><span class="dt">int</span><span class="op">{})</span> <span class="op">==</span> ExpressionType<span class="op">::</span>Rvalue<span class="op">);</span>        <span class="co">// universal_ref2の引数はrvalue</span></span>
<span id="cb261-17"><a href="#cb261-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>pm2<span class="op">.</span>first <span class="op">==</span> ExpressionType<span class="op">::</span>Rvalue<span class="op">);</span>                    <span class="co">// universal_refの引数はrvalue</span></span>
<span id="cb261-18"><a href="#cb261-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>pm2<span class="op">.</span>second <span class="op">==</span> ExpressionType<span class="op">::</span>Lvalue<span class="op">);</span>                   <span class="co">// universal_ref中のuniversal_ref2の引数はrvalue</span></span></code></pre></div>
<p>この問題はstd::forwardにより対処できる。これによって改良されたコードを下記に示す。</p>
<div class="sourceCode" id="cb262"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 124</span></span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-3"><a href="#cb262-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> STR0<span class="op">,</span> <span class="kw">typename</span> STR1<span class="op">&gt;</span></span>
<span id="cb262-4"><a href="#cb262-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> gen_vector<span class="op">(</span>STR0<span class="op">&amp;&amp;</span> s0<span class="op">,</span> STR1<span class="op">&amp;&amp;</span> s1<span class="op">)</span></span>
<span id="cb262-5"><a href="#cb262-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb262-6"><a href="#cb262-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> ret <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{};</span></span>
<span id="cb262-7"><a href="#cb262-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-8"><a href="#cb262-8" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>STR0<span class="op">&gt;(</span>s0<span class="op">));</span></span>
<span id="cb262-9"><a href="#cb262-9" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>STR1<span class="op">&gt;(</span>s1<span class="op">));</span></span>
<span id="cb262-10"><a href="#cb262-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-11"><a href="#cb262-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb262-12"><a href="#cb262-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>下記単体テストが示す通り、rvalueリファレンスはmove代入され、lvalueリファレンスはcopy代入されている。</p>
<div class="sourceCode" id="cb263"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 142</span></span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;a&quot;</span><span class="op">};</span></span>
<span id="cb263-4"><a href="#cb263-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;b&quot;</span><span class="op">};</span></span>
<span id="cb263-5"><a href="#cb263-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-6"><a href="#cb263-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> gen_vector<span class="op">(</span>a<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(</span>b<span class="op">));</span></span>
<span id="cb263-7"><a href="#cb263-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-8"><a href="#cb263-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">((</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">}),</span> v<span class="op">);</span></span>
<span id="cb263-9"><a href="#cb263-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;a&quot;</span><span class="op">,</span> a<span class="op">);</span></span>
<span id="cb263-10"><a href="#cb263-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">,</span> b<span class="op">);</span>  <span class="co">// bはmoveされた</span></span></code></pre></div>
<p>しかし残念ながら、このコードにも改良すべき点がある。</p>
<div class="sourceCode" id="cb264"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 155</span></span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;a&quot;</span><span class="op">};</span></span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-5"><a href="#cb264-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> gen_vector<span class="op">(</span>a<span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">);</span></span>
<span id="cb264-6"><a href="#cb264-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-7"><a href="#cb264-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">((</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">}),</span> v<span class="op">);</span></span>
<span id="cb264-8"><a href="#cb264-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;a&quot;</span><span class="op">,</span> a<span class="op">);</span></span></code></pre></div>
<p>上記の”b”のような文字列リテラルを引数にした場合、
それをstd::vector&lt;std::string&gt;::push_backに渡した時に、
“b”はテンポラリオブジェクトstd::string(“b”)のに変換されてしまう。
std::vector&lt;std::string&gt;へのオブジェクトの挿入は、文字列リテラルから行うことが出来るため、
このテンポラリオブジェクトの生成は明らかに不要な処理である。</p>
<p>下記は、この対策を施すとともに任意の数の引数を受け取れるように改良したコードである。</p>
<div class="sourceCode" id="cb265"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 171</span></span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> emplace_back<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;&amp;)</span> <span class="op">{}</span></span>
<span id="cb265-4"><a href="#cb265-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-5"><a href="#cb265-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> HEAD<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> TAIL<span class="op">&gt;</span></span>
<span id="cb265-6"><a href="#cb265-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> emplace_back<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;&amp;</span> strs<span class="op">,</span> HEAD<span class="op">&amp;&amp;</span> head<span class="op">,</span> TAIL<span class="op">&amp;&amp;...</span> tails<span class="op">)</span></span>
<span id="cb265-7"><a href="#cb265-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb265-8"><a href="#cb265-8" aria-hidden="true" tabindex="-1"></a>        strs<span class="op">.</span>emplace_back<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>HEAD<span class="op">&gt;(</span>head<span class="op">));</span></span>
<span id="cb265-9"><a href="#cb265-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-10"><a href="#cb265-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="kw">sizeof</span><span class="op">...(</span>tails<span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb265-11"><a href="#cb265-11" aria-hidden="true" tabindex="-1"></a>            emplace_back<span class="op">(</span>strs<span class="op">,</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>TAIL<span class="op">&gt;(</span>tails<span class="op">)...);</span></span>
<span id="cb265-12"><a href="#cb265-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb265-13"><a href="#cb265-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb265-14"><a href="#cb265-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-15"><a href="#cb265-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> STR<span class="op">&gt;</span></span>
<span id="cb265-16"><a href="#cb265-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> gen_vector<span class="op">(</span>STR<span class="op">&amp;&amp;...</span> ss<span class="op">)</span></span>
<span id="cb265-17"><a href="#cb265-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb265-18"><a href="#cb265-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> ret <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{};</span></span>
<span id="cb265-19"><a href="#cb265-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-20"><a href="#cb265-20" aria-hidden="true" tabindex="-1"></a>        emplace_back<span class="op">(</span>ret<span class="op">,</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>STR<span class="op">&gt;(</span>ss<span class="op">)...);</span></span>
<span id="cb265-21"><a href="#cb265-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-22"><a href="#cb265-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb265-23"><a href="#cb265-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>上記の</p>
<div class="sourceCode" id="cb266"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">sizeof</span><span class="op">...(</span>tails<span class="op">)</span></span></code></pre></div>
<p>はパラメータパックの個数を受け取るための記法である。
従ってこのコードではすべてのパラメータパック変数を消費するまでリカーシブコールを続けることになる
(が、このリカーシブコールはコンパイル時に行われるため、実行時の速度低下は起こさない)。</p>
<p>上記の</p>
<div class="sourceCode" id="cb267"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>forward<span class="op">&lt;</span>TAIL<span class="op">&gt;(</span>tails<span class="op">)...</span></span></code></pre></div>
<p>は、それぞれのパラメータパック変数をstd::forwardに渡した戻り値を、
再びパラメータパックにするための記法である。</p>
<p>このコードは下記の単体テストが示すように正しく動作する
(が、残念ならがテンポラリオブジェクトが生成されていないことを単体テストで証明することはできない)。</p>
<div class="sourceCode" id="cb268"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 197</span></span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> a <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;a&quot;</span><span class="op">};</span></span>
<span id="cb268-4"><a href="#cb268-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> b <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;b&quot;</span><span class="op">};</span></span>
<span id="cb268-5"><a href="#cb268-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-6"><a href="#cb268-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> gen_vector<span class="op">(</span>a<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(</span>b<span class="op">),</span> <span class="st">&quot;c&quot;</span><span class="op">);</span></span>
<span id="cb268-7"><a href="#cb268-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-8"><a href="#cb268-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">((</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">,</span> <span class="st">&quot;c&quot;</span><span class="op">}),</span> v<span class="op">);</span></span>
<span id="cb268-9"><a href="#cb268-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;a&quot;</span><span class="op">,</span> a<span class="op">);</span></span>
<span id="cb268-10"><a href="#cb268-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">,</span> b<span class="op">);</span>  <span class="co">// bはmoveされた</span></span></code></pre></div>
<p>上記のgen_vectorはリカーシブコールを使って実装したが、 <a
href="term_explanation.html#SS_19_11_3">畳み込み式</a>を使用した下記の実装の方がより明確である。</p>
<div class="sourceCode" id="cb269"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 211</span></span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb269-3"><a href="#cb269-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> STR<span class="op">&gt;</span></span>
<span id="cb269-4"><a href="#cb269-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> gen_vector<span class="op">(</span>STR<span class="op">&amp;&amp;...</span> ss<span class="op">)</span></span>
<span id="cb269-5"><a href="#cb269-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb269-6"><a href="#cb269-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> ret <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{};</span></span>
<span id="cb269-7"><a href="#cb269-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb269-8"><a href="#cb269-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>ret<span class="op">.</span>emplace_back<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>STR<span class="op">&gt;(</span>ss<span class="op">)),</span> <span class="op">...);</span></span>
<span id="cb269-9"><a href="#cb269-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb269-10"><a href="#cb269-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb269-11"><a href="#cb269-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>ユニバーサルリファレンスはconstにすることができないが (T
const&amp;&amp;はconstな<a
href="term_explanation.html#SS_19_14_3">rvalue</a>リファレンスである)、
ユニバーサルリファレンスが<a
href="term_explanation.html#SS_19_14_2">lvalue</a>リファレンスであった場合は、
constなlvalueリファレンスとして扱うべきである。</p>
<p>従って、下記のようなコードは書くべきではない。</p>
<div class="sourceCode" id="cb270"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 240</span></span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> STR0<span class="op">,</span> <span class="kw">typename</span> STR1<span class="op">&gt;</span></span>
<span id="cb270-4"><a href="#cb270-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> gen_vector<span class="op">(</span>STR0<span class="op">&amp;&amp;</span> s0<span class="op">,</span> STR1<span class="op">&amp;&amp;</span> s1<span class="op">)</span></span>
<span id="cb270-5"><a href="#cb270-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb270-6"><a href="#cb270-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> ret <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{};</span></span>
<span id="cb270-7"><a href="#cb270-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-8"><a href="#cb270-8" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s0<span class="op">));</span></span>
<span id="cb270-9"><a href="#cb270-9" aria-hidden="true" tabindex="-1"></a>        ret<span class="op">.</span>push_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s1<span class="op">));</span></span>
<span id="cb270-10"><a href="#cb270-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb270-11"><a href="#cb270-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb270-12"><a href="#cb270-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>もしそのようにしてしまえば、
下記単体テストが示すように非constな実引数はmoveされてしまうことになる。</p>
<div class="sourceCode" id="cb271"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 257</span></span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>       a <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;a&quot;</span><span class="op">};</span></span>
<span id="cb271-4"><a href="#cb271-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="at">const</span> b <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;b&quot;</span><span class="op">};</span></span>
<span id="cb271-5"><a href="#cb271-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-6"><a href="#cb271-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> gen_vector<span class="op">(</span>a<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(</span>b<span class="op">));</span></span>
<span id="cb271-7"><a href="#cb271-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-8"><a href="#cb271-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">((</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;{</span><span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">}),</span> v<span class="op">);</span></span>
<span id="cb271-9"><a href="#cb271-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">,</span> a<span class="op">);</span>   <span class="co">// aはmoveされてしまう</span></span>
<span id="cb271-10"><a href="#cb271-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;b&quot;</span><span class="op">,</span> b<span class="op">);</span>  <span class="co">// bはconstなのでmoveされない</span></span></code></pre></div>
<p>任意の型Tのrvalueのみを引数に取る関数テンプレートを下記のように記述した場合、
すでに述べたように引数はユニバーサルリファレンスとなってしまうため、lvalueにもバインドしてしまう。</p>
<div class="sourceCode" id="cb272"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 273</span></span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-3"><a href="#cb272-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb272-4"><a href="#cb272-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span>T<span class="op">&amp;&amp;</span> t<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb272-5"><a href="#cb272-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb272-6"><a href="#cb272-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb272-7"><a href="#cb272-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>このような場合、下記の記述が必要になる。</p>
<div class="sourceCode" id="cb273"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 292</span></span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span>T<span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span></code></pre></div>
<p>この効果により、下記に示した通りlvalueにはバインドできなくなり、
当初の目的通り、rvalueのみを引数に取る関数テンプレートが定義できたことになる。</p>
<div class="sourceCode" id="cb274"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/universal_ref_ut.cpp 300</span></span>
<span id="cb274-2"><a href="#cb274-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-3"><a href="#cb274-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> s <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{};</span></span>
<span id="cb274-4"><a href="#cb274-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-5"><a href="#cb274-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// f(s);           // f(std::string&amp;)はdeleteされたため、コンパイルエラー</span></span>
<span id="cb274-6"><a href="#cb274-6" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(</span><span class="bu">std::</span>string<span class="op">{});</span>  <span class="co">// f(std::string&amp;&amp;)にはバインドできる</span></span></code></pre></div>
<p>なお、ユニバーサルリファレンスは、<a
href="term_explanation.html#SS_19_15_4">リファレンスcollapsing</a>の一機能としても理解できる。</p>
<h3
id="ジェネリックラムダによる関数内での関数テンプレートの定義">ジェネリックラムダによる関数内での関数テンプレートの定義
<a id="SS_13_7_2"></a></h3>
<p>下記のようなクラスとoperator&lt;&lt;があった場合を考える。</p>
<div class="sourceCode" id="cb275"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/generic_lambda_ut.cpp 13</span></span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> XYZ <span class="op">{</span></span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a>        XYZ<span class="op">(</span><span class="dt">int</span> ax<span class="op">,</span> <span class="dt">int</span> ay<span class="op">,</span> <span class="dt">int</span> az<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> x<span class="op">{</span>ax<span class="op">},</span> y<span class="op">{</span>ay<span class="op">},</span> z<span class="op">{</span>az<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb275-6"><a href="#cb275-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb275-7"><a href="#cb275-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> z<span class="op">;</span></span>
<span id="cb275-8"><a href="#cb275-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb275-9"><a href="#cb275-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-10"><a href="#cb275-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> XYZ <span class="at">const</span><span class="op">&amp;</span> xyz<span class="op">)</span></span>
<span id="cb275-11"><a href="#cb275-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb275-12"><a href="#cb275-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>to_string<span class="op">(</span>xyz<span class="op">.</span>x<span class="op">)</span> <span class="op">+</span> <span class="st">&quot;/&quot;</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span>xyz<span class="op">.</span>y<span class="op">)</span> <span class="op">+</span> <span class="st">&quot;/&quot;</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span>xyz<span class="op">.</span>z<span class="op">);</span></span>
<span id="cb275-13"><a href="#cb275-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>「<a
href="template_meta_programming.html#SS_13_4_2">Nstd::SafeIndexの開発</a>」や「<a
href="template_meta_programming.html#SS_13_4_4">コンテナ用Nstd::operator&lt;&lt;の開発</a>」
の成果物との組み合わせの単体テストは下記のように書けるだろう。</p>
<div class="sourceCode" id="cb276"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/generic_lambda_ut.cpp 31</span></span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v   <span class="op">=</span> Nstd<span class="op">::</span>SafeVector<span class="op">&lt;</span>XYZ<span class="op">&gt;{{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">7</span><span class="op">},</span> <span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">}};</span></span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb276-5"><a href="#cb276-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-6"><a href="#cb276-6" aria-hidden="true" tabindex="-1"></a>    oss <span class="op">&lt;&lt;</span> v<span class="op">;</span></span>
<span id="cb276-7"><a href="#cb276-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;9/8/7, 6/5/4, 3/2/1, 0/1/2&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span></code></pre></div>
<p>std::sortによるソートができるかどうかのテストは、C++11までは、</p>
<div class="sourceCode" id="cb277"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/generic_lambda_ut.cpp 41</span></span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-3"><a href="#cb277-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> Nstd<span class="op">::</span>SafeVector<span class="op">&lt;</span>XYZ<span class="op">&gt;{{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">7</span><span class="op">},</span> <span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">}};</span></span>
<span id="cb277-4"><a href="#cb277-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-5"><a href="#cb277-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// C++11 lambda                  型の明示が必要</span></span>
<span id="cb277-6"><a href="#cb277-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//                               ↓               ↓</span></span>
<span id="cb277-7"><a href="#cb277-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span>XYZ <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> XYZ <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb277-8"><a href="#cb277-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>tie<span class="op">(</span>lhs<span class="op">.</span>x<span class="op">,</span> lhs<span class="op">.</span>y<span class="op">,</span> lhs<span class="op">.</span>z<span class="op">)</span> <span class="op">&lt;</span> <span class="bu">std::</span>tie<span class="op">(</span>rhs<span class="op">.</span>x<span class="op">,</span> rhs<span class="op">.</span>y<span class="op">,</span> rhs<span class="op">.</span>z<span class="op">);</span></span>
<span id="cb277-9"><a href="#cb277-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb277-10"><a href="#cb277-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb277-11"><a href="#cb277-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-12"><a href="#cb277-12" aria-hidden="true" tabindex="-1"></a>    oss <span class="op">&lt;&lt;</span> v<span class="op">;</span></span>
<span id="cb277-13"><a href="#cb277-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;0/1/2, 3/2/1, 6/5/4, 9/8/7&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span></code></pre></div>
<p>のように書くのが一般的だろう。ラムダ式の引数の型を指定しなければならないのは、
範囲for文でautoが使用出来ること等と比べると見劣りがするが、
C++14からは下記のコードで示した通り引数にautoが使えるようになった。</p>
<div class="sourceCode" id="cb278"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/generic_lambda_ut.cpp 57</span></span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-3"><a href="#cb278-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> Nstd<span class="op">::</span>SafeVector<span class="op">&lt;</span>XYZ<span class="op">&gt;{{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">7</span><span class="op">},</span> <span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">}};</span></span>
<span id="cb278-4"><a href="#cb278-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-5"><a href="#cb278-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// C++14 generic lambda          型の明示が不要</span></span>
<span id="cb278-6"><a href="#cb278-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//                               ↓                ↓</span></span>
<span id="cb278-7"><a href="#cb278-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> <span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb278-8"><a href="#cb278-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>tie<span class="op">(</span>lhs<span class="op">.</span>x<span class="op">,</span> lhs<span class="op">.</span>y<span class="op">,</span> lhs<span class="op">.</span>z<span class="op">)</span> <span class="op">&lt;</span> <span class="bu">std::</span>tie<span class="op">(</span>rhs<span class="op">.</span>x<span class="op">,</span> rhs<span class="op">.</span>y<span class="op">,</span> rhs<span class="op">.</span>z<span class="op">);</span></span>
<span id="cb278-9"><a href="#cb278-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb278-10"><a href="#cb278-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb278-11"><a href="#cb278-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-12"><a href="#cb278-12" aria-hidden="true" tabindex="-1"></a>    oss <span class="op">&lt;&lt;</span> v<span class="op">;</span></span>
<span id="cb278-13"><a href="#cb278-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;0/1/2, 3/2/1, 6/5/4, 9/8/7&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span></code></pre></div>
<p>この記法は<a
href="term_explanation.html#SS_19_11_4">ジェネリックラムダ</a>と呼ばれる。
この機能により関数の中で関数テンプレートと同等のものが定義できるようになった。</p>
<h4 id="ジェネリックラムダの内部構造">ジェネリックラムダの内部構造
<a id="SS_13_7_2_1"></a></h4>
<p>ジェネリックラムダは下記のように使用することができる。</p>
<div class="sourceCode" id="cb279"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/generic_lambda_ut.cpp 73</span></span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> PUTTO<span class="op">&gt;</span></span>
<span id="cb279-4"><a href="#cb279-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span>PUTTO<span class="op">&amp;&amp;</span> p<span class="op">)</span></span>
<span id="cb279-5"><a href="#cb279-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb279-6"><a href="#cb279-6" aria-hidden="true" tabindex="-1"></a>        p<span class="op">(</span><span class="dv">1</span><span class="op">);</span>       <span class="co">// ラムダの引数elemの型はint</span></span>
<span id="cb279-7"><a href="#cb279-7" aria-hidden="true" tabindex="-1"></a>        p<span class="op">(</span><span class="fl">2.71</span><span class="op">);</span>    <span class="co">// ラムダの引数elemは型はdouble</span></span>
<span id="cb279-8"><a href="#cb279-8" aria-hidden="true" tabindex="-1"></a>        p<span class="op">(</span><span class="st">&quot;hehe&quot;</span><span class="op">);</span>  <span class="co">// ラムダの引数elemは型はchar [5]</span></span>
<span id="cb279-9"><a href="#cb279-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb279-10"><a href="#cb279-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-11"><a href="#cb279-11" aria-hidden="true" tabindex="-1"></a>    TEST<span class="op">(</span>Template<span class="op">,</span> generic_lambda<span class="op">)</span></span>
<span id="cb279-12"><a href="#cb279-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb279-13"><a href="#cb279-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb279-14"><a href="#cb279-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-15"><a href="#cb279-15" aria-hidden="true" tabindex="-1"></a>        f<span class="op">([&amp;</span>oss<span class="op">](</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> elem<span class="op">)</span> <span class="op">{</span> oss <span class="op">&lt;&lt;</span> elem <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span> <span class="op">});</span></span>
<span id="cb279-16"><a href="#cb279-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-17"><a href="#cb279-17" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;1</span><span class="sc">\n</span><span class="st">2.71</span><span class="sc">\n</span><span class="st">hehe</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb279-18"><a href="#cb279-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>この例で使用しているクロージャは一見、型をダイナミックに扱っているように見えるが、
下記のような「テンプレートoperator()を持つ関数型」オブジェクトとして展開されていると考えれば、
理解できる。</p>
<div class="sourceCode" id="cb280"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/generic_lambda_ut.cpp 92</span></span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-3"><a href="#cb280-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Closure <span class="op">{</span></span>
<span id="cb280-4"><a href="#cb280-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb280-5"><a href="#cb280-5" aria-hidden="true" tabindex="-1"></a>        Closure<span class="op">(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">)</span> <span class="op">:</span> <span class="va">os_</span><span class="op">{</span>os<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb280-6"><a href="#cb280-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-7"><a href="#cb280-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb280-8"><a href="#cb280-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>T<span class="op">&amp;&amp;</span> t<span class="op">)</span></span>
<span id="cb280-9"><a href="#cb280-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb280-10"><a href="#cb280-10" aria-hidden="true" tabindex="-1"></a>            <span class="va">os_</span> <span class="op">&lt;&lt;</span> t <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb280-11"><a href="#cb280-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb280-12"><a href="#cb280-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-13"><a href="#cb280-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb280-14"><a href="#cb280-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="va">os_</span><span class="op">;</span></span>
<span id="cb280-15"><a href="#cb280-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb281"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/generic_lambda_ut.cpp 111</span></span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb281-4"><a href="#cb281-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-5"><a href="#cb281-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> closure <span class="op">=</span> Closure<span class="op">{</span>oss<span class="op">};</span></span>
<span id="cb281-6"><a href="#cb281-6" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(</span>closure<span class="op">);</span></span>
<span id="cb281-7"><a href="#cb281-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb281-8"><a href="#cb281-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;1</span><span class="sc">\n</span><span class="st">2.71</span><span class="sc">\n</span><span class="st">hehe</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span></code></pre></div>
<h4 id="stdvariantとジェネリックラムダ">std::variantとジェネリックラムダ
<a id="SS_13_7_2_2"></a></h4>
<p>unionは、オブジェクトを全く無関係な複数の型に切り替えることができるため、
これが必要な場面では有用な機能であるが、未定義動作を誘発してしまう問題がある。
この対策としてC++17で導入されたものが、std::variantである。</p>
<p>まずは、std::variantの使用例を下記する。</p>
<div class="sourceCode" id="cb282"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/variant_ut.cpp 13</span></span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-3"><a href="#cb282-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> <span class="bu">std::</span>variant<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="dt">double</span><span class="op">&gt;{};</span>  <span class="co">// 3つの型を切り替える</span></span>
<span id="cb282-4"><a href="#cb282-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-5"><a href="#cb282-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::get&lt;N&gt;()の戻り値型は、下記の通りで、</span></span>
<span id="cb282-6"><a href="#cb282-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// N == 0, 1, 2 は、それぞれint, std::string, doubleに対応</span></span>
<span id="cb282-7"><a href="#cb282-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>v<span class="op">)),</span> <span class="dt">int</span><span class="op">&amp;&gt;);</span></span>
<span id="cb282-8"><a href="#cb282-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>v<span class="op">)),</span> <span class="bu">std::</span>string<span class="op">&amp;&gt;);</span></span>
<span id="cb282-9"><a href="#cb282-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;(</span>v<span class="op">)),</span> <span class="dt">double</span><span class="op">&amp;&gt;);</span></span>
<span id="cb282-10"><a href="#cb282-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-11"><a href="#cb282-11" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> <span class="dt">int</span><span class="op">{</span><span class="dv">3</span><span class="op">};</span>  <span class="co">// int型の3を代入</span></span>
<span id="cb282-12"><a href="#cb282-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-13"><a href="#cb282-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>v<span class="op">.</span>index<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span>                                <span class="co">// intを保持</span></span>
<span id="cb282-14"><a href="#cb282-14" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>v<span class="op">),</span> <span class="dv">3</span><span class="op">);</span>                           <span class="co">// intなので問題なくアクセス</span></span>
<span id="cb282-15"><a href="#cb282-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>v<span class="op">),</span> <span class="bu">std::</span>bad_variant_access<span class="op">);</span>  <span class="co">// std::stringではないのでエクセプション</span></span>
<span id="cb282-16"><a href="#cb282-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;(</span>v<span class="op">),</span> <span class="bu">std::</span>bad_variant_access<span class="op">);</span>  <span class="co">// doubleではないのでエクセプション</span></span>
<span id="cb282-17"><a href="#cb282-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-18"><a href="#cb282-18" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;str&quot;</span><span class="op">};</span>  <span class="co">// std::stringオブジェクトを代入</span></span>
<span id="cb282-19"><a href="#cb282-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-20"><a href="#cb282-20" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>v<span class="op">.</span>index<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span>                                <span class="co">// std::stringを保持</span></span>
<span id="cb282-21"><a href="#cb282-21" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>v<span class="op">),</span> <span class="bu">std::</span>bad_variant_access<span class="op">);</span>  <span class="co">// intではないのでエクセプション</span></span>
<span id="cb282-22"><a href="#cb282-22" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>v<span class="op">),</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;str&quot;</span><span class="op">});</span>  <span class="co">// std::stringなので問題なくアクセス</span></span>
<span id="cb282-23"><a href="#cb282-23" aria-hidden="true" tabindex="-1"></a>    ASSERT_THROW<span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;(</span>v<span class="op">),</span> <span class="bu">std::</span>bad_variant_access<span class="op">);</span>  <span class="co">// doubleではないのでエクセプション</span></span></code></pre></div>
<p>上記からわかる通り、std::variantオブジェクトは、直前に代入されたオブジェクトの型以外で、
値を読み出した場合、問題なく読み出せるが、それ以外ではエクセプションを発生させる。</p>
<p>このstd::variantオブジェクトの保持する型とその値を文字列として取り出すラムダ式は、
下記のように書ける。</p>
<div class="sourceCode" id="cb283"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/variant_ut.cpp 37</span></span>
<span id="cb283-2"><a href="#cb283-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb283-3"><a href="#cb283-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb283-4"><a href="#cb283-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb283-5"><a href="#cb283-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// type_valueはvが保持する型をその値を文字列で返す</span></span>
<span id="cb283-6"><a href="#cb283-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> type_value <span class="op">=</span> <span class="op">[&amp;</span>oss<span class="op">](</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span>  <span class="co">// ジェネリックラムダでなくても実装可能</span></span>
<span id="cb283-7"><a href="#cb283-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>index<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb283-8"><a href="#cb283-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> a  <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>v<span class="op">);</span></span>
<span id="cb283-9"><a href="#cb283-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">using</span> T <span class="op">=</span> <span class="bu">std::</span>remove_const_t<span class="op">&lt;</span><span class="bu">std::</span>remove_reference_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">)&gt;&gt;;</span></span>
<span id="cb283-10"><a href="#cb283-10" aria-hidden="true" tabindex="-1"></a>            oss <span class="op">&lt;&lt;</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; : &quot;</span> <span class="op">&lt;&lt;</span> a<span class="op">;</span>  <span class="co">// Nstd::Type2Str&lt;T&gt;はTの型を文字列にする</span></span>
<span id="cb283-11"><a href="#cb283-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb283-12"><a href="#cb283-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>index<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb283-13"><a href="#cb283-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> a  <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>v<span class="op">);</span></span>
<span id="cb283-14"><a href="#cb283-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">using</span> T <span class="op">=</span> <span class="bu">std::</span>remove_const_t<span class="op">&lt;</span><span class="bu">std::</span>remove_reference_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">)&gt;&gt;;</span></span>
<span id="cb283-15"><a href="#cb283-15" aria-hidden="true" tabindex="-1"></a>            oss <span class="op">&lt;&lt;</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; : &quot;</span> <span class="op">&lt;&lt;</span> a<span class="op">;</span>  <span class="co">// Nstd::Type2Str&lt;T&gt;はTの型を文字列にする</span></span>
<span id="cb283-16"><a href="#cb283-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb283-17"><a href="#cb283-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>index<span class="op">()</span> <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb283-18"><a href="#cb283-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> a  <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;(</span>v<span class="op">);</span></span>
<span id="cb283-19"><a href="#cb283-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">using</span> T <span class="op">=</span> <span class="bu">std::</span>remove_const_t<span class="op">&lt;</span><span class="bu">std::</span>remove_reference_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">)&gt;&gt;;</span></span>
<span id="cb283-20"><a href="#cb283-20" aria-hidden="true" tabindex="-1"></a>            oss <span class="op">&lt;&lt;</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; : &quot;</span> <span class="op">&lt;&lt;</span> a<span class="op">;</span>  <span class="co">// Nstd::Type2Str&lt;T&gt;はTの型を文字列にする</span></span>
<span id="cb283-21"><a href="#cb283-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb283-22"><a href="#cb283-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb283-23"><a href="#cb283-23" aria-hidden="true" tabindex="-1"></a>            <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span>  <span class="co">// ここには来ないはず</span></span>
<span id="cb283-24"><a href="#cb283-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb283-25"><a href="#cb283-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb283-26"><a href="#cb283-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb283-27"><a href="#cb283-27" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>  <span class="co">// int型の3を代入</span></span>
<span id="cb283-28"><a href="#cb283-28" aria-hidden="true" tabindex="-1"></a>    type_value<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb283-29"><a href="#cb283-29" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;int : 3&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb283-30"><a href="#cb283-30" aria-hidden="true" tabindex="-1"></a>    oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span>  <span class="co">// ossのリセット</span></span>
<span id="cb283-31"><a href="#cb283-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb283-32"><a href="#cb283-32" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span><span class="st">&quot;str&quot;</span><span class="op">};</span>  <span class="co">// std::stringオブジェクトを代入</span></span>
<span id="cb283-33"><a href="#cb283-33" aria-hidden="true" tabindex="-1"></a>    type_value<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb283-34"><a href="#cb283-34" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;std::string : str&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb283-35"><a href="#cb283-35" aria-hidden="true" tabindex="-1"></a>    oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span>  <span class="co">// ossのリセット</span></span>
<span id="cb283-36"><a href="#cb283-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb283-37"><a href="#cb283-37" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> <span class="fl">1.1</span><span class="op">;</span>  <span class="co">// double型の1.1を代入</span></span>
<span id="cb283-38"><a href="#cb283-38" aria-hidden="true" tabindex="-1"></a>    type_value<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb283-39"><a href="#cb283-39" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;double : 1.1&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span></code></pre></div>
<p>このラムダは、
3つの型をテンプレートパラメータとするstd::variantオブジェクト以外には適用できないため、
型の個数に制限のない方法を考える。</p>
<p>この実装は、</p>
<ul>
<li>保持する型が何番目かを見つけるための関数テンプレート</li>
<li>関数テンプレートの引数となるジェネリックラムダ</li>
</ul>
<p>の2つによって下記のように行うことができる。</p>
<div class="sourceCode" id="cb284"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/variant_ut.cpp 79</span></span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb284-3"><a href="#cb284-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> VARIANT<span class="op">,</span> <span class="kw">typename</span> F<span class="op">,</span> <span class="dt">size_t</span> INDEX <span class="op">=</span> <span class="dv">0</span><span class="op">&gt;</span></span>
<span id="cb284-4"><a href="#cb284-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> org_visit<span class="op">(</span><span class="at">const</span> F<span class="op">&amp;</span> f<span class="op">,</span> <span class="at">const</span> VARIANT<span class="op">&amp;</span> v<span class="op">)</span></span>
<span id="cb284-5"><a href="#cb284-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb284-6"><a href="#cb284-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">auto</span> n <span class="op">=</span> <span class="bu">std::</span>variant_size_v<span class="op">&lt;</span>VARIANT<span class="op">&gt;;</span></span>
<span id="cb284-7"><a href="#cb284-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb284-8"><a href="#cb284-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>INDEX <span class="op">&lt;</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb284-9"><a href="#cb284-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>v<span class="op">.</span>index<span class="op">()</span> <span class="op">==</span> INDEX<span class="op">)</span> <span class="op">{</span>  <span class="co">// 保持する型が見つかった</span></span>
<span id="cb284-10"><a href="#cb284-10" aria-hidden="true" tabindex="-1"></a>                f<span class="op">(</span><span class="bu">std::</span>get<span class="op">&lt;</span>INDEX<span class="op">&gt;(</span>v<span class="op">));</span></span>
<span id="cb284-11"><a href="#cb284-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span><span class="op">;</span></span>
<span id="cb284-12"><a href="#cb284-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb284-13"><a href="#cb284-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="op">{</span>  <span class="co">// 保持する型が見つかるまでリカーシブ</span></span>
<span id="cb284-14"><a href="#cb284-14" aria-hidden="true" tabindex="-1"></a>                org_visit<span class="op">&lt;</span>VARIANT<span class="op">,</span> F<span class="op">,</span> INDEX <span class="op">+</span> <span class="dv">1</span><span class="op">&gt;(</span>f<span class="op">,</span> v<span class="op">);</span></span>
<span id="cb284-15"><a href="#cb284-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb284-16"><a href="#cb284-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb284-17"><a href="#cb284-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb284-18"><a href="#cb284-18" aria-hidden="true" tabindex="-1"></a>            <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span>  <span class="co">// ここには来ないはず</span></span>
<span id="cb284-19"><a href="#cb284-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb284-20"><a href="#cb284-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb285"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/variant_ut.cpp 103</span></span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-3"><a href="#cb285-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb285-4"><a href="#cb285-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-5"><a href="#cb285-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 文字列を返すためのジェネリックラムダ</span></span>
<span id="cb285-6"><a href="#cb285-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> type_value <span class="op">=</span> <span class="op">[&amp;</span>oss<span class="op">](</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb285-7"><a href="#cb285-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> T <span class="op">=</span> <span class="bu">std::</span>remove_const_t<span class="op">&lt;</span><span class="bu">std::</span>remove_reference_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>a<span class="op">)&gt;&gt;;</span></span>
<span id="cb285-8"><a href="#cb285-8" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">&lt;&lt;</span> <span class="st">&quot; : &quot;</span> <span class="op">&lt;&lt;</span> a<span class="op">;</span></span>
<span id="cb285-9"><a href="#cb285-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>単体テストは、以下のようになる。</p>
<div class="sourceCode" id="cb286"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/variant_ut.cpp 113</span></span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> v <span class="op">=</span> <span class="bu">std::</span>variant<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="dt">double</span><span class="op">&gt;{};</span>  <span class="co">// 3つの型を切り替える</span></span>
<span id="cb286-4"><a href="#cb286-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-5"><a href="#cb286-5" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb286-6"><a href="#cb286-6" aria-hidden="true" tabindex="-1"></a>        org_visit<span class="op">(</span>type_value<span class="op">,</span> v<span class="op">);</span></span>
<span id="cb286-7"><a href="#cb286-7" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;int : 3&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb286-8"><a href="#cb286-8" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span>  <span class="co">// ossのリセット</span></span>
<span id="cb286-9"><a href="#cb286-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-10"><a href="#cb286-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb286-11"><a href="#cb286-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb286-12"><a href="#cb286-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb286-13"><a href="#cb286-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> v <span class="op">=</span> <span class="bu">std::</span>variant<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="dt">double</span><span class="op">&gt;{};</span>  <span class="co">// 4つの型を切り替える</span></span>
<span id="cb286-14"><a href="#cb286-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-15"><a href="#cb286-15" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb286-16"><a href="#cb286-16" aria-hidden="true" tabindex="-1"></a>        org_visit<span class="op">(</span>type_value<span class="op">,</span> v<span class="op">);</span></span>
<span id="cb286-17"><a href="#cb286-17" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;int : 3&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb286-18"><a href="#cb286-18" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span>  <span class="co">// ossのリセット</span></span>
<span id="cb286-19"><a href="#cb286-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-20"><a href="#cb286-20" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> <span class="ch">&#39;c&#39;</span><span class="op">;</span></span>
<span id="cb286-21"><a href="#cb286-21" aria-hidden="true" tabindex="-1"></a>        org_visit<span class="op">(</span>type_value<span class="op">,</span> v<span class="op">);</span></span>
<span id="cb286-22"><a href="#cb286-22" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span><span class="st">&quot;char : c&quot;</span><span class="op">,</span> oss<span class="op">.</span>str<span class="op">());</span></span>
<span id="cb286-23"><a href="#cb286-23" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span>  <span class="co">// ossのリセット</span></span>
<span id="cb286-24"><a href="#cb286-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-25"><a href="#cb286-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb286-26"><a href="#cb286-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>下記のように継承関係のない複数のクラスが同じシグネチャのメンバ関数を持つ場合、</p>
<div class="sourceCode" id="cb287"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/variant_ut.cpp 177</span></span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-3"><a href="#cb287-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb287-4"><a href="#cb287-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb287-5"><a href="#cb287-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> f<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="ch">&#39;A&#39;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb287-6"><a href="#cb287-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb287-7"><a href="#cb287-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-8"><a href="#cb287-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> B <span class="op">{</span></span>
<span id="cb287-9"><a href="#cb287-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb287-10"><a href="#cb287-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> f<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="ch">&#39;B&#39;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb287-11"><a href="#cb287-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb287-12"><a href="#cb287-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-13"><a href="#cb287-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> C <span class="op">{</span></span>
<span id="cb287-14"><a href="#cb287-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb287-15"><a href="#cb287-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> f<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="ch">&#39;C&#39;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb287-16"><a href="#cb287-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>std::variant、上に示した関数テンプレート、ジェネリックラムダを使い、
下記に示したような疑似的なポリモーフィズムを実現できる。</p>
<div class="sourceCode" id="cb288"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/variant_ut.cpp 197</span></span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> ret<span class="op">{};</span></span>
<span id="cb288-4"><a href="#cb288-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> call_f <span class="op">=</span> <span class="op">[&amp;</span>ret<span class="op">](</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> a<span class="op">)</span> <span class="op">{</span> ret <span class="op">=</span> a<span class="op">.</span>f<span class="op">();</span> <span class="op">};</span></span>
<span id="cb288-5"><a href="#cb288-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-6"><a href="#cb288-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> v <span class="op">=</span> <span class="bu">std::</span>variant<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">&gt;{};</span></span>
<span id="cb288-7"><a href="#cb288-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-8"><a href="#cb288-8" aria-hidden="true" tabindex="-1"></a>    org_visit<span class="op">(</span>call_f<span class="op">,</span> v<span class="op">);</span>  <span class="co">// 疑似的なポリモーフィズム</span></span>
<span id="cb288-9"><a href="#cb288-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="ch">&#39;A&#39;</span><span class="op">,</span> ret<span class="op">);</span></span>
<span id="cb288-10"><a href="#cb288-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-11"><a href="#cb288-11" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> B<span class="op">{};</span></span>
<span id="cb288-12"><a href="#cb288-12" aria-hidden="true" tabindex="-1"></a>    org_visit<span class="op">(</span>call_f<span class="op">,</span> v<span class="op">);</span>  <span class="co">// 疑似的なポリモーフィズム</span></span>
<span id="cb288-13"><a href="#cb288-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="ch">&#39;B&#39;</span><span class="op">,</span> ret<span class="op">);</span></span>
<span id="cb288-14"><a href="#cb288-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-15"><a href="#cb288-15" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> C<span class="op">{};</span></span>
<span id="cb288-16"><a href="#cb288-16" aria-hidden="true" tabindex="-1"></a>    org_visit<span class="op">(</span>call_f<span class="op">,</span> v<span class="op">);</span>  <span class="co">// 疑似的なポリモーフィズム</span></span>
<span id="cb288-17"><a href="#cb288-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="ch">&#39;C&#39;</span><span class="op">,</span> ret<span class="op">);</span></span></code></pre></div>
<p>ここで示した関数テンプレートは、デザインパターン<a
href="design_pattern.html#SS_9_20">Visitor</a>の例であり、
ほぼこれと同様のものがstd::visitとして定義されている。</p>
<div class="sourceCode" id="cb289"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/variant_ut.cpp 215</span></span>
<span id="cb289-2"><a href="#cb289-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-3"><a href="#cb289-3" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> A<span class="op">{};</span></span>
<span id="cb289-4"><a href="#cb289-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>visit<span class="op">(</span>call_f<span class="op">,</span> v<span class="op">);</span>  <span class="co">// 疑似的なポリモーフィズム</span></span>
<span id="cb289-5"><a href="#cb289-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="ch">&#39;A&#39;</span><span class="op">,</span> ret<span class="op">);</span></span>
<span id="cb289-6"><a href="#cb289-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-7"><a href="#cb289-7" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> B<span class="op">{};</span></span>
<span id="cb289-8"><a href="#cb289-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>visit<span class="op">(</span>call_f<span class="op">,</span> v<span class="op">);</span>  <span class="co">// 疑似的なポリモーフィズム</span></span>
<span id="cb289-9"><a href="#cb289-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="ch">&#39;B&#39;</span><span class="op">,</span> ret<span class="op">);</span></span>
<span id="cb289-10"><a href="#cb289-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-11"><a href="#cb289-11" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> C<span class="op">{};</span></span>
<span id="cb289-12"><a href="#cb289-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>visit<span class="op">(</span>call_f<span class="op">,</span> v<span class="op">);</span>  <span class="co">// 疑似的なポリモーフィズム</span></span>
<span id="cb289-13"><a href="#cb289-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="ch">&#39;C&#39;</span><span class="op">,</span> ret<span class="op">);</span></span></code></pre></div>
<h3
id="クラステンプレートと継承の再帰構造">クラステンプレートと継承の再帰構造
<a id="SS_13_7_3"></a></h3>
<p>クラステンプレートと継承の再帰構造はCRTPと呼ばれる。
このコードパターンについては、 「<a
href="design_pattern.html#SS_9_21">CRTP(curiously recurring template
pattern)</a>」で説明している。</p>
<h3 id="意図しないname-lookupの防止">意図しないname lookupの防止
<a id="SS_13_7_4"></a></h3>
<p>下記のようにクラスや関数テンプレートが定義されている場合を考える。</p>
<div class="sourceCode" id="cb290"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 11</span></span>
<span id="cb290-2"><a href="#cb290-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-3"><a href="#cb290-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb290-4"><a href="#cb290-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-5"><a href="#cb290-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> XY <span class="op">{</span></span>
<span id="cb290-6"><a href="#cb290-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb290-7"><a href="#cb290-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb290-8"><a href="#cb290-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb290-9"><a href="#cb290-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-10"><a href="#cb290-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// このような関数テンプレートは適用範囲が広すぎるので定義すべきではないが、</span></span>
<span id="cb290-11"><a href="#cb290-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 危険な例を示すためあえて定義している</span></span>
<span id="cb290-12"><a href="#cb290-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb290-13"><a href="#cb290-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="kw">auto</span> is_equal<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> U <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb290-14"><a href="#cb290-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>lhs<span class="op">.</span>x <span class="op">==</span> rhs<span class="op">.</span>x<span class="op">,</span> lhs<span class="op">.</span>y <span class="op">==</span> rhs<span class="op">.</span>y<span class="op">)</span></span>
<span id="cb290-15"><a href="#cb290-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb290-16"><a href="#cb290-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lhs<span class="op">.</span>x <span class="op">==</span> rhs<span class="op">.</span>x <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>y <span class="op">==</span> rhs<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb290-17"><a href="#cb290-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb290-18"><a href="#cb290-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>これに対しての単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb291"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 37</span></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-3"><a href="#cb291-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> xy0 <span class="op">=</span> App<span class="op">::</span>XY<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb291-4"><a href="#cb291-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> xy1 <span class="op">=</span> App<span class="op">::</span>XY<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb291-5"><a href="#cb291-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> xy2 <span class="op">=</span> App<span class="op">::</span>XY<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb291-6"><a href="#cb291-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-7"><a href="#cb291-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>is_equal<span class="op">(</span>xy0<span class="op">,</span> xy1<span class="op">));</span></span>
<span id="cb291-8"><a href="#cb291-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>is_equal<span class="op">(</span>xy0<span class="op">,</span> xy2<span class="op">));</span></span>
<span id="cb291-9"><a href="#cb291-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-10"><a href="#cb291-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> point <span class="op">{</span></span>
<span id="cb291-11"><a href="#cb291-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb291-12"><a href="#cb291-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb291-13"><a href="#cb291-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb291-14"><a href="#cb291-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p0 <span class="op">=</span> point<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb291-15"><a href="#cb291-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-16"><a href="#cb291-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記のような比較ができるようにするためis_equalはテンプレートで実装している</span></span>
<span id="cb291-17"><a href="#cb291-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>is_equal<span class="op">(</span>p0<span class="op">,</span> xy0<span class="op">));</span></span>
<span id="cb291-18"><a href="#cb291-18" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>is_equal<span class="op">(</span>p0<span class="op">,</span> xy1<span class="op">));</span></span></code></pre></div>
<p>上記の抜粋である</p>
<div class="sourceCode" id="cb292"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 43</span></span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>is_equal<span class="op">(</span>xy0<span class="op">,</span> xy1<span class="op">));</span></span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>is_equal<span class="op">(</span>xy0<span class="op">,</span> xy2<span class="op">));</span></span></code></pre></div>
<p>が名前空間Appの指定なしでコンパイルできる理由は、 <a
href="term_explanation.html#SS_19_10_5">ADL</a>(実引数依存探索)により、Appもis_equalの<a
href="term_explanation.html#SS_19_10_2">name
lookup</a>の対象になるからである。
これは便利な機能であるが、その副作用として意図しないname
lookupによるバグの混入を起こしてしまうことがある。</p>
<p>上記の名前空間での定義が可視である状態で、下記のようなコードを書いた場合を考える。</p>
<div class="sourceCode" id="cb293"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 63</span></span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-3"><a href="#cb293-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App2 <span class="op">{</span></span>
<span id="cb293-4"><a href="#cb293-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> XYZ <span class="op">{</span></span>
<span id="cb293-5"><a href="#cb293-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb293-6"><a href="#cb293-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb293-7"><a href="#cb293-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> z<span class="op">;</span></span>
<span id="cb293-8"><a href="#cb293-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb293-9"><a href="#cb293-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-10"><a href="#cb293-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="dt">bool</span> is_equal<span class="op">(</span>XYZ <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> XYZ <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb293-11"><a href="#cb293-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb293-12"><a href="#cb293-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lhs<span class="op">.</span>x <span class="op">==</span> rhs<span class="op">.</span>x <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>y <span class="op">==</span> rhs<span class="op">.</span>y <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>z <span class="op">==</span> rhs<span class="op">.</span>z<span class="op">;</span></span>
<span id="cb293-13"><a href="#cb293-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb293-14"><a href="#cb293-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App2</span></span></code></pre></div>
<p>この単体テストは、やはりADLを使い下記のように書ける。</p>
<div class="sourceCode" id="cb294"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 84</span></span>
<span id="cb294-2"><a href="#cb294-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> xyz0 <span class="op">=</span> App2<span class="op">::</span>XYZ<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb294-3"><a href="#cb294-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> xyz1 <span class="op">=</span> App2<span class="op">::</span>XYZ<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb294-4"><a href="#cb294-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb294-5"><a href="#cb294-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>is_equal<span class="op">(</span>xyz0<span class="op">,</span> xyz0<span class="op">));</span></span>
<span id="cb294-6"><a href="#cb294-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>is_equal<span class="op">(</span>xyz0<span class="op">,</span> xyz1<span class="op">));</span></span></code></pre></div>
<p>これに問題はないが、下記のテストもコンパイルでき、且つテストもパスしてしまうことには問題がある。</p>
<div class="sourceCode" id="cb295"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 93</span></span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> xyz0 <span class="op">=</span> App2<span class="op">::</span>XYZ<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> xyz1 <span class="op">=</span> App2<span class="op">::</span>XYZ<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb295-5"><a href="#cb295-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> xy0  <span class="op">=</span> App<span class="op">::</span>XY<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb295-6"><a href="#cb295-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-7"><a href="#cb295-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>is_equal<span class="op">(</span>xy0<span class="op">,</span> xyz0<span class="op">));</span>  <span class="co">// これがコンパイルできてしまう</span></span>
<span id="cb295-8"><a href="#cb295-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>is_equal<span class="op">(</span>xy0<span class="op">,</span> xyz1<span class="op">));</span>   <span class="co">// このis_equalはAppで定義されたもの</span></span></code></pre></div>
<p>このセマンティクス的に無意味な(もしくは混乱を引き起こしてしまうであろう)コードは、</p>
<ul>
<li>is_equalの引数の型XY、XYZはそれぞれ名前空間App、App2で定義されている</li>
<li>従って、ADLによりis_equalのname
lookupには名前空間App、App2も使われる</li>
<li>引数の型XY、XYZを取り得るis_equalはAppで定義されたもののみである</li>
</ul>
<p>というメカニズムによりコンパイルできてしまう。</p>
<p>こういったname lookup、特にADLの問題に対処する方法は、</p>
<ul>
<li><a
href="template_meta_programming.html#SS_13_7_4_1">ジェネリックすぎるテンプレートを書かない</a></li>
<li><a
href="template_meta_programming.html#SS_13_7_4_2">ADLが本当に必要でない限り名前を修飾する</a></li>
<li><a href="template_meta_programming.html#SS_13_7_4_3">ADL
Firewallを使う</a></li>
</ul>
<p>のようにいくつか考えられる。これらについて以下で説明を行う。</p>
<h4
id="ジェネリックすぎるテンプレートを書かない">ジェネリックすぎるテンプレートを書かない
<a id="SS_13_7_4_1"></a></h4>
<p>ここでの「ジェネリックすぎるテンプレート」とは、
シンタックス的には適用範囲が広いにもかかわらず、セマンティクス的な適用範囲は限られているものを指す。
従って下記のような関数テンプレートを指す概念ではない。</p>
<div class="sourceCode" id="cb296"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 108</span></span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-3"><a href="#cb296-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb296-4"><a href="#cb296-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> array_length<span class="op">(</span>T <span class="at">const</span> <span class="op">(&amp;)[</span>N<span class="op">])</span> <span class="kw">noexcept</span></span>
<span id="cb296-5"><a href="#cb296-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb296-6"><a href="#cb296-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> N<span class="op">;</span></span>
<span id="cb296-7"><a href="#cb296-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>前記で問題を起こした関数テンプレート</p>
<div class="sourceCode" id="cb297"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 20</span></span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-3"><a href="#cb297-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// このような関数テンプレートは適用範囲が広すぎるので定義すべきではないが、</span></span>
<span id="cb297-4"><a href="#cb297-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 危険な例を示すためあえて定義している</span></span>
<span id="cb297-5"><a href="#cb297-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb297-6"><a href="#cb297-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="kw">auto</span> is_equal<span class="op">(</span>T <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> U <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb297-7"><a href="#cb297-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>lhs<span class="op">.</span>x <span class="op">==</span> rhs<span class="op">.</span>x<span class="op">,</span> lhs<span class="op">.</span>y <span class="op">==</span> rhs<span class="op">.</span>y<span class="op">)</span></span>
<span id="cb297-8"><a href="#cb297-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb297-9"><a href="#cb297-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lhs<span class="op">.</span>x <span class="op">==</span> rhs<span class="op">.</span>x <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>y <span class="op">==</span> rhs<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb297-10"><a href="#cb297-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb297-11"><a href="#cb297-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>が典型的な「ジェネリックすぎるテンプレート」である。
これに対する最も安全な対処は下記コードで示す通りテンプレートを使わないことである。</p>
<div class="sourceCode" id="cb298"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 126</span></span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-3"><a href="#cb298-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb298-4"><a href="#cb298-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-5"><a href="#cb298-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> XY <span class="op">{</span></span>
<span id="cb298-6"><a href="#cb298-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb298-7"><a href="#cb298-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb298-8"><a href="#cb298-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb298-9"><a href="#cb298-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb298-10"><a href="#cb298-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="dt">bool</span> is_equal<span class="op">(</span>XY <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> XY <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb298-11"><a href="#cb298-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb298-12"><a href="#cb298-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lhs<span class="op">.</span>x <span class="op">==</span> rhs<span class="op">.</span>x <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>y <span class="op">==</span> rhs<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb298-13"><a href="#cb298-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb298-14"><a href="#cb298-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>ジェネリックなis_equalが必要であれば下記単体テストのように <a
href="template_meta_programming.html#SS_13_7_2">ジェネリックラムダによる関数内での関数テンプレートの定義</a>を行えばよい。
こうすることでその適用範囲はそれを定義した関数内に留まる。</p>
<div class="sourceCode" id="cb299"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 153</span></span>
<span id="cb299-2"><a href="#cb299-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb299-3"><a href="#cb299-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 下記のpointのようなクラスが他にもいくつかあった場合、</span></span>
<span id="cb299-4"><a href="#cb299-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// このジェネリックラムダでコードの被りは回避できる</span></span>
<span id="cb299-5"><a href="#cb299-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> is_equal <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> <span class="kw">auto</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb299-6"><a href="#cb299-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lhs<span class="op">.</span>x <span class="op">==</span> rhs<span class="op">.</span>x <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>y <span class="op">==</span> rhs<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb299-7"><a href="#cb299-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb299-8"><a href="#cb299-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb299-9"><a href="#cb299-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> point <span class="op">{</span></span>
<span id="cb299-10"><a href="#cb299-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb299-11"><a href="#cb299-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb299-12"><a href="#cb299-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb299-13"><a href="#cb299-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p0 <span class="op">=</span> point<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb299-14"><a href="#cb299-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb299-15"><a href="#cb299-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>is_equal<span class="op">(</span>p0<span class="op">,</span> xy0<span class="op">));</span></span>
<span id="cb299-16"><a href="#cb299-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_FALSE<span class="op">(</span>is_equal<span class="op">(</span>p0<span class="op">,</span> xy1<span class="op">));</span></span></code></pre></div>
<p>上記で示した</p>
<ul>
<li>テンプレートを使わない</li>
<li>適用範囲の広いテンプレート(ジェネリック)に対してはアクセスできる箇所を局所化する</li>
</ul>
<p>といった方法の他にも、「<a
href="template_meta_programming.html#SS_13_4_4">コンテナ用Nstd::operator&lt;&lt;の開発</a>」で示した</p>
<ul>
<li><a
href="template_meta_programming.html#SS_13_3_1_4">std::enable_if</a>や<a
href="term_explanation.html#SS_19_11_2">コンセプト</a>等を使用してテンプレートに適用できる型を制約する</li>
</ul>
<p>ことも考えられる。
ベストな方法は状況に大きく依存するため一概には決められない。
その状況でのもっとも単純は方法を選ぶべきだろう(が、何が単純かも一概に決めることは難しい)。</p>
<h4
id="adlが本当に必要でない限り名前を修飾する">ADLが本当に必要でない限り名前を修飾する
<a id="SS_13_7_4_2"></a></h4>
<p>下記のコードについて考える。</p>
<div class="sourceCode" id="cb300"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 176</span></span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-3"><a href="#cb300-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb300-4"><a href="#cb300-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> i <span class="op">*</span> <span class="dv">3</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb300-5"><a href="#cb300-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb300-6"><a href="#cb300-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-7"><a href="#cb300-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> i <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb300-8"><a href="#cb300-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-9"><a href="#cb300-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb300-10"><a href="#cb300-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-11"><a href="#cb300-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb300-12"><a href="#cb300-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> ExecF <span class="op">:</span> <span class="kw">public</span> T <span class="op">{</span></span>
<span id="cb300-13"><a href="#cb300-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb300-14"><a href="#cb300-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb300-15"><a href="#cb300-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb300-16"><a href="#cb300-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> f<span class="op">(</span>i<span class="op">);</span>  <span class="co">// T::fの呼び出しにも見えるが、::fの呼び出し</span></span>
<span id="cb300-17"><a href="#cb300-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb300-18"><a href="#cb300-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-19"><a href="#cb300-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Tを使ったコード</span></span>
<span id="cb300-20"><a href="#cb300-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb300-21"><a href="#cb300-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb300-22"><a href="#cb300-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>基底クラスのメンバ関数を呼び出す場合は、T::f()、もしくは、this-&gt;f()と書く必要があるため、
下記コードで呼び出した関数fは外部関数fの呼び出しになる (<a
href="term_explanation.html#SS_19_10_3">two phase name
lookup</a>の一回目のname lookupでfがバインドされるため)。</p>
<div class="sourceCode" id="cb301"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 203</span></span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ef <span class="op">=</span> App<span class="op">::</span>ExecF<span class="op">&lt;</span>A<span class="op">&gt;{};</span></span>
<span id="cb301-4"><a href="#cb301-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-5"><a href="#cb301-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">4</span><span class="op">,</span> ef<span class="op">(</span><span class="dv">2</span><span class="op">));</span>  <span class="co">// ::fの呼び出しなので、2 * 2 == 4となる</span></span></code></pre></div>
<p>これだけでも十分わかりづらいが、
ExecFのテンプレートパラメータにはクラスAしか使われないことがわかったので、
下記のようにリファクタリングしたとしよう。</p>
<div class="sourceCode" id="cb302"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 213</span></span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-3"><a href="#cb302-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb302-4"><a href="#cb302-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> i <span class="op">*</span> <span class="dv">3</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb302-5"><a href="#cb302-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb302-6"><a href="#cb302-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-7"><a href="#cb302-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> i<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> i <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb302-8"><a href="#cb302-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-9"><a href="#cb302-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb302-10"><a href="#cb302-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-11"><a href="#cb302-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> ExecF <span class="op">:</span> <span class="kw">public</span> A <span class="op">{</span></span>
<span id="cb302-12"><a href="#cb302-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb302-13"><a href="#cb302-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> i<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> f<span class="op">(</span>i<span class="op">);</span> <span class="op">}</span></span>
<span id="cb302-14"><a href="#cb302-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-15"><a href="#cb302-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Tを使ったコード</span></span>
<span id="cb302-16"><a href="#cb302-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb302-17"><a href="#cb302-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb302-18"><a href="#cb302-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>すると、fのname
lookupの対象が変わってしまい、元の単体テストはパスしなくなる。</p>
<div class="sourceCode" id="cb303"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/suppress_adl_ut.cpp 236</span></span>
<span id="cb303-2"><a href="#cb303-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-3"><a href="#cb303-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ef <span class="op">=</span> App<span class="op">::</span>ExecF<span class="op">{};</span></span>
<span id="cb303-4"><a href="#cb303-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-5"><a href="#cb303-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_EQ(4, ef(2));</span></span>
<span id="cb303-6"><a href="#cb303-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">6</span><span class="op">,</span> ef<span class="op">(</span><span class="dv">2</span><span class="op">));</span>  <span class="co">// リファクタリングでname lookupの対象が変わり、A::fが呼ばれる</span></span></code></pre></div>
<p>こういった場合に備え単体テストを実行すべきなのだが、この程度の問題はコンパイルで検出したい。
<a href="term_explanation.html#SS_19_10_5">ADL</a>や<a
href="term_explanation.html#SS_19_10_3">two phase name
lookup</a>が絡む場合ならなおさらである。</p>
<p>こういう意図しない<a href="term_explanation.html#SS_19_10_2">name
lookup</a>に備えるためには、
修飾されていない識別子を使わないこと、つまり、
識別子には、名前空間、クラス名、this-&gt;等による修飾を施すことが重要である。</p>
<p>ただし、「<a
href="template_meta_programming.html#SS_13_4_4">コンテナ用Nstd::operator&lt;&lt;の開発</a>」で示したコード等にはADLが欠かせないため、
修飾することをルール化することはできない。場合に合わせた運用が唯一の解となる。</p>
<h4 id="adl-firewallを使う">ADL Firewallを使う
<a id="SS_13_7_4_3"></a></h4>
<p>下記のコードについて考える。</p>
<div class="sourceCode" id="cb304"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/adl_firewall_0_ut.cpp 10</span></span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-3"><a href="#cb304-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb304-4"><a href="#cb304-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-5"><a href="#cb304-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb304-6"><a href="#cb304-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string ToString<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb304-7"><a href="#cb304-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb304-8"><a href="#cb304-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb304-9"><a href="#cb304-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-10"><a href="#cb304-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> Nstd<span class="op">::</span><span class="kw">operator</span><span class="op">&lt;&lt;;</span></span>
<span id="cb304-11"><a href="#cb304-11" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> t<span class="op">;</span>  <span class="co">// Nstd::operator&lt;&lt;もname lookupの対象に含める</span></span>
<span id="cb304-12"><a href="#cb304-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-13"><a href="#cb304-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> oss<span class="op">.</span>str<span class="op">();</span></span>
<span id="cb304-14"><a href="#cb304-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb304-15"><a href="#cb304-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span>
<span id="cb304-16"><a href="#cb304-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-17"><a href="#cb304-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb304-18"><a href="#cb304-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-19"><a href="#cb304-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb304-20"><a href="#cb304-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> XY <span class="op">{</span></span>
<span id="cb304-21"><a href="#cb304-21" aria-hidden="true" tabindex="-1"></a>        XY<span class="op">(</span><span class="dt">int</span> ax<span class="op">,</span> <span class="dt">int</span> ay<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> x<span class="op">{</span>ax<span class="op">},</span> y<span class="op">{</span>ay<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb304-22"><a href="#cb304-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb304-23"><a href="#cb304-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb304-24"><a href="#cb304-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb304-25"><a href="#cb304-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-26"><a href="#cb304-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> XY <span class="at">const</span><span class="op">&amp;</span> xyz<span class="op">)</span></span>
<span id="cb304-27"><a href="#cb304-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb304-28"><a href="#cb304-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>to_string<span class="op">(</span>xyz<span class="op">.</span>x<span class="op">)</span> <span class="op">+</span> <span class="st">&quot;/&quot;</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span>xyz<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb304-29"><a href="#cb304-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb304-30"><a href="#cb304-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>上記のApp::ToStringは「<a
href="template_meta_programming.html#SS_13_4_4">コンテナ用Nstd::operator&lt;&lt;の開発</a>」のコードを使用し、
std::vectorオブジェクトをstd::stringに変換する。</p>
<p>これに対しての単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb305"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/adl_firewall_0_ut.cpp 47</span></span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> xys <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>App<span class="op">::</span>XY<span class="op">&gt;{{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">8</span><span class="op">},</span> <span class="op">{</span><span class="dv">7</span><span class="op">,</span> <span class="dv">6</span><span class="op">}};</span></span>
<span id="cb305-4"><a href="#cb305-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb305-5"><a href="#cb305-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;9/8, 7/6&quot;</span><span class="op">,</span> App<span class="op">::</span>ToString<span class="op">(</span>xys<span class="op">));</span></span></code></pre></div>
<p>これは想定通りの動作だが、上記のAppの後に下記のコードを追加するとApp::ToStringは影響を受ける。</p>
<div class="sourceCode" id="cb306"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/adl_firewall_1_ut.cpp 40</span></span>
<span id="cb306-2"><a href="#cb306-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb306-3"><a href="#cb306-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Appに下記を追加</span></span>
<span id="cb306-4"><a href="#cb306-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb306-5"><a href="#cb306-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb306-6"><a href="#cb306-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> t<span class="op">)</span></span>
<span id="cb306-7"><a href="#cb306-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb306-8"><a href="#cb306-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os <span class="op">&lt;&lt;</span> <span class="st">&quot;size:&quot;</span> <span class="op">&lt;&lt;</span> t<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb306-9"><a href="#cb306-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb306-10"><a href="#cb306-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>これにより元の単体テストはエラーとなり、新しい単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb307"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/adl_firewall_1_ut.cpp 56</span></span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-3"><a href="#cb307-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> xys <span class="op">=</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>App<span class="op">::</span>XY<span class="op">&gt;{{</span><span class="dv">9</span><span class="op">,</span> <span class="dv">8</span><span class="op">},</span> <span class="op">{</span><span class="dv">7</span><span class="op">,</span> <span class="dv">6</span><span class="op">}};</span></span>
<span id="cb307-4"><a href="#cb307-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb307-5"><a href="#cb307-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// App::operator&lt;&lt;の追加で、App::ToStringの出力が影響を受ける</span></span>
<span id="cb307-6"><a href="#cb307-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASSERT_EQ(&quot;9/8, 7/6&quot;, App::ToString(xys));</span></span>
<span id="cb307-7"><a href="#cb307-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;size:2&quot;</span><span class="op">,</span> App<span class="op">::</span>ToString<span class="op">(</span>xys<span class="op">));</span></span></code></pre></div>
<p>これが意図通りなら問題ないが、
ここでは「新たに追加した関数テンプレートApp::operator&lt;&lt;はstd::vector&lt;App::XY&gt;用ではなかった」
としよう。その場合、これは意図しないADLによるバグの混入となる。 「<a
href="template_meta_programming.html#SS_13_7_4_1">ジェネリックすぎるテンプレートを書かない</a>」
で述べたように追加した関数テンプレートの適用範囲が広すぎることが原因であるが、
XY型から生成されたオブジェクト(std::vector&lt;App::XY&gt;も含む)によるADLのため、
Appの宣言がname lookupの対象になったことにも原因がある。</p>
<p>下記のコードは後者の原因を解消する。</p>
<div class="sourceCode" id="cb308"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/adl_firewall_2_ut.cpp 23</span></span>
<span id="cb308-2"><a href="#cb308-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb308-3"><a href="#cb308-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Appの中の新たな名前空間XY_Firewall_でstruct XYとoperator&lt;&lt;を宣言</span></span>
<span id="cb308-4"><a href="#cb308-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> App <span class="op">{</span></span>
<span id="cb308-5"><a href="#cb308-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> XY_Firewall_ <span class="op">{</span></span>
<span id="cb308-6"><a href="#cb308-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb308-7"><a href="#cb308-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> XY <span class="op">{</span></span>
<span id="cb308-8"><a href="#cb308-8" aria-hidden="true" tabindex="-1"></a>        XY<span class="op">(</span><span class="dt">int</span> ax<span class="op">,</span> <span class="dt">int</span> ay<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> x<span class="op">{</span>ax<span class="op">},</span> y<span class="op">{</span>ay<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb308-9"><a href="#cb308-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb308-10"><a href="#cb308-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb308-11"><a href="#cb308-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb308-12"><a href="#cb308-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb308-13"><a href="#cb308-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ostream<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">&lt;&lt;(</span><span class="bu">std::</span>ostream<span class="op">&amp;</span> os<span class="op">,</span> XY <span class="at">const</span><span class="op">&amp;</span> xyz<span class="op">)</span></span>
<span id="cb308-14"><a href="#cb308-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb308-15"><a href="#cb308-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os <span class="op">&lt;&lt;</span> <span class="bu">std::</span>to_string<span class="op">(</span>xyz<span class="op">.</span>x<span class="op">)</span> <span class="op">+</span> <span class="st">&quot;/&quot;</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span>xyz<span class="op">.</span>y<span class="op">);</span></span>
<span id="cb308-16"><a href="#cb308-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb308-17"><a href="#cb308-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace XY_Firewall_</span></span>
<span id="cb308-18"><a href="#cb308-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb308-19"><a href="#cb308-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> XY <span class="op">=</span> XY_Firewall_<span class="op">::</span>XY<span class="op">;</span></span>
<span id="cb308-20"><a href="#cb308-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb308-21"><a href="#cb308-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace App</span></span></code></pre></div>
<p>XY型オブジェクトを引数にした関数呼び出しによる<a
href="term_explanation.html#SS_19_10_6">関連名前空間</a>は、
極小なApp::XY_Firewall_であるため、意図しないADLは起こりづらく、起こっても発見しやすい。
また、XY型用operator&lt;&lt;もApp::XY_Firewall_で定義し、 App内でusing
XYを宣言したことで、これまで通りApp::XYが使える。</p>
<p>このようなテクニックをADL firewallと呼ぶ。</p>
<h3 id="nstdtype2strの開発">Nstd::Type2Strの開発
<a id="SS_13_7_5"></a></h3>
<p>「<a
href="template_meta_programming.html#SS_13_2">Nstdライブラリの開発</a>」等で行ったメタ関数の実装は、</p>
<ul>
<li>入り組んだ&lt;&gt;や()の対応漏れ</li>
<li>&amp;や&amp;&amp;のつけ忘れ</li>
<li>typenameやtemplateキーワードの漏れ</li>
<li>メタ関数メンバー::valueや::typeの漏れ</li>
</ul>
<p>等によるコンパイルエラーとの戦いである。 また、これをクリアしても<a
href="term_explanation.html#SS_19_10_3">two phase name lookup</a>や<a
href="term_explanation.html#SS_19_10_5">ADL</a>が次の関門になる。
これには、デバッガのステップ実行が強力な武器となるが、
型を文字列に変換する関数があればこれもまた強力な武器となる。</p>
<p>以下に示すNstd::Type2Strは、「<a
href="template_meta_programming.html#SS_13_2">Nstdライブラリの開発</a>」等で実際に使用したそのような関数である。</p>
<div class="sourceCode" id="cb309"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/nstd_type2str.h 9</span></span>
<span id="cb309-2"><a href="#cb309-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-3"><a href="#cb309-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Nstd <span class="op">{</span></span>
<span id="cb309-4"><a href="#cb309-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb309-5"><a href="#cb309-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-6"><a href="#cb309-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">inline</span> <span class="bu">std::</span>string demangle<span class="op">(</span><span class="dt">char</span> <span class="at">const</span><span class="op">*</span> to_demagle<span class="op">)</span></span>
<span id="cb309-7"><a href="#cb309-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb309-8"><a href="#cb309-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> status<span class="op">;</span></span>
<span id="cb309-9"><a href="#cb309-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-10"><a href="#cb309-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> demangled <span class="op">=</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(&amp;</span><span class="bu">std::</span>free<span class="op">)&gt;{</span></span>
<span id="cb309-11"><a href="#cb309-11" aria-hidden="true" tabindex="-1"></a>            abi<span class="op">::</span>__cxa_demangle<span class="op">(</span>to_demagle<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">&amp;</span>status<span class="op">),</span> <span class="op">&amp;</span><span class="bu">std::</span>free<span class="op">};</span></span>
<span id="cb309-12"><a href="#cb309-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-13"><a href="#cb309-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> demangled<span class="op">.</span>get<span class="op">();</span></span>
<span id="cb309-14"><a href="#cb309-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb309-15"><a href="#cb309-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-16"><a href="#cb309-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">&gt;</span>  <span class="co">// typenameを取り出すためだけのクラステンプレート</span></span>
<span id="cb309-17"><a href="#cb309-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> type_capture <span class="op">{</span></span>
<span id="cb309-18"><a href="#cb309-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb309-19"><a href="#cb309-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb309-20"><a href="#cb309-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-21"><a href="#cb309-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb309-22"><a href="#cb309-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string Type2Str<span class="op">()</span></span>
<span id="cb309-23"><a href="#cb309-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb309-24"><a href="#cb309-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// typeid(T)とした場合、const/volatile/&amp;の情報が捨てられるため、</span></span>
<span id="cb309-25"><a href="#cb309-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// typeid(type_capture&lt;T&gt;)とし、それを防ぐ。</span></span>
<span id="cb309-26"><a href="#cb309-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> str <span class="op">=</span> <span class="bu">std::</span>string<span class="op">{</span>Inner_<span class="op">::</span>demangle<span class="op">(</span><span class="kw">typeid</span><span class="op">(</span>Inner_<span class="op">::</span>type_capture<span class="op">&lt;</span>T<span class="op">&gt;).</span>name<span class="op">())};</span></span>
<span id="cb309-27"><a href="#cb309-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-28"><a href="#cb309-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// T   == const int ならば、</span></span>
<span id="cb309-29"><a href="#cb309-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// str == Nstd::Inner_::type_capture&lt;int const&gt;</span></span>
<span id="cb309-30"><a href="#cb309-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">//        &lt;----------- 27 ----------&gt;&lt;-- x --&gt; 下記ではxを切り出す</span></span>
<span id="cb309-31"><a href="#cb309-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="kw">auto</span> beg <span class="op">=</span> <span class="dv">27</span><span class="bu">U</span><span class="op">;</span>                           <span class="co">// 先頭の不要な文字列数</span></span>
<span id="cb309-32"><a href="#cb309-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> name <span class="op">=</span> str<span class="op">.</span>substr<span class="op">(</span>beg<span class="op">,</span> str<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> beg <span class="op">-</span> <span class="dv">1</span><span class="op">);</span>  <span class="co">// 最後の文字は&gt;なので不要</span></span>
<span id="cb309-33"><a href="#cb309-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-34"><a href="#cb309-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>name<span class="op">.</span>back<span class="op">()</span> <span class="op">==</span> <span class="ch">&#39; &#39;</span><span class="op">)</span> <span class="op">{</span>  <span class="co">// 無駄なスペースを消す</span></span>
<span id="cb309-35"><a href="#cb309-35" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> last <span class="op">=</span> <span class="op">--</span>name<span class="op">.</span>end<span class="op">();</span></span>
<span id="cb309-36"><a href="#cb309-36" aria-hidden="true" tabindex="-1"></a>            name<span class="op">.</span>erase<span class="op">(</span>last<span class="op">);</span></span>
<span id="cb309-37"><a href="#cb309-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb309-38"><a href="#cb309-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-39"><a href="#cb309-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> name<span class="op">;</span></span>
<span id="cb309-40"><a href="#cb309-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb309-41"><a href="#cb309-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Nstd</span></span></code></pre></div>
<p>typeid::name()が返す文字列リテラルは引数の型の文字列表現を持つが、
マングリングされているためヒューマンリーダブルではない。
それをデマングルするのがabi::__cxa_demangleであるが、
残念なことにこの関数は非標準であるため、
それを使っているNstd::Inner_::demangleは<a
href="term_explanation.html#SS_19_19_1">g++</a>/<a
href="term_explanation.html#SS_19_19_2">clang++</a>
でなければコンパイルできないだろう。</p>
<p>それを除けば、
複雑なシンタックスを持つ型を文字列で表現できるNstd::Type2Strは、
テンプレートプログラミングおける有効なデバッグツールであると言える。</p>
<p>下記単体テストは、そのことを示している。</p>
<div class="sourceCode" id="cb310"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_type2str_ut.cpp 11</span></span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-3"><a href="#cb310-3" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;int const&quot;</span><span class="op">,</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span><span class="dt">int</span> <span class="at">const</span><span class="op">&gt;());</span></span>
<span id="cb310-4"><a href="#cb310-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;std::string&quot;</span><span class="op">,</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;());</span></span>
<span id="cb310-5"><a href="#cb310-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;std::vector&lt;int, std::allocator&lt;int&gt; &gt;&quot;</span><span class="op">,</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;());</span></span>
<span id="cb310-6"><a href="#cb310-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-7"><a href="#cb310-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">extern</span> <span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span><span class="op">);</span></span>
<span id="cb310-8"><a href="#cb310-8" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;void (int)&quot;</span><span class="op">,</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>f<span class="op">)&gt;());</span>  <span class="co">// 関数の型</span></span>
<span id="cb310-9"><a href="#cb310-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-10"><a href="#cb310-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> lamda <span class="op">=</span> <span class="op">[]()</span> <span class="kw">noexcept</span> <span class="op">{};</span></span>
<span id="cb310-11"><a href="#cb310-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_NE<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">,</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>lamda<span class="op">)&gt;());</span>  <span class="co">// XXX::{lambda()#1}な感じになる</span></span>
<span id="cb310-12"><a href="#cb310-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-13"><a href="#cb310-13" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;std::ostream&amp; (std::ostream&amp;, int const (&amp;) [3])&quot;</span><span class="op">,</span></span>
<span id="cb310-14"><a href="#cb310-14" aria-hidden="true" tabindex="-1"></a>              Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>Nstd<span class="op">::</span><span class="kw">operator</span><span class="op">&lt;&lt;</span> <span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;)&gt;());</span></span>
<span id="cb310-15"><a href="#cb310-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-16"><a href="#cb310-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::declvalはrvalueリファレンスを返す</span></span>
<span id="cb310-17"><a href="#cb310-17" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;int (&amp;&amp;) [3]&quot;</span><span class="op">,</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span><span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]&gt;())&gt;());</span></span>
<span id="cb310-18"><a href="#cb310-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-19"><a href="#cb310-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i3<span class="op">[</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb310-20"><a href="#cb310-20" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;int [3]&quot;</span><span class="op">,</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>i3<span class="op">)&gt;());</span></span>
<span id="cb310-21"><a href="#cb310-21" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;int (&amp;) [3]&quot;</span><span class="op">,</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">((</span>i3<span class="op">))&gt;());</span>  <span class="co">// (i3)はlvalueリファレンス</span></span>
<span id="cb310-22"><a href="#cb310-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-23"><a href="#cb310-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span><span class="op">&amp;</span> r <span class="op">=</span> i3<span class="op">;</span></span>
<span id="cb310-24"><a href="#cb310-24" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="st">&quot;int (&amp;) [3]&quot;</span><span class="op">,</span> Nstd<span class="op">::</span>Type2Str<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)&gt;());</span></span></code></pre></div>
<h3 id="静的な文字列オブジェクト">静的な文字列オブジェクト
<a id="SS_13_7_6"></a></h3>
<p>std::stringは文字列を扱うことにおいて、非常に有益なクラスではあるが、
コンパイル時に文字列が決定できる場合でも、動的にメモリを確保する。</p>
<p>この振る舞いは、</p>
<ul>
<li>ランタイム時にnew/deleteを行うため、処理の遅さにつながる。</li>
<li>下記のようにエクセプションオブジェクトにファイル位置を埋め込むことは、
デバッグに便利であるが、メモリ確保失敗を通知するような場面ではこの方法は使えない。</li>
</ul>
<div class="sourceCode" id="cb311"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_exception_ut.cpp 6</span></span>
<span id="cb311-2"><a href="#cb311-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-3"><a href="#cb311-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Exception <span class="op">:</span> <span class="bu">std::</span>exception <span class="op">{</span></span>
<span id="cb311-4"><a href="#cb311-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb311-5"><a href="#cb311-5" aria-hidden="true" tabindex="-1"></a>        Exception<span class="op">(</span><span class="dt">char</span> <span class="at">const</span><span class="op">*</span> filename<span class="op">,</span> <span class="dt">uint32_t</span> line_num<span class="op">,</span> <span class="dt">char</span> <span class="at">const</span><span class="op">*</span> msg<span class="op">)</span></span>
<span id="cb311-6"><a href="#cb311-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> <span class="va">what_str_</span><span class="op">{</span><span class="bu">std::</span>string<span class="op">{</span>filename<span class="op">}</span> <span class="op">+</span> <span class="st">&quot;:&quot;</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span>line_num<span class="op">)</span> <span class="op">+</span> <span class="st">&quot;:&quot;</span> <span class="op">+</span> msg<span class="op">}</span></span>
<span id="cb311-7"><a href="#cb311-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb311-8"><a href="#cb311-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb311-9"><a href="#cb311-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-10"><a href="#cb311-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="at">const</span><span class="op">*</span> what<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">what_str_</span><span class="op">.</span>c_str<span class="op">();</span> <span class="op">}</span></span>
<span id="cb311-11"><a href="#cb311-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-12"><a href="#cb311-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb311-13"><a href="#cb311-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string <span class="va">what_str_</span><span class="op">;</span></span>
<span id="cb311-14"><a href="#cb311-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb311-15"><a href="#cb311-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-16"><a href="#cb311-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> div<span class="op">(</span><span class="dt">int32_t</span> a<span class="op">,</span> <span class="dt">int32_t</span> b<span class="op">)</span></span>
<span id="cb311-17"><a href="#cb311-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb311-18"><a href="#cb311-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>b <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb311-19"><a href="#cb311-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> Exception<span class="op">{</span><span class="ot">__FILE__</span><span class="op">,</span> <span class="ot">__LINE__</span><span class="op">,</span> <span class="st">&quot;divided by 0&quot;</span><span class="op">};</span>  <span class="co">// 24行目</span></span>
<span id="cb311-20"><a href="#cb311-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb311-21"><a href="#cb311-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-22"><a href="#cb311-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">/</span> b<span class="op">;</span></span>
<span id="cb311-23"><a href="#cb311-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb312"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_exception_ut.cpp 34</span></span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb312-3"><a href="#cb312-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> caught <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb312-4"><a href="#cb312-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb312-5"><a href="#cb312-5" aria-hidden="true" tabindex="-1"></a>        div<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb312-6"><a href="#cb312-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb312-7"><a href="#cb312-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">catch</span> <span class="op">(</span>Exception <span class="at">const</span><span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb312-8"><a href="#cb312-8" aria-hidden="true" tabindex="-1"></a>        ASSERT_STREQ<span class="op">(</span><span class="st">&quot;nstd_exception_ut.cpp:24:divided by 0&quot;</span><span class="op">,</span> e<span class="op">.</span>what<span class="op">());</span></span>
<span id="cb312-9"><a href="#cb312-9" aria-hidden="true" tabindex="-1"></a>        caught <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb312-10"><a href="#cb312-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb312-11"><a href="#cb312-11" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>caught<span class="op">);</span></span></code></pre></div>
<p>このような問題を回避するために、ここでは静的に文字列を扱うためのクラスStaticStringを開発する。</p>
<h4
id="staticstringのヘルパークラスの開発">StaticStringのヘルパークラスの開発
<a id="SS_13_7_6_1"></a></h4>
<p>StaticStringオブジェクトは、char配列をメンバとして持つが、
コンパイル時に解決できる配列の初期化にはパラメータパックが利用できる。
そのパラメータパック生成クラスを下記のように定義する。</p>
<div class="sourceCode" id="cb313"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_seq.h 4</span></span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-3"><a href="#cb313-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// パラメータパック展開ヘルパクラス</span></span>
<span id="cb313-4"><a href="#cb313-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span><span class="op">...</span> Ns<span class="op">&gt;</span></span>
<span id="cb313-5"><a href="#cb313-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> index_sequence <span class="op">{</span></span>
<span id="cb313-6"><a href="#cb313-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb313-7"><a href="#cb313-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-8"><a href="#cb313-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// index_sequence&lt;0, 1, 2, ...&gt;を作るためのクラステンプレート</span></span>
<span id="cb313-9"><a href="#cb313-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// make_index_sequence&lt;3&gt;</span></span>
<span id="cb313-10"><a href="#cb313-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// -&gt; make_index_sequence&lt;2, 2&gt;</span></span>
<span id="cb313-11"><a href="#cb313-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// -&gt; make_index_sequence&lt;1, 1, 2&gt;</span></span>
<span id="cb313-12"><a href="#cb313-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// -&gt; make_index_sequence&lt;0, 0, 1, 2&gt;</span></span>
<span id="cb313-13"><a href="#cb313-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// -&gt; index_sequence&lt;0, 1, 2&gt;</span></span>
<span id="cb313-14"><a href="#cb313-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">,</span> <span class="dt">size_t</span><span class="op">...</span> Ns<span class="op">&gt;</span></span>
<span id="cb313-15"><a href="#cb313-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> make_index_sequence <span class="op">:</span> make_index_sequence<span class="op">&lt;</span>N <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> N <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> Ns<span class="op">...&gt;</span> <span class="op">{</span></span>
<span id="cb313-16"><a href="#cb313-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb313-17"><a href="#cb313-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-18"><a href="#cb313-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span><span class="op">...</span> Ns<span class="op">&gt;</span></span>
<span id="cb313-19"><a href="#cb313-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> make_index_sequence<span class="op">&lt;</span><span class="dv">0</span><span class="op">,</span> Ns<span class="op">...&gt;</span> <span class="op">:</span> index_sequence<span class="op">&lt;</span>Ns<span class="op">...&gt;</span> <span class="op">{</span></span>
<span id="cb313-20"><a href="#cb313-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>このクラスにより、下記のような配列メンバの初期ができるようになる。</p>
<div class="sourceCode" id="cb314"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_seq_ut.cpp 7</span></span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-3"><a href="#cb314-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb314-4"><a href="#cb314-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> seq_test <span class="op">{</span></span>
<span id="cb314-5"><a href="#cb314-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span><span class="op">...</span> S<span class="op">&gt;</span></span>
<span id="cb314-6"><a href="#cb314-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> seq_test<span class="op">(</span>index_sequence<span class="op">&lt;</span>S<span class="op">...&gt;)</span> <span class="kw">noexcept</span> <span class="op">:</span> data<span class="op">{</span>S<span class="op">...}</span></span>
<span id="cb314-7"><a href="#cb314-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb314-8"><a href="#cb314-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb314-9"><a href="#cb314-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="at">const</span> data<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb314-10"><a href="#cb314-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb315"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_seq_ut.cpp 24</span></span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> st <span class="op">=</span> seq_test<span class="op">&lt;</span><span class="dv">3</span><span class="op">&gt;{</span>index_sequence<span class="op">&lt;</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;()};</span></span>
<span id="cb315-4"><a href="#cb315-4" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">1</span><span class="op">,</span> st<span class="op">.</span>data<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb315-5"><a href="#cb315-5" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">2</span><span class="op">,</span> st<span class="op">.</span>data<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb315-6"><a href="#cb315-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="dv">3</span><span class="op">,</span> st<span class="op">.</span>data<span class="op">[</span><span class="dv">2</span><span class="op">]);</span></span></code></pre></div>
<p>これを下記のように使うことで、メンバである文字列配列のコンパイル時初期化ができるようになる。</p>
<div class="sourceCode" id="cb316"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_seq_ut.cpp 33</span></span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-3"><a href="#cb316-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb316-4"><a href="#cb316-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> seq_test2 <span class="op">{</span></span>
<span id="cb316-5"><a href="#cb316-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb316-6"><a href="#cb316-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span><span class="op">...</span> S<span class="op">&gt;</span></span>
<span id="cb316-7"><a href="#cb316-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> seq_test2<span class="op">(</span><span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>str<span class="op">)[</span>N<span class="op">],</span> index_sequence<span class="op">&lt;</span>S<span class="op">...&gt;)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">string_</span><span class="op">{</span>str<span class="op">[</span>S<span class="op">]...}</span></span>
<span id="cb316-8"><a href="#cb316-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb316-9"><a href="#cb316-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb316-10"><a href="#cb316-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-11"><a href="#cb316-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>String<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">)[</span>N<span class="op">]</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">string_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb316-12"><a href="#cb316-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-13"><a href="#cb316-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb316-14"><a href="#cb316-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="at">const</span> <span class="va">string_</span><span class="op">[</span>N<span class="op">];</span></span>
<span id="cb316-15"><a href="#cb316-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb317"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_seq_ut.cpp 52</span></span>
<span id="cb317-2"><a href="#cb317-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-3"><a href="#cb317-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">char</span> <span class="at">const</span> str<span class="op">[]{</span><span class="st">&quot;123&quot;</span><span class="op">};</span></span>
<span id="cb317-4"><a href="#cb317-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-5"><a href="#cb317-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> st <span class="op">=</span> seq_test2<span class="op">&lt;</span><span class="dv">4</span><span class="op">&gt;{</span>str<span class="op">,</span> index_sequence<span class="op">&lt;</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;()};</span></span>
<span id="cb317-6"><a href="#cb317-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_STREQ<span class="op">(</span><span class="st">&quot;123&quot;</span><span class="op">,</span> st<span class="op">.</span>String<span class="op">());</span></span>
<span id="cb317-7"><a href="#cb317-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-8"><a href="#cb317-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> st2 <span class="op">=</span> seq_test2<span class="op">&lt;</span><span class="dv">4</span><span class="op">&gt;{</span>str<span class="op">,</span> make_index_sequence<span class="op">&lt;</span><span class="kw">sizeof</span><span class="op">(</span>str<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;()};</span></span>
<span id="cb317-9"><a href="#cb317-9" aria-hidden="true" tabindex="-1"></a>    ASSERT_STREQ<span class="op">(</span><span class="st">&quot;123&quot;</span><span class="op">,</span> st2<span class="op">.</span>String<span class="op">());</span></span></code></pre></div>
<p>上記とほぼ同様のクラステンプレートstd::index_sequence、std::make_index_sequenceが、
utilityで定義されているため、以下ではこれらを使用する。</p>
<h4 id="staticstringの開発">StaticStringの開発
<a id="SS_13_7_6_2"></a></h4>
<p>StaticStringはすでに示したテクニックを使い、下記のように定義できる。</p>
<div class="sourceCode" id="cb318"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_static_string.h 10</span></span>
<span id="cb318-2"><a href="#cb318-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb318-3"><a href="#cb318-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb318-4"><a href="#cb318-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> StaticString <span class="op">{</span></span>
<span id="cb318-5"><a href="#cb318-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb318-6"><a href="#cb318-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> StaticString<span class="op">(</span><span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>str<span class="op">)[</span>N<span class="op">])</span> <span class="kw">noexcept</span></span>
<span id="cb318-7"><a href="#cb318-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> StaticString<span class="op">{</span><span class="dv">0</span><span class="op">,</span> str<span class="op">,</span> <span class="bu">std::</span>make_index_sequence<span class="op">&lt;</span>N <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;{}}</span></span>
<span id="cb318-8"><a href="#cb318-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb318-9"><a href="#cb318-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb318-10"><a href="#cb318-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb318-11"><a href="#cb318-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> M<span class="op">&gt;</span></span>
<span id="cb318-12"><a href="#cb318-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> StaticString<span class="op">(</span><span class="dt">size_t</span> offset<span class="op">,</span> StaticString<span class="op">&lt;</span>M<span class="op">&gt;</span> ss<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb318-13"><a href="#cb318-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> StaticString<span class="op">{</span>offset<span class="op">,</span> ss<span class="op">.</span><span class="va">string_</span><span class="op">,</span> <span class="bu">std::</span>make_index_sequence<span class="op">&lt;</span>N <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;{}}</span></span>
<span id="cb318-14"><a href="#cb318-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb318-15"><a href="#cb318-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb318-16"><a href="#cb318-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb318-17"><a href="#cb318-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> StaticString<span class="op">(</span><span class="bu">std::</span>initializer_list<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> args<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb318-18"><a href="#cb318-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> StaticString<span class="op">{</span><span class="dv">0</span><span class="op">,</span> args<span class="op">,</span> <span class="bu">std::</span>make_index_sequence<span class="op">&lt;</span>N <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;{}}</span></span>
<span id="cb318-19"><a href="#cb318-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb318-20"><a href="#cb318-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb318-21"><a href="#cb318-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb318-22"><a href="#cb318-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>String<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span><span class="op">)[</span>N<span class="op">]</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">string_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb318-23"><a href="#cb318-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="dt">size_t</span> Size<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> N<span class="op">;</span> <span class="op">}</span></span>
<span id="cb318-24"><a href="#cb318-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb318-25"><a href="#cb318-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb318-26"><a href="#cb318-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="at">const</span> <span class="va">string_</span><span class="op">[</span>N<span class="op">];</span></span>
<span id="cb318-27"><a href="#cb318-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb318-28"><a href="#cb318-28" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb318-29"><a href="#cb318-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span>Beginable T<span class="op">,</span> <span class="dt">size_t</span><span class="op">...</span> I<span class="op">&gt;</span></span>
<span id="cb318-30"><a href="#cb318-30" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb318-31"><a href="#cb318-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span><span class="op">...</span> I<span class="op">&gt;</span></span>
<span id="cb318-32"><a href="#cb318-32" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb318-33"><a href="#cb318-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// offsetは部分StaticString切り出しのため(TopStr, BottomStr)</span></span>
<span id="cb318-34"><a href="#cb318-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> StaticString<span class="op">(</span><span class="dt">size_t</span> offset<span class="op">,</span> T<span class="op">&amp;</span> t<span class="op">,</span> <span class="bu">std::</span>index_sequence<span class="op">&lt;</span>I<span class="op">...&gt;)</span> <span class="kw">noexcept</span></span>
<span id="cb318-35"><a href="#cb318-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">:</span> <span class="va">string_</span><span class="op">{</span><span class="bu">std::</span>begin<span class="op">(</span>t<span class="op">)[</span>I <span class="op">+</span> offset<span class="op">]...}</span></span>
<span id="cb318-36"><a href="#cb318-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb318-37"><a href="#cb318-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb318-38"><a href="#cb318-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb318-39"><a href="#cb318-39" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> M<span class="op">&gt;</span></span>
<span id="cb318-40"><a href="#cb318-40" aria-hidden="true" tabindex="-1"></a>        <span class="kw">friend</span> <span class="kw">class</span> StaticString<span class="op">;</span></span>
<span id="cb318-41"><a href="#cb318-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>文字列リテラルからStaticStringを生成する単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb319"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_static_string_ut.cpp 12</span></span>
<span id="cb319-2"><a href="#cb319-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-3"><a href="#cb319-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> fs <span class="op">=</span> StaticString<span class="op">{</span><span class="st">&quot;abc&quot;</span><span class="op">};</span>  <span class="co">// C++17からのNの指定は不要</span></span>
<span id="cb319-4"><a href="#cb319-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-5"><a href="#cb319-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dv">4</span><span class="op">)</span> <span class="op">==</span> fs<span class="op">.</span>Size<span class="op">());</span></span>
<span id="cb319-6"><a href="#cb319-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_STREQ<span class="op">(</span><span class="st">&quot;abc&quot;</span><span class="op">,</span> fs<span class="op">.</span>String<span class="op">());</span></span>
<span id="cb319-7"><a href="#cb319-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-8"><a href="#cb319-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 文字列不足であるため、下記はコンパイルさせない</span></span>
<span id="cb319-9"><a href="#cb319-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// constexpr StaticString&lt;4&gt; fs2{&quot;ab&quot;};</span></span></code></pre></div>
<p>また、std::initializer_list&lt;char&gt;による初期化の単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb320"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_static_string_ut.cpp 24</span></span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-3"><a href="#cb320-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> fs <span class="op">=</span> StaticString<span class="op">&lt;</span><span class="dv">4</span><span class="op">&gt;{</span><span class="ch">&#39;a&#39;</span><span class="op">,</span> <span class="ch">&#39;b&#39;</span><span class="op">,</span> <span class="ch">&#39;c&#39;</span><span class="op">};</span>  <span class="co">// C++17でもNの指定は必要</span></span>
<span id="cb320-4"><a href="#cb320-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-5"><a href="#cb320-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dv">4</span><span class="op">)</span> <span class="op">==</span> fs<span class="op">.</span>Size<span class="op">());</span></span>
<span id="cb320-6"><a href="#cb320-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_STREQ<span class="op">(</span><span class="st">&quot;abc&quot;</span><span class="op">,</span> fs<span class="op">.</span>String<span class="op">());</span></span>
<span id="cb320-7"><a href="#cb320-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-8"><a href="#cb320-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 文字列不足であるため、下記はコンパイルさせない</span></span>
<span id="cb320-9"><a href="#cb320-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// constexpr StaticString&lt;4&gt; fs2{&#39;a&#39;, &#39;b&#39;};</span></span></code></pre></div>
<p>次にこのクラスにc++17用に<code>operator==</code>とc++20用に<code>operator&lt;=&gt;</code>を追加する。</p>
<div class="sourceCode" id="cb321"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_static_string.h 52</span></span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-3"><a href="#cb321-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb321-4"><a href="#cb321-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb321-5"><a href="#cb321-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> equal_n<span class="op">(</span><span class="dt">size_t</span> n<span class="op">,</span> StaticString<span class="op">&lt;</span>N<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> StaticString<span class="op">&lt;</span>N<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb321-6"><a href="#cb321-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-7"><a href="#cb321-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb321-8"><a href="#cb321-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb321-9"><a href="#cb321-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb321-10"><a href="#cb321-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb321-11"><a href="#cb321-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> lhs<span class="op">.</span>String<span class="op">()[</span>n<span class="op">]</span> <span class="op">!=</span> rhs<span class="op">.</span>String<span class="op">()[</span>n<span class="op">]</span> <span class="op">?</span> <span class="kw">false</span> <span class="op">:</span> equal_n<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> lhs<span class="op">,</span> rhs<span class="op">);</span></span>
<span id="cb321-12"><a href="#cb321-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb321-13"><a href="#cb321-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-14"><a href="#cb321-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb321-15"><a href="#cb321-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-16"><a href="#cb321-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &lt;= 201703L  </span><span class="co">// c++17</span></span>
<span id="cb321-17"><a href="#cb321-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-18"><a href="#cb321-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>StaticString<span class="op">&lt;</span>N1<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;,</span> StaticString<span class="op">&lt;</span>N2<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;)</span> <span class="kw">noexcept</span></span>
<span id="cb321-19"><a href="#cb321-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-20"><a href="#cb321-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb321-21"><a href="#cb321-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-22"><a href="#cb321-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-23"><a href="#cb321-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-24"><a href="#cb321-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>StaticString<span class="op">&lt;</span>N1<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> StaticString<span class="op">&lt;</span>N2<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb321-25"><a href="#cb321-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-26"><a href="#cb321-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb321-27"><a href="#cb321-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-28"><a href="#cb321-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-29"><a href="#cb321-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb321-30"><a href="#cb321-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>StaticString<span class="op">&lt;</span>N<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> StaticString<span class="op">&lt;</span>N<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb321-31"><a href="#cb321-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-32"><a href="#cb321-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Inner_<span class="op">::</span>equal_n<span class="op">(</span><span class="dv">0</span><span class="op">,</span> lhs<span class="op">,</span> rhs<span class="op">);</span></span>
<span id="cb321-33"><a href="#cb321-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-34"><a href="#cb321-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-35"><a href="#cb321-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb321-36"><a href="#cb321-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>StaticString<span class="op">&lt;</span>N<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> StaticString<span class="op">&lt;</span>N<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb321-37"><a href="#cb321-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-38"><a href="#cb321-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb321-39"><a href="#cb321-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-40"><a href="#cb321-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-41"><a href="#cb321-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-42"><a href="#cb321-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>StaticString<span class="op">&lt;</span>N1<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> <span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>rhs<span class="op">)[</span>N2<span class="op">])</span> <span class="kw">noexcept</span></span>
<span id="cb321-43"><a href="#cb321-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-44"><a href="#cb321-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lhs <span class="op">==</span> StaticString<span class="op">{</span>rhs<span class="op">};</span></span>
<span id="cb321-45"><a href="#cb321-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-46"><a href="#cb321-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-47"><a href="#cb321-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-48"><a href="#cb321-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span>StaticString<span class="op">&lt;</span>N1<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> <span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>rhs<span class="op">)[</span>N2<span class="op">])</span> <span class="kw">noexcept</span></span>
<span id="cb321-49"><a href="#cb321-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-50"><a href="#cb321-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb321-51"><a href="#cb321-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-52"><a href="#cb321-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-53"><a href="#cb321-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-54"><a href="#cb321-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>lhs<span class="op">)[</span>N1<span class="op">],</span> StaticString<span class="op">&lt;</span>N2<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb321-55"><a href="#cb321-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-56"><a href="#cb321-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> StaticString<span class="op">{</span>lhs<span class="op">}</span> <span class="op">==</span> rhs<span class="op">;</span></span>
<span id="cb321-57"><a href="#cb321-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-58"><a href="#cb321-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-59"><a href="#cb321-59" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-60"><a href="#cb321-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span><span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>lhs<span class="op">)[</span>N1<span class="op">],</span> StaticString<span class="op">&lt;</span>N2<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb321-61"><a href="#cb321-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-62"><a href="#cb321-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">);</span></span>
<span id="cb321-63"><a href="#cb321-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-64"><a href="#cb321-64" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#elif </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb321-65"><a href="#cb321-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 以下、operator==とoperator!=を&lt;=&gt;に置き換え</span></span>
<span id="cb321-66"><a href="#cb321-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-67"><a href="#cb321-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>StaticString<span class="op">&lt;</span>N1<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> StaticString<span class="op">&lt;</span>N2<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb321-68"><a href="#cb321-68" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-69"><a href="#cb321-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>N1 <span class="op">!=</span> N2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb321-70"><a href="#cb321-70" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> N1 <span class="op">&lt;=&gt;</span> N2<span class="op">;</span>  <span class="co">// サイズが異なる場合は直接サイズを比較</span></span>
<span id="cb321-71"><a href="#cb321-71" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb321-72"><a href="#cb321-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb321-73"><a href="#cb321-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">std::</span>lexicographical_compare_three_way<span class="op">(</span>lhs<span class="op">.</span>String<span class="op">(),</span> lhs<span class="op">.</span>String<span class="op">()</span> <span class="op">+</span> N1 <span class="op">-</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb321-74"><a href="#cb321-74" aria-hidden="true" tabindex="-1"></a>                                                          rhs<span class="op">.</span>String<span class="op">(),</span> rhs<span class="op">.</span>String<span class="op">()</span> <span class="op">+</span> N2 <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb321-75"><a href="#cb321-75" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb321-76"><a href="#cb321-76" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-77"><a href="#cb321-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-78"><a href="#cb321-78" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-79"><a href="#cb321-79" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>StaticString<span class="op">&lt;</span>N1<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> <span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>rhs<span class="op">)[</span>N2<span class="op">])</span> <span class="kw">noexcept</span></span>
<span id="cb321-80"><a href="#cb321-80" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-81"><a href="#cb321-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lhs <span class="op">&lt;=&gt;</span> StaticString<span class="op">{</span>rhs<span class="op">};</span></span>
<span id="cb321-82"><a href="#cb321-82" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-83"><a href="#cb321-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-84"><a href="#cb321-84" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-85"><a href="#cb321-85" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span><span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>lhs<span class="op">)[</span>N1<span class="op">],</span> StaticString<span class="op">&lt;</span>N2<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb321-86"><a href="#cb321-86" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-87"><a href="#cb321-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> StaticString<span class="op">{</span>lhs<span class="op">}</span> <span class="op">&lt;=&gt;</span> rhs<span class="op">;</span></span>
<span id="cb321-88"><a href="#cb321-88" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-89"><a href="#cb321-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-90"><a href="#cb321-90" aria-hidden="true" tabindex="-1"></a>    <span class="co">// operator==は明示的に定義する必要がある（&lt;=&gt;からは自動生成されない）</span></span>
<span id="cb321-91"><a href="#cb321-91" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-92"><a href="#cb321-92" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>StaticString<span class="op">&lt;</span>N1<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> StaticString<span class="op">&lt;</span>N2<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb321-93"><a href="#cb321-93" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-94"><a href="#cb321-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>lhs <span class="op">&lt;=&gt;</span> rhs<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb321-95"><a href="#cb321-95" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-96"><a href="#cb321-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-97"><a href="#cb321-97" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-98"><a href="#cb321-98" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>StaticString<span class="op">&lt;</span>N1<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> <span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>rhs<span class="op">)[</span>N2<span class="op">])</span> <span class="kw">noexcept</span></span>
<span id="cb321-99"><a href="#cb321-99" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-100"><a href="#cb321-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lhs <span class="op">==</span> StaticString<span class="op">{</span>rhs<span class="op">};</span></span>
<span id="cb321-101"><a href="#cb321-101" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-102"><a href="#cb321-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-103"><a href="#cb321-103" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb321-104"><a href="#cb321-104" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>lhs<span class="op">)[</span>N1<span class="op">],</span> StaticString<span class="op">&lt;</span>N2<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb321-105"><a href="#cb321-105" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb321-106"><a href="#cb321-106" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> StaticString<span class="op">{</span>lhs<span class="op">}</span> <span class="op">==</span> rhs<span class="op">;</span></span>
<span id="cb321-107"><a href="#cb321-107" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-108"><a href="#cb321-108" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span></code></pre></div>
<p>単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb322"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_static_string_ut.cpp 70</span></span>
<span id="cb322-2"><a href="#cb322-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-3"><a href="#cb322-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>StaticString<span class="op">{</span><span class="st">&quot;123&quot;</span><span class="op">}</span> <span class="op">==</span> StaticString<span class="op">{</span><span class="st">&quot;123&quot;</span><span class="op">});</span></span>
<span id="cb322-4"><a href="#cb322-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>StaticString<span class="op">{</span><span class="st">&quot;123&quot;</span><span class="op">}</span> <span class="op">!=</span> StaticString<span class="op">{</span><span class="st">&quot;1234&quot;</span><span class="op">});</span></span>
<span id="cb322-5"><a href="#cb322-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>StaticString<span class="op">{</span><span class="st">&quot;123&quot;</span><span class="op">}</span> <span class="op">==</span> <span class="st">&quot;123&quot;</span><span class="op">);</span></span>
<span id="cb322-6"><a href="#cb322-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="st">&quot;123&quot;</span> <span class="op">==</span> StaticString<span class="op">{</span><span class="st">&quot;123&quot;</span><span class="op">});</span></span>
<span id="cb322-7"><a href="#cb322-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>StaticString<span class="op">{</span><span class="st">&quot;123&quot;</span><span class="op">}</span> <span class="op">!=</span> <span class="st">&quot;1234&quot;</span><span class="op">);</span></span>
<span id="cb322-8"><a href="#cb322-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="st">&quot;1234&quot;</span> <span class="op">!=</span> StaticString<span class="op">{</span><span class="st">&quot;123&quot;</span><span class="op">});</span></span></code></pre></div>
<p><a
href="term_explanation.html#SS_19_13_1">暗黙の型変換</a>を利用した文字列リテラルからStaticStringオブジェクトへの変換は、
StaticStringがテンプレートであるため機能せず、上記のように書く必要がある。</p>
<p>同様にoperator + を追加する。</p>
<div class="sourceCode" id="cb323"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_static_string.h 161</span></span>
<span id="cb323-2"><a href="#cb323-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb323-3"><a href="#cb323-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb323-4"><a href="#cb323-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span><span class="op">...</span> I1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">,</span> <span class="dt">size_t</span><span class="op">...</span> I2<span class="op">&gt;</span></span>
<span id="cb323-5"><a href="#cb323-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> StaticString<span class="op">&lt;</span>N1 <span class="op">+</span> N2 <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;</span> concat<span class="op">(</span><span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>str1<span class="op">)[</span>N1<span class="op">],</span> <span class="bu">std::</span>index_sequence<span class="op">&lt;</span>I1<span class="op">...&gt;,</span></span>
<span id="cb323-6"><a href="#cb323-6" aria-hidden="true" tabindex="-1"></a>                                               <span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>str2<span class="op">)[</span>N2<span class="op">],</span></span>
<span id="cb323-7"><a href="#cb323-7" aria-hidden="true" tabindex="-1"></a>                                               <span class="bu">std::</span>index_sequence<span class="op">&lt;</span>I2<span class="op">...&gt;)</span> <span class="kw">noexcept</span></span>
<span id="cb323-8"><a href="#cb323-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb323-9"><a href="#cb323-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>str1<span class="op">[</span>I1<span class="op">]...,</span> str2<span class="op">[</span>I2<span class="op">]...};</span></span>
<span id="cb323-10"><a href="#cb323-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb323-11"><a href="#cb323-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb323-12"><a href="#cb323-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb323-13"><a href="#cb323-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb323-14"><a href="#cb323-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+(</span>StaticString<span class="op">&lt;</span>N1<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> StaticString<span class="op">&lt;</span>N2<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb323-15"><a href="#cb323-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb323-16"><a href="#cb323-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Inner_<span class="op">::</span>concat<span class="op">(</span>lhs<span class="op">.</span>String<span class="op">(),</span> <span class="bu">std::</span>make_index_sequence<span class="op">&lt;</span>N1 <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;{},</span> rhs<span class="op">.</span>String<span class="op">(),</span></span>
<span id="cb323-17"><a href="#cb323-17" aria-hidden="true" tabindex="-1"></a>                              <span class="bu">std::</span>make_index_sequence<span class="op">&lt;</span>N2<span class="op">&gt;{});</span></span>
<span id="cb323-18"><a href="#cb323-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb323-19"><a href="#cb323-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb323-20"><a href="#cb323-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb323-21"><a href="#cb323-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+(</span>StaticString<span class="op">&lt;</span>N1<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> lhs<span class="op">,</span> <span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>rhs<span class="op">)[</span>N2<span class="op">])</span> <span class="kw">noexcept</span></span>
<span id="cb323-22"><a href="#cb323-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb323-23"><a href="#cb323-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> lhs <span class="op">+</span> StaticString<span class="op">{</span>rhs<span class="op">};</span></span>
<span id="cb323-24"><a href="#cb323-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb323-25"><a href="#cb323-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb323-26"><a href="#cb323-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N1<span class="op">,</span> <span class="dt">size_t</span> N2<span class="op">&gt;</span></span>
<span id="cb323-27"><a href="#cb323-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+(</span><span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>lhs<span class="op">)[</span>N1<span class="op">],</span> StaticString<span class="op">&lt;</span>N2<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb323-28"><a href="#cb323-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb323-29"><a href="#cb323-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> StaticString<span class="op">{</span>lhs<span class="op">}</span> <span class="op">+</span> rhs<span class="op">;</span></span>
<span id="cb323-30"><a href="#cb323-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb324"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_static_string_ut.cpp 83</span></span>
<span id="cb324-2"><a href="#cb324-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-3"><a href="#cb324-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> fs0 <span class="op">=</span> StaticString<span class="op">{</span><span class="st">&quot;1234&quot;</span><span class="op">}</span> <span class="op">+</span> StaticString<span class="op">{</span><span class="st">&quot;567&quot;</span><span class="op">};</span></span>
<span id="cb324-4"><a href="#cb324-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>StaticString<span class="op">&lt;</span>fs0<span class="op">.</span>Size<span class="op">()&gt;</span> <span class="at">const</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>fs0<span class="op">)&gt;);</span></span>
<span id="cb324-5"><a href="#cb324-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="st">&quot;1234567&quot;</span> <span class="op">==</span> fs0<span class="op">);</span></span>
<span id="cb324-6"><a href="#cb324-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-7"><a href="#cb324-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> fs1 <span class="op">=</span> StaticString<span class="op">{</span><span class="st">&quot;1234&quot;</span><span class="op">}</span> <span class="op">+</span> <span class="st">&quot;:&quot;</span><span class="op">;</span></span>
<span id="cb324-8"><a href="#cb324-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>StaticString<span class="op">&lt;</span>fs1<span class="op">.</span>Size<span class="op">()&gt;</span> <span class="at">const</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>fs1<span class="op">)&gt;);</span></span>
<span id="cb324-9"><a href="#cb324-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="st">&quot;1234:&quot;</span> <span class="op">==</span> fs1<span class="op">);</span></span>
<span id="cb324-10"><a href="#cb324-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-11"><a href="#cb324-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> fs2 <span class="op">=</span> <span class="st">&quot;:&quot;</span> <span class="op">+</span> StaticString<span class="op">{</span><span class="st">&quot;567&quot;</span><span class="op">};</span></span>
<span id="cb324-12"><a href="#cb324-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>StaticString<span class="op">&lt;</span>fs2<span class="op">.</span>Size<span class="op">()&gt;</span> <span class="at">const</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>fs2<span class="op">)&gt;);</span></span>
<span id="cb324-13"><a href="#cb324-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="st">&quot;:567&quot;</span> <span class="op">==</span> fs2<span class="op">);</span></span>
<span id="cb324-14"><a href="#cb324-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-15"><a href="#cb324-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> fs3 <span class="op">=</span> StaticString<span class="op">{</span><span class="st">&quot;1234&quot;</span><span class="op">}</span> <span class="op">+</span> <span class="st">&quot;:&quot;</span> <span class="op">+</span> StaticString<span class="op">{</span><span class="st">&quot;567&quot;</span><span class="op">};</span></span>
<span id="cb324-16"><a href="#cb324-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>StaticString<span class="op">&lt;</span>fs3<span class="op">.</span>Size<span class="op">()&gt;</span> <span class="at">const</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>fs3<span class="op">)&gt;);</span></span>
<span id="cb324-17"><a href="#cb324-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="st">&quot;1234:567&quot;</span> <span class="op">==</span> fs3<span class="op">);</span></span></code></pre></div>
<p>以上でstd::stringのように=、==、+などの演算が可能となった。
さらに下記の関数を追加することで、任意の位置、
任意のサイズの文字列を切り出せるようにすることでStaticStringはより便利に使用できるようになる。</p>
<div class="sourceCode" id="cb325"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_static_string.h 192</span></span>
<span id="cb325-2"><a href="#cb325-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-3"><a href="#cb325-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> SIZE<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span>  <span class="co">// StaticString&lt;SiZE&gt;の部分文字列生成</span></span>
<span id="cb325-4"><a href="#cb325-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> TopStr<span class="op">(</span>StaticString<span class="op">&lt;</span>N<span class="op">&gt;</span> ss<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb325-5"><a href="#cb325-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb325-6"><a href="#cb325-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> StaticString<span class="op">&lt;</span>SIZE <span class="op">+</span> <span class="dv">1</span><span class="op">&gt;{</span><span class="dv">0</span><span class="op">,</span> ss<span class="op">};</span>  <span class="co">// SIZE文字 + 終端文字</span></span>
<span id="cb325-7"><a href="#cb325-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb325-8"><a href="#cb325-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb325-9"><a href="#cb325-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> OFFSET<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span>  <span class="co">// 先頭からオフセット2文字～終端文字まで</span></span>
<span id="cb325-10"><a href="#cb325-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> BottomStr<span class="op">(</span>StaticString<span class="op">&lt;</span>N<span class="op">&gt;</span> ss<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb325-11"><a href="#cb325-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb325-12"><a href="#cb325-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> StaticString<span class="op">&lt;</span>N <span class="op">-</span> OFFSET<span class="op">&gt;{</span>OFFSET<span class="op">,</span> ss<span class="op">};</span></span>
<span id="cb325-13"><a href="#cb325-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb326"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_static_string_ut.cpp 53</span></span>
<span id="cb326-2"><a href="#cb326-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb326-3"><a href="#cb326-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> ss  <span class="op">=</span> StaticString<span class="op">{</span><span class="st">&quot;0123456789&quot;</span><span class="op">};</span></span>
<span id="cb326-4"><a href="#cb326-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>           ss2 <span class="op">=</span> TopStr<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;(</span>ss<span class="op">);</span>  <span class="co">// 先頭2文字</span></span>
<span id="cb326-5"><a href="#cb326-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">3</span> <span class="op">==</span> ss2<span class="op">.</span>Size<span class="op">());</span>      <span class="co">// 先頭2文字 + 終端文字</span></span>
<span id="cb326-6"><a href="#cb326-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_STREQ<span class="op">(</span><span class="st">&quot;01&quot;</span><span class="op">,</span> ss2<span class="op">.</span>String<span class="op">());</span></span>
<span id="cb326-7"><a href="#cb326-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb326-8"><a href="#cb326-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ss8 <span class="op">=</span> BottomStr<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;(</span>ss<span class="op">);</span>  <span class="co">// 先頭からオフセット2文字～終端文字まで</span></span>
<span id="cb326-9"><a href="#cb326-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="dv">9</span> <span class="op">==</span> ss8<span class="op">.</span>Size<span class="op">());</span>  <span class="co">// 先頭からオフセット2文字～終端文字までは結果的に9文字</span></span>
<span id="cb326-10"><a href="#cb326-10" aria-hidden="true" tabindex="-1"></a>    ASSERT_STREQ<span class="op">(</span><span class="st">&quot;23456789&quot;</span><span class="op">,</span> ss8<span class="op">.</span>String<span class="op">());</span></span>
<span id="cb326-11"><a href="#cb326-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb326-12"><a href="#cb326-12" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span>ss2 <span class="op">+</span> ss8<span class="op">,</span> ss<span class="op">);</span>  <span class="co">// 元に戻す。+、= が使用される。</span></span></code></pre></div>
<h4
id="整数をstaticstringに変換する関数の開発">整数をStaticStringに変換する関数の開発
<a id="SS_13_7_6_3"></a></h4>
<p>コンパイル時に__LINE__をStaticStringに変換できれば、
ファイル位置をStaticStringで表現できるため、
ここではその変換関数Int2StaticString&lt;&gt;()の実装を行う。</p>
<p>行番号を10進数での文字列で表現するため、いくつかのヘルパ関数を下記のように定義する。</p>
<div class="sourceCode" id="cb327"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_static_string_num.h 8</span></span>
<span id="cb327-2"><a href="#cb327-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-3"><a href="#cb327-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb327-4"><a href="#cb327-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-5"><a href="#cb327-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 10進数桁数を返す</span></span>
<span id="cb327-6"><a href="#cb327-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">size_t</span> num_of_digits<span class="op">(</span><span class="dt">size_t</span> n<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> n <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">+</span> num_of_digits<span class="op">(</span>n <span class="op">/</span> <span class="dv">10</span><span class="op">)</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb327-7"><a href="#cb327-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-8"><a href="#cb327-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 10のn乗を返す</span></span>
<span id="cb327-9"><a href="#cb327-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint32_t</span> ten_to_nth_power<span class="op">(</span><span class="dt">uint32_t</span> n<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb327-10"><a href="#cb327-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb327-11"><a href="#cb327-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">10</span> <span class="op">*</span> ten_to_nth_power<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb327-12"><a href="#cb327-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb327-13"><a href="#cb327-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-14"><a href="#cb327-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 10進数の桁の若い順番に左から並べなおす(12345 -&gt; 54321)</span></span>
<span id="cb327-15"><a href="#cb327-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">uint32_t</span> reverse_num<span class="op">(</span><span class="dt">uint32_t</span> num<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb327-16"><a href="#cb327-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb327-17"><a href="#cb327-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> num <span class="op">!=</span> <span class="dv">0</span> <span class="op">?</span> <span class="op">(</span>num <span class="op">%</span> <span class="dv">10</span><span class="op">)</span> <span class="op">*</span> ten_to_nth_power<span class="op">(</span>num_of_digits<span class="op">(</span>num<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> reverse_num<span class="op">(</span>num <span class="op">/</span> <span class="dv">10</span><span class="op">)</span></span>
<span id="cb327-18"><a href="#cb327-18" aria-hidden="true" tabindex="-1"></a>                        <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb327-19"><a href="#cb327-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb327-20"><a href="#cb327-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-21"><a href="#cb327-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 10進数一桁をacsii文字に変換</span></span>
<span id="cb327-22"><a href="#cb327-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">char</span> digit_to_char<span class="op">(</span><span class="dt">uint32_t</span> num<span class="op">,</span> <span class="dt">uint32_t</span> n_th<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb327-23"><a href="#cb327-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb327-24"><a href="#cb327-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="ch">&#39;0&#39;</span> <span class="op">+</span> <span class="op">(</span>num <span class="op">%</span> <span class="op">(</span>ten_to_nth_power<span class="op">(</span>n_th <span class="op">+</span> <span class="dv">1</span><span class="op">)))</span> <span class="op">/</span> ten_to_nth_power<span class="op">(</span>n_th<span class="op">);</span></span>
<span id="cb327-25"><a href="#cb327-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb327-26"><a href="#cb327-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-27"><a href="#cb327-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Int2StaticStringのヘルパ関数</span></span>
<span id="cb327-28"><a href="#cb327-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">,</span> <span class="dt">size_t</span><span class="op">...</span> Cs<span class="op">&gt;</span></span>
<span id="cb327-29"><a href="#cb327-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> StaticString<span class="op">&lt;</span>num_of_digits<span class="op">(</span>N<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">&gt;</span> make_static_string<span class="op">(</span><span class="bu">std::</span>index_sequence<span class="op">&lt;</span>Cs<span class="op">...&gt;)</span> <span class="kw">noexcept</span></span>
<span id="cb327-30"><a href="#cb327-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb327-31"><a href="#cb327-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>digit_to_char<span class="op">(</span>reverse_num<span class="op">(</span>N<span class="op">),</span> Cs<span class="op">)...};</span></span>
<span id="cb327-32"><a href="#cb327-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb327-33"><a href="#cb327-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span></code></pre></div>
<p>単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb328"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_static_string_num_ut.cpp 47</span></span>
<span id="cb328-2"><a href="#cb328-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb328-3"><a href="#cb328-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> ns</span>
<span id="cb328-4"><a href="#cb328-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">=</span> make_static_string<span class="op">&lt;</span><span class="ot">__LINE__</span><span class="op">&gt;(</span><span class="bu">std::</span>make_index_sequence<span class="op">&lt;</span>Inner_<span class="op">::</span>num_of_digits<span class="op">(</span><span class="ot">__LINE__</span><span class="op">)&gt;());</span></span>
<span id="cb328-5"><a href="#cb328-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> line_num <span class="op">=</span> <span class="ot">__LINE__</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb328-6"><a href="#cb328-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb328-7"><a href="#cb328-7" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>to_string<span class="op">(</span>line_num<span class="op">),</span> ns<span class="op">.</span>String<span class="op">());</span></span></code></pre></div>
<p>このままでは使いづらいため、これをラッピングした関数を下記のように定義することで、
Int2StaticString&lt;&gt;()が得られる。</p>
<div class="sourceCode" id="cb329"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_static_string_num.h 42</span></span>
<span id="cb329-2"><a href="#cb329-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-3"><a href="#cb329-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb329-4"><a href="#cb329-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> StaticString<span class="op">&lt;</span>Inner_<span class="op">::</span>num_of_digits<span class="op">(</span>N<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">&gt;</span> Int2StaticString<span class="op">()</span> <span class="kw">noexcept</span></span>
<span id="cb329-5"><a href="#cb329-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb329-6"><a href="#cb329-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Inner_<span class="op">::</span>make_static_string<span class="op">&lt;</span>N<span class="op">&gt;(</span><span class="bu">std::</span>make_index_sequence<span class="op">&lt;</span>Inner_<span class="op">::</span>num_of_digits<span class="op">(</span>N<span class="op">)&gt;());</span></span>
<span id="cb329-7"><a href="#cb329-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb330"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template/nstd_static_string_num_ut.cpp 66</span></span>
<span id="cb330-2"><a href="#cb330-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-3"><a href="#cb330-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="kw">auto</span> ns       <span class="op">=</span> Int2StaticString<span class="op">&lt;</span><span class="ot">__LINE__</span><span class="op">&gt;();</span></span>
<span id="cb330-4"><a href="#cb330-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>           line_num <span class="op">=</span> <span class="ot">__LINE__</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb330-5"><a href="#cb330-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-6"><a href="#cb330-6" aria-hidden="true" tabindex="-1"></a>    ASSERT_EQ<span class="op">(</span><span class="bu">std::</span>to_string<span class="op">(</span>line_num<span class="op">),</span> ns<span class="op">.</span>String<span class="op">());</span></span></code></pre></div>
<h4
id="ファイル位置を静的に保持したエクセプションクラスの開発">ファイル位置を静的に保持したエクセプションクラスの開発
<a id="SS_13_7_6_4"></a></h4>
<p>「<a
href="template_meta_programming.html#SS_13_7_6">静的な文字列オブジェクト</a>」で見たように、
ファイル位置を動的に保持するエクセプションクラスは使い勝手が悪い。
ここでは、その問題を解決するためのExceptionクラスの実装を示す。</p>
<div class="sourceCode" id="cb331"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb331-1"><a href="#cb331-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_exception.h 11</span></span>
<span id="cb331-2"><a href="#cb331-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb331-3"><a href="#cb331-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@class</span><span class="co"> </span><span class="cv">Exception</span></span>
<span id="cb331-4"><a href="#cb331-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> StaticString&lt;&gt;を使ったエクセプションクラス</span></span>
<span id="cb331-5"><a href="#cb331-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">///        下記のMAKE_EXCEPTIONを使い生成</span></span>
<span id="cb331-6"><a href="#cb331-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@tparam</span><span class="co"> </span><span class="cv">E</span><span class="co">   std::exceptionから派生したエクセプションクラス</span></span>
<span id="cb331-7"><a href="#cb331-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@tparam</span><span class="co"> </span><span class="cv">N</span><span class="co">   StaticString</span><span class="kw">&lt;N&gt;</span></span>
<span id="cb331-8"><a href="#cb331-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> E<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb331-9"><a href="#cb331-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb331-10"><a href="#cb331-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="bu">std::</span>derived_from<span class="op">&lt;</span>E<span class="op">,</span> <span class="bu">std::</span>exception<span class="op">&gt;</span></span>
<span id="cb331-11"><a href="#cb331-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb331-12"><a href="#cb331-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Exception <span class="op">:</span> <span class="kw">public</span> E <span class="op">{</span></span>
<span id="cb331-13"><a href="#cb331-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb331-14"><a href="#cb331-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>exception<span class="op">,</span> E<span class="op">&gt;);</span></span>
<span id="cb331-15"><a href="#cb331-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb331-16"><a href="#cb331-16" aria-hidden="true" tabindex="-1"></a>        Exception<span class="op">(</span>StaticString<span class="op">&lt;</span>N<span class="op">&gt;</span> <span class="at">const</span><span class="op">&amp;</span> what_str<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">what_str_</span><span class="op">{</span>what_str<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb331-17"><a href="#cb331-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="at">const</span><span class="op">*</span> what<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">what_str_</span><span class="op">.</span>String<span class="op">();</span> <span class="op">}</span></span>
<span id="cb331-18"><a href="#cb331-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb331-19"><a href="#cb331-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb331-20"><a href="#cb331-20" aria-hidden="true" tabindex="-1"></a>        StaticString<span class="op">&lt;</span>N<span class="op">&gt;</span> <span class="at">const</span> <span class="va">what_str_</span><span class="op">;</span></span>
<span id="cb331-21"><a href="#cb331-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>StaticStringと同様に、このままでは不便であるため、下記の関数を定義する。</p>
<div class="sourceCode" id="cb332"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb332-1"><a href="#cb332-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_exception.h 33</span></span>
<span id="cb332-2"><a href="#cb332-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb332-3"><a href="#cb332-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">namespace</span> Inner_ <span class="op">{</span></span>
<span id="cb332-4"><a href="#cb332-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> E<span class="op">,</span> <span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span><span class="op">&gt;</span> <span class="kw">class</span> STATIC_STR<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb332-5"><a href="#cb332-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb332-6"><a href="#cb332-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="bu">std::</span>derived_from<span class="op">&lt;</span>E<span class="op">,</span> <span class="bu">std::</span>exception<span class="op">&gt;</span></span>
<span id="cb332-7"><a href="#cb332-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb332-8"><a href="#cb332-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> make_exception<span class="op">(</span>STATIC_STR<span class="op">&lt;</span>N<span class="op">&gt;</span> exception_str<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> Exception<span class="op">&lt;</span>E<span class="op">,</span> N<span class="op">&gt;{</span>exception_str<span class="op">};</span> <span class="op">}</span></span>
<span id="cb332-9"><a href="#cb332-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>  <span class="co">// namespace Inner_</span></span>
<span id="cb332-10"><a href="#cb332-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb332-11"><a href="#cb332-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> E<span class="op">,</span> <span class="dt">size_t</span> LINE_NUM<span class="op">,</span> <span class="dt">size_t</span> F_N<span class="op">,</span> <span class="dt">size_t</span> M_N<span class="op">&gt;</span></span>
<span id="cb332-12"><a href="#cb332-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L  </span><span class="co">// c++20</span></span>
<span id="cb332-13"><a href="#cb332-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="bu">std::</span>derived_from<span class="op">&lt;</span>E<span class="op">,</span> <span class="bu">std::</span>exception<span class="op">&gt;</span></span>
<span id="cb332-14"><a href="#cb332-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb332-15"><a href="#cb332-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> MakeException<span class="op">(</span><span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>filename<span class="op">)[</span>F_N<span class="op">],</span> <span class="dt">char</span> <span class="at">const</span> <span class="op">(&amp;</span>msg<span class="op">)[</span>M_N<span class="op">])</span> <span class="kw">noexcept</span></span>
<span id="cb332-16"><a href="#cb332-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb332-17"><a href="#cb332-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Inner_<span class="op">::</span>make_exception<span class="op">&lt;</span>E<span class="op">&gt;(</span>StaticString<span class="op">{</span>filename<span class="op">}</span> <span class="op">+</span> <span class="st">&quot;:&quot;</span> <span class="op">+</span> Int2StaticString<span class="op">&lt;</span>LINE_NUM<span class="op">&gt;()</span></span>
<span id="cb332-18"><a href="#cb332-18" aria-hidden="true" tabindex="-1"></a>                                         <span class="op">+</span> <span class="st">&quot;:&quot;</span> <span class="op">+</span> msg<span class="op">);</span></span>
<span id="cb332-19"><a href="#cb332-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb333"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb333-1"><a href="#cb333-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_exception_ut.cpp 89</span></span>
<span id="cb333-2"><a href="#cb333-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb333-3"><a href="#cb333-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> caught   <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb333-4"><a href="#cb333-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> line_num <span class="op">=</span> <span class="ot">__LINE__</span> <span class="op">+</span> <span class="dv">2</span><span class="op">;</span>  <span class="co">// 2行下の行番号</span></span>
<span id="cb333-5"><a href="#cb333-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb333-6"><a href="#cb333-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> MakeException<span class="op">&lt;</span><span class="bu">std::</span>exception<span class="op">,</span> <span class="ot">__LINE__</span><span class="op">&gt;(</span><span class="ot">__FILE__</span><span class="op">,</span> <span class="st">&quot;some error message&quot;</span><span class="op">);</span></span>
<span id="cb333-7"><a href="#cb333-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb333-8"><a href="#cb333-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception <span class="at">const</span><span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span></span>
<span id="cb333-9"><a href="#cb333-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb333-10"><a href="#cb333-10" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> <span class="ot">__FILE__</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;:&quot;</span> <span class="op">&lt;&lt;</span> line_num <span class="op">&lt;&lt;</span> <span class="st">&quot;:some error message&quot;</span><span class="op">;</span></span>
<span id="cb333-11"><a href="#cb333-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb333-12"><a href="#cb333-12" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>oss<span class="op">.</span>str<span class="op">(),</span> e<span class="op">.</span>what<span class="op">());</span></span>
<span id="cb333-13"><a href="#cb333-13" aria-hidden="true" tabindex="-1"></a>        caught <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb333-14"><a href="#cb333-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb333-15"><a href="#cb333-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb333-16"><a href="#cb333-16" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>caught<span class="op">);</span></span></code></pre></div>
<p>Exceptionクラスの利便性をさらに高めるため、下記の定義を行う。</p>
<div class="sourceCode" id="cb334"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb334-1"><a href="#cb334-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/h/nstd_exception.h 55</span></span>
<span id="cb334-2"><a href="#cb334-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb334-3"><a href="#cb334-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define MAKE_EXCEPTION</span><span class="op">(</span>E__<span class="op">,</span><span class="pp"> </span><span class="va">msg__</span><span class="op">)</span><span class="pp"> </span>Nstd<span class="op">::</span>MakeException<span class="op">&lt;</span>E__<span class="op">,</span><span class="pp"> </span><span class="ot">__LINE__</span><span class="op">&gt;(</span><span class="ot">__FILE__</span><span class="op">,</span><span class="pp"> </span><span class="va">msg__</span><span class="op">)</span></span></code></pre></div>
<p>上記は、関数型マクロの数少ない使いどころである。</p>
<p>単体テストは下記のようになる。</p>
<div class="sourceCode" id="cb335"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb335-1"><a href="#cb335-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_exception_ut.cpp 109</span></span>
<span id="cb335-2"><a href="#cb335-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb335-3"><a href="#cb335-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint32_t</span> line_num_div<span class="op">;</span>  <span class="co">// エクセプション行を指定</span></span>
<span id="cb335-4"><a href="#cb335-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb335-5"><a href="#cb335-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> div<span class="op">(</span><span class="dt">int32_t</span> a<span class="op">,</span> <span class="dt">int32_t</span> b<span class="op">)</span></span>
<span id="cb335-6"><a href="#cb335-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb335-7"><a href="#cb335-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>b <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb335-8"><a href="#cb335-8" aria-hidden="true" tabindex="-1"></a>            line_num_div <span class="op">=</span> <span class="ot">__LINE__</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// 次の行番号</span></span>
<span id="cb335-9"><a href="#cb335-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span> MAKE_EXCEPTION<span class="op">(</span><span class="bu">std::</span>exception<span class="op">,</span> <span class="st">&quot;divided by 0&quot;</span><span class="op">);</span></span>
<span id="cb335-10"><a href="#cb335-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb335-11"><a href="#cb335-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb335-12"><a href="#cb335-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">/</span> b<span class="op">;</span></span>
<span id="cb335-13"><a href="#cb335-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb336"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb336-1"><a href="#cb336-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/nstd_exception_ut.cpp 126</span></span>
<span id="cb336-2"><a href="#cb336-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-3"><a href="#cb336-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> caught <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb336-4"><a href="#cb336-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-5"><a href="#cb336-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb336-6"><a href="#cb336-6" aria-hidden="true" tabindex="-1"></a>        div<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb336-7"><a href="#cb336-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb336-8"><a href="#cb336-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">catch</span> <span class="op">(</span><span class="bu">std::</span>exception <span class="at">const</span><span class="op">&amp;</span> e<span class="op">)</span> <span class="op">{</span>  <span class="co">// リファレンスでcatchしなければならない</span></span>
<span id="cb336-9"><a href="#cb336-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> oss <span class="op">=</span> <span class="bu">std::</span>ostringstream<span class="op">{};</span></span>
<span id="cb336-10"><a href="#cb336-10" aria-hidden="true" tabindex="-1"></a>        oss <span class="op">&lt;&lt;</span> <span class="ot">__FILE__</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;:&quot;</span> <span class="op">&lt;&lt;</span> line_num_div <span class="op">&lt;&lt;</span> <span class="st">&quot;:divided by 0&quot;</span><span class="op">;</span></span>
<span id="cb336-11"><a href="#cb336-11" aria-hidden="true" tabindex="-1"></a>        ASSERT_EQ<span class="op">(</span>oss<span class="op">.</span>str<span class="op">(),</span> e<span class="op">.</span>what<span class="op">());</span></span>
<span id="cb336-12"><a href="#cb336-12" aria-hidden="true" tabindex="-1"></a>        caught <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb336-13"><a href="#cb336-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb336-14"><a href="#cb336-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-15"><a href="#cb336-15" aria-hidden="true" tabindex="-1"></a>    ASSERT_TRUE<span class="op">(</span>caught<span class="op">);</span></span></code></pre></div>
<h3
id="関数型をテンプレートパラメータで使う">関数型をテンプレートパラメータで使う
<a id="SS_13_7_7"></a></h3>
<p>ここで使う「関数型」とは、</p>
<ul>
<li>関数へのポインタの型</li>
<li>クロージャの型、もしくはラムダ式の型</li>
<li>関数オブジェクトの型</li>
</ul>
<p>の総称を指す。</p>
<p>std::unique_ptrは、</p>
<ul>
<li>第1パラメータにポインタの型</li>
<li>第2パラメータにそのポインタの解放用の関数ポインタの型</li>
</ul>
<p>を取ることができるが、通常は第2パラメータは省略される。
省略時にはstd::default_deleteが割り当てられ、そのオブジェクトによって、
第1パラメータに対応するポインタがdeleteされる。</p>
<p>下記コードではこの第2パラメータにstd::freeのポインタの型を与え、
それから生成されるstd::unique_ptrオブジェクトを、</p>
<ul>
<li>abi::__cxa_demangleがstd::mallocで取得したchar型ポインタ</li>
<li>std::freeのポインタ</li>
</ul>
<p>で初期化することでメモリの解放を行っている。</p>
<div class="sourceCode" id="cb337"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb337-1"><a href="#cb337-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/nstd_type2str.h 18</span></span>
<span id="cb337-2"><a href="#cb337-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb337-3"><a href="#cb337-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> demangled <span class="op">=</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="kw">decltype</span><span class="op">(&amp;</span><span class="bu">std::</span>free<span class="op">)&gt;{</span></span>
<span id="cb337-4"><a href="#cb337-4" aria-hidden="true" tabindex="-1"></a>        abi<span class="op">::</span>__cxa_demangle<span class="op">(</span>to_demagle<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">&amp;</span>status<span class="op">),</span> <span class="op">&amp;</span><span class="bu">std::</span>free<span class="op">};</span></span></code></pre></div>
<p>std::unique_ptrの第2パラメータには、上記のような関数へのポインタのみではなく、
関数型を取ることができる。</p>
<p>そのことを順を追って示す。
まずは、std::unique_ptrの動作を確かめるためのクラスを下記のように定義する。</p>
<div class="sourceCode" id="cb338"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb338-1"><a href="#cb338-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 8</span></span>
<span id="cb338-2"><a href="#cb338-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb338-3"><a href="#cb338-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// デストラクタが呼び出された時に、外部から渡されたフラグをtrueにする</span></span>
<span id="cb338-4"><a href="#cb338-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb338-5"><a href="#cb338-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> A<span class="op">(</span><span class="dt">bool</span><span class="op">&amp;</span> destructor_called<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> destructor_called<span class="op">{</span>destructor_called<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb338-6"><a href="#cb338-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>A<span class="op">()</span> <span class="op">{</span> destructor_called <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb338-7"><a href="#cb338-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb338-8"><a href="#cb338-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span><span class="op">&amp;</span> destructor_called<span class="op">;</span></span>
<span id="cb338-9"><a href="#cb338-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>次に示すのは、第2パラメータに何も指定しないパターンである。
テスト用クラスAの動作確認ができるはずである。</p>
<div class="sourceCode" id="cb339"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 25</span></span>
<span id="cb339-2"><a href="#cb339-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb339-3"><a href="#cb339-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// 第2パラメータに何も指定しない</span></span>
<span id="cb339-4"><a href="#cb339-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> is_called <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb339-5"><a href="#cb339-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb339-6"><a href="#cb339-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> ua <span class="op">=</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>A<span class="op">&gt;{</span><span class="kw">new</span> A<span class="op">{</span>is_called<span class="op">}};</span></span>
<span id="cb339-7"><a href="#cb339-7" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// uaのデストラクタは呼ばれていない</span></span>
<span id="cb339-8"><a href="#cb339-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb339-9"><a href="#cb339-9" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// uaのデストラクタは呼ばれた</span></span>
<span id="cb339-10"><a href="#cb339-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>次に示すのは、</p>
<div class="sourceCode" id="cb340"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 18</span></span>
<span id="cb340-2"><a href="#cb340-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb340-3"><a href="#cb340-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> delete_func<span class="op">(</span>A<span class="op">*</span> a<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="kw">delete</span> a<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>のポインタをstd::unique_ptrの第2パラメータに与えた例である。</p>
<div class="sourceCode" id="cb341"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 36</span></span>
<span id="cb341-2"><a href="#cb341-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb341-3"><a href="#cb341-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// 第2パラメータに関数ポインタを与える</span></span>
<span id="cb341-4"><a href="#cb341-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> is_called <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb341-5"><a href="#cb341-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb341-6"><a href="#cb341-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> ua <span class="op">=</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>A<span class="op">,</span> <span class="dt">void</span> <span class="op">(*)(</span>A<span class="op">*)&gt;{</span><span class="kw">new</span> A<span class="op">{</span>is_called<span class="op">},</span> <span class="op">&amp;</span>delete_func<span class="op">};</span></span>
<span id="cb341-7"><a href="#cb341-7" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// uaのデストラクタは呼ばれていない</span></span>
<span id="cb341-8"><a href="#cb341-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb341-9"><a href="#cb341-9" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// uaのデストラクタは呼ばれた</span></span>
<span id="cb341-10"><a href="#cb341-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>次に示すのは、std::unique_ptrの第2パラメータにラムダを与えた例である。</p>
<div class="sourceCode" id="cb342"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb342-1"><a href="#cb342-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 47</span></span>
<span id="cb342-2"><a href="#cb342-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb342-3"><a href="#cb342-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// 第2パラメータにラムダを与える</span></span>
<span id="cb342-4"><a href="#cb342-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> is_called <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb342-5"><a href="#cb342-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb342-6"><a href="#cb342-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> delete_lambda <span class="op">=</span> <span class="op">[](</span>A<span class="op">*</span> a<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="kw">delete</span> a<span class="op">;</span> <span class="op">};</span></span>
<span id="cb342-7"><a href="#cb342-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb342-8"><a href="#cb342-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// ラムダ式の型はインスタンス毎に異なるため、</span></span>
<span id="cb342-9"><a href="#cb342-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">// ラムダ式の型を取得するためには下記のようにdecltypeを使う必要がある</span></span>
<span id="cb342-10"><a href="#cb342-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> ua <span class="op">=</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>A<span class="op">,</span> <span class="kw">decltype</span><span class="op">(</span>delete_lambda<span class="op">)&gt;{</span><span class="kw">new</span> A<span class="op">{</span>is_called<span class="op">},</span> delete_lambda<span class="op">};</span></span>
<span id="cb342-11"><a href="#cb342-11" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// uaのデストラクタは呼ばれていない</span></span>
<span id="cb342-12"><a href="#cb342-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb342-13"><a href="#cb342-13" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// uaのデストラクタは呼ばれた</span></span>
<span id="cb342-14"><a href="#cb342-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>次に示すのは、
std::unique_ptrの第2パラメータに関数型オブジェクトの型(std::function)を与えた例である。</p>
<div class="sourceCode" id="cb343"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb343-1"><a href="#cb343-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 62</span></span>
<span id="cb343-2"><a href="#cb343-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-3"><a href="#cb343-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// 第2パラメータにstd::function型オブジェクトを与える</span></span>
<span id="cb343-4"><a href="#cb343-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> is_called <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb343-5"><a href="#cb343-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb343-6"><a href="#cb343-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> delete_obj <span class="op">=</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span>A<span class="op">*)&gt;{[](</span>A<span class="op">*</span> a<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="kw">delete</span> a<span class="op">;</span> <span class="op">}};</span></span>
<span id="cb343-7"><a href="#cb343-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> ua <span class="op">=</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>A<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span>A<span class="op">*)&gt;&amp;&gt;{</span><span class="kw">new</span> A<span class="op">{</span>is_called<span class="op">},</span> delete_obj<span class="op">};</span></span>
<span id="cb343-8"><a href="#cb343-8" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// uaのデストラクタは呼ばれていない</span></span>
<span id="cb343-9"><a href="#cb343-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb343-10"><a href="#cb343-10" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// uaのデストラクタは呼ばれた</span></span>
<span id="cb343-11"><a href="#cb343-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>以上で見てきたようにstd::unique_ptrの第2パラメータには、
第1パラメータのポインタを引数に取る関数型であれば指定できる。</p>
<p>このようなテンプレートパラメータを持つクラステンプレートの実装例を示すため、
「<a href="design_pattern.html#SS_9_9">RAII(scoped
guard)</a>でも示したScopedGuardの実装を下記する。</p>
<p>やや意外だが、このようなテンプレートパラメータに特別な記法はなく、以下のようにすれば良い。</p>
<div class="sourceCode" id="cb344"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb344-1"><a href="#cb344-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/scoped_guard.h 7</span></span>
<span id="cb344-2"><a href="#cb344-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb344-3"><a href="#cb344-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> RAIIのためのクラス。コンストラクタ引数の関数オブジェクトをデストラクタから呼び出す</span></span>
<span id="cb344-4"><a href="#cb344-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb344-5"><a href="#cb344-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L   </span><span class="co">// c++20</span></span>
<span id="cb344-6"><a href="#cb344-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb344-7"><a href="#cb344-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>invocable F<span class="op">&gt;</span>  <span class="co">// Fが呼び出し可能であることを制約</span></span>
<span id="cb344-8"><a href="#cb344-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb344-9"><a href="#cb344-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb344-10"><a href="#cb344-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb344-11"><a href="#cb344-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span>
<span id="cb344-12"><a href="#cb344-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> ScopedGuard <span class="op">{</span></span>
<span id="cb344-13"><a href="#cb344-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb344-14"><a href="#cb344-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> ScopedGuard<span class="op">(</span>F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">:</span> <span class="va">f_</span><span class="op">{</span>f<span class="op">}</span></span>
<span id="cb344-15"><a href="#cb344-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb344-16"><a href="#cb344-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb344-17"><a href="#cb344-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb344-18"><a href="#cb344-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">~</span>ScopedGuard<span class="op">()</span> <span class="op">{</span> <span class="va">f_</span><span class="op">();</span> <span class="op">}</span></span>
<span id="cb344-19"><a href="#cb344-19" aria-hidden="true" tabindex="-1"></a>        ScopedGuard<span class="op">(</span>ScopedGuard <span class="at">const</span><span class="op">&amp;)</span>            <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span>  <span class="co">// copyは禁止</span></span>
<span id="cb344-20"><a href="#cb344-20" aria-hidden="true" tabindex="-1"></a>        ScopedGuard<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>ScopedGuard <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span>  <span class="co">// copyは禁止</span></span>
<span id="cb344-21"><a href="#cb344-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb344-22"><a href="#cb344-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb344-23"><a href="#cb344-23" aria-hidden="true" tabindex="-1"></a>        F <span class="va">f_</span><span class="op">;</span></span>
<span id="cb344-24"><a href="#cb344-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>上記コードの抜粋である下記は、テンプレートパラメータを関数型に制約するためのものである。</p>
<div class="sourceCode" id="cb345"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb345-1"><a href="#cb345-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/scoped_guard.h 7</span></span>
<span id="cb345-2"><a href="#cb345-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb345-3"><a href="#cb345-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// </span><span class="an">@brief</span><span class="co"> RAIIのためのクラス。コンストラクタ引数の関数オブジェクトをデストラクタから呼び出す</span></span>
<span id="cb345-4"><a href="#cb345-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb345-5"><a href="#cb345-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#if </span><span class="ot">__cplusplus</span><span class="pp"> &gt;= 202002L   </span><span class="co">// c++20</span></span>
<span id="cb345-6"><a href="#cb345-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb345-7"><a href="#cb345-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>invocable F<span class="op">&gt;</span>  <span class="co">// Fが呼び出し可能であることを制約</span></span>
<span id="cb345-8"><a href="#cb345-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#else  </span><span class="co">// c++17</span></span>
<span id="cb345-9"><a href="#cb345-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb345-10"><a href="#cb345-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb345-11"><a href="#cb345-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#endif</span></span></code></pre></div>
<p>これがなければ、誤った型の関数型をテンプレートパラメータに指定できてしまう。</p>
<p>以下にこのクラステンプレートの単体テストを示す。</p>
<p>まずは、以下の関数と静的変数の組み合わせ</p>
<div class="sourceCode" id="cb346"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb346-1"><a href="#cb346-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 78</span></span>
<span id="cb346-2"><a href="#cb346-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb346-3"><a href="#cb346-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> is_caleded_in_static<span class="op">{</span><span class="kw">false</span><span class="op">};</span></span>
<span id="cb346-4"><a href="#cb346-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> caleded_by_destructor<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span> is_caleded_in_static <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>を使った例である。</p>
<div class="sourceCode" id="cb347"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb347-1"><a href="#cb347-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 86</span></span>
<span id="cb347-2"><a href="#cb347-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-3"><a href="#cb347-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// Fに関数ポインタを与える</span></span>
<span id="cb347-4"><a href="#cb347-4" aria-hidden="true" tabindex="-1"></a>        is_caleded_in_static <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb347-5"><a href="#cb347-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb347-6"><a href="#cb347-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> sg <span class="op">=</span> ScopedGuard<span class="op">{&amp;</span>caleded_by_destructor<span class="op">};</span></span>
<span id="cb347-7"><a href="#cb347-7" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_caleded_in_static<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれていない</span></span>
<span id="cb347-8"><a href="#cb347-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb347-9"><a href="#cb347-9" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_caleded_in_static<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれた</span></span>
<span id="cb347-10"><a href="#cb347-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>次に示すのは、それぞれにラムダ式とstd::functionを使った2例である。</p>
<div class="sourceCode" id="cb348"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb348-1"><a href="#cb348-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 101</span></span>
<span id="cb348-2"><a href="#cb348-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb348-3"><a href="#cb348-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// Fにラムダ式を与える</span></span>
<span id="cb348-4"><a href="#cb348-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> is_called <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb348-5"><a href="#cb348-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb348-6"><a href="#cb348-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> gs <span class="op">=</span> ScopedGuard<span class="op">{[&amp;</span>is_called<span class="op">]()</span> <span class="kw">noexcept</span> <span class="op">{</span> is_called <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="op">}};</span></span>
<span id="cb348-7"><a href="#cb348-7" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれていない</span></span>
<span id="cb348-8"><a href="#cb348-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb348-9"><a href="#cb348-9" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれた</span></span>
<span id="cb348-10"><a href="#cb348-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb348-11"><a href="#cb348-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// Fにstd::function型オブジェクトを与える</span></span>
<span id="cb348-12"><a href="#cb348-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> is_called <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb348-13"><a href="#cb348-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb348-14"><a href="#cb348-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> f  <span class="op">=</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span><span class="dt">void</span><span class="op">)&gt;{[&amp;</span>is_called<span class="op">]()</span> <span class="kw">noexcept</span> <span class="op">{</span> is_called <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="op">}};</span></span>
<span id="cb348-15"><a href="#cb348-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> gs <span class="op">=</span> ScopedGuard<span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>f<span class="op">)};</span>  <span class="co">// sgのデストラクタは呼ばれていない</span></span>
<span id="cb348-16"><a href="#cb348-16" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_called<span class="op">);</span>              <span class="co">// sgのデストラクタは呼ばれた</span></span>
<span id="cb348-17"><a href="#cb348-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb348-18"><a href="#cb348-18" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_called<span class="op">);</span></span>
<span id="cb348-19"><a href="#cb348-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>次に示すのは関数型オブジェクト</p>
<div class="sourceCode" id="cb349"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb349-1"><a href="#cb349-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 123</span></span>
<span id="cb349-2"><a href="#cb349-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb349-3"><a href="#cb349-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> TestFunctor <span class="op">{</span></span>
<span id="cb349-4"><a href="#cb349-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">explicit</span> TestFunctor<span class="op">(</span><span class="dt">bool</span><span class="op">&amp;</span> is_called<span class="op">)</span> <span class="op">:</span> <span class="va">is_called_</span><span class="op">{</span>is_called<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb349-5"><a href="#cb349-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span>  <span class="kw">operator</span><span class="op">()()</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="va">is_called_</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb349-6"><a href="#cb349-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span><span class="op">&amp;</span> <span class="va">is_called_</span><span class="op">;</span></span>
<span id="cb349-7"><a href="#cb349-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>を使った例である。</p>
<div class="sourceCode" id="cb350"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb350-1"><a href="#cb350-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 134</span></span>
<span id="cb350-2"><a href="#cb350-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb350-3"><a href="#cb350-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// Fに関数型オブジェクトを与える</span></span>
<span id="cb350-4"><a href="#cb350-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> is_called <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb350-5"><a href="#cb350-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> tf        <span class="op">=</span> TestFunctor<span class="op">{</span>is_called<span class="op">};</span></span>
<span id="cb350-6"><a href="#cb350-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb350-7"><a href="#cb350-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> sg <span class="op">=</span> ScopedGuard<span class="op">{</span><span class="bu">std::</span>move<span class="op">(</span>tf<span class="op">)};</span>  <span class="co">// C++17以降の記法</span></span>
<span id="cb350-8"><a href="#cb350-8" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれていない</span></span>
<span id="cb350-9"><a href="#cb350-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb350-10"><a href="#cb350-10" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれた</span></span>
<span id="cb350-11"><a href="#cb350-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>C++17からサポートされた「クラステンプレートのテンプレートパラメータ推論」が使えないC++14以前では、
下記に示すようにScopedGuardのテンプレートラメータ型を指定しなければならない煩雑さがある。</p>
<div class="sourceCode" id="cb351"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb351-1"><a href="#cb351-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 146</span></span>
<span id="cb351-2"><a href="#cb351-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// Fに関数型オブジェクトを与える</span></span>
<span id="cb351-3"><a href="#cb351-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> is_called <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb351-4"><a href="#cb351-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> tf        <span class="op">=</span> TestFunctor<span class="op">{</span>is_called<span class="op">};</span></span>
<span id="cb351-5"><a href="#cb351-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb351-6"><a href="#cb351-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> sg <span class="op">=</span> ScopedGuard<span class="op">&lt;</span>TestFunctor<span class="op">&gt;{</span><span class="bu">std::</span>move<span class="op">(</span>tf<span class="op">)};</span>  <span class="co">// C++14以前の記法</span></span>
<span id="cb351-7"><a href="#cb351-7" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれていない</span></span>
<span id="cb351-8"><a href="#cb351-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb351-9"><a href="#cb351-9" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれた</span></span>
<span id="cb351-10"><a href="#cb351-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>これを回避するためには下記のような関数テンプレートを用意すればよい。</p>
<div class="sourceCode" id="cb352"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb352-1"><a href="#cb352-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  h/scoped_guard.h 38</span></span>
<span id="cb352-2"><a href="#cb352-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb352-3"><a href="#cb352-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> F<span class="op">&gt;</span></span>
<span id="cb352-4"><a href="#cb352-4" aria-hidden="true" tabindex="-1"></a>    ScopedGuard<span class="op">&lt;</span>F<span class="op">&gt;</span> MakeScopedGuard<span class="op">(</span>F<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb352-5"><a href="#cb352-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb352-6"><a href="#cb352-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ScopedGuard<span class="op">&lt;</span>F<span class="op">&gt;(</span><span class="bu">std::</span>move<span class="op">(</span>f<span class="op">));</span></span>
<span id="cb352-7"><a href="#cb352-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>下記に示した単体テストから明らかな通り、関数テンプレートの型推測の機能により、
テンプレートパラメータを指定する必要がなくなる。</p>
<div class="sourceCode" id="cb353"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb353-1"><a href="#cb353-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/func_type_ut.cpp 161</span></span>
<span id="cb353-2"><a href="#cb353-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb353-3"><a href="#cb353-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// Fに関数ポインタを与える</span></span>
<span id="cb353-4"><a href="#cb353-4" aria-hidden="true" tabindex="-1"></a>        is_caleded_in_static <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb353-5"><a href="#cb353-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb353-6"><a href="#cb353-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> sg <span class="op">=</span> MakeScopedGuard<span class="op">(&amp;</span>caleded_by_destructor<span class="op">);</span></span>
<span id="cb353-7"><a href="#cb353-7" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_caleded_in_static<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれていない</span></span>
<span id="cb353-8"><a href="#cb353-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb353-9"><a href="#cb353-9" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_caleded_in_static<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれた</span></span>
<span id="cb353-10"><a href="#cb353-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb353-11"><a href="#cb353-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// Fにラムダ式を与える</span></span>
<span id="cb353-12"><a href="#cb353-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> is_called <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb353-13"><a href="#cb353-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb353-14"><a href="#cb353-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> sg <span class="op">=</span> MakeScopedGuard<span class="op">([&amp;</span>is_called<span class="op">]()</span> <span class="kw">noexcept</span> <span class="op">{</span> is_called <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="op">});</span></span>
<span id="cb353-15"><a href="#cb353-15" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれていない</span></span>
<span id="cb353-16"><a href="#cb353-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb353-17"><a href="#cb353-17" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれた</span></span>
<span id="cb353-18"><a href="#cb353-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb353-19"><a href="#cb353-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// Fにstd::function型オブジェクトを与える</span></span>
<span id="cb353-20"><a href="#cb353-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> is_called <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb353-21"><a href="#cb353-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb353-22"><a href="#cb353-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> f  <span class="op">=</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span><span class="dt">void</span><span class="op">)&gt;{[&amp;</span>is_called<span class="op">]()</span> <span class="kw">noexcept</span> <span class="op">{</span> is_called <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="op">}};</span></span>
<span id="cb353-23"><a href="#cb353-23" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> sg <span class="op">=</span> MakeScopedGuard<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>f<span class="op">));</span></span>
<span id="cb353-24"><a href="#cb353-24" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれていない</span></span>
<span id="cb353-25"><a href="#cb353-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb353-26"><a href="#cb353-26" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれた</span></span>
<span id="cb353-27"><a href="#cb353-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb353-28"><a href="#cb353-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>  <span class="co">// Fに関数型オブジェクトを与える</span></span>
<span id="cb353-29"><a href="#cb353-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> is_called <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb353-30"><a href="#cb353-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> tf        <span class="op">=</span> TestFunctor<span class="op">{</span>is_called<span class="op">};</span></span>
<span id="cb353-31"><a href="#cb353-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb353-32"><a href="#cb353-32" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> sg <span class="op">=</span> MakeScopedGuard<span class="op">(</span><span class="bu">std::</span>ref<span class="op">(</span>tf<span class="op">));</span>  <span class="co">// std::refが必要</span></span>
<span id="cb353-33"><a href="#cb353-33" aria-hidden="true" tabindex="-1"></a>            ASSERT_FALSE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれていない</span></span>
<span id="cb353-34"><a href="#cb353-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb353-35"><a href="#cb353-35" aria-hidden="true" tabindex="-1"></a>        ASSERT_TRUE<span class="op">(</span>is_called<span class="op">);</span>  <span class="co">// sgのデストラクタは呼ばれた</span></span>
<span id="cb353-36"><a href="#cb353-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>このような便利なテンプレートは、Nstdのようなライブラリで定義、宣言し、
ソースコード全域からアクセスできるようにするとプロジェクトの開発効率が少しだけ高まる。</p>
<p><a
href="exercise_q.html#SS_20_11_15">演習-関数型のテンプレートパラメータを持つクラステンプレート</a></p>
<h2 id="注意点まとめ">注意点まとめ <a id="SS_13_8"></a></h2>
<p>本章では、テンプレートメタプログラミングのテクニックや注意点について解説したが、
本章の情報量は多く、また他の章で行ったものもあるため以下にそれらをまとめる。</p>
<ul>
<li><p><a href="term_explanation.html#SS_19_10_2">name
lookup</a>には複雑なルールが適用されるため、非直感的なバインドが行われる場合がある。
従って、テンプレートライブラリの開発には単体テストは必須である。</p></li>
<li><p>使用しているコンパイラが<a
href="term_explanation.html#SS_19_10_3">two phase name
lookup</a>をサポートしているか否かに気を付ける。
それがオプションである場合は、two phase name
lookupを活性化させる。</p></li>
<li><p>関数型マクロはそれ以外に実装方法がない時のみに使用する (「<a
href="programming_convention.html#SS_3_6_1">関数型マクロ</a>」参照)
。</p></li>
<li><p>可変長引数を持つ関数の実装には<a
href="template_meta_programming.html#SS_13_1_3">パラメータパック</a>を使う。</p></li>
<li><p>処理速度や関数のリターンの型に影響する場合があるため、
パラメータパックの処理の順番に気を付ける(「<a
href="template_meta_programming.html#SS_13_1_3_2">前から演算するパラメータパック</a>」参照)。</p></li>
<li><p><a
href="term_explanation.html#SS_19_10_5">ADL</a>を利用しない場合、テンプレートで使う識別子は名前空間名やthis-&gt;等で修飾する
(「<a href="template_meta_programming.html#SS_13_7_4">意図しないname
lookupの防止</a>」参照)。</p></li>
<li><p>テンプレートのインターフェースではないが、実装の都合上ヘッダファイルに記述する定義は、
“namespace Inner_”を使用し、非公開であることを明示する。
また、“namespace
Inner_”で宣言、定義されている宣言、定義は単体テストを除き、
外部から参照しない(「<a
href="template_meta_programming.html#SS_13_3_2_3">is_void_sfinae_f</a>の実装」参照)。</p></li>
<li><p>ユニバーサルリファレンスの実際の型がlvalueリファレンスであるならば、
constなlvalueリファレンスとして扱う (「<a
href="programming_convention.html#SS_3_3_3_5">実引数/仮引数</a>」参照)
。</p></li>
<li><p>ユニバーサルリファレンス引数を他の関数に渡すのであれば、std::forwardを使う
(「<a
href="term_explanation.html#SS_19_15_1">ユニバーサルリファレンス</a>」、「<a
href="template_meta_programming.html#SS_13_7_1">ユニバーサルリファレンスとstd::forward</a>」参照)。</p></li>
<li><p>関数テンプレートとその特殊化はソースコード上なるべく近い位置で定義する
(「<a href="term_explanation.html#SS_19_10_3">two phase name
lookup</a>」参照)。</p></li>
<li><p><a href="term_explanation.html#SS_19_10_3">two phase name
lookup</a>により意図しない副作用が発生する可能性があるため、
STLが特殊化を想定しているstd::hash等を除き、STLの拡張は行わない。</p></li>
<li><p>ユーザが定義するテンプレートは適切に定義された名前空間内で定義する
(「<a
href="programming_convention.html#SS_3_8_1">スコープの定義と原則</a>」参照)
。</p></li>
<li><p>型とその2項演算子オーバーロードは同じ名前空間で定義する (「<a
href="term_explanation.html#SS_19_10_3">two phase name
lookup</a>」参照)。</p></li>
<li><p>関数テンプレートのオーバーロードと特殊化の<a
href="term_explanation.html#SS_19_10_2">name
lookup</a>の優先度に気を付ける。
オーバーロードのベストマッチ選択後に特殊化された関数テンプレートがname
lookupの対象になるため、
下記コードが示すように直感に反する関数が選択される場合がある。</p></li>
</ul>
<div class="sourceCode" id="cb354"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb354-1"><a href="#cb354-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/etc_ut.cpp 7</span></span>
<span id="cb354-2"><a href="#cb354-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb354-3"><a href="#cb354-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">constexpr</span> <span class="dt">int32_t</span> f<span class="op">(</span>T<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span>                   <span class="co">// f-0</span></span>
<span id="cb354-4"><a href="#cb354-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">constexpr</span> <span class="dt">int32_t</span> f<span class="op">(</span>T<span class="op">*)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span>                  <span class="co">// f-1</span></span>
<span id="cb354-5"><a href="#cb354-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;&gt;</span>           <span class="kw">constexpr</span> <span class="dt">int32_t</span> f<span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">*&gt;(</span><span class="dt">int32_t</span><span class="op">*)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// f-2</span></span>
<span id="cb354-6"><a href="#cb354-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// f-2はf-1の特殊化のように見えるが、T == int32_t*の場合のf-0の特殊化である。</span></span></code></pre></div>
<div class="sourceCode" id="cb355"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb355-1"><a href="#cb355-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  example/template_cpp17/etc_ut.cpp 18</span></span>
<span id="cb355-2"><a href="#cb355-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb355-3"><a href="#cb355-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 以下、f-0/f-1/f-2のテスト</span></span>
<span id="cb355-4"><a href="#cb355-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> c   <span class="op">=</span> <span class="dt">char</span><span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb355-5"><a href="#cb355-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> i32 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb355-6"><a href="#cb355-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb355-7"><a href="#cb355-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 以下はおそらく直感通り</span></span>
<span id="cb355-8"><a href="#cb355-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>f<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span>               <span class="co">// f-0が呼ばれる</span></span>
<span id="cb355-9"><a href="#cb355-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>f<span class="op">(&amp;</span>c<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">);</span>              <span class="co">// f-1が呼ばれる</span></span>
<span id="cb355-10"><a href="#cb355-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>f<span class="op">&lt;</span><span class="dt">int32_t</span><span class="op">*&gt;(&amp;</span>i32<span class="op">)</span> <span class="op">==</span> <span class="dv">2</span><span class="op">);</span>  <span class="co">// f-2が呼ばれる</span></span>
<span id="cb355-11"><a href="#cb355-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb355-12"><a href="#cb355-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 以下はおそらく直感に反する</span></span>
<span id="cb355-13"><a href="#cb355-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>f<span class="op">(</span><span class="kw">nullptr</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// f-1ではなく、f-0が呼ばれる</span></span>
<span id="cb355-14"><a href="#cb355-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span>f<span class="op">(&amp;</span>i32<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">);</span>     <span class="co">// f-2ではなく、f-1が呼ばれる</span></span></code></pre></div>
<ul>
<li><p>ユニバーサルリファレンスを持つ関数テンプレートをオーバーロードしない。
「<a
href="template_meta_programming.html#SS_13_7_1">ユニバーサルリファレンスとstd::forward</a>」で述べたように、
ユニバーサルリファレンスはオーバーロードするためのものではなく、
lvalue、rvalue両方を受け取ることができる関数テンプレートを、
オーバーロードを使わずに実現するための記法である。</p></li>
<li><p>テンプレートに関数型オブジェクトを渡す場合、リファレンスの付け忘れに気を付ける
(「<a
href="template_meta_programming.html#SS_13_7_7">関数型をテンプレートパラメータで使う</a>」
、「<a href="debug.html#SS_15_9_6">現象6 - STLのバグ?</a>」
参照)。</p></li>
<li><p>意図しないテンプレートパラメータによるインスタンス化の防止や、
コンパイルエラーを解読しやすくするために、適切にstatic_assert使うことは重要であるが、
static_assertによるテンプレートパラメータの制約よりも、<a
href="term_explanation.html#SS_19_11_2">コンセプト</a>による制約を優先する。</p></li>
<li><p>ランタイム時の処理を削減する、static_assertを適切に用いる等の目的のために、
関数テンプレートには適切にconstexprを付けて宣言する (「<a
href="template_meta_programming.html#SS_13_4_4">コンテナ用Nstd::operator&lt;&lt;の開発</a>」
参照)。</p></li>
</ul>
</body>
</html>
